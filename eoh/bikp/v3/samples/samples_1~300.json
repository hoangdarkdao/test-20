[
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a weighted random selection favoring solutions with higher objective values and lower weights, then applies a hybrid local search operator that combines random swaps with a greedy selection of items to maximize both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution with weighted randomness\n    total_values = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = total_values / np.sum(total_values) if np.sum(total_values) > 0 else np.ones(len(archive)) / len(archive)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps with greedy selection\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select a subset of items to consider for swaps\n    swap_candidates = np.random.choice(n_items, size=min(10, n_items), replace=False)\n\n    for item in swap_candidates:\n        if new_solution[item] == 1:\n            # Consider removing the item\n            new_weight = current_weight - weight_lst[item]\n            if new_weight <= capacity:\n                current_weight = new_weight\n                new_solution[item] = 0\n        else:\n            # Consider adding the item\n            new_weight = current_weight + weight_lst[item]\n            if new_weight <= capacity:\n                # Greedily select items that improve both objectives\n                value1_gain = value1_lst[item]\n                value2_gain = value2_lst[item]\n                if value1_gain > 0 or value2_gain > 0:\n                    current_weight = new_weight\n                    new_solution[item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.3842042426609896,
            3.491807758808136
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution with weighted randomness\n    total_values = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = total_values / np.sum(total_values) if np.sum(total_values) > 0 else np.ones(len(archive)) / len(archive)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps with greedy selection\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select a subset of items to consider for swaps\n    swap_candidates = np.random.choice(n_items, size=min(10, n_items), replace=False)\n\n    for item in swap_candidates:\n        if new_solution[item] == 1:\n            # Consider removing the item\n            new_weight = current_weight - weight_lst[item]\n            if new_weight <= capacity:\n                current_weight = new_weight\n                new_solution[item] = 0\n        else:\n            # Consider adding the item\n            new_weight = current_weight + weight_lst[item]\n            if new_weight <= capacity:\n                # Greedily select items that improve both objectives\n                value1_gain = value1_lst[item]\n                value2_gain = value2_lst[item]\n                if value1_gain > 0 or value2_gain > 0:\n                    current_weight = new_weight\n                    new_solution[item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a weighted random selection favoring solutions with higher objective values and lower weights, then applies a hybrid local search operator that combines random swaps with a greedy selection of items to maximize both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution with weighted randomness\n    total_values = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = total_values / np.sum(total_values) if np.sum(total_values) > 0 else np.ones(len(archive)) / len(archive)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps with greedy selection\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select a subset of items to consider for swaps\n    swap_candidates = np.random.choice(n_items, size=min(10, n_items), replace=False)\n\n    for item in swap_candidates:\n        if new_solution[item] == 1:\n            # Consider removing the item\n            new_weight = current_weight - weight_lst[item]\n            if new_weight <= capacity:\n                current_weight = new_weight\n                new_solution[item] = 0\n        else:\n            # Consider adding the item\n            new_weight = current_weight + weight_lst[item]\n            if new_weight <= capacity:\n                # Greedily select items that improve both objectives\n                value1_gain = value1_lst[item]\n                value2_gain = value2_lst[item]\n                if value1_gain > 0 or value2_gain > 0:\n                    current_weight = new_weight\n                    new_solution[item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.3842042426609896,
            3.491807758808136
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution with weighted randomness\n    total_values = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = total_values / np.sum(total_values) if np.sum(total_values) > 0 else np.ones(len(archive)) / len(archive)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps with greedy selection\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select a subset of items to consider for swaps\n    swap_candidates = np.random.choice(n_items, size=min(10, n_items), replace=False)\n\n    for item in swap_candidates:\n        if new_solution[item] == 1:\n            # Consider removing the item\n            new_weight = current_weight - weight_lst[item]\n            if new_weight <= capacity:\n                current_weight = new_weight\n                new_solution[item] = 0\n        else:\n            # Consider adding the item\n            new_weight = current_weight + weight_lst[item]\n            if new_weight <= capacity:\n                # Greedily select items that improve both objectives\n                value1_gain = value1_lst[item]\n                value2_gain = value2_lst[item]\n                if value1_gain > 0 or value2_gain > 0:\n                    current_weight = new_weight\n                    new_solution[item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a weighted random selection favoring solutions with higher objective values and lower weights, then applies a hybrid local search operator that combines random swaps with a greedy selection of items to maximize both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution with weighted randomness\n    total_values = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = total_values / np.sum(total_values) if np.sum(total_values) > 0 else np.ones(len(archive)) / len(archive)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps with greedy selection\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select a subset of items to consider for swaps\n    swap_candidates = np.random.choice(n_items, size=min(10, n_items), replace=False)\n\n    for item in swap_candidates:\n        if new_solution[item] == 1:\n            # Consider removing the item\n            new_weight = current_weight - weight_lst[item]\n            if new_weight <= capacity:\n                current_weight = new_weight\n                new_solution[item] = 0\n        else:\n            # Consider adding the item\n            new_weight = current_weight + weight_lst[item]\n            if new_weight <= capacity:\n                # Greedily select items that improve both objectives\n                value1_gain = value1_lst[item]\n                value2_gain = value2_lst[item]\n                if value1_gain > 0 or value2_gain > 0:\n                    current_weight = new_weight\n                    new_solution[item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.3842042426609896,
            3.491807758808136
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution with weighted randomness\n    total_values = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = total_values / np.sum(total_values) if np.sum(total_values) > 0 else np.ones(len(archive)) / len(archive)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps with greedy selection\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select a subset of items to consider for swaps\n    swap_candidates = np.random.choice(n_items, size=min(10, n_items), replace=False)\n\n    for item in swap_candidates:\n        if new_solution[item] == 1:\n            # Consider removing the item\n            new_weight = current_weight - weight_lst[item]\n            if new_weight <= capacity:\n                current_weight = new_weight\n                new_solution[item] = 0\n        else:\n            # Consider adding the item\n            new_weight = current_weight + weight_lst[item]\n            if new_weight <= capacity:\n                # Greedily select items that improve both objectives\n                value1_gain = value1_lst[item]\n                value2_gain = value2_lst[item]\n                if value1_gain > 0 or value2_gain > 0:\n                    current_weight = new_weight\n                    new_solution[item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify items that can be toggled (either added or removed)\n    toggle_candidates = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if removing the item keeps the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                toggle_candidates.append(i)\n        else:\n            # Check if adding the item keeps the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                toggle_candidates.append(i)\n\n    if not toggle_candidates:\n        # If no toggle candidates, return a random neighbor by flipping one item\n        random_idx = np.random.randint(0, len(base_solution))\n        new_solution[random_idx] = 1 - new_solution[random_idx]\n        return new_solution\n\n    # Select a random item to toggle\n    toggle_idx = np.random.choice(toggle_candidates)\n    new_solution[toggle_idx] = 1 - new_solution[toggle_idx]\n\n    # Apply a hybrid local search: flip multiple items if beneficial\n    # Calculate the marginal contribution of each item\n    marginal_contributions = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 0:\n            marginal = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n            marginal_contributions.append((marginal, i))\n        else:\n            marginal = -(value1_lst[i] + value2_lst[i]) / weight_lst[i]\n            marginal_contributions.append((marginal, i))\n\n    # Sort by marginal contribution (descending)\n    marginal_contributions.sort(reverse=True, key=lambda x: x[0])\n\n    # Flip top-k items that can be added or removed without violating capacity\n    k = min(3, len(marginal_contributions))\n    for _, i in marginal_contributions[:k]:\n        if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            new_solution[i] = 1\n        elif new_solution[i] == 1 and current_weight - weight_lst[i] <= capacity:\n            new_solution[i] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.921370479514642,
            6.669167697429657
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify items that can be toggled (either added or removed)\n    toggle_candidates = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if removing the item keeps the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                toggle_candidates.append(i)\n        else:\n            # Check if adding the item keeps the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                toggle_candidates.append(i)\n\n    if not toggle_candidates:\n        # If no toggle candidates, return a random neighbor by flipping one item\n        random_idx = np.random.randint(0, len(base_solution))\n        new_solution[random_idx] = 1 - new_solution[random_idx]\n        return new_solution\n\n    # Select a random item to toggle\n    toggle_idx = np.random.choice(toggle_candidates)\n    new_solution[toggle_idx] = 1 - new_solution[toggle_idx]\n\n    # Apply a hybrid local search: flip multiple items if beneficial\n    # Calculate the marginal contribution of each item\n    marginal_contributions = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 0:\n            marginal = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n            marginal_contributions.append((marginal, i))\n        else:\n            marginal = -(value1_lst[i] + value2_lst[i]) / weight_lst[i]\n            marginal_contributions.append((marginal, i))\n\n    # Sort by marginal contribution (descending)\n    marginal_contributions.sort(reverse=True, key=lambda x: x[0])\n\n    # Flip top-k items that can be added or removed without violating capacity\n    k = min(3, len(marginal_contributions))\n    for _, i in marginal_contributions[:k]:\n        if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            new_solution[i] = 1\n        elif new_solution[i] == 1 and current_weight - weight_lst[i] <= capacity:\n            new_solution[i] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify items that can be toggled (either added or removed)\n    toggle_candidates = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if removing the item keeps the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                toggle_candidates.append(i)\n        else:\n            # Check if adding the item keeps the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                toggle_candidates.append(i)\n\n    if not toggle_candidates:\n        # If no toggle candidates, return a random neighbor by flipping one item\n        random_idx = np.random.randint(0, len(base_solution))\n        new_solution[random_idx] = 1 - new_solution[random_idx]\n        return new_solution\n\n    # Select a random item to toggle\n    toggle_idx = np.random.choice(toggle_candidates)\n    new_solution[toggle_idx] = 1 - new_solution[toggle_idx]\n\n    # Apply a hybrid local search: flip multiple items if beneficial\n    # Calculate the marginal contribution of each item\n    marginal_contributions = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 0:\n            marginal = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n            marginal_contributions.append((marginal, i))\n        else:\n            marginal = -(value1_lst[i] + value2_lst[i]) / weight_lst[i]\n            marginal_contributions.append((marginal, i))\n\n    # Sort by marginal contribution (descending)\n    marginal_contributions.sort(reverse=True, key=lambda x: x[0])\n\n    # Flip top-k items that can be added or removed without violating capacity\n    k = min(3, len(marginal_contributions))\n    for _, i in marginal_contributions[:k]:\n        if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            new_solution[i] = 1\n        elif new_solution[i] == 1 and current_weight - weight_lst[i] <= capacity:\n            new_solution[i] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.921370479514642,
            6.669167697429657
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify items that can be toggled (either added or removed)\n    toggle_candidates = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if removing the item keeps the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                toggle_candidates.append(i)\n        else:\n            # Check if adding the item keeps the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                toggle_candidates.append(i)\n\n    if not toggle_candidates:\n        # If no toggle candidates, return a random neighbor by flipping one item\n        random_idx = np.random.randint(0, len(base_solution))\n        new_solution[random_idx] = 1 - new_solution[random_idx]\n        return new_solution\n\n    # Select a random item to toggle\n    toggle_idx = np.random.choice(toggle_candidates)\n    new_solution[toggle_idx] = 1 - new_solution[toggle_idx]\n\n    # Apply a hybrid local search: flip multiple items if beneficial\n    # Calculate the marginal contribution of each item\n    marginal_contributions = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 0:\n            marginal = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n            marginal_contributions.append((marginal, i))\n        else:\n            marginal = -(value1_lst[i] + value2_lst[i]) / weight_lst[i]\n            marginal_contributions.append((marginal, i))\n\n    # Sort by marginal contribution (descending)\n    marginal_contributions.sort(reverse=True, key=lambda x: x[0])\n\n    # Flip top-k items that can be added or removed without violating capacity\n    k = min(3, len(marginal_contributions))\n    for _, i in marginal_contributions[:k]:\n        if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            new_solution[i] = 1\n        elif new_solution[i] == 1 and current_weight - weight_lst[i] <= capacity:\n            new_solution[i] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{The heuristic function selects a promising solution from the archive by prioritizing those with high objective values and low weight, then applies a hybrid local search combining random item swaps and objective-driven flips to explore neighboring solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (np.sum(weight_lst[x[0] == 1]) + 1e-6), reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    items = np.where(new_solution == 1)[0]\n    non_items = np.where(new_solution == 0)[0]\n\n    # Randomly select items to flip (swap)\n    if len(items) > 0 and len(non_items) > 0:\n        swap_indices = random.sample(list(items), min(2, len(items)))\n        for idx in swap_indices:\n            new_solution[idx] = 0\n        new_weight = current_weight - np.sum(weight_lst[swap_indices])\n\n        # Add items with highest value-to-weight ratio that fit\n        remaining_capacity = capacity - new_weight\n        if remaining_capacity > 0:\n            available_items = non_items[weight_lst[non_items] <= remaining_capacity]\n            if len(available_items) > 0:\n                # Prioritize items that improve both objectives\n                value_ratios = (value1_lst[available_items] + value2_lst[available_items]) / weight_lst[available_items]\n                best_item = available_items[np.argmax(value_ratios)]\n                new_solution[best_item] = 1\n\n    # Ensure feasibility\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        items_in_solution = np.where(new_solution == 1)[0]\n        if len(items_in_solution) == 0:\n            break\n        # Remove the item with the lowest value-to-weight ratio\n        ratios = (value1_lst[items_in_solution] + value2_lst[items_in_solution]) / weight_lst[items_in_solution]\n        worst_item = items_in_solution[np.argmin(ratios)]\n        new_solution[worst_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.591282962705335,
            5.497230738401413
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (np.sum(weight_lst[x[0] == 1]) + 1e-6), reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    items = np.where(new_solution == 1)[0]\n    non_items = np.where(new_solution == 0)[0]\n\n    # Randomly select items to flip (swap)\n    if len(items) > 0 and len(non_items) > 0:\n        swap_indices = random.sample(list(items), min(2, len(items)))\n        for idx in swap_indices:\n            new_solution[idx] = 0\n        new_weight = current_weight - np.sum(weight_lst[swap_indices])\n\n        # Add items with highest value-to-weight ratio that fit\n        remaining_capacity = capacity - new_weight\n        if remaining_capacity > 0:\n            available_items = non_items[weight_lst[non_items] <= remaining_capacity]\n            if len(available_items) > 0:\n                # Prioritize items that improve both objectives\n                value_ratios = (value1_lst[available_items] + value2_lst[available_items]) / weight_lst[available_items]\n                best_item = available_items[np.argmax(value_ratios)]\n                new_solution[best_item] = 1\n\n    # Ensure feasibility\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        items_in_solution = np.where(new_solution == 1)[0]\n        if len(items_in_solution) == 0:\n            break\n        # Remove the item with the lowest value-to-weight ratio\n        ratios = (value1_lst[items_in_solution] + value2_lst[items_in_solution]) / weight_lst[items_in_solution]\n        worst_item = items_in_solution[np.argmin(ratios)]\n        new_solution[worst_item] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{This algorithm intelligently selects a solution from the archive with high potential for improvement by evaluating the density of each objective's values, then applies a hybrid local search that combines greedy item swaps with probabilistic exploration to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the most promising solution based on objective densities\n    densities = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst[sol == 1])\n        density1 = obj[0] / total_weight if total_weight > 0 else 0\n        density2 = obj[1] / total_weight if total_weight > 0 else 0\n        densities.append((density1 + density2) / 2)  # Average density\n\n    # Select top 30% solutions with highest average density\n    top_indices = np.argsort(densities)[-max(1, len(densities) // 3):]\n    selected_idx = random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    items = np.where(base_solution == 1)[0]\n    non_items = np.where(base_solution == 0)[0]\n\n    # Probabilistic exploration: flip items with low value density\n    if len(items) > 0:\n        item_densities = []\n        for i in items:\n            item_densities.append((value1_lst[i] + value2_lst[i]) / weight_lst[i])\n        avg_density = np.mean(item_densities)\n        for i in items:\n            if (value1_lst[i] + value2_lst[i]) / weight_lst[i] < avg_density and random.random() < 0.3:\n                new_weight = current_weight - weight_lst[i]\n                if new_weight >= 0:\n                    new_solution[i] = 0\n                    current_weight = new_weight\n\n    # Greedy addition: add best non-items that fit\n    if len(non_items) > 0:\n        candidates = []\n        for i in non_items:\n            if weight_lst[i] <= (capacity - current_weight):\n                candidates.append(i)\n        if candidates:\n            best_item = max(candidates, key=lambda x: (value1_lst[x] + value2_lst[x]) / weight_lst[x])\n            new_solution[best_item] = 1\n\n    # Ensure feasibility\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        items_in_new = np.where(new_solution == 1)[0]\n        if len(items_in_new) == 0:\n            break\n        # Remove least valuable item\n        least_val_item = min(items_in_new, key=lambda x: (value1_lst[x] + value2_lst[x]) / weight_lst[x])\n        new_solution[least_val_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.8176239474946493,
            10.571910172700882
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the most promising solution based on objective densities\n    densities = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst[sol == 1])\n        density1 = obj[0] / total_weight if total_weight > 0 else 0\n        density2 = obj[1] / total_weight if total_weight > 0 else 0\n        densities.append((density1 + density2) / 2)  # Average density\n\n    # Select top 30% solutions with highest average density\n    top_indices = np.argsort(densities)[-max(1, len(densities) // 3):]\n    selected_idx = random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    items = np.where(base_solution == 1)[0]\n    non_items = np.where(base_solution == 0)[0]\n\n    # Probabilistic exploration: flip items with low value density\n    if len(items) > 0:\n        item_densities = []\n        for i in items:\n            item_densities.append((value1_lst[i] + value2_lst[i]) / weight_lst[i])\n        avg_density = np.mean(item_densities)\n        for i in items:\n            if (value1_lst[i] + value2_lst[i]) / weight_lst[i] < avg_density and random.random() < 0.3:\n                new_weight = current_weight - weight_lst[i]\n                if new_weight >= 0:\n                    new_solution[i] = 0\n                    current_weight = new_weight\n\n    # Greedy addition: add best non-items that fit\n    if len(non_items) > 0:\n        candidates = []\n        for i in non_items:\n            if weight_lst[i] <= (capacity - current_weight):\n                candidates.append(i)\n        if candidates:\n            best_item = max(candidates, key=lambda x: (value1_lst[x] + value2_lst[x]) / weight_lst[x])\n            new_solution[best_item] = 1\n\n    # Ensure feasibility\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        items_in_new = np.where(new_solution == 1)[0]\n        if len(items_in_new) == 0:\n            break\n        # Remove least valuable item\n        least_val_item = min(items_in_new, key=lambda x: (value1_lst[x] + value2_lst[x]) / weight_lst[x])\n        new_solution[least_val_item] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{The algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines random flips with greedy evaluations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions with high potential for improvement (e.g., those with high objective values)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate potential for improvement (e.g., based on objective values)\n    potential = [obj[0] + obj[1] for obj in archive_objectives]\n    selected_idx = np.argmax(potential)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search operator\n    new_solution = base_solution.copy()\n    n_items = len(new_solution)\n\n    # Randomly select a subset of items to flip (with some bias towards items with high value-to-weight ratio)\n    value_to_weight1 = value1_lst / (weight_lst + 1e-10)\n    value_to_weight2 = value2_lst / (weight_lst + 1e-10)\n    combined_vw_ratio = value_to_weight1 + value_to_weight2\n\n    # Probability of flipping an item is proportional to its combined value-to-weight ratio\n    flip_probs = combined_vw_ratio / np.sum(combined_vw_ratio)\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), p=flip_probs, replace=False)\n\n    # Flip the selected items and ensure feasibility\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            # Check if adding the item exceeds capacity\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Additional greedy improvement: try to add the highest value-to-weight item not in the solution\n    remaining_items = np.where(new_solution == 0)[0]\n    if len(remaining_items) > 0:\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        candidate_items = remaining_items[weight_lst[remaining_items] <= capacity - current_weight]\n        if len(candidate_items) > 0:\n            best_candidate = candidate_items[np.argmax(combined_vw_ratio[candidate_items])]\n            new_solution[best_candidate] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.4261178585705723,
            4.984556883573532
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions with high potential for improvement (e.g., those with high objective values)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate potential for improvement (e.g., based on objective values)\n    potential = [obj[0] + obj[1] for obj in archive_objectives]\n    selected_idx = np.argmax(potential)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search operator\n    new_solution = base_solution.copy()\n    n_items = len(new_solution)\n\n    # Randomly select a subset of items to flip (with some bias towards items with high value-to-weight ratio)\n    value_to_weight1 = value1_lst / (weight_lst + 1e-10)\n    value_to_weight2 = value2_lst / (weight_lst + 1e-10)\n    combined_vw_ratio = value_to_weight1 + value_to_weight2\n\n    # Probability of flipping an item is proportional to its combined value-to-weight ratio\n    flip_probs = combined_vw_ratio / np.sum(combined_vw_ratio)\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), p=flip_probs, replace=False)\n\n    # Flip the selected items and ensure feasibility\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            # Check if adding the item exceeds capacity\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Additional greedy improvement: try to add the highest value-to-weight item not in the solution\n    remaining_items = np.where(new_solution == 0)[0]\n    if len(remaining_items) > 0:\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        candidate_items = remaining_items[weight_lst[remaining_items] <= capacity - current_weight]\n        if len(candidate_items) > 0:\n            best_candidate = candidate_items[np.argmax(combined_vw_ratio[candidate_items])]\n            new_solution[best_candidate] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search that combines random perturbation with a directed flip of items that show the highest marginal gain in either objective while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[0]))[0].copy()\n    current_weight = np.sum(weight_lst * selected_solution)\n\n    # Randomly perturb the solution\n    new_solution = selected_solution.copy()\n    for _ in range(3):  # Number of perturbations\n        idx = random.randint(0, len(weight_lst) - 1)\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Update current weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Apply directed flip: find items that can be flipped to improve at least one objective\n    for idx in range(len(weight_lst)):\n        if new_solution[idx] == 1:\n            # Try removing the item\n            temp_weight = current_weight - weight_lst[idx]\n            if temp_weight <= capacity:\n                # Check if removing improves at least one objective\n                if (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                    new_solution[idx] = 0\n                    current_weight = temp_weight\n        else:\n            # Try adding the item\n            temp_weight = current_weight + weight_lst[idx]\n            if temp_weight <= capacity:\n                # Check if adding improves at least one objective\n                if (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                    new_solution[idx] = 1\n                    current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -0.47158875461795646,
            6.265466660261154
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[0]))[0].copy()\n    current_weight = np.sum(weight_lst * selected_solution)\n\n    # Randomly perturb the solution\n    new_solution = selected_solution.copy()\n    for _ in range(3):  # Number of perturbations\n        idx = random.randint(0, len(weight_lst) - 1)\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Update current weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Apply directed flip: find items that can be flipped to improve at least one objective\n    for idx in range(len(weight_lst)):\n        if new_solution[idx] == 1:\n            # Try removing the item\n            temp_weight = current_weight - weight_lst[idx]\n            if temp_weight <= capacity:\n                # Check if removing improves at least one objective\n                if (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                    new_solution[idx] = 0\n                    current_weight = temp_weight\n        else:\n            # Try adding the item\n            temp_weight = current_weight + weight_lst[idx]\n            if temp_weight <= capacity:\n                # Check if adding improves at least one objective\n                if (value1_lst[idx] > 0 or value2_lst[idx] > 0):\n                    new_solution[idx] = 1\n                    current_weight = temp_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a hybrid local search strategy that combines adaptive item swapping with a biased random walk to explore high-potential regions while ensuring feasibility, then generates a neighbor by intelligently flipping items that maximize marginal gain in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with a bias towards those with higher potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        current_weight = np.sum(weight_lst * sol)\n        potential = np.sum((value1_lst + value2_lst) * (1 - sol))  # Potential gain if all remaining items were added\n        candidates.append((sol, obj, potential))\n\n    # Sort candidates by potential (descending) and select one with probability inversely proportional to rank\n    candidates.sort(key=lambda x: -x[2])\n    ranks = np.arange(1, len(candidates) + 1)\n    probs = 1 / ranks\n    probs = probs / np.sum(probs)\n    selected_idx = np.random.choice(len(candidates), p=probs)\n    base_solution = candidates[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Phase 1: Adaptive item swapping (focus on high-value items)\n    swap_candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Consider removing item i\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                gain1 = -value1_lst[i]\n                gain2 = -value2_lst[i]\n                swap_candidates.append((i, None, gain1, gain2, new_weight))\n        else:\n            # Consider adding item i\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                gain1 = value1_lst[i]\n                gain2 = value2_lst[i]\n                swap_candidates.append((i, None, gain1, gain2, new_weight))\n\n    if swap_candidates:\n        # Select swap with highest combined gain (normalized)\n        gains = np.array([(g1 + g2) / (weight_lst[i] + 1e-6) for i, _, g1, g2, _ in swap_candidates])\n        best_idx = np.argmax(gains)\n        i, _, _, _, _ = swap_candidates[best_idx]\n        new_solution[i] = 1 - new_solution[i]\n\n    # Phase 2: Biased random walk (explore nearby solutions)\n    if np.random.rand() < 0.3:  # 30% chance of random walk\n        for _ in range(3):  # Limit steps to avoid excessive exploration\n            i = np.random.randint(len(new_solution))\n            if new_solution[i] == 1:\n                new_weight = current_weight - weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 0\n                    current_weight = new_weight\n            else:\n                new_weight = current_weight + weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 1\n                    current_weight = new_weight\n\n    return new_solution\n\n",
        "score": [
            -0.32168470889954726,
            9.08032414317131
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with a bias towards those with higher potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        current_weight = np.sum(weight_lst * sol)\n        potential = np.sum((value1_lst + value2_lst) * (1 - sol))  # Potential gain if all remaining items were added\n        candidates.append((sol, obj, potential))\n\n    # Sort candidates by potential (descending) and select one with probability inversely proportional to rank\n    candidates.sort(key=lambda x: -x[2])\n    ranks = np.arange(1, len(candidates) + 1)\n    probs = 1 / ranks\n    probs = probs / np.sum(probs)\n    selected_idx = np.random.choice(len(candidates), p=probs)\n    base_solution = candidates[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Phase 1: Adaptive item swapping (focus on high-value items)\n    swap_candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Consider removing item i\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                gain1 = -value1_lst[i]\n                gain2 = -value2_lst[i]\n                swap_candidates.append((i, None, gain1, gain2, new_weight))\n        else:\n            # Consider adding item i\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                gain1 = value1_lst[i]\n                gain2 = value2_lst[i]\n                swap_candidates.append((i, None, gain1, gain2, new_weight))\n\n    if swap_candidates:\n        # Select swap with highest combined gain (normalized)\n        gains = np.array([(g1 + g2) / (weight_lst[i] + 1e-6) for i, _, g1, g2, _ in swap_candidates])\n        best_idx = np.argmax(gains)\n        i, _, _, _, _ = swap_candidates[best_idx]\n        new_solution[i] = 1 - new_solution[i]\n\n    # Phase 2: Biased random walk (explore nearby solutions)\n    if np.random.rand() < 0.3:  # 30% chance of random walk\n        for _ in range(3):  # Limit steps to avoid excessive exploration\n            i = np.random.randint(len(new_solution))\n            if new_solution[i] == 1:\n                new_weight = current_weight - weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 0\n                    current_weight = new_weight\n            else:\n                new_weight = current_weight + weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 1\n                    current_weight = new_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with the highest combined objective values, then applies a novel hybrid local search operator that combines item swaps, reinsertions, and probabilistic flips to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution (highest sum of objectives)\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    for _ in range(5):  # Number of local search iterations\n        # Step 1: Randomly select items to swap\n        candidate_items = np.where(base_solution == 1)[0]\n        if len(candidate_items) < 2:\n            break\n        i, j = random.sample(list(candidate_items), 2)\n\n        # Step 2: Swap two items\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n        temp_weight = np.sum(weight_lst * temp_solution)\n\n        if temp_weight <= capacity:\n            new_solution = temp_solution\n            current_weight = temp_weight\n            continue\n\n        # Step 3: If swap fails, try removing one item and adding another\n        candidate_out = np.where(new_solution == 1)[0]\n        candidate_in = np.where(new_solution == 0)[0]\n\n        if len(candidate_out) > 0 and len(candidate_in) > 0:\n            out_item = random.choice(candidate_out)\n            in_item = random.choice(candidate_in)\n            temp_solution = new_solution.copy()\n            temp_solution[out_item] = 0\n            temp_solution[in_item] = 1\n            temp_weight = np.sum(weight_lst * temp_solution)\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n    # Step 4: Probabilistic flip for diversification\n    for i in range(len(new_solution)):\n        if random.random() < 0.1:  # 10% chance to flip\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.38198365644297816,
            5.108511835336685
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution (highest sum of objectives)\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    for _ in range(5):  # Number of local search iterations\n        # Step 1: Randomly select items to swap\n        candidate_items = np.where(base_solution == 1)[0]\n        if len(candidate_items) < 2:\n            break\n        i, j = random.sample(list(candidate_items), 2)\n\n        # Step 2: Swap two items\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n        temp_weight = np.sum(weight_lst * temp_solution)\n\n        if temp_weight <= capacity:\n            new_solution = temp_solution\n            current_weight = temp_weight\n            continue\n\n        # Step 3: If swap fails, try removing one item and adding another\n        candidate_out = np.where(new_solution == 1)[0]\n        candidate_in = np.where(new_solution == 0)[0]\n\n        if len(candidate_out) > 0 and len(candidate_in) > 0:\n            out_item = random.choice(candidate_out)\n            in_item = random.choice(candidate_in)\n            temp_solution = new_solution.copy()\n            temp_solution[out_item] = 0\n            temp_solution[in_item] = 1\n            temp_weight = np.sum(weight_lst * temp_solution)\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n    # Step 4: Probabilistic flip for diversification\n    for i in range(len(new_solution)):\n        if random.random() < 0.1:  # 10% chance to flip\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{The heuristic function selects a solution from the archive with the highest potential for local improvement by evaluating the trade-off between the two objectives, then applies a novel local search strategy that combines item swaps with a probabilistic acceptance criterion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., high marginal gains)\n    selected_idx = np.argmax([(obj[0] + obj[1]) / (np.sum(weight_lst[sol == 1]) + 1e-6) for sol, obj in archive])\n    base_solution, base_obj = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and values\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = base_obj[0]\n    current_value2 = base_obj[1]\n\n    # Novel local search: probabilistic item swaps with feasibility check\n    for _ in range(10):  # Number of attempts\n        # Select two random items (one in, one out)\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n        if len(in_items) == 0 or len(out_items) == 0:\n            break\n\n        item_in = random.choice(in_items)\n        item_out = random.choice(out_items)\n\n        # Calculate new weight and values\n        new_weight = current_weight - weight_lst[item_in] + weight_lst[item_out]\n        if new_weight > capacity:\n            continue\n\n        new_value1 = current_value1 - value1_lst[item_in] + value1_lst[item_out]\n        new_value2 = current_value2 - value2_lst[item_in] + value2_lst[item_out]\n\n        # Probabilistic acceptance based on improvement in both objectives\n        improvement = (new_value1 - current_value1) * (new_value2 - current_value2)\n        if improvement > 0 or random.random() < 0.3:  # Accept with some probability\n            new_solution[item_in] = 0\n            new_solution[item_out] = 1\n            current_weight = new_weight\n            current_value1 = new_value1\n            current_value2 = new_value2\n\n    return new_solution\n\n",
        "score": [
            -0.5527696388437167,
            6.235230207443237
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., high marginal gains)\n    selected_idx = np.argmax([(obj[0] + obj[1]) / (np.sum(weight_lst[sol == 1]) + 1e-6) for sol, obj in archive])\n    base_solution, base_obj = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and values\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = base_obj[0]\n    current_value2 = base_obj[1]\n\n    # Novel local search: probabilistic item swaps with feasibility check\n    for _ in range(10):  # Number of attempts\n        # Select two random items (one in, one out)\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n        if len(in_items) == 0 or len(out_items) == 0:\n            break\n\n        item_in = random.choice(in_items)\n        item_out = random.choice(out_items)\n\n        # Calculate new weight and values\n        new_weight = current_weight - weight_lst[item_in] + weight_lst[item_out]\n        if new_weight > capacity:\n            continue\n\n        new_value1 = current_value1 - value1_lst[item_in] + value1_lst[item_out]\n        new_value2 = current_value2 - value2_lst[item_in] + value2_lst[item_out]\n\n        # Probabilistic acceptance based on improvement in both objectives\n        improvement = (new_value1 - current_value1) * (new_value2 - current_value2)\n        if improvement > 0 or random.random() < 0.3:  # Accept with some probability\n            new_solution[item_in] = 0\n            new_solution[item_out] = 1\n            current_weight = new_weight\n            current_value1 = new_value1\n            current_value2 = new_value2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{A novel hybrid local search strategy that intelligently selects a solution from the archive, applies a combination of item swap and perturbation operators to explore the neighborhood while ensuring feasibility, and prioritizes solutions with higher marginal gains in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (i + 1) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Create a copy of the base solution\n    new_solution = base_solution.copy()\n\n    # Identify items to consider for swap or perturbation\n    included_items = np.where(new_solution == 1)[0]\n    excluded_items = np.where(new_solution == 0)[0]\n\n    # Calculate current total weight\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: combination of swap and perturbation\n    if len(included_items) > 0 and len(excluded_items) > 0:\n        # Randomly select an item to swap out\n        swap_out = random.choice(included_items)\n        # Find feasible items to swap in\n        feasible_in = [item for item in excluded_items if total_weight - weight_lst[swap_out] + weight_lst[item] <= capacity]\n        if feasible_in:\n            swap_in = random.choice(feasible_in)\n            new_solution[swap_out] = 0\n            new_solution[swap_in] = 1\n        else:\n            # If no feasible swap, perform perturbation by flipping a random bit\n            perturb_item = random.choice(included_items)\n            if total_weight - weight_lst[perturb_item] <= capacity:\n                new_solution[perturb_item] = 0\n    else:\n        # If all items are included or excluded, perform perturbation\n        if len(included_items) > 0:\n            perturb_item = random.choice(included_items)\n            if total_weight - weight_lst[perturb_item] <= capacity:\n                new_solution[perturb_item] = 0\n        elif len(excluded_items) > 0:\n            perturb_item = random.choice(excluded_items)\n            if total_weight + weight_lst[perturb_item] <= capacity:\n                new_solution[perturb_item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.5893570925866405,
            4.184779018163681
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (i + 1) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Create a copy of the base solution\n    new_solution = base_solution.copy()\n\n    # Identify items to consider for swap or perturbation\n    included_items = np.where(new_solution == 1)[0]\n    excluded_items = np.where(new_solution == 0)[0]\n\n    # Calculate current total weight\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: combination of swap and perturbation\n    if len(included_items) > 0 and len(excluded_items) > 0:\n        # Randomly select an item to swap out\n        swap_out = random.choice(included_items)\n        # Find feasible items to swap in\n        feasible_in = [item for item in excluded_items if total_weight - weight_lst[swap_out] + weight_lst[item] <= capacity]\n        if feasible_in:\n            swap_in = random.choice(feasible_in)\n            new_solution[swap_out] = 0\n            new_solution[swap_in] = 1\n        else:\n            # If no feasible swap, perform perturbation by flipping a random bit\n            perturb_item = random.choice(included_items)\n            if total_weight - weight_lst[perturb_item] <= capacity:\n                new_solution[perturb_item] = 0\n    else:\n        # If all items are included or excluded, perform perturbation\n        if len(included_items) > 0:\n            perturb_item = random.choice(included_items)\n            if total_weight - weight_lst[perturb_item] <= capacity:\n                new_solution[perturb_item] = 0\n        elif len(excluded_items) > 0:\n            perturb_item = random.choice(excluded_items)\n            if total_weight + weight_lst[perturb_item] <= capacity:\n                new_solution[perturb_item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{The heuristic function 'select_neighbor' first identifies solutions in the archive with high potential for improvement by evaluating their objective values and diversity, then applies a hybrid local search strategy combining random perturbation and gradient-based refinement to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Choose solutions with high objective values or diverse solutions\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight <= capacity:\n            candidates.append((sol, obj))\n\n    if not candidates:\n        raise ValueError(\"No feasible solutions in the archive.\")\n\n    # Select a candidate with high potential (e.g., top 30% in either objective)\n    candidates.sort(key=lambda x: -max(x[1][0], x[1][1]))\n    top_candidates = candidates[:max(1, len(candidates) // 3)]\n    selected_idx = np.random.choice(len(top_candidates))\n    base_solution = top_candidates[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search to generate a neighbor\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Randomly perturb the solution (flip some bits)\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility: if weight exceeds capacity, remove the heaviest item\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Find the heaviest item in the solution\n        heavy_items = np.where(new_solution == 1)[0]\n        if len(heavy_items) > 0:\n            heaviest_idx = heavy_items[np.argmax(weight_lst[heavy_items])]\n            new_solution[heaviest_idx] = 0\n            total_weight -= weight_lst[heaviest_idx]\n\n    # Further refine by adding items with high marginal value\n    remaining_items = np.where(new_solution == 0)[0]\n    np.random.shuffle(remaining_items)\n    for idx in remaining_items:\n        if total_weight + weight_lst[idx] <= capacity:\n            # Use a weighted marginal value for both objectives\n            marginal_value1 = value1_lst[idx]\n            marginal_value2 = value2_lst[idx]\n            # Prioritize items with high marginal value in either objective\n            if marginal_value1 > 0 or marginal_value2 > 0:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.4536989571522697,
            7.974859774112701
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Choose solutions with high objective values or diverse solutions\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight <= capacity:\n            candidates.append((sol, obj))\n\n    if not candidates:\n        raise ValueError(\"No feasible solutions in the archive.\")\n\n    # Select a candidate with high potential (e.g., top 30% in either objective)\n    candidates.sort(key=lambda x: -max(x[1][0], x[1][1]))\n    top_candidates = candidates[:max(1, len(candidates) // 3)]\n    selected_idx = np.random.choice(len(top_candidates))\n    base_solution = top_candidates[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search to generate a neighbor\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Randomly perturb the solution (flip some bits)\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility: if weight exceeds capacity, remove the heaviest item\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Find the heaviest item in the solution\n        heavy_items = np.where(new_solution == 1)[0]\n        if len(heavy_items) > 0:\n            heaviest_idx = heavy_items[np.argmax(weight_lst[heavy_items])]\n            new_solution[heaviest_idx] = 0\n            total_weight -= weight_lst[heaviest_idx]\n\n    # Further refine by adding items with high marginal value\n    remaining_items = np.where(new_solution == 0)[0]\n    np.random.shuffle(remaining_items)\n    for idx in remaining_items:\n        if total_weight + weight_lst[idx] <= capacity:\n            # Use a weighted marginal value for both objectives\n            marginal_value1 = value1_lst[idx]\n            marginal_value2 = value2_lst[idx]\n            # Prioritize items with high marginal value in either objective\n            if marginal_value1 > 0 or marginal_value2 > 0:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{The algorithm intelligently selects a solution from the archive by prioritizing those with the highest potential for improvement, then applies a hybrid local search operator that combines item swaps with a novel value-weighted random walk to explore the neighborhood while ensuring feasibility and maximizing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the most promising solution (highest combined value)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate a neighbor using a hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Perform a value-weighted random walk to explore the neighborhood\n    for _ in range(min(3, n_items)):\n        # Select an item to flip (consider both adding and removing)\n        candidates = np.where(new_solution == 0)[0] if np.random.rand() > 0.5 else np.where(new_solution == 1)[0]\n        if len(candidates) == 0:\n            continue\n        item = np.random.choice(candidates)\n\n        # Calculate the effect of flipping the item\n        delta_weight = weight_lst[item] if new_solution[item] == 0 else -weight_lst[item]\n        new_weight = current_weight + delta_weight\n\n        # Ensure feasibility\n        if new_weight <= capacity:\n            new_solution[item] = 1 - new_solution[item]\n            current_weight = new_weight\n\n    # Step 2: Perform a local swap to improve both objectives\n    for _ in range(min(2, n_items)):\n        # Select two items to swap\n        item1 = np.random.choice(np.where(new_solution == 1)[0])\n        item2 = np.random.choice(np.where(new_solution == 0)[0])\n\n        # Calculate the effect of swapping\n        delta_weight = weight_lst[item2] - weight_lst[item1]\n        new_weight = current_weight + delta_weight\n\n        # Ensure feasibility\n        if new_weight <= capacity:\n            new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n            current_weight = new_weight\n\n    return new_solution\n\n",
        "score": [
            -0.3429066199641783,
            3.9130915105342865
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the most promising solution (highest combined value)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate a neighbor using a hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Perform a value-weighted random walk to explore the neighborhood\n    for _ in range(min(3, n_items)):\n        # Select an item to flip (consider both adding and removing)\n        candidates = np.where(new_solution == 0)[0] if np.random.rand() > 0.5 else np.where(new_solution == 1)[0]\n        if len(candidates) == 0:\n            continue\n        item = np.random.choice(candidates)\n\n        # Calculate the effect of flipping the item\n        delta_weight = weight_lst[item] if new_solution[item] == 0 else -weight_lst[item]\n        new_weight = current_weight + delta_weight\n\n        # Ensure feasibility\n        if new_weight <= capacity:\n            new_solution[item] = 1 - new_solution[item]\n            current_weight = new_weight\n\n    # Step 2: Perform a local swap to improve both objectives\n    for _ in range(min(2, n_items)):\n        # Select two items to swap\n        item1 = np.random.choice(np.where(new_solution == 1)[0])\n        item2 = np.random.choice(np.where(new_solution == 0)[0])\n\n        # Calculate the effect of swapping\n        delta_weight = weight_lst[item2] - weight_lst[item1]\n        new_weight = current_weight + delta_weight\n\n        # Ensure feasibility\n        if new_weight <= capacity:\n            new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n            current_weight = new_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 13,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a diverse solution from the archive, applies a combination of random subset swaps and objective-guided flips to explore the search space while maintaining feasibility, and ensures the neighbor solution balances both objectives through adaptive weight adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by objective diversity (Euclidean distance from the centroid)\n        centroid = np.mean([obj for _, obj in archive], axis=0)\n        distances = [np.linalg.norm(np.array(obj) - centroid) for _, obj in archive]\n        selected_idx = np.argmax(distances)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Hybrid local search operator\n    # Step 1: Random subset swap\n    subset_size = max(1, int(n_items * 0.2))\n    swap_indices = np.random.choice(n_items, subset_size, replace=False)\n    for idx in swap_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Step 2: Objective-guided flips\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        # Remove items to make feasible\n        excess_weight = current_weight - capacity\n        candidate_indices = np.where(new_solution == 1)[0]\n        weights = weight_lst[candidate_indices]\n        sorted_indices = np.argsort(weights)\n        for i in sorted_indices:\n            if excess_weight <= 0:\n                break\n            idx = candidate_indices[i]\n            new_solution[idx] = 0\n            excess_weight -= weight_lst[idx]\n\n    # Step 3: Adaptive flips based on objective dominance\n    if np.random.random() < 0.5:  # 50% chance of flipping based on objective\n        if np.random.random() < 0.5:  # Flip based on value1\n            candidate_indices = np.where(new_solution == 0)[0]\n            if len(candidate_indices) > 0:\n                values = value1_lst[candidate_indices]\n                idx = candidate_indices[np.argmax(values)]\n                new_weight = np.sum(weight_lst[new_solution == 1]) + weight_lst[idx]\n                if new_weight <= capacity:\n                    new_solution[idx] = 1\n        else:  # Flip based on value2\n            candidate_indices = np.where(new_solution == 0)[0]\n            if len(candidate_indices) > 0:\n                values = value2_lst[candidate_indices]\n                idx = candidate_indices[np.argmax(values)]\n                new_weight = np.sum(weight_lst[new_solution == 1]) + weight_lst[idx]\n                if new_weight <= capacity:\n                    new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.5654527669118774,
            4.2121637761592865
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by objective diversity (Euclidean distance from the centroid)\n        centroid = np.mean([obj for _, obj in archive], axis=0)\n        distances = [np.linalg.norm(np.array(obj) - centroid) for _, obj in archive]\n        selected_idx = np.argmax(distances)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Hybrid local search operator\n    # Step 1: Random subset swap\n    subset_size = max(1, int(n_items * 0.2))\n    swap_indices = np.random.choice(n_items, subset_size, replace=False)\n    for idx in swap_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Step 2: Objective-guided flips\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        # Remove items to make feasible\n        excess_weight = current_weight - capacity\n        candidate_indices = np.where(new_solution == 1)[0]\n        weights = weight_lst[candidate_indices]\n        sorted_indices = np.argsort(weights)\n        for i in sorted_indices:\n            if excess_weight <= 0:\n                break\n            idx = candidate_indices[i]\n            new_solution[idx] = 0\n            excess_weight -= weight_lst[idx]\n\n    # Step 3: Adaptive flips based on objective dominance\n    if np.random.random() < 0.5:  # 50% chance of flipping based on objective\n        if np.random.random() < 0.5:  # Flip based on value1\n            candidate_indices = np.where(new_solution == 0)[0]\n            if len(candidate_indices) > 0:\n                values = value1_lst[candidate_indices]\n                idx = candidate_indices[np.argmax(values)]\n                new_weight = np.sum(weight_lst[new_solution == 1]) + weight_lst[idx]\n                if new_weight <= capacity:\n                    new_solution[idx] = 1\n        else:  # Flip based on value2\n            candidate_indices = np.where(new_solution == 0)[0]\n            if len(candidate_indices) > 0:\n                values = value2_lst[candidate_indices]\n                idx = candidate_indices[np.argmax(values)]\n                new_weight = np.sum(weight_lst[new_solution == 1]) + weight_lst[idx]\n                if new_weight <= capacity:\n                    new_solution[idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 14,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with the highest combined objective values, then applies a hybrid local search operator that combines item swaps with a probabilistic relaxation of constraints to explore high-potential neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst)\n\n    # Select a promising solution based on combined objective values\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search operator\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 1: Randomly select a subset of items to consider for swap\n    candidate_indices = np.where(new_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.arange(len(weight_lst))\n\n    random.shuffle(candidate_indices)\n    subset_size = min(5, len(candidate_indices))\n    subset_indices = candidate_indices[:subset_size]\n\n    for i in subset_indices:\n        # Step 2: Probabilistically relax the constraint to explore neighbors\n        if random.random() < 0.3:  # 30% chance to consider swapping\n            # Step 3: Try to swap an item in the knapsack with one outside\n            if new_solution[i] == 1:\n                outside_indices = np.where(new_solution == 0)[0]\n                for j in outside_indices:\n                    new_weight = current_weight - weight_lst[i] + weight_lst[j]\n                    if new_weight <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = new_weight\n                        break\n            else:\n                inside_indices = np.where(new_solution == 1)[0]\n                for j in inside_indices:\n                    new_weight = current_weight - weight_lst[j] + weight_lst[i]\n                    if new_weight <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = new_weight\n                        break\n\n    # Step 4: Apply a probabilistic flip to explore additional neighbors\n    for i in range(len(new_solution)):\n        if random.random() < 0.1:  # 10% chance to flip each bit\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.386276125142188,
            3.0009967982769012
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst)\n\n    # Select a promising solution based on combined objective values\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search operator\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 1: Randomly select a subset of items to consider for swap\n    candidate_indices = np.where(new_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.arange(len(weight_lst))\n\n    random.shuffle(candidate_indices)\n    subset_size = min(5, len(candidate_indices))\n    subset_indices = candidate_indices[:subset_size]\n\n    for i in subset_indices:\n        # Step 2: Probabilistically relax the constraint to explore neighbors\n        if random.random() < 0.3:  # 30% chance to consider swapping\n            # Step 3: Try to swap an item in the knapsack with one outside\n            if new_solution[i] == 1:\n                outside_indices = np.where(new_solution == 0)[0]\n                for j in outside_indices:\n                    new_weight = current_weight - weight_lst[i] + weight_lst[j]\n                    if new_weight <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = new_weight\n                        break\n            else:\n                inside_indices = np.where(new_solution == 1)[0]\n                for j in inside_indices:\n                    new_weight = current_weight - weight_lst[j] + weight_lst[i]\n                    if new_weight <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = new_weight\n                        break\n\n    # Step 4: Apply a probabilistic flip to explore additional neighbors\n    for i in range(len(new_solution)):\n        if random.random() < 0.1:  # 10% chance to flip each bit\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 14,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with the highest combined objective values, then applies a hybrid local search operator that combines item swaps with a probabilistic relaxation of constraints to explore high-potential neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst)\n\n    # Select a promising solution based on combined objective values\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search operator\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 1: Randomly select a subset of items to consider for swap\n    candidate_indices = np.where(new_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.arange(len(weight_lst))\n\n    random.shuffle(candidate_indices)\n    subset_size = min(5, len(candidate_indices))\n    subset_indices = candidate_indices[:subset_size]\n\n    for i in subset_indices:\n        # Step 2: Probabilistically relax the constraint to explore neighbors\n        if random.random() < 0.3:  # 30% chance to consider swapping\n            # Step 3: Try to swap an item in the knapsack with one outside\n            if new_solution[i] == 1:\n                outside_indices = np.where(new_solution == 0)[0]\n                for j in outside_indices:\n                    new_weight = current_weight - weight_lst[i] + weight_lst[j]\n                    if new_weight <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = new_weight\n                        break\n            else:\n                inside_indices = np.where(new_solution == 1)[0]\n                for j in inside_indices:\n                    new_weight = current_weight - weight_lst[j] + weight_lst[i]\n                    if new_weight <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = new_weight\n                        break\n\n    # Step 4: Apply a probabilistic flip to explore additional neighbors\n    for i in range(len(new_solution)):\n        if random.random() < 0.1:  # 10% chance to flip each bit\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.386276125142188,
            3.0009967982769012
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst)\n\n    # Select a promising solution based on combined objective values\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search operator\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 1: Randomly select a subset of items to consider for swap\n    candidate_indices = np.where(new_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.arange(len(weight_lst))\n\n    random.shuffle(candidate_indices)\n    subset_size = min(5, len(candidate_indices))\n    subset_indices = candidate_indices[:subset_size]\n\n    for i in subset_indices:\n        # Step 2: Probabilistically relax the constraint to explore neighbors\n        if random.random() < 0.3:  # 30% chance to consider swapping\n            # Step 3: Try to swap an item in the knapsack with one outside\n            if new_solution[i] == 1:\n                outside_indices = np.where(new_solution == 0)[0]\n                for j in outside_indices:\n                    new_weight = current_weight - weight_lst[i] + weight_lst[j]\n                    if new_weight <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = new_weight\n                        break\n            else:\n                inside_indices = np.where(new_solution == 1)[0]\n                for j in inside_indices:\n                    new_weight = current_weight - weight_lst[j] + weight_lst[i]\n                    if new_weight <= capacity:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        current_weight = new_weight\n                        break\n\n    # Step 4: Apply a probabilistic flip to explore additional neighbors\n    for i in range(len(new_solution)):\n        if random.random() < 0.1:  # 10% chance to flip each bit\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 15,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: sum(x[0]) / len(x[0]))  # Prefer solutions with more items (higher density)\n    new_solution = base_solution.copy()\n\n    # Identify items that could be swapped or flipped to improve both objectives\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    possible_items = np.where(new_solution == 0)[0]  # Items not in the solution\n    possible_removals = np.where(new_solution == 1)[0]  # Items in the solution\n\n    # Hybrid local search: try to add an item that improves both objectives\n    for item in possible_items:\n        if current_weight + weight_lst[item] <= capacity:\n            new_solution[item] = 1\n            # If adding the item improves both objectives, keep it\n            if (np.sum(value1_lst[new_solution == 1]) > np.sum(value1_lst[base_solution == 1]) and\n                np.sum(value2_lst[new_solution == 1]) > np.sum(value2_lst[base_solution == 1])):\n                break\n            else:\n                new_solution[item] = 0  # Revert if no improvement\n\n    # If no addition improves both, try to remove an item that allows adding another\n    if np.array_equal(new_solution, base_solution):\n        for item in possible_removals:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            for new_item in possible_items:\n                if temp_weight + weight_lst[new_item] <= capacity:\n                    temp_solution[new_item] = 1\n                    if (np.sum(value1_lst[temp_solution == 1]) > np.sum(value1_lst[new_solution == 1]) and\n                        np.sum(value2_lst[temp_solution == 1]) > np.sum(value2_lst[new_solution == 1])):\n                        new_solution = temp_solution\n                        break\n            if not np.array_equal(new_solution, base_solution):\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.47920772719361493,
            5.201026022434235
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: sum(x[0]) / len(x[0]))  # Prefer solutions with more items (higher density)\n    new_solution = base_solution.copy()\n\n    # Identify items that could be swapped or flipped to improve both objectives\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    possible_items = np.where(new_solution == 0)[0]  # Items not in the solution\n    possible_removals = np.where(new_solution == 1)[0]  # Items in the solution\n\n    # Hybrid local search: try to add an item that improves both objectives\n    for item in possible_items:\n        if current_weight + weight_lst[item] <= capacity:\n            new_solution[item] = 1\n            # If adding the item improves both objectives, keep it\n            if (np.sum(value1_lst[new_solution == 1]) > np.sum(value1_lst[base_solution == 1]) and\n                np.sum(value2_lst[new_solution == 1]) > np.sum(value2_lst[base_solution == 1])):\n                break\n            else:\n                new_solution[item] = 0  # Revert if no improvement\n\n    # If no addition improves both, try to remove an item that allows adding another\n    if np.array_equal(new_solution, base_solution):\n        for item in possible_removals:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            for new_item in possible_items:\n                if temp_weight + weight_lst[new_item] <= capacity:\n                    temp_solution[new_item] = 1\n                    if (np.sum(value1_lst[temp_solution == 1]) > np.sum(value1_lst[new_solution == 1]) and\n                        np.sum(value2_lst[temp_solution == 1]) > np.sum(value2_lst[new_solution == 1])):\n                        new_solution = temp_solution\n                        break\n            if not np.array_equal(new_solution, base_solution):\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 16,
        "algorithm": "{The algorithm intelligently selects a solution from the archive by prioritizing those with the highest potential for local improvement, then applies a hybrid local search strategy combining item swaps and probabilistic flips to generate a feasible neighbor solution that balances exploration and exploitation of the objective space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive cannot be empty\")\n\n    # Select a solution with high potential for improvement\n    candidates = []\n    for sol, _ in archive:\n        current_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - current_weight\n        # Prioritize solutions with remaining capacity and non-dominated status\n        candidates.append((sol, remaining_capacity))\n\n    # Select the solution with the highest remaining capacity\n    candidates.sort(key=lambda x: -x[1])\n    base_solution = candidates[0][0].copy()\n\n    # Hybrid local search: probabilistic item flips and item swaps\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Probabilistic flip: randomly flip items with high marginal value\n    for i in range(n_items):\n        if random.random() < 0.3:  # 30% chance to flip\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Item swap: swap items with high marginal value difference\n    for _ in range(3):  # Perform 3 swaps\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            in_idx = random.choice(in_items)\n            out_idx = random.choice(out_items)\n\n            # Check feasibility\n            delta_weight = weight_lst[out_idx] - weight_lst[in_idx]\n            if current_weight + delta_weight <= capacity:\n                new_solution[in_idx] = 0\n                new_solution[out_idx] = 1\n                current_weight += delta_weight\n\n    return new_solution\n\n",
        "score": [
            -0.5372555901524196,
            3.02256116271019
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive cannot be empty\")\n\n    # Select a solution with high potential for improvement\n    candidates = []\n    for sol, _ in archive:\n        current_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - current_weight\n        # Prioritize solutions with remaining capacity and non-dominated status\n        candidates.append((sol, remaining_capacity))\n\n    # Select the solution with the highest remaining capacity\n    candidates.sort(key=lambda x: -x[1])\n    base_solution = candidates[0][0].copy()\n\n    # Hybrid local search: probabilistic item flips and item swaps\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Probabilistic flip: randomly flip items with high marginal value\n    for i in range(n_items):\n        if random.random() < 0.3:  # 30% chance to flip\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Item swap: swap items with high marginal value difference\n    for _ in range(3):  # Perform 3 swaps\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            in_idx = random.choice(in_items)\n            out_idx = random.choice(out_items)\n\n            # Check feasibility\n            delta_weight = weight_lst[out_idx] - weight_lst[in_idx]\n            if current_weight + delta_weight <= capacity:\n                new_solution[in_idx] = 0\n                new_solution[out_idx] = 1\n                current_weight += delta_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 17,
        "algorithm": "{The heuristic function selects a promising solution from the archive based on the highest combined normalized objective values, then applies a hybrid local search operator that combines item swaps and random flips while ensuring feasibility, aiming to diversify the search while preserving high-quality solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest combined normalized objective values\n    max_combined = -1\n    best_solution = None\n    for sol, obj in archive:\n        combined = obj[0] + obj[1]\n        if combined > max_combined:\n            max_combined = combined\n            best_solution = sol\n\n    if best_solution is None:\n        best_solution = archive[0][0]\n\n    new_solution = best_solution.copy()\n\n    # Hybrid local search operator\n    # Step 1: Randomly swap two items (if feasible)\n    items = np.where(new_solution == 1)[0]\n    if len(items) >= 2:\n        i, j = random.sample(list(items), 2)\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Randomly flip an item (add/remove) if feasible\n    all_items = np.arange(len(weight_lst))\n    random.shuffle(all_items)\n    for item in all_items:\n        if new_solution[item] == 1:\n            if (np.sum(weight_lst[new_solution == 1]) - weight_lst[item]) <= capacity:\n                new_solution[item] = 0\n                break\n        else:\n            if (np.sum(weight_lst[new_solution == 1]) + weight_lst[item]) <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7377630388768972,
            2.8325568437576294
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest combined normalized objective values\n    max_combined = -1\n    best_solution = None\n    for sol, obj in archive:\n        combined = obj[0] + obj[1]\n        if combined > max_combined:\n            max_combined = combined\n            best_solution = sol\n\n    if best_solution is None:\n        best_solution = archive[0][0]\n\n    new_solution = best_solution.copy()\n\n    # Hybrid local search operator\n    # Step 1: Randomly swap two items (if feasible)\n    items = np.where(new_solution == 1)[0]\n    if len(items) >= 2:\n        i, j = random.sample(list(items), 2)\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Randomly flip an item (add/remove) if feasible\n    all_items = np.arange(len(weight_lst))\n    random.shuffle(all_items)\n    for item in all_items:\n        if new_solution[item] == 1:\n            if (np.sum(weight_lst[new_solution == 1]) - weight_lst[item]) <= capacity:\n                new_solution[item] = 0\n                break\n        else:\n            if (np.sum(weight_lst[new_solution == 1]) + weight_lst[item]) <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 17,
        "algorithm": "{The heuristic function selects a promising solution from the archive based on the highest combined normalized objective values, then applies a hybrid local search operator that combines item swaps and random flips while ensuring feasibility, aiming to diversify the search while preserving high-quality solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest combined normalized objective values\n    max_combined = -1\n    best_solution = None\n    for sol, obj in archive:\n        combined = obj[0] + obj[1]\n        if combined > max_combined:\n            max_combined = combined\n            best_solution = sol\n\n    if best_solution is None:\n        best_solution = archive[0][0]\n\n    new_solution = best_solution.copy()\n\n    # Hybrid local search operator\n    # Step 1: Randomly swap two items (if feasible)\n    items = np.where(new_solution == 1)[0]\n    if len(items) >= 2:\n        i, j = random.sample(list(items), 2)\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Randomly flip an item (add/remove) if feasible\n    all_items = np.arange(len(weight_lst))\n    random.shuffle(all_items)\n    for item in all_items:\n        if new_solution[item] == 1:\n            if (np.sum(weight_lst[new_solution == 1]) - weight_lst[item]) <= capacity:\n                new_solution[item] = 0\n                break\n        else:\n            if (np.sum(weight_lst[new_solution == 1]) + weight_lst[item]) <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7377630388768972,
            2.8325568437576294
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest combined normalized objective values\n    max_combined = -1\n    best_solution = None\n    for sol, obj in archive:\n        combined = obj[0] + obj[1]\n        if combined > max_combined:\n            max_combined = combined\n            best_solution = sol\n\n    if best_solution is None:\n        best_solution = archive[0][0]\n\n    new_solution = best_solution.copy()\n\n    # Hybrid local search operator\n    # Step 1: Randomly swap two items (if feasible)\n    items = np.where(new_solution == 1)[0]\n    if len(items) >= 2:\n        i, j = random.sample(list(items), 2)\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        if (current_weight - weight_lst[i] + weight_lst[j]) <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Randomly flip an item (add/remove) if feasible\n    all_items = np.arange(len(weight_lst))\n    random.shuffle(all_items)\n    for item in all_items:\n        if new_solution[item] == 1:\n            if (np.sum(weight_lst[new_solution == 1]) - weight_lst[item]) <= capacity:\n                new_solution[item] = 0\n                break\n        else:\n            if (np.sum(weight_lst[new_solution == 1]) + weight_lst[item]) <= capacity:\n                new_solution[item] = 1\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 18,
        "algorithm": "{The algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search combining random flips, value-based swaps, and capacity-aware adjustments to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with high potential for improvement\n    base_solution, _ = max(archive, key=lambda x: np.sum(x[0]) / len(x[0]))  # Prioritize solutions with more items\n    new_solution = base_solution.copy()\n\n    # Hybrid local search steps\n    # Step 1: Random flip with value-based bias\n    for _ in range(2):\n        if random.random() < 0.7:  # Higher probability to flip\n            candidates = np.where(new_solution == 1)[0]\n            if len(candidates) > 0:\n                item = random.choice(candidates)\n                new_solution[item] = 0\n                # Add a high-value item if capacity allows\n                available_items = np.where((weight_lst <= capacity - np.sum(weight_lst * new_solution)) & (new_solution == 0))[0]\n                if len(available_items) > 0:\n                    best_item = max(available_items, key=lambda i: (value1_lst[i] + value2_lst[i]) / weight_lst[i])\n                    new_solution[best_item] = 1\n\n    # Step 2: Value-based swap\n    if random.random() < 0.5:\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n        if len(in_items) > 0 and len(out_items) > 0:\n            in_item = random.choice(in_items)\n            out_item = random.choice(out_items)\n            if (np.sum(weight_lst * new_solution) - weight_lst[in_item] + weight_lst[out_item]) <= capacity:\n                new_solution[in_item], new_solution[out_item] = new_solution[out_item], new_solution[in_item]\n\n    # Step 3: Capacity adjustment\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove low-value items until feasible\n        while current_weight > capacity and np.sum(new_solution) > 0:\n            in_items = np.where(new_solution == 1)[0]\n            if len(in_items) == 0:\n                break\n            worst_item = min(in_items, key=lambda i: (value1_lst[i] + value2_lst[i]) / weight_lst[i])\n            new_solution[worst_item] = 0\n            current_weight -= weight_lst[worst_item]\n\n    return new_solution\n\n",
        "score": [
            -0.4644063872586225,
            4.0172052681446075
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with high potential for improvement\n    base_solution, _ = max(archive, key=lambda x: np.sum(x[0]) / len(x[0]))  # Prioritize solutions with more items\n    new_solution = base_solution.copy()\n\n    # Hybrid local search steps\n    # Step 1: Random flip with value-based bias\n    for _ in range(2):\n        if random.random() < 0.7:  # Higher probability to flip\n            candidates = np.where(new_solution == 1)[0]\n            if len(candidates) > 0:\n                item = random.choice(candidates)\n                new_solution[item] = 0\n                # Add a high-value item if capacity allows\n                available_items = np.where((weight_lst <= capacity - np.sum(weight_lst * new_solution)) & (new_solution == 0))[0]\n                if len(available_items) > 0:\n                    best_item = max(available_items, key=lambda i: (value1_lst[i] + value2_lst[i]) / weight_lst[i])\n                    new_solution[best_item] = 1\n\n    # Step 2: Value-based swap\n    if random.random() < 0.5:\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n        if len(in_items) > 0 and len(out_items) > 0:\n            in_item = random.choice(in_items)\n            out_item = random.choice(out_items)\n            if (np.sum(weight_lst * new_solution) - weight_lst[in_item] + weight_lst[out_item]) <= capacity:\n                new_solution[in_item], new_solution[out_item] = new_solution[out_item], new_solution[in_item]\n\n    # Step 3: Capacity adjustment\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove low-value items until feasible\n        while current_weight > capacity and np.sum(new_solution) > 0:\n            in_items = np.where(new_solution == 1)[0]\n            if len(in_items) == 0:\n                break\n            worst_item = min(in_items, key=lambda i: (value1_lst[i] + value2_lst[i]) / weight_lst[i])\n            new_solution[worst_item] = 0\n            current_weight -= weight_lst[worst_item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 19,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive, prioritizing those with high potential for improvement by evaluating their objective diversity and feasibility, then applies a hybrid local search operator combining item swaps and probabilistic flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (randomly from top 50% by diversity)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_idx = min(len(sorted_archive) // 2, len(sorted_archive) - 1)\n    selected_solution, _ = sorted_archive[selected_idx]\n\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: swap two items or flip one item probabilistically\n    if random.random() < 0.7:\n        # Swap two items (if possible)\n        candidates = np.where(new_solution == 1)[0]\n        if len(candidates) >= 2:\n            i, j = random.sample(list(candidates), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            new_weight = np.sum(weight_lst[new_solution == 1])\n            if new_weight > capacity:\n                # Undo swap if infeasible\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Flip one item (add or remove)\n        candidates = np.where(new_solution == 0)[0]\n        if len(candidates) > 0:\n            i = random.choice(candidates)\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n        else:\n            candidates = np.where(new_solution == 1)[0]\n            if len(candidates) > 0:\n                i = random.choice(candidates)\n                new_solution[i] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.8691743953036504,
            1.4873332977294922
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (randomly from top 50% by diversity)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_idx = min(len(sorted_archive) // 2, len(sorted_archive) - 1)\n    selected_solution, _ = sorted_archive[selected_idx]\n\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: swap two items or flip one item probabilistically\n    if random.random() < 0.7:\n        # Swap two items (if possible)\n        candidates = np.where(new_solution == 1)[0]\n        if len(candidates) >= 2:\n            i, j = random.sample(list(candidates), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            new_weight = np.sum(weight_lst[new_solution == 1])\n            if new_weight > capacity:\n                # Undo swap if infeasible\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Flip one item (add or remove)\n        candidates = np.where(new_solution == 0)[0]\n        if len(candidates) > 0:\n            i = random.choice(candidates)\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n        else:\n            candidates = np.where(new_solution == 1)[0]\n            if len(candidates) > 0:\n                i = random.choice(candidates)\n                new_solution[i] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 19,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive, prioritizing those with high potential for improvement by evaluating their objective diversity and feasibility, then applies a hybrid local search operator combining item swaps and probabilistic flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (randomly from top 50% by diversity)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_idx = min(len(sorted_archive) // 2, len(sorted_archive) - 1)\n    selected_solution, _ = sorted_archive[selected_idx]\n\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: swap two items or flip one item probabilistically\n    if random.random() < 0.7:\n        # Swap two items (if possible)\n        candidates = np.where(new_solution == 1)[0]\n        if len(candidates) >= 2:\n            i, j = random.sample(list(candidates), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            new_weight = np.sum(weight_lst[new_solution == 1])\n            if new_weight > capacity:\n                # Undo swap if infeasible\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Flip one item (add or remove)\n        candidates = np.where(new_solution == 0)[0]\n        if len(candidates) > 0:\n            i = random.choice(candidates)\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n        else:\n            candidates = np.where(new_solution == 1)[0]\n            if len(candidates) > 0:\n                i = random.choice(candidates)\n                new_solution[i] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.8691743953036504,
            1.4873332977294922
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (randomly from top 50% by diversity)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_idx = min(len(sorted_archive) // 2, len(sorted_archive) - 1)\n    selected_solution, _ = sorted_archive[selected_idx]\n\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: swap two items or flip one item probabilistically\n    if random.random() < 0.7:\n        # Swap two items (if possible)\n        candidates = np.where(new_solution == 1)[0]\n        if len(candidates) >= 2:\n            i, j = random.sample(list(candidates), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            new_weight = np.sum(weight_lst[new_solution == 1])\n            if new_weight > capacity:\n                # Undo swap if infeasible\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Flip one item (add or remove)\n        candidates = np.where(new_solution == 0)[0]\n        if len(candidates) > 0:\n            i = random.choice(candidates)\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n        else:\n            candidates = np.where(new_solution == 1)[0]\n            if len(candidates) > 0:\n                i = random.choice(candidates)\n                new_solution[i] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 20,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a solution from the archive, applies a dynamic neighborhood exploration strategy combining item swaps and insertions, and ensures feasibility by adaptive weight adjustment.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution (randomly among top 20% of archive)\n    top_solutions = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)[:max(1, len(archive) // 5)]\n    selected_idx = random.randint(0, len(top_solutions) - 1)\n    base_solution = top_solutions[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Dynamic neighborhood exploration: swap or insert items\n    if random.random() < 0.7:  # 70% chance to use swap\n        # Find items to swap (one included, one excluded)\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            swap_in = random.choice(included)\n            swap_out = random.choice(excluded)\n\n            # Check feasibility of swap\n            total_weight = np.sum(weight_lst[base_solution == 1])\n            delta_weight = weight_lst[swap_out] - weight_lst[swap_in]\n\n            if total_weight + delta_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n    else:  # 30% chance to use insertion\n        # Find items to insert (excluded items that fit)\n        excluded = np.where(base_solution == 0)[0]\n        candidates = [i for i in excluded if weight_lst[i] <= capacity - np.sum(weight_lst[base_solution == 1])]\n\n        if candidates:\n            insert_item = random.choice(candidates)\n            new_solution[insert_item] = 1\n\n    # Additional diversification: flip a random bit if solution didn't change\n    if np.array_equal(new_solution, base_solution):\n        flip_idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[flip_idx] == 0 and (np.sum(weight_lst[base_solution == 1]) + weight_lst[flip_idx] <= capacity):\n            new_solution[flip_idx] = 1\n        elif new_solution[flip_idx] == 1:\n            new_solution[flip_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.3261567298515907,
            6.934502840042114
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution (randomly among top 20% of archive)\n    top_solutions = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)[:max(1, len(archive) // 5)]\n    selected_idx = random.randint(0, len(top_solutions) - 1)\n    base_solution = top_solutions[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Dynamic neighborhood exploration: swap or insert items\n    if random.random() < 0.7:  # 70% chance to use swap\n        # Find items to swap (one included, one excluded)\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            swap_in = random.choice(included)\n            swap_out = random.choice(excluded)\n\n            # Check feasibility of swap\n            total_weight = np.sum(weight_lst[base_solution == 1])\n            delta_weight = weight_lst[swap_out] - weight_lst[swap_in]\n\n            if total_weight + delta_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n    else:  # 30% chance to use insertion\n        # Find items to insert (excluded items that fit)\n        excluded = np.where(base_solution == 0)[0]\n        candidates = [i for i in excluded if weight_lst[i] <= capacity - np.sum(weight_lst[base_solution == 1])]\n\n        if candidates:\n            insert_item = random.choice(candidates)\n            new_solution[insert_item] = 1\n\n    # Additional diversification: flip a random bit if solution didn't change\n    if np.array_equal(new_solution, base_solution):\n        flip_idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[flip_idx] == 0 and (np.sum(weight_lst[base_solution == 1]) + weight_lst[flip_idx] <= capacity):\n            new_solution[flip_idx] = 1\n        elif new_solution[flip_idx] == 1:\n            new_solution[flip_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 21,
        "algorithm": "{This algorithm selects a promising solution from the archive by identifying those solutions with the highest diversity in their objective values, then applies a hybrid local search operator that combines bit-flipping with a greedy selection of items based on a weighted objective function to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high diversity in objectives (promising for improvement)\n    objectives = np.array([obj for (sol, obj) in archive])\n    if len(objectives) > 1:\n        # Normalize objectives to avoid scale bias\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        diversity = np.std(normalized, axis=1)\n        selected_idx = np.argmax(diversity)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: bit-flipping + weighted greedy selection\n    n_items = len(base_solution)\n    if n_items == 0:\n        return new_solution\n\n    # Randomly select a subset of items to flip\n    flip_mask = np.random.rand(n_items) < 0.3  # 30% chance to flip each item\n    flipped = new_solution ^ flip_mask.astype(int)\n\n    # Calculate current weight and remaining capacity\n    current_weight = np.sum(weight_lst[flipped == 1])\n    remaining_capacity = capacity - current_weight\n\n    # If over capacity, remove items until feasible\n    if remaining_capacity < 0:\n        # Sort items in flipped solution by weight (ascending) to remove lightest first\n        flipped_items = np.where(flipped == 1)[0]\n        sorted_items = sorted(flipped_items, key=lambda x: weight_lst[x])\n        for item in sorted_items:\n            if remaining_capacity >= 0:\n                break\n            flipped[item] = 0\n            remaining_capacity += weight_lst[item]\n    else:\n        # Add items greedily based on weighted objective function\n        candidates = np.where(flipped == 0)[0]\n        # Randomly choose between value1 and value2 as the primary objective\n        if random.random() > 0.5:\n            primary_values = value1_lst\n            secondary_values = value2_lst\n        else:\n            primary_values = value2_lst\n            secondary_values = value1_lst\n\n        # Sort candidates by primary objective, then secondary\n        sorted_candidates = sorted(candidates, key=lambda x: (-primary_values[x], -secondary_values[x]))\n\n        for item in sorted_candidates:\n            if weight_lst[item] <= remaining_capacity:\n                flipped[item] = 1\n                remaining_capacity -= weight_lst[item]\n\n    new_solution = flipped\n    return new_solution\n\n",
        "score": [
            -0.9104589825444341,
            2.4448400735855103
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high diversity in objectives (promising for improvement)\n    objectives = np.array([obj for (sol, obj) in archive])\n    if len(objectives) > 1:\n        # Normalize objectives to avoid scale bias\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        diversity = np.std(normalized, axis=1)\n        selected_idx = np.argmax(diversity)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: bit-flipping + weighted greedy selection\n    n_items = len(base_solution)\n    if n_items == 0:\n        return new_solution\n\n    # Randomly select a subset of items to flip\n    flip_mask = np.random.rand(n_items) < 0.3  # 30% chance to flip each item\n    flipped = new_solution ^ flip_mask.astype(int)\n\n    # Calculate current weight and remaining capacity\n    current_weight = np.sum(weight_lst[flipped == 1])\n    remaining_capacity = capacity - current_weight\n\n    # If over capacity, remove items until feasible\n    if remaining_capacity < 0:\n        # Sort items in flipped solution by weight (ascending) to remove lightest first\n        flipped_items = np.where(flipped == 1)[0]\n        sorted_items = sorted(flipped_items, key=lambda x: weight_lst[x])\n        for item in sorted_items:\n            if remaining_capacity >= 0:\n                break\n            flipped[item] = 0\n            remaining_capacity += weight_lst[item]\n    else:\n        # Add items greedily based on weighted objective function\n        candidates = np.where(flipped == 0)[0]\n        # Randomly choose between value1 and value2 as the primary objective\n        if random.random() > 0.5:\n            primary_values = value1_lst\n            secondary_values = value2_lst\n        else:\n            primary_values = value2_lst\n            secondary_values = value1_lst\n\n        # Sort candidates by primary objective, then secondary\n        sorted_candidates = sorted(candidates, key=lambda x: (-primary_values[x], -secondary_values[x]))\n\n        for item in sorted_candidates:\n            if weight_lst[item] <= remaining_capacity:\n                flipped[item] = 1\n                remaining_capacity -= weight_lst[item]\n\n    new_solution = flipped\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 22,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a hybrid local search strategy that combines a probabilistic swap of items with a value-aware perturbation, ensuring feasibility by checking weight constraints and intelligently exploring the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 - i/len(archive) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: probabilistic swap + value-aware perturbation\n    items = np.where(base_solution == 1)[0]\n    non_items = np.where(base_solution == 0)[0]\n\n    # Step 1: Probabilistic swap (swap a random item with a non-item)\n    if len(items) > 0 and len(non_items) > 0:\n        swap_item = random.choice(items)\n        swap_non_item = random.choice(non_items)\n        new_solution[swap_item] = 0\n        new_solution[swap_non_item] = 1\n\n        # Check feasibility\n        if np.sum(weight_lst[new_solution == 1]) > capacity:\n            # Revert if infeasible\n            new_solution[swap_item] = 1\n            new_solution[swap_non_item] = 0\n\n    # Step 2: Value-aware perturbation (flip a random item if it improves the objective)\n    if len(items) > 0:\n        flip_item = random.choice(items)\n        new_solution[flip_item] = 0\n        # Check feasibility\n        if np.sum(weight_lst[new_solution == 1]) <= capacity:\n            # Accept if feasible (no further check for improvement, as it's a perturbation)\n            pass\n        else:\n            new_solution[flip_item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.46505240627091793,
            1.9719839990139008
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 - i/len(archive) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: probabilistic swap + value-aware perturbation\n    items = np.where(base_solution == 1)[0]\n    non_items = np.where(base_solution == 0)[0]\n\n    # Step 1: Probabilistic swap (swap a random item with a non-item)\n    if len(items) > 0 and len(non_items) > 0:\n        swap_item = random.choice(items)\n        swap_non_item = random.choice(non_items)\n        new_solution[swap_item] = 0\n        new_solution[swap_non_item] = 1\n\n        # Check feasibility\n        if np.sum(weight_lst[new_solution == 1]) > capacity:\n            # Revert if infeasible\n            new_solution[swap_item] = 1\n            new_solution[swap_non_item] = 0\n\n    # Step 2: Value-aware perturbation (flip a random item if it improves the objective)\n    if len(items) > 0:\n        flip_item = random.choice(items)\n        new_solution[flip_item] = 0\n        # Check feasibility\n        if np.sum(weight_lst[new_solution == 1]) <= capacity:\n            # Accept if feasible (no further check for improvement, as it's a perturbation)\n            pass\n        else:\n            new_solution[flip_item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 23,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines item swapping with probabilistic item addition/removal to generate a new neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution based on potential improvement\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (i + 1) for i in range(len(archive))])[0]\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine swapping and probabilistic addition/removal\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 1: Randomly swap some items\n    swap_indices = random.sample(range(n_items), min(3, n_items))\n    for idx in swap_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility after swapping\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # If overweight, remove items randomly until feasible\n        excess_weight = current_weight - capacity\n        removable_indices = [i for i in range(n_items) if new_solution[i] == 1]\n        while excess_weight > 0 and removable_indices:\n            idx = random.choice(removable_indices)\n            if weight_lst[idx] <= excess_weight:\n                new_solution[idx] = 0\n                excess_weight -= weight_lst[idx]\n            removable_indices.remove(idx)\n\n    # Step 2: Probabilistic addition of items not in the solution\n    for idx in range(n_items):\n        if new_solution[idx] == 0 and random.random() < 0.3:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.37054235431811267,
            5.653627783060074
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution based on potential improvement\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (i + 1) for i in range(len(archive))])[0]\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine swapping and probabilistic addition/removal\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 1: Randomly swap some items\n    swap_indices = random.sample(range(n_items), min(3, n_items))\n    for idx in swap_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility after swapping\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # If overweight, remove items randomly until feasible\n        excess_weight = current_weight - capacity\n        removable_indices = [i for i in range(n_items) if new_solution[i] == 1]\n        while excess_weight > 0 and removable_indices:\n            idx = random.choice(removable_indices)\n            if weight_lst[idx] <= excess_weight:\n                new_solution[idx] = 0\n                excess_weight -= weight_lst[idx]\n            removable_indices.remove(idx)\n\n    # Step 2: Probabilistic addition of items not in the solution\n    for idx in range(n_items):\n        if new_solution[idx] == 0 and random.random() < 0.3:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 24,
        "algorithm": "{A novel hybrid local search algorithm that intelligently combines a greedy selection of critical items with a probabilistic swap of non-critical items to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and values\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Identify critical items (high value-to-weight ratio)\n    value_to_weight1 = value1_lst / weight_lst\n    value_to_weight2 = value2_lst / weight_lst\n    critical_items = np.where((value_to_weight1 > np.median(value_to_weight1)) & (value_to_weight2 > np.median(value_to_weight2)))[0]\n\n    # Flip a critical item if possible\n    for item in critical_items:\n        if base_solution[item] == 1:\n            new_solution[item] = 0\n            new_weight = current_weight - weight_lst[item]\n            if new_weight <= capacity:\n                break\n            else:\n                new_solution[item] = 1\n        else:\n            new_solution[item] = 1\n            new_weight = current_weight + weight_lst[item]\n            if new_weight <= capacity:\n                break\n            else:\n                new_solution[item] = 0\n\n    # Randomly flip a non-critical item to explore neighborhood\n    non_critical_items = np.where(~np.isin(np.arange(len(weight_lst)), critical_items))[0]\n    if len(non_critical_items) > 0:\n        item = random.choice(non_critical_items)\n        if base_solution[item] == 1:\n            new_solution[item] = 0\n            new_weight = np.sum(weight_lst[new_solution == 1])\n            if new_weight > capacity:\n                new_solution[item] = 1\n        else:\n            new_solution[item] = 1\n            new_weight = np.sum(weight_lst[new_solution == 1])\n            if new_weight > capacity:\n                new_solution[item] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.34983714699290686,
            6.394265919923782
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and values\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Identify critical items (high value-to-weight ratio)\n    value_to_weight1 = value1_lst / weight_lst\n    value_to_weight2 = value2_lst / weight_lst\n    critical_items = np.where((value_to_weight1 > np.median(value_to_weight1)) & (value_to_weight2 > np.median(value_to_weight2)))[0]\n\n    # Flip a critical item if possible\n    for item in critical_items:\n        if base_solution[item] == 1:\n            new_solution[item] = 0\n            new_weight = current_weight - weight_lst[item]\n            if new_weight <= capacity:\n                break\n            else:\n                new_solution[item] = 1\n        else:\n            new_solution[item] = 1\n            new_weight = current_weight + weight_lst[item]\n            if new_weight <= capacity:\n                break\n            else:\n                new_solution[item] = 0\n\n    # Randomly flip a non-critical item to explore neighborhood\n    non_critical_items = np.where(~np.isin(np.arange(len(weight_lst)), critical_items))[0]\n    if len(non_critical_items) > 0:\n        item = random.choice(non_critical_items)\n        if base_solution[item] == 1:\n            new_solution[item] = 0\n            new_weight = np.sum(weight_lst[new_solution == 1])\n            if new_weight > capacity:\n                new_solution[item] = 1\n        else:\n            new_solution[item] = 1\n            new_weight = np.sum(weight_lst[new_solution == 1])\n            if new_weight > capacity:\n                new_solution[item] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 25,
        "algorithm": "{A novel hybrid local search heuristic selects a solution from the archive based on its potential for improvement, then applies a combination of random item swaps and objective-specific perturbations to generate a feasible neighbor solution while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to capacity)\n    selected_idx = np.argmax([np.sum(weight_lst[archive[i][0] == 1]) for i in range(len(archive))])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate a neighbor by swapping or flipping items with probability based on objective values\n    new_solution = base_solution.copy()\n    for i in range(len(new_solution)):\n        if np.random.rand() < 0.3:  # 30% chance to consider flipping\n            if new_solution[i] == 1:\n                # Try removing the item\n                temp_weight = current_weight - weight_lst[i]\n                if temp_weight <= capacity:\n                    new_solution[i] = 0\n                    current_weight = temp_weight\n            else:\n                # Try adding the item\n                temp_weight = current_weight + weight_lst[i]\n                if temp_weight <= capacity:\n                    new_solution[i] = 1\n                    current_weight = temp_weight\n\n    # Apply a secondary perturbation: swap two items if it improves at least one objective\n    if len(new_solution) >= 2:\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        if new_solution[i] != new_solution[j]:\n            # Check if swap is feasible\n            delta_weight = (weight_lst[j] - weight_lst[i]) if new_solution[i] == 1 else (weight_lst[i] - weight_lst[j])\n            if current_weight + delta_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.3959544507533277,
            6.5846119821071625
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to capacity)\n    selected_idx = np.argmax([np.sum(weight_lst[archive[i][0] == 1]) for i in range(len(archive))])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate a neighbor by swapping or flipping items with probability based on objective values\n    new_solution = base_solution.copy()\n    for i in range(len(new_solution)):\n        if np.random.rand() < 0.3:  # 30% chance to consider flipping\n            if new_solution[i] == 1:\n                # Try removing the item\n                temp_weight = current_weight - weight_lst[i]\n                if temp_weight <= capacity:\n                    new_solution[i] = 0\n                    current_weight = temp_weight\n            else:\n                # Try adding the item\n                temp_weight = current_weight + weight_lst[i]\n                if temp_weight <= capacity:\n                    new_solution[i] = 1\n                    current_weight = temp_weight\n\n    # Apply a secondary perturbation: swap two items if it improves at least one objective\n    if len(new_solution) >= 2:\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        if new_solution[i] != new_solution[j]:\n            # Check if swap is feasible\n            delta_weight = (weight_lst[j] - weight_lst[i]) if new_solution[i] == 1 else (weight_lst[i] - weight_lst[j])\n            if current_weight + delta_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 26,
        "algorithm": "{A hybrid local search strategy that combines adaptive item swapping with dynamic neighborhood exploration to intelligently flip items based on their marginal contributions to both objectives, while ensuring feasibility and promoting diversity in the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution, (current_v1, current_v2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Identify items that can be flipped (either in or out)\n    candidate_items = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Check if removing this item keeps the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                candidate_items.append((i, 'remove'))\n        else:\n            # Check if adding this item keeps the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                candidate_items.append((i, 'add'))\n\n    if not candidate_items:\n        return new_solution  # No feasible moves\n\n    # Select items to flip based on their marginal contributions\n    selected_items = []\n    for _ in range(min(3, len(candidate_items))):  # Flip up to 3 items\n        item_idx, action = candidate_items[np.random.randint(len(candidate_items))]\n        selected_items.append((item_idx, action))\n\n    # Apply the flips\n    for item_idx, action in selected_items:\n        if action == 'remove':\n            new_solution[item_idx] = 0\n        else:\n            new_solution[item_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.9207363532919777,
            6.376050025224686
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution, (current_v1, current_v2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Identify items that can be flipped (either in or out)\n    candidate_items = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Check if removing this item keeps the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                candidate_items.append((i, 'remove'))\n        else:\n            # Check if adding this item keeps the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                candidate_items.append((i, 'add'))\n\n    if not candidate_items:\n        return new_solution  # No feasible moves\n\n    # Select items to flip based on their marginal contributions\n    selected_items = []\n    for _ in range(min(3, len(candidate_items))):  # Flip up to 3 items\n        item_idx, action = candidate_items[np.random.randint(len(candidate_items))]\n        selected_items.append((item_idx, action))\n\n    # Apply the flips\n    for item_idx, action in selected_items:\n        if action == 'remove':\n            new_solution[item_idx] = 0\n        else:\n            new_solution[item_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 27,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate the total value ratios for each objective\n    value_ratios = [obj[0] / (obj[1] + 1e-10) for _, obj in archive]\n    # Select the solution with the highest ratio (indicating potential for multi-objective improvement)\n    selected_idx = np.argmax(value_ratios)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search operator\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Randomly select a subset of items to flip (with bias towards items with high marginal contribution)\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n    for idx in flip_indices:\n        # Calculate marginal contribution if flipped\n        if base_solution[idx] == 1:\n            new_weight = np.sum(weight_lst * new_solution) - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n        else:\n            new_weight = np.sum(weight_lst * new_solution) + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n\n    # Step 3: Ensure feasibility (redundant but safe)\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # If infeasible, remove items randomly until feasible\n        while total_weight > capacity:\n            excess_items = np.where(new_solution == 1)[0]\n            if len(excess_items) == 0:\n                break\n            remove_idx = np.random.choice(excess_items)\n            new_solution[remove_idx] = 0\n            total_weight = np.sum(weight_lst * new_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.7319338941153716,
            3.5447097420692444
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate the total value ratios for each objective\n    value_ratios = [obj[0] / (obj[1] + 1e-10) for _, obj in archive]\n    # Select the solution with the highest ratio (indicating potential for multi-objective improvement)\n    selected_idx = np.argmax(value_ratios)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search operator\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Randomly select a subset of items to flip (with bias towards items with high marginal contribution)\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n    for idx in flip_indices:\n        # Calculate marginal contribution if flipped\n        if base_solution[idx] == 1:\n            new_weight = np.sum(weight_lst * new_solution) - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n        else:\n            new_weight = np.sum(weight_lst * new_solution) + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n\n    # Step 3: Ensure feasibility (redundant but safe)\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # If infeasible, remove items randomly until feasible\n        while total_weight > capacity:\n            excess_items = np.where(new_solution == 1)[0]\n            if len(excess_items) == 0:\n                break\n            remove_idx = np.random.choice(excess_items)\n            new_solution[remove_idx] = 0\n            total_weight = np.sum(weight_lst * new_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 28,
        "algorithm": "{This algorithm selects a promising solution from the archive by evaluating the potential for local improvement based on the trade-off between the two objectives, then applies a hybrid local search operator that combines item swapping and diversification moves to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Evaluate potential for improvement based on trade-off between objectives\n        # Select a solution with the highest potential for improvement\n        selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + obj[0] + obj[1]) for _, obj in archive], k=1)[0]\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    # Step 1: Randomly select a subset of items to swap\n    swap_indices = np.where(base_solution == 1)[0]\n    if len(swap_indices) > 1:\n        i, j = random.sample(list(swap_indices), 2)\n        # Step 2: Swap two items if feasible\n        if (np.sum(weight_lst[base_solution == 1]) - weight_lst[i] + weight_lst[j] <= capacity):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # If swap is not feasible, try to replace with a new item\n            candidate_indices = np.where(base_solution == 0)[0]\n            for idx in candidate_indices:\n                if weight_lst[idx] <= capacity - (np.sum(weight_lst[base_solution == 1]) - weight_lst[i]):\n                    new_solution[i] = 0\n                    new_solution[idx] = 1\n                    break\n\n    # Step 3: Diversification move - randomly flip one item if feasible\n    flip_idx = random.randint(0, len(new_solution) - 1)\n    if new_solution[flip_idx] == 1:\n        if np.sum(weight_lst[new_solution == 1]) - weight_lst[flip_idx] <= capacity:\n            new_solution[flip_idx] = 0\n    else:\n        if np.sum(weight_lst[new_solution == 1]) + weight_lst[flip_idx] <= capacity:\n            new_solution[flip_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.37009882077673856,
            10.472782582044601
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Evaluate potential for improvement based on trade-off between objectives\n        # Select a solution with the highest potential for improvement\n        selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + obj[0] + obj[1]) for _, obj in archive], k=1)[0]\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    # Step 1: Randomly select a subset of items to swap\n    swap_indices = np.where(base_solution == 1)[0]\n    if len(swap_indices) > 1:\n        i, j = random.sample(list(swap_indices), 2)\n        # Step 2: Swap two items if feasible\n        if (np.sum(weight_lst[base_solution == 1]) - weight_lst[i] + weight_lst[j] <= capacity):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # If swap is not feasible, try to replace with a new item\n            candidate_indices = np.where(base_solution == 0)[0]\n            for idx in candidate_indices:\n                if weight_lst[idx] <= capacity - (np.sum(weight_lst[base_solution == 1]) - weight_lst[i]):\n                    new_solution[i] = 0\n                    new_solution[idx] = 1\n                    break\n\n    # Step 3: Diversification move - randomly flip one item if feasible\n    flip_idx = random.randint(0, len(new_solution) - 1)\n    if new_solution[flip_idx] == 1:\n        if np.sum(weight_lst[new_solution == 1]) - weight_lst[flip_idx] <= capacity:\n            new_solution[flip_idx] = 0\n    else:\n        if np.sum(weight_lst[new_solution == 1]) + weight_lst[flip_idx] <= capacity:\n            new_solution[flip_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 29,
        "algorithm": "{This algorithm selects a promising solution from the archive based on a weighted random choice favoring solutions with higher objective values, then applies a hybrid local search operator that combines item swaps and random flips to explore the neighborhood while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution using weighted random choice\n    objectives = np.array([obj for _, obj in archive])\n    weights = objectives[:, 0] + objectives[:, 1]  # Combine objectives for weighting\n    weights = weights - weights.min() + 1e-6  # Ensure positive weights\n    selected_idx = random.choices(range(len(archive)), weights=weights)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: item swaps and random flips\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # First, try to swap items to improve both objectives\n    for _ in range(10):  # Limit iterations to avoid long computation\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            i = random.choice(in_items)\n            j = random.choice(out_items)\n\n            delta_weight = weight_lst[j] - weight_lst[i]\n            if current_weight + delta_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight += delta_weight\n\n    # Then, try random flips with feasibility check\n    for _ in range(5):\n        flip_idx = random.randint(0, len(weight_lst) - 1)\n        if new_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] >= 0:\n                new_solution[flip_idx] = 0\n                current_weight -= weight_lst[flip_idx]\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n                current_weight += weight_lst[flip_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3647954778127501,
            4.805924624204636
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution using weighted random choice\n    objectives = np.array([obj for _, obj in archive])\n    weights = objectives[:, 0] + objectives[:, 1]  # Combine objectives for weighting\n    weights = weights - weights.min() + 1e-6  # Ensure positive weights\n    selected_idx = random.choices(range(len(archive)), weights=weights)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: item swaps and random flips\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # First, try to swap items to improve both objectives\n    for _ in range(10):  # Limit iterations to avoid long computation\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            i = random.choice(in_items)\n            j = random.choice(out_items)\n\n            delta_weight = weight_lst[j] - weight_lst[i]\n            if current_weight + delta_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight += delta_weight\n\n    # Then, try random flips with feasibility check\n    for _ in range(5):\n        flip_idx = random.randint(0, len(weight_lst) - 1)\n        if new_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] >= 0:\n                new_solution[flip_idx] = 0\n                current_weight -= weight_lst[flip_idx]\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n                current_weight += weight_lst[flip_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 30,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a solution from the archive, applies a dynamic neighborhood exploration strategy combining item swaps, flips, and guided moves to escape local optima, and ensures feasibility by validating weight constraints at each step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too crowded in the archive)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: combine item flips, swaps, and guided moves\n    new_solution = base_solution.copy()\n\n    # Step 1: Item flip with guided selection\n    for _ in range(3):  # Try 3 random flips\n        item_idx = random.randint(0, len(weight_lst) - 1)\n        if new_solution[item_idx] == 1:\n            if current_weight - weight_lst[item_idx] <= capacity:\n                new_solution[item_idx] = 0\n                current_weight -= weight_lst[item_idx]\n        else:\n            if current_weight + weight_lst[item_idx] <= capacity:\n                new_solution[item_idx] = 1\n                current_weight += weight_lst[item_idx]\n\n    # Step 2: Item swap with high potential\n    for _ in range(2):  # Try 2 random swaps\n        item1, item2 = random.sample(range(len(weight_lst)), 2)\n        if new_solution[item1] != new_solution[item2]:\n            delta_weight = (weight_lst[item2] - weight_lst[item1]) if new_solution[item1] == 1 else (weight_lst[item1] - weight_lst[item2])\n            if current_weight + delta_weight <= capacity:\n                new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n                current_weight += delta_weight\n\n    # Step 3: Guided move: add high-value item if possible\n    if current_weight < capacity:\n        # Calculate value-to-weight ratios for objective 1 and 2\n        ratios1 = value1_lst / weight_lst\n        ratios2 = value2_lst / weight_lst\n        combined_ratio = ratios1 + ratios2  # Simple combination for multi-objective\n        # Select top 5 items not in the solution\n        candidate_items = np.where(new_solution == 0)[0]\n        if len(candidate_items) > 0:\n            top_items = sorted(candidate_items, key=lambda x: -combined_ratio[x])[:5]\n            for item in top_items:\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.3731817329910466,
            5.571807265281677
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too crowded in the archive)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: combine item flips, swaps, and guided moves\n    new_solution = base_solution.copy()\n\n    # Step 1: Item flip with guided selection\n    for _ in range(3):  # Try 3 random flips\n        item_idx = random.randint(0, len(weight_lst) - 1)\n        if new_solution[item_idx] == 1:\n            if current_weight - weight_lst[item_idx] <= capacity:\n                new_solution[item_idx] = 0\n                current_weight -= weight_lst[item_idx]\n        else:\n            if current_weight + weight_lst[item_idx] <= capacity:\n                new_solution[item_idx] = 1\n                current_weight += weight_lst[item_idx]\n\n    # Step 2: Item swap with high potential\n    for _ in range(2):  # Try 2 random swaps\n        item1, item2 = random.sample(range(len(weight_lst)), 2)\n        if new_solution[item1] != new_solution[item2]:\n            delta_weight = (weight_lst[item2] - weight_lst[item1]) if new_solution[item1] == 1 else (weight_lst[item1] - weight_lst[item2])\n            if current_weight + delta_weight <= capacity:\n                new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n                current_weight += delta_weight\n\n    # Step 3: Guided move: add high-value item if possible\n    if current_weight < capacity:\n        # Calculate value-to-weight ratios for objective 1 and 2\n        ratios1 = value1_lst / weight_lst\n        ratios2 = value2_lst / weight_lst\n        combined_ratio = ratios1 + ratios2  # Simple combination for multi-objective\n        # Select top 5 items not in the solution\n        candidate_items = np.where(new_solution == 0)[0]\n        if len(candidate_items) > 0:\n            top_items = sorted(candidate_items, key=lambda x: -combined_ratio[x])[:5]\n            for item in top_items:\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 31,
        "algorithm": "{The algorithm selects a promising solution from the archive by evaluating the potential for improvement in both objectives, then applies a hybrid local search that combines item swaps and targeted flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on potential for improvement\n    potential = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - total_weight\n        # Potential is based on how much weight can be added without violating capacity\n        potential.append(remaining_capacity)\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: item swaps and targeted flips\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly select a subset of items to consider for flipping\n    subset_size = min(5, n_items)\n    candidate_indices = random.sample(range(n_items), subset_size)\n\n    # Step 2: Evaluate flipping each candidate item\n    for idx in candidate_indices:\n        if new_solution[idx] == 1:\n            # Check if removing this item keeps the solution feasible\n            new_weight = np.sum(weight_lst * new_solution) - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n        else:\n            # Check if adding this item keeps the solution feasible\n            new_weight = np.sum(weight_lst * new_solution) + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n\n    # Step 3: Perform a targeted swap between two items if beneficial\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] != new_solution[j]:\n            # Check if swapping keeps the solution feasible\n            delta_weight = weight_lst[j] - weight_lst[i]\n            current_weight = np.sum(weight_lst * new_solution)\n            if current_weight + delta_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5381351609439751,
            6.184375464916229
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on potential for improvement\n    potential = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - total_weight\n        # Potential is based on how much weight can be added without violating capacity\n        potential.append(remaining_capacity)\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: item swaps and targeted flips\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly select a subset of items to consider for flipping\n    subset_size = min(5, n_items)\n    candidate_indices = random.sample(range(n_items), subset_size)\n\n    # Step 2: Evaluate flipping each candidate item\n    for idx in candidate_indices:\n        if new_solution[idx] == 1:\n            # Check if removing this item keeps the solution feasible\n            new_weight = np.sum(weight_lst * new_solution) - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n        else:\n            # Check if adding this item keeps the solution feasible\n            new_weight = np.sum(weight_lst * new_solution) + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n\n    # Step 3: Perform a targeted swap between two items if beneficial\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] != new_solution[j]:\n            # Check if swapping keeps the solution feasible\n            delta_weight = weight_lst[j] - weight_lst[i]\n            current_weight = np.sum(weight_lst * new_solution)\n            if current_weight + delta_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 32,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a promising solution from the archive, combines adaptive perturbation, item swapping, and greedy improvement to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., with high diversity or potential for improvement)\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (i + 1) for i in range(len(archive))], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Adaptive perturbation + item swapping + greedy improvement\n    # Step 1: Adaptive perturbation - flip a few items based on their contribution\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    for _ in range(3):  # Perturb 3 items\n        if random.random() < 0.5:  # 50% chance to flip an item\n            candidates = np.where(new_solution == 1)[0]\n            if len(candidates) > 0:\n                item_to_flip = random.choice(candidates)\n                new_weight = total_weight - weight_lst[item_to_flip]\n                if new_weight <= capacity:\n                    new_solution[item_to_flip] = 0\n                    total_weight = new_weight\n\n    # Step 2: Item swapping - swap items between included and excluded\n    included = np.where(new_solution == 1)[0]\n    excluded = np.where(new_solution == 0)[0]\n\n    if len(included) > 0 and len(excluded) > 0:\n        # Select items with high potential for improvement\n        potential_items = []\n        for item in excluded:\n            if total_weight + weight_lst[item] <= capacity:\n                potential_items.append(item)\n\n        if potential_items:\n            best_item = random.choice(potential_items)\n            new_solution[best_item] = 1\n            total_weight += weight_lst[best_item]\n\n            # Remove a low-contribution item if needed\n            if total_weight > capacity:\n                # Find items to remove to restore feasibility\n                removable = np.where(new_solution == 1)[0]\n                for item in removable:\n                    if total_weight - weight_lst[item] <= capacity:\n                        new_solution[item] = 0\n                        total_weight -= weight_lst[item]\n                        break\n\n    # Step 3: Greedy improvement - add items that improve both objectives\n    excluded = np.where(new_solution == 0)[0]\n    np.random.shuffle(excluded)\n\n    for item in excluded:\n        if total_weight + weight_lst[item] <= capacity:\n            # Calculate potential improvement\n            delta_obj1 = value1_lst[item]\n            delta_obj2 = value2_lst[item]\n\n            # Accept if it improves both objectives\n            if delta_obj1 > 0 and delta_obj2 > 0:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.37637452413128036,
            6.059948235750198
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., with high diversity or potential for improvement)\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (i + 1) for i in range(len(archive))], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Adaptive perturbation + item swapping + greedy improvement\n    # Step 1: Adaptive perturbation - flip a few items based on their contribution\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    for _ in range(3):  # Perturb 3 items\n        if random.random() < 0.5:  # 50% chance to flip an item\n            candidates = np.where(new_solution == 1)[0]\n            if len(candidates) > 0:\n                item_to_flip = random.choice(candidates)\n                new_weight = total_weight - weight_lst[item_to_flip]\n                if new_weight <= capacity:\n                    new_solution[item_to_flip] = 0\n                    total_weight = new_weight\n\n    # Step 2: Item swapping - swap items between included and excluded\n    included = np.where(new_solution == 1)[0]\n    excluded = np.where(new_solution == 0)[0]\n\n    if len(included) > 0 and len(excluded) > 0:\n        # Select items with high potential for improvement\n        potential_items = []\n        for item in excluded:\n            if total_weight + weight_lst[item] <= capacity:\n                potential_items.append(item)\n\n        if potential_items:\n            best_item = random.choice(potential_items)\n            new_solution[best_item] = 1\n            total_weight += weight_lst[best_item]\n\n            # Remove a low-contribution item if needed\n            if total_weight > capacity:\n                # Find items to remove to restore feasibility\n                removable = np.where(new_solution == 1)[0]\n                for item in removable:\n                    if total_weight - weight_lst[item] <= capacity:\n                        new_solution[item] = 0\n                        total_weight -= weight_lst[item]\n                        break\n\n    # Step 3: Greedy improvement - add items that improve both objectives\n    excluded = np.where(new_solution == 0)[0]\n    np.random.shuffle(excluded)\n\n    for item in excluded:\n        if total_weight + weight_lst[item] <= capacity:\n            # Calculate potential improvement\n            delta_obj1 = value1_lst[item]\n            delta_obj2 = value2_lst[item]\n\n            # Accept if it improves both objectives\n            if delta_obj1 > 0 and delta_obj2 > 0:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 33,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects promising solutions from the archive and applies a combination of item swaps, flips, and objective-driven perturbations to generate high-quality neighbors while ensuring feasibility and diversity in the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(1, 0.1, len(archive)) / np.sum(np.linspace(1, 0.1, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Hybrid local search: combination of swaps, flips, and objective-driven perturbations\n    for _ in range(3):  # Perform 3 perturbation steps\n        # Randomly select a subset of items to modify\n        candidate_indices = np.where(base_solution == 1)[0]\n        if len(candidate_indices) > 0:\n            # Swap one item out for another not in the solution\n            out_idx = np.random.choice(candidate_indices)\n            new_solution[out_idx] = 0\n            available_indices = np.where((weight_lst <= capacity - current_weight + weight_lst[out_idx]) & (base_solution == 0))[0]\n            if len(available_indices) > 0:\n                in_idx = np.random.choice(available_indices)\n                new_solution[in_idx] = 1\n\n        # Randomly flip some items based on objective dominance\n        flip_indices = np.random.choice(len(base_solution), size=min(3, len(base_solution)), replace=False)\n        for idx in flip_indices:\n            if np.random.rand() < 0.5:  # 50% chance to flip\n                if new_solution[idx] == 1:\n                    if current_weight - weight_lst[idx] <= capacity:\n                        new_solution[idx] = 0\n                else:\n                    if current_weight + weight_lst[idx] <= capacity:\n                        new_solution[idx] = 1\n\n    # Ensure feasibility\n    new_weight = np.sum(weight_lst * new_solution)\n    while new_weight > capacity:\n        # Remove items randomly until feasible\n        excess_indices = np.where(new_solution == 1)[0]\n        if len(excess_indices) == 0:\n            break\n        remove_idx = np.random.choice(excess_indices)\n        new_solution[remove_idx] = 0\n        new_weight = np.sum(weight_lst * new_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.4834727192889415,
            10.104422867298126
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(1, 0.1, len(archive)) / np.sum(np.linspace(1, 0.1, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Hybrid local search: combination of swaps, flips, and objective-driven perturbations\n    for _ in range(3):  # Perform 3 perturbation steps\n        # Randomly select a subset of items to modify\n        candidate_indices = np.where(base_solution == 1)[0]\n        if len(candidate_indices) > 0:\n            # Swap one item out for another not in the solution\n            out_idx = np.random.choice(candidate_indices)\n            new_solution[out_idx] = 0\n            available_indices = np.where((weight_lst <= capacity - current_weight + weight_lst[out_idx]) & (base_solution == 0))[0]\n            if len(available_indices) > 0:\n                in_idx = np.random.choice(available_indices)\n                new_solution[in_idx] = 1\n\n        # Randomly flip some items based on objective dominance\n        flip_indices = np.random.choice(len(base_solution), size=min(3, len(base_solution)), replace=False)\n        for idx in flip_indices:\n            if np.random.rand() < 0.5:  # 50% chance to flip\n                if new_solution[idx] == 1:\n                    if current_weight - weight_lst[idx] <= capacity:\n                        new_solution[idx] = 0\n                else:\n                    if current_weight + weight_lst[idx] <= capacity:\n                        new_solution[idx] = 1\n\n    # Ensure feasibility\n    new_weight = np.sum(weight_lst * new_solution)\n    while new_weight > capacity:\n        # Remove items randomly until feasible\n        excess_indices = np.where(new_solution == 1)[0]\n        if len(excess_indices) == 0:\n            break\n        remove_idx = np.random.choice(excess_indices)\n        new_solution[remove_idx] = 0\n        new_weight = np.sum(weight_lst * new_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 34,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its potential for local improvement by analyzing the trade-off between the two objectives, then applies a hybrid local search operator that combines item swaps, flips, and guided moves to explore the solution space while ensuring feasibility, thus generating a high-quality neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too extreme in either objective)\n    objectives = np.array([obj for _, obj in archive])\n    mean_obj = np.mean(objectives, axis=0)\n    distances = np.linalg.norm(objectives - mean_obj, axis=1)\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: swap, flip, and guided moves\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Randomly select a subset of items to consider for modification\n    candidate_indices = np.where(new_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.arange(len(weight_lst))\n    np.random.shuffle(candidate_indices)\n\n    # Step 2: Apply a guided move (swap with a promising item not in the solution)\n    for idx in candidate_indices:\n        if new_solution[idx] == 0:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n                break\n        else:\n            # Consider removing the item and adding a more valuable one\n            total_weight -= weight_lst[idx]\n            new_solution[idx] = 0\n            # Find the most valuable item not in the solution\n            available_items = np.where(new_solution == 0)[0]\n            if len(available_items) > 0:\n                # Prefer items that improve both objectives\n                combined_value = value1_lst + value2_lst\n                best_item = available_items[np.argmax(combined_value[available_items])]\n                if total_weight + weight_lst[best_item] <= capacity:\n                    new_solution[best_item] = 1\n                    total_weight += weight_lst[best_item]\n            break\n\n    # Step 3: Random flip to escape local optima\n    if random.random() < 0.3:\n        flip_idx = random.choice(np.arange(len(weight_lst)))\n        if new_solution[flip_idx] == 1:\n            if total_weight - weight_lst[flip_idx] >= 0:\n                new_solution[flip_idx] = 0\n        else:\n            if total_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.9284801494261996,
            3.9215634167194366
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too extreme in either objective)\n    objectives = np.array([obj for _, obj in archive])\n    mean_obj = np.mean(objectives, axis=0)\n    distances = np.linalg.norm(objectives - mean_obj, axis=1)\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: swap, flip, and guided moves\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Randomly select a subset of items to consider for modification\n    candidate_indices = np.where(new_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.arange(len(weight_lst))\n    np.random.shuffle(candidate_indices)\n\n    # Step 2: Apply a guided move (swap with a promising item not in the solution)\n    for idx in candidate_indices:\n        if new_solution[idx] == 0:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n                break\n        else:\n            # Consider removing the item and adding a more valuable one\n            total_weight -= weight_lst[idx]\n            new_solution[idx] = 0\n            # Find the most valuable item not in the solution\n            available_items = np.where(new_solution == 0)[0]\n            if len(available_items) > 0:\n                # Prefer items that improve both objectives\n                combined_value = value1_lst + value2_lst\n                best_item = available_items[np.argmax(combined_value[available_items])]\n                if total_weight + weight_lst[best_item] <= capacity:\n                    new_solution[best_item] = 1\n                    total_weight += weight_lst[best_item]\n            break\n\n    # Step 3: Random flip to escape local optima\n    if random.random() < 0.3:\n        flip_idx = random.choice(np.arange(len(weight_lst)))\n        if new_solution[flip_idx] == 1:\n            if total_weight - weight_lst[flip_idx] >= 0:\n                new_solution[flip_idx] = 0\n        else:\n            if total_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 34,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its potential for local improvement by analyzing the trade-off between the two objectives, then applies a hybrid local search operator that combines item swaps, flips, and guided moves to explore the solution space while ensuring feasibility, thus generating a high-quality neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too extreme in either objective)\n    objectives = np.array([obj for _, obj in archive])\n    mean_obj = np.mean(objectives, axis=0)\n    distances = np.linalg.norm(objectives - mean_obj, axis=1)\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: swap, flip, and guided moves\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Randomly select a subset of items to consider for modification\n    candidate_indices = np.where(new_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.arange(len(weight_lst))\n    np.random.shuffle(candidate_indices)\n\n    # Step 2: Apply a guided move (swap with a promising item not in the solution)\n    for idx in candidate_indices:\n        if new_solution[idx] == 0:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n                break\n        else:\n            # Consider removing the item and adding a more valuable one\n            total_weight -= weight_lst[idx]\n            new_solution[idx] = 0\n            # Find the most valuable item not in the solution\n            available_items = np.where(new_solution == 0)[0]\n            if len(available_items) > 0:\n                # Prefer items that improve both objectives\n                combined_value = value1_lst + value2_lst\n                best_item = available_items[np.argmax(combined_value[available_items])]\n                if total_weight + weight_lst[best_item] <= capacity:\n                    new_solution[best_item] = 1\n                    total_weight += weight_lst[best_item]\n            break\n\n    # Step 3: Random flip to escape local optima\n    if random.random() < 0.3:\n        flip_idx = random.choice(np.arange(len(weight_lst)))\n        if new_solution[flip_idx] == 1:\n            if total_weight - weight_lst[flip_idx] >= 0:\n                new_solution[flip_idx] = 0\n        else:\n            if total_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.9284801494261996,
            3.9215634167194366
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too extreme in either objective)\n    objectives = np.array([obj for _, obj in archive])\n    mean_obj = np.mean(objectives, axis=0)\n    distances = np.linalg.norm(objectives - mean_obj, axis=1)\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: swap, flip, and guided moves\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Randomly select a subset of items to consider for modification\n    candidate_indices = np.where(new_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.arange(len(weight_lst))\n    np.random.shuffle(candidate_indices)\n\n    # Step 2: Apply a guided move (swap with a promising item not in the solution)\n    for idx in candidate_indices:\n        if new_solution[idx] == 0:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n                break\n        else:\n            # Consider removing the item and adding a more valuable one\n            total_weight -= weight_lst[idx]\n            new_solution[idx] = 0\n            # Find the most valuable item not in the solution\n            available_items = np.where(new_solution == 0)[0]\n            if len(available_items) > 0:\n                # Prefer items that improve both objectives\n                combined_value = value1_lst + value2_lst\n                best_item = available_items[np.argmax(combined_value[available_items])]\n                if total_weight + weight_lst[best_item] <= capacity:\n                    new_solution[best_item] = 1\n                    total_weight += weight_lst[best_item]\n            break\n\n    # Step 3: Random flip to escape local optima\n    if random.random() < 0.3:\n        flip_idx = random.choice(np.arange(len(weight_lst)))\n        if new_solution[flip_idx] == 1:\n            if total_weight - weight_lst[flip_idx] >= 0:\n                new_solution[flip_idx] = 0\n        else:\n            if total_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 35,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a hybrid of crowding distance and objective diversity, then applies a novel \"adaptive item swap and flip\" local search to generate a neighbor by intelligently swapping or flipping items while ensuring feasibility, balancing both objectives, and exploring high-potential regions of the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Use a hybrid of crowding distance and objective diversity\n    solutions = [s[0] for s in archive]\n    objectives = [s[1] for s in archive]\n\n    # Calculate crowding distance for each objective\n    crowding_distances = []\n    for i in range(2):\n        sorted_idx = np.argsort([obj[i] for obj in objectives])\n        sorted_obj = [objectives[idx][i] for idx in sorted_idx]\n        distances = np.zeros(len(sorted_obj))\n        distances[0] = distances[-1] = float('inf')\n        for j in range(1, len(sorted_obj)-1):\n            distances[j] = sorted_obj[j+1] - sorted_obj[j-1]\n        crowding_distances.append([distances[i] for i in np.argsort(sorted_idx)])\n\n    # Combine crowding distances and select a solution with high potential\n    total_scores = [crowding_distances[0][i] + crowding_distances[1][i] for i in range(len(archive))]\n    selected_idx = np.argmax(total_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Step 2: Generate a neighbor using adaptive item swap and flip\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Identify items that could be swapped or flipped\n    zero_indices = np.where(new_solution == 0)[0]\n    one_indices = np.where(new_solution == 1)[0]\n\n    # Adaptive strategy: prioritize items with high impact on both objectives\n    if len(zero_indices) > 0 and len(one_indices) > 0:\n        # Calculate potential impact of flipping each item\n        flip_candidates = []\n        for idx in zero_indices:\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                impact1 = value1_lst[idx]\n                impact2 = value2_lst[idx]\n                flip_candidates.append((idx, impact1, impact2))\n\n        for idx in one_indices:\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                impact1 = -value1_lst[idx]\n                impact2 = -value2_lst[idx]\n                flip_candidates.append((idx, impact1, impact2))\n\n        if flip_candidates:\n            # Select the item with the highest combined impact\n            flip_candidates.sort(key=lambda x: x[1] + x[2], reverse=True)\n            best_idx, _, _ = flip_candidates[0]\n            new_solution[best_idx] = 1 - new_solution[best_idx]\n\n    # Additional swap operation for diversity\n    if len(one_indices) >= 2:\n        # Select two items to swap\n        i, j = random.sample(list(one_indices), 2)\n        new_weight = current_weight - weight_lst[i] - weight_lst[j] + weight_lst[i] + weight_lst[j]\n        if new_weight <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8854811163817164,
            6.243106961250305
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Use a hybrid of crowding distance and objective diversity\n    solutions = [s[0] for s in archive]\n    objectives = [s[1] for s in archive]\n\n    # Calculate crowding distance for each objective\n    crowding_distances = []\n    for i in range(2):\n        sorted_idx = np.argsort([obj[i] for obj in objectives])\n        sorted_obj = [objectives[idx][i] for idx in sorted_idx]\n        distances = np.zeros(len(sorted_obj))\n        distances[0] = distances[-1] = float('inf')\n        for j in range(1, len(sorted_obj)-1):\n            distances[j] = sorted_obj[j+1] - sorted_obj[j-1]\n        crowding_distances.append([distances[i] for i in np.argsort(sorted_idx)])\n\n    # Combine crowding distances and select a solution with high potential\n    total_scores = [crowding_distances[0][i] + crowding_distances[1][i] for i in range(len(archive))]\n    selected_idx = np.argmax(total_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Step 2: Generate a neighbor using adaptive item swap and flip\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Identify items that could be swapped or flipped\n    zero_indices = np.where(new_solution == 0)[0]\n    one_indices = np.where(new_solution == 1)[0]\n\n    # Adaptive strategy: prioritize items with high impact on both objectives\n    if len(zero_indices) > 0 and len(one_indices) > 0:\n        # Calculate potential impact of flipping each item\n        flip_candidates = []\n        for idx in zero_indices:\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                impact1 = value1_lst[idx]\n                impact2 = value2_lst[idx]\n                flip_candidates.append((idx, impact1, impact2))\n\n        for idx in one_indices:\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                impact1 = -value1_lst[idx]\n                impact2 = -value2_lst[idx]\n                flip_candidates.append((idx, impact1, impact2))\n\n        if flip_candidates:\n            # Select the item with the highest combined impact\n            flip_candidates.sort(key=lambda x: x[1] + x[2], reverse=True)\n            best_idx, _, _ = flip_candidates[0]\n            new_solution[best_idx] = 1 - new_solution[best_idx]\n\n    # Additional swap operation for diversity\n    if len(one_indices) >= 2:\n        # Select two items to swap\n        i, j = random.sample(list(one_indices), 2)\n        new_weight = current_weight - weight_lst[i] - weight_lst[j] + weight_lst[i] + weight_lst[j]\n        if new_weight <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 36,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a hybrid local search strategy that combines random perturbation with a novel two-phase optimization (intelligent item swapping and capacity-aware adjustment) to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    top_k = max(1, len(archive) // 3)\n    selected_idx = random.randint(0, top_k - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Phase 1 - Intelligent item swapping\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    for _ in range(5):  # Try multiple swaps\n        # Randomly select items to swap (one in, one out)\n        out_items = np.where(base_solution == 1)[0]\n        in_items = np.where(base_solution == 0)[0]\n\n        if len(out_items) == 0 or len(in_items) == 0:\n            break\n\n        out_item = random.choice(out_items)\n        in_item = random.choice(in_items)\n\n        # Calculate new weight\n        new_weight = current_weight - weight_lst[out_item] + weight_lst[in_item]\n\n        if new_weight <= capacity:\n            # Perform swap\n            new_solution[out_item] = 0\n            new_solution[in_item] = 1\n            current_weight = new_weight\n\n    # Phase 2 - Capacity-aware adjustment (add/remove items to maximize objectives)\n    for _ in range(3):\n        # Randomly select an operation (add or remove)\n        operation = random.choice(['add', 'remove'])\n\n        if operation == 'add':\n            # Add highest value item that fits\n            available_items = np.where(new_solution == 0)[0]\n            if len(available_items) == 0:\n                continue\n\n            # Sort by combined value\n            combined_values = value1_lst + value2_lst\n            sorted_items = sorted(available_items, key=lambda x: -combined_values[x])\n\n            for item in sorted_items:\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n                    break\n        else:\n            # Remove lowest value item\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                continue\n\n            # Sort by combined value\n            combined_values = value1_lst + value2_lst\n            sorted_items = sorted(included_items, key=lambda x: combined_values[x])\n\n            for item in sorted_items:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.3141560707679516,
            10.263574123382568
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    top_k = max(1, len(archive) // 3)\n    selected_idx = random.randint(0, top_k - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Phase 1 - Intelligent item swapping\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    for _ in range(5):  # Try multiple swaps\n        # Randomly select items to swap (one in, one out)\n        out_items = np.where(base_solution == 1)[0]\n        in_items = np.where(base_solution == 0)[0]\n\n        if len(out_items) == 0 or len(in_items) == 0:\n            break\n\n        out_item = random.choice(out_items)\n        in_item = random.choice(in_items)\n\n        # Calculate new weight\n        new_weight = current_weight - weight_lst[out_item] + weight_lst[in_item]\n\n        if new_weight <= capacity:\n            # Perform swap\n            new_solution[out_item] = 0\n            new_solution[in_item] = 1\n            current_weight = new_weight\n\n    # Phase 2 - Capacity-aware adjustment (add/remove items to maximize objectives)\n    for _ in range(3):\n        # Randomly select an operation (add or remove)\n        operation = random.choice(['add', 'remove'])\n\n        if operation == 'add':\n            # Add highest value item that fits\n            available_items = np.where(new_solution == 0)[0]\n            if len(available_items) == 0:\n                continue\n\n            # Sort by combined value\n            combined_values = value1_lst + value2_lst\n            sorted_items = sorted(available_items, key=lambda x: -combined_values[x])\n\n            for item in sorted_items:\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n                    break\n        else:\n            # Remove lowest value item\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                continue\n\n            # Sort by combined value\n            combined_values = value1_lst + value2_lst\n            sorted_items = sorted(included_items, key=lambda x: combined_values[x])\n\n            for item in sorted_items:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 37,
        "algorithm": "{A novel local search heuristic called \"Adaptive Objective-Driven Swap and Shift\" intelligently selects a solution from the archive based on objective diversity and applies a hybrid neighborhood operator that combines random swaps, objective-specific shifts, and adaptive weight adjustments to ensure feasibility and high-quality multi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_obj1, current_obj2 = archive[selected_idx][1]\n\n    # Calculate current weight and values\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Determine which objective to prioritize for improvement\n    obj1_improvement = np.max(value1_lst) - current_value1\n    obj2_improvement = np.max(value2_lst) - current_value2\n\n    prioritize_obj1 = obj1_improvement > obj2_improvement\n\n    # Generate neighbor solution\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Hybrid neighborhood operator\n    if random.random() < 0.7:  # 70% chance for swap-based move\n        # Randomly select two items to swap\n        item1 = random.randint(0, n_items - 1)\n        item2 = random.randint(0, n_items - 1)\n        if item1 != item2:\n            # Calculate potential weight change\n            delta_weight = (weight_lst[item2] - weight_lst[item1]) * (new_solution[item1] - new_solution[item2])\n            if current_weight + delta_weight <= capacity:\n                new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n    else:  # 30% chance for shift-based move\n        # Select an item to potentially add or remove\n        item = random.randint(0, n_items - 1)\n        if new_solution[item] == 1:\n            # Remove the item\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n        else:\n            # Add the item if it fits\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n\n    # Adaptive adjustment to ensure feasibility\n    if np.sum(weight_lst[new_solution == 1]) > capacity:\n        # Remove items until feasible\n        while np.sum(weight_lst[new_solution == 1]) > capacity:\n            # Remove the item with the smallest ratio of (value1 + value2)/weight\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break\n            ratios = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n            remove_idx = included_items[np.argmin(ratios)]\n            new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.36308348978942534,
            4.70284315943718
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_obj1, current_obj2 = archive[selected_idx][1]\n\n    # Calculate current weight and values\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Determine which objective to prioritize for improvement\n    obj1_improvement = np.max(value1_lst) - current_value1\n    obj2_improvement = np.max(value2_lst) - current_value2\n\n    prioritize_obj1 = obj1_improvement > obj2_improvement\n\n    # Generate neighbor solution\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Hybrid neighborhood operator\n    if random.random() < 0.7:  # 70% chance for swap-based move\n        # Randomly select two items to swap\n        item1 = random.randint(0, n_items - 1)\n        item2 = random.randint(0, n_items - 1)\n        if item1 != item2:\n            # Calculate potential weight change\n            delta_weight = (weight_lst[item2] - weight_lst[item1]) * (new_solution[item1] - new_solution[item2])\n            if current_weight + delta_weight <= capacity:\n                new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n    else:  # 30% chance for shift-based move\n        # Select an item to potentially add or remove\n        item = random.randint(0, n_items - 1)\n        if new_solution[item] == 1:\n            # Remove the item\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n        else:\n            # Add the item if it fits\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n\n    # Adaptive adjustment to ensure feasibility\n    if np.sum(weight_lst[new_solution == 1]) > capacity:\n        # Remove items until feasible\n        while np.sum(weight_lst[new_solution == 1]) > capacity:\n            # Remove the item with the smallest ratio of (value1 + value2)/weight\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break\n            ratios = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n            remove_idx = included_items[np.argmin(ratios)]\n            new_solution[remove_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 38,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a solution from the archive, applies a combination of random perturbation and gradient-based improvement to generate a neighbor solution while ensuring feasibility, and prioritizes solutions with high potential for multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol_obj[0] for sol_obj in archive]\n    archive_values = np.array([sol_obj[1] for sol_obj in archive])\n\n    # Calculate the \"improvement potential\" as the sum of normalized values\n    if len(archive_values) > 1:\n        normalized_values = (archive_values - np.min(archive_values, axis=0)) / (np.max(archive_values, axis=0) - np.min(archive_values, axis=0) + 1e-8)\n        improvement_potential = np.sum(normalized_values, axis=1)\n        selected_idx = np.argmax(improvement_potential)\n    else:\n        selected_idx = 0\n\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random perturbation + gradient-based improvement\n    n_items = len(base_solution)\n\n    # Random perturbation: flip a random subset of items\n    flip_mask = np.random.rand(n_items) < 0.2\n    new_solution[flip_mask] = 1 - new_solution[flip_mask]\n\n    # Ensure feasibility by removing excess items\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        # Remove items with lowest ratio of (value1 + value2) / weight\n        item_ratios = (value1_lst + value2_lst) / weight_lst\n        sorted_indices = np.argsort(item_ratios)\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    # Gradient-based improvement: try to add items with high value-to-weight ratio\n    remaining_weight = capacity - np.sum(weight_lst[new_solution == 1])\n    if remaining_weight > 0:\n        # Calculate potential items to add\n        candidate_items = np.where(new_solution == 0)[0]\n        if len(candidate_items) > 0:\n            candidate_ratios = (value1_lst[candidate_items] + value2_lst[candidate_items]) / weight_lst[candidate_items]\n            sorted_candidates = candidate_items[np.argsort(-candidate_ratios)]\n\n            for idx in sorted_candidates:\n                if weight_lst[idx] <= remaining_weight:\n                    new_solution[idx] = 1\n                    remaining_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3515129635756633,
            4.656444430351257
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol_obj[0] for sol_obj in archive]\n    archive_values = np.array([sol_obj[1] for sol_obj in archive])\n\n    # Calculate the \"improvement potential\" as the sum of normalized values\n    if len(archive_values) > 1:\n        normalized_values = (archive_values - np.min(archive_values, axis=0)) / (np.max(archive_values, axis=0) - np.min(archive_values, axis=0) + 1e-8)\n        improvement_potential = np.sum(normalized_values, axis=1)\n        selected_idx = np.argmax(improvement_potential)\n    else:\n        selected_idx = 0\n\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random perturbation + gradient-based improvement\n    n_items = len(base_solution)\n\n    # Random perturbation: flip a random subset of items\n    flip_mask = np.random.rand(n_items) < 0.2\n    new_solution[flip_mask] = 1 - new_solution[flip_mask]\n\n    # Ensure feasibility by removing excess items\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        # Remove items with lowest ratio of (value1 + value2) / weight\n        item_ratios = (value1_lst + value2_lst) / weight_lst\n        sorted_indices = np.argsort(item_ratios)\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    # Gradient-based improvement: try to add items with high value-to-weight ratio\n    remaining_weight = capacity - np.sum(weight_lst[new_solution == 1])\n    if remaining_weight > 0:\n        # Calculate potential items to add\n        candidate_items = np.where(new_solution == 0)[0]\n        if len(candidate_items) > 0:\n            candidate_ratios = (value1_lst[candidate_items] + value2_lst[candidate_items]) / weight_lst[candidate_items]\n            sorted_candidates = candidate_items[np.argsort(-candidate_ratios)]\n\n            for idx in sorted_candidates:\n                if weight_lst[idx] <= remaining_weight:\n                    new_solution[idx] = 1\n                    remaining_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 39,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by evaluating the diversity and non-dominated status of solutions, then applies a hybrid local search combining random swaps and targeted flips to generate a feasible neighbor solution while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly biased toward diverse solutions)\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (i + 1) for i in range(len(archive))])[0]\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps + targeted flips\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Random swaps (exploration)\n    for _ in range(min(3, n_items // 2)):\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] != new_solution[j]:\n            delta_weight = (weight_lst[j] - weight_lst[i]) if new_solution[i] == 1 else (weight_lst[i] - weight_lst[j])\n            if current_weight + delta_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight += delta_weight\n                current_value1 += (value1_lst[j] - value1_lst[i]) if new_solution[i] == 1 else (value1_lst[i] - value1_lst[j])\n                current_value2 += (value2_lst[j] - value2_lst[i]) if new_solution[i] == 1 else (value2_lst[i] - value2_lst[j])\n\n    # Targeted flips (exploitation)\n    for i in range(n_items):\n        if new_solution[i] == 1:\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n                current_value1 -= value1_lst[i]\n                current_value2 -= value2_lst[i]\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                # Consider adding item if it improves both objectives\n                if (value1_lst[i] > 0 and value2_lst[i] > 0) or random.random() < 0.3:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n                    current_value1 += value1_lst[i]\n                    current_value2 += value2_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5138479338591969,
            4.2750853300094604
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly biased toward diverse solutions)\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (i + 1) for i in range(len(archive))])[0]\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps + targeted flips\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Random swaps (exploration)\n    for _ in range(min(3, n_items // 2)):\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] != new_solution[j]:\n            delta_weight = (weight_lst[j] - weight_lst[i]) if new_solution[i] == 1 else (weight_lst[i] - weight_lst[j])\n            if current_weight + delta_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight += delta_weight\n                current_value1 += (value1_lst[j] - value1_lst[i]) if new_solution[i] == 1 else (value1_lst[i] - value1_lst[j])\n                current_value2 += (value2_lst[j] - value2_lst[i]) if new_solution[i] == 1 else (value2_lst[i] - value2_lst[j])\n\n    # Targeted flips (exploitation)\n    for i in range(n_items):\n        if new_solution[i] == 1:\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n                current_value1 -= value1_lst[i]\n                current_value2 -= value2_lst[i]\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                # Consider adding item if it improves both objectives\n                if (value1_lst[i] > 0 and value2_lst[i] > 0) or random.random() < 0.3:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n                    current_value1 += value1_lst[i]\n                    current_value2 += value2_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 40,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a random solution from the archive\n    selected_idx = np.random.randint(len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Identify items that can be added or removed while maintaining feasibility\n    candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Check if removing this item keeps the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                candidates.append((i, -1))  # -1 indicates removal\n        else:\n            # Check if adding this item keeps the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                candidates.append((i, 1))  # 1 indicates addition\n\n    if not candidates:\n        return new_solution  # No feasible moves\n\n    # Randomly select a candidate\n    item_idx, action = random.choice(candidates)\n\n    # Apply the move\n    new_solution[item_idx] = 1 if action == 1 else 0\n\n    return new_solution\n\n",
        "score": [
            -0.9137471812983597,
            1.9506396353244781
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a random solution from the archive\n    selected_idx = np.random.randint(len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Identify items that can be added or removed while maintaining feasibility\n    candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Check if removing this item keeps the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                candidates.append((i, -1))  # -1 indicates removal\n        else:\n            # Check if adding this item keeps the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                candidates.append((i, 1))  # 1 indicates addition\n\n    if not candidates:\n        return new_solution  # No feasible moves\n\n    # Randomly select a candidate\n    item_idx, action = random.choice(candidates)\n\n    # Apply the move\n    new_solution[item_idx] = 1 if action == 1 else 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 41,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive item swapping with dynamic subset perturbation, prioritizing high-potential solutions based on marginal gains and diversity, to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of normalized objectives (prioritize high-potential solutions)\n        objectives = np.array([obj for _, obj in archive])\n        max_obj = np.max(objectives, axis=0)\n        normalized = objectives / (max_obj + 1e-10)  # Avoid division by zero\n        scores = np.sum(normalized, axis=1)\n        sorted_indices = np.argsort(scores)[::-1]\n        selected_idx = random.choices(sorted_indices[:max(1, len(archive)//2)], k=1)[0]\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and values\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Hybrid local search strategy\n    # Step 1: Adaptive item swapping (swap items if it improves both objectives)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        candidates = np.where(new_solution == 1)[0]\n        if len(candidates) < 2:\n            break\n        i, j = random.sample(list(candidates), 2)\n        if new_solution[i] == new_solution[j]:\n            continue\n\n        # Calculate new weight and values\n        new_weight = current_weight - weight_lst[i] + weight_lst[j]\n        if new_weight > capacity:\n            continue\n\n        new_value1 = current_value1 - value1_lst[i] + value1_lst[j]\n        new_value2 = current_value2 - value2_lst[i] + value2_lst[j]\n\n        # Accept if both objectives improve or one improves significantly\n        if (new_value1 > current_value1 and new_value2 > current_value2) or \\\n           (new_value1 > current_value1 + 0.1 * current_value1 and new_value2 > current_value2) or \\\n           (new_value1 > current_value1 and new_value2 > current_value2 - 0.1 * current_value2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight, current_value1, current_value2 = new_weight, new_value1, new_value2\n\n    # Step 2: Dynamic subset perturbation (flip a small subset of items)\n    perturbation_size = max(1, len(new_solution) // 10)\n    perturb_indices = random.sample(range(len(new_solution)), perturbation_size)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.43975853981024215,
            2.951557844877243
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of normalized objectives (prioritize high-potential solutions)\n        objectives = np.array([obj for _, obj in archive])\n        max_obj = np.max(objectives, axis=0)\n        normalized = objectives / (max_obj + 1e-10)  # Avoid division by zero\n        scores = np.sum(normalized, axis=1)\n        sorted_indices = np.argsort(scores)[::-1]\n        selected_idx = random.choices(sorted_indices[:max(1, len(archive)//2)], k=1)[0]\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and values\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Hybrid local search strategy\n    # Step 1: Adaptive item swapping (swap items if it improves both objectives)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        candidates = np.where(new_solution == 1)[0]\n        if len(candidates) < 2:\n            break\n        i, j = random.sample(list(candidates), 2)\n        if new_solution[i] == new_solution[j]:\n            continue\n\n        # Calculate new weight and values\n        new_weight = current_weight - weight_lst[i] + weight_lst[j]\n        if new_weight > capacity:\n            continue\n\n        new_value1 = current_value1 - value1_lst[i] + value1_lst[j]\n        new_value2 = current_value2 - value2_lst[i] + value2_lst[j]\n\n        # Accept if both objectives improve or one improves significantly\n        if (new_value1 > current_value1 and new_value2 > current_value2) or \\\n           (new_value1 > current_value1 + 0.1 * current_value1 and new_value2 > current_value2) or \\\n           (new_value1 > current_value1 and new_value2 > current_value2 - 0.1 * current_value2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight, current_value1, current_value2 = new_weight, new_value1, new_value2\n\n    # Step 2: Dynamic subset perturbation (flip a small subset of items)\n    perturbation_size = max(1, len(new_solution) // 10)\n    perturb_indices = random.sample(range(len(new_solution)), perturbation_size)\n    for idx in perturb_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 42,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search combining random perturbation and objective-specific swaps to generate a feasible neighbor solution that balances exploration and exploitation across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with high potential for improvement\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[(archive[i][1][0] + archive[i][1][1]) / (np.sum(archive[i][0]) + 1e-6) for i in range(len(archive))],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: random perturbation + objective-specific swaps\n    new_solution = base_solution.copy()\n\n    # Random perturbation (flip a few bits)\n    num_perturb = min(3, len(new_solution) // 5)\n    perturb_indices = random.sample(range(len(new_solution)), num_perturb)\n    for i in perturb_indices:\n        new_solution[i] = 1 - new_solution[i]\n\n    # Ensure feasibility after perturbation\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Remove excess items by objective-specific criteria\n        excess = total_weight - capacity\n        excess_items = np.where(new_solution == 1)[0]\n        # Sort by marginal contribution to both objectives\n        marginal_contributions = (value1_lst[excess_items] + value2_lst[excess_items]) / weight_lst[excess_items]\n        sorted_indices = np.argsort(marginal_contributions)\n        for i in sorted_indices:\n            if excess <= 0:\n                break\n            item_idx = excess_items[i]\n            if new_solution[item_idx] == 1:\n                new_solution[item_idx] = 0\n                excess -= weight_lst[item_idx]\n\n    # Objective-specific swaps\n    if random.random() < 0.7:  # Higher chance for objective-specific swaps\n        # Identify items to swap based on objective dominance\n        obj1_dominance = value1_lst / (value2_lst + 1e-6)\n        obj2_dominance = value2_lst / (value1_lst + 1e-6)\n\n        # Swap items based on objective dominance\n        for i in range(len(new_solution)):\n            if new_solution[i] == 0:\n                # Consider adding if it improves both objectives\n                if (obj1_dominance[i] > 1 and obj2_dominance[i] > 1):\n                    new_weight = np.sum(weight_lst[new_solution == 1]) + weight_lst[i]\n                    if new_weight <= capacity:\n                        new_solution[i] = 1\n            else:\n                # Consider removing if it hurts both objectives\n                if (obj1_dominance[i] < 1 and obj2_dominance[i] < 1):\n                    new_solution[i] = 0\n\n    # Final feasibility check\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # If still infeasible, remove random items\n        excess = total_weight - capacity\n        while excess > 0:\n            items = np.where(new_solution == 1)[0]\n            if len(items) == 0:\n                break\n            item_to_remove = random.choice(items)\n            new_solution[item_to_remove] = 0\n            excess -= weight_lst[item_to_remove]\n\n    return new_solution\n\n",
        "score": [
            -0.36765523804129974,
            5.890794724225998
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with high potential for improvement\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[(archive[i][1][0] + archive[i][1][1]) / (np.sum(archive[i][0]) + 1e-6) for i in range(len(archive))],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: random perturbation + objective-specific swaps\n    new_solution = base_solution.copy()\n\n    # Random perturbation (flip a few bits)\n    num_perturb = min(3, len(new_solution) // 5)\n    perturb_indices = random.sample(range(len(new_solution)), num_perturb)\n    for i in perturb_indices:\n        new_solution[i] = 1 - new_solution[i]\n\n    # Ensure feasibility after perturbation\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Remove excess items by objective-specific criteria\n        excess = total_weight - capacity\n        excess_items = np.where(new_solution == 1)[0]\n        # Sort by marginal contribution to both objectives\n        marginal_contributions = (value1_lst[excess_items] + value2_lst[excess_items]) / weight_lst[excess_items]\n        sorted_indices = np.argsort(marginal_contributions)\n        for i in sorted_indices:\n            if excess <= 0:\n                break\n            item_idx = excess_items[i]\n            if new_solution[item_idx] == 1:\n                new_solution[item_idx] = 0\n                excess -= weight_lst[item_idx]\n\n    # Objective-specific swaps\n    if random.random() < 0.7:  # Higher chance for objective-specific swaps\n        # Identify items to swap based on objective dominance\n        obj1_dominance = value1_lst / (value2_lst + 1e-6)\n        obj2_dominance = value2_lst / (value1_lst + 1e-6)\n\n        # Swap items based on objective dominance\n        for i in range(len(new_solution)):\n            if new_solution[i] == 0:\n                # Consider adding if it improves both objectives\n                if (obj1_dominance[i] > 1 and obj2_dominance[i] > 1):\n                    new_weight = np.sum(weight_lst[new_solution == 1]) + weight_lst[i]\n                    if new_weight <= capacity:\n                        new_solution[i] = 1\n            else:\n                # Consider removing if it hurts both objectives\n                if (obj1_dominance[i] < 1 and obj2_dominance[i] < 1):\n                    new_solution[i] = 0\n\n    # Final feasibility check\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # If still infeasible, remove random items\n        excess = total_weight - capacity\n        while excess > 0:\n            items = np.where(new_solution == 1)[0]\n            if len(items) == 0:\n                break\n            item_to_remove = random.choice(items)\n            new_solution[item_to_remove] = 0\n            excess -= weight_lst[item_to_remove]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 43,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = max(archive, key=lambda x: np.sum(x[0]))[0].copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify items with the highest marginal value-to-weight ratio for each objective\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n\n    # Combine marginal values and sort by their sum (prioritizing items that improve both objectives)\n    combined_marginal = marginal_value1 + marginal_value2\n    sorted_indices = np.argsort(-combined_marginal)\n\n    # Apply a hybrid local search: flip items with the highest marginal value, then perform a limited swap\n    new_solution = base_solution.copy()\n\n    # First, flip up to 3 items with the highest marginal value (if feasible)\n    for idx in sorted_indices[:3]:\n        if new_solution[idx] == 0:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n            else:\n                break\n\n    # Then, perform a limited swap: swap one item with the highest marginal value for another\n    if np.sum(new_solution) > 1:  # Ensure at least one item is selected\n        # Find the item with the lowest marginal value in the current solution\n        current_marginal = (value1_lst + value2_lst) * new_solution\n        worst_idx = np.argmin(current_marginal[current_marginal > 0])\n\n        # Find the best item not in the solution\n        best_idx = sorted_indices[0]\n        while best_idx in np.where(new_solution == 1)[0] or new_solution[best_idx] == 1:\n            best_idx = sorted_indices[np.where(sorted_indices == best_idx)[0][0] + 1]\n\n        # Swap if feasible\n        if (current_weight - weight_lst[worst_idx] + weight_lst[best_idx]) <= capacity:\n            new_solution[worst_idx] = 0\n            new_solution[best_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8746096872697682,
            3.475343257188797
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = max(archive, key=lambda x: np.sum(x[0]))[0].copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify items with the highest marginal value-to-weight ratio for each objective\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n\n    # Combine marginal values and sort by their sum (prioritizing items that improve both objectives)\n    combined_marginal = marginal_value1 + marginal_value2\n    sorted_indices = np.argsort(-combined_marginal)\n\n    # Apply a hybrid local search: flip items with the highest marginal value, then perform a limited swap\n    new_solution = base_solution.copy()\n\n    # First, flip up to 3 items with the highest marginal value (if feasible)\n    for idx in sorted_indices[:3]:\n        if new_solution[idx] == 0:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n            else:\n                break\n\n    # Then, perform a limited swap: swap one item with the highest marginal value for another\n    if np.sum(new_solution) > 1:  # Ensure at least one item is selected\n        # Find the item with the lowest marginal value in the current solution\n        current_marginal = (value1_lst + value2_lst) * new_solution\n        worst_idx = np.argmin(current_marginal[current_marginal > 0])\n\n        # Find the best item not in the solution\n        best_idx = sorted_indices[0]\n        while best_idx in np.where(new_solution == 1)[0] or new_solution[best_idx] == 1:\n            best_idx = sorted_indices[np.where(sorted_indices == best_idx)[0][0] + 1]\n\n        # Swap if feasible\n        if (current_weight - weight_lst[worst_idx] + weight_lst[best_idx]) <= capacity:\n            new_solution[worst_idx] = 0\n            new_solution[best_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 44,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a promising solution from the archive, then applies a multi-phase perturbation strategy combining item swaps, flips, and guided objective-driven flips to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Step 1: Intelligently select a promising solution from the archive\n    # Select a solution with high potential for improvement (e.g., not too crowded in the objective space)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Step 2: Generate a neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Phase 1: Random item flip with feasibility check\n    flip_idx = random.randint(0, n_items - 1)\n    if new_solution[flip_idx] == 1:\n        if np.sum(weight_lst[new_solution == 1]) - weight_lst[flip_idx] <= capacity:\n            new_solution[flip_idx] = 0\n    else:\n        if np.sum(weight_lst[new_solution == 1]) + weight_lst[flip_idx] <= capacity:\n            new_solution[flip_idx] = 1\n\n    # Phase 2: Guided objective-driven flip (prioritize items with high marginal value)\n    if random.random() < 0.5:  # 50% chance to apply this phase\n        marginal_value1 = value1_lst / (weight_lst + 1e-6)\n        marginal_value2 = value2_lst / (weight_lst + 1e-6)\n        combined_marginal = marginal_value1 + marginal_value2\n\n        # Sort items by combined marginal value in descending order\n        sorted_indices = np.argsort(-combined_marginal)\n\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                if np.sum(weight_lst[new_solution == 1]) - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n            else:\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    break  # Add one item at a time to control perturbation\n\n    # Phase 3: Random swap between items (if feasible)\n    if random.random() < 0.3:  # 30% chance to apply this phase\n        swap_indices = random.sample(range(n_items), 2)\n        i, j = swap_indices\n        if new_solution[i] != new_solution[j]:\n            if new_solution[i] == 1:\n                if np.sum(weight_lst[new_solution == 1]) - weight_lst[i] + weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[i] - weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.38569282825885015,
            2.3819403052330017
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Step 1: Intelligently select a promising solution from the archive\n    # Select a solution with high potential for improvement (e.g., not too crowded in the objective space)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Step 2: Generate a neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Phase 1: Random item flip with feasibility check\n    flip_idx = random.randint(0, n_items - 1)\n    if new_solution[flip_idx] == 1:\n        if np.sum(weight_lst[new_solution == 1]) - weight_lst[flip_idx] <= capacity:\n            new_solution[flip_idx] = 0\n    else:\n        if np.sum(weight_lst[new_solution == 1]) + weight_lst[flip_idx] <= capacity:\n            new_solution[flip_idx] = 1\n\n    # Phase 2: Guided objective-driven flip (prioritize items with high marginal value)\n    if random.random() < 0.5:  # 50% chance to apply this phase\n        marginal_value1 = value1_lst / (weight_lst + 1e-6)\n        marginal_value2 = value2_lst / (weight_lst + 1e-6)\n        combined_marginal = marginal_value1 + marginal_value2\n\n        # Sort items by combined marginal value in descending order\n        sorted_indices = np.argsort(-combined_marginal)\n\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                if np.sum(weight_lst[new_solution == 1]) - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n            else:\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    break  # Add one item at a time to control perturbation\n\n    # Phase 3: Random swap between items (if feasible)\n    if random.random() < 0.3:  # 30% chance to apply this phase\n        swap_indices = random.sample(range(n_items), 2)\n        i, j = swap_indices\n        if new_solution[i] != new_solution[j]:\n            if new_solution[i] == 1:\n                if np.sum(weight_lst[new_solution == 1]) - weight_lst[i] + weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[i] - weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 45,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines random item swaps with a greedy selection of items that improve both objectives, ensuring feasibility through weighted adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    import numpy as np\n\n    # Select a random solution from the archive\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_val1, current_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Get the current weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: random swaps with greedy improvements\n    for _ in range(5):  # Number of attempts\n        # Randomly select two items to swap\n        item1, item2 = random.sample(range(len(new_solution)), 2)\n\n        # Swap the items\n        new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n\n        # Calculate new weight\n        new_weight = current_weight - weight_lst[item1] + weight_lst[item2]\n\n        # If feasible, keep the swap; otherwise revert\n        if new_weight <= capacity:\n            current_weight = new_weight\n        else:\n            new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n\n    # Greedy addition of items that improve both objectives\n    for item in range(len(new_solution)):\n        if new_solution[item] == 0 and (current_weight + weight_lst[item]) <= capacity:\n            # Check if adding the item improves both objectives\n            if (value1_lst[item] > 0) and (value2_lst[item] > 0):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.3694755398064673,
            2.4980162978172302
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    import numpy as np\n\n    # Select a random solution from the archive\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_val1, current_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Get the current weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: random swaps with greedy improvements\n    for _ in range(5):  # Number of attempts\n        # Randomly select two items to swap\n        item1, item2 = random.sample(range(len(new_solution)), 2)\n\n        # Swap the items\n        new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n\n        # Calculate new weight\n        new_weight = current_weight - weight_lst[item1] + weight_lst[item2]\n\n        # If feasible, keep the swap; otherwise revert\n        if new_weight <= capacity:\n            current_weight = new_weight\n        else:\n            new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n\n    # Greedy addition of items that improve both objectives\n    for item in range(len(new_solution)):\n        if new_solution[item] == 0 and (current_weight + weight_lst[item]) <= capacity:\n            # Check if adding the item improves both objectives\n            if (value1_lst[item] > 0) and (value2_lst[item] > 0):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 46,
        "algorithm": "{The algorithm intelligently selects a solution from the archive by prioritizing those with high objective values and low dominance counts, then applies a hybrid local search combining item swaps and adaptive perturbations to generate a feasible neighbor solution with improved potential.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions with higher objective values and lower dominance counts\n    selected_solution, _ = max(archive, key=lambda x: (sum(x[1]), -sum(x[0])))\n\n    # Step 2: Generate a neighbor solution using a hybrid local search\n    new_solution = selected_solution.copy()\n    n_items = len(weight_lst)\n\n    # Randomly select a subset of items to consider for perturbation\n    subset_size = max(1, int(0.3 * n_items))\n    candidate_indices = random.sample(range(n_items), subset_size)\n\n    # Try to swap items in the subset to improve both objectives\n    for i in candidate_indices:\n        if new_solution[i] == 1:\n            # Try removing the item\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                # Accept the removal if it doesn't violate capacity\n                new_solution = temp_solution\n        else:\n            # Try adding the item\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                # Accept the addition if it doesn't violate capacity\n                new_solution = temp_solution\n\n    # Step 3: Perform adaptive perturbation based on objective values\n    current_obj1 = np.sum(value1_lst[new_solution == 1])\n    current_obj2 = np.sum(value2_lst[new_solution == 1])\n\n    # Perturb more aggressively if one objective is significantly worse than the other\n    if current_obj1 * 1.5 < current_obj2 or current_obj2 * 1.5 < current_obj1:\n        # Try to balance the objectives by adding/removing items with high value ratio\n        value_ratio = value1_lst / (value2_lst + 1e-10)  # Avoid division by zero\n        sorted_indices = np.argsort(-value_ratio)  # Sort by descending value ratio\n\n        for i in sorted_indices[:subset_size]:\n            if new_solution[i] == 0:\n                temp_solution = new_solution.copy()\n                temp_solution[i] = 1\n                temp_weight = np.sum(weight_lst[temp_solution == 1])\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.46412459670113915,
            9.622727423906326
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions with higher objective values and lower dominance counts\n    selected_solution, _ = max(archive, key=lambda x: (sum(x[1]), -sum(x[0])))\n\n    # Step 2: Generate a neighbor solution using a hybrid local search\n    new_solution = selected_solution.copy()\n    n_items = len(weight_lst)\n\n    # Randomly select a subset of items to consider for perturbation\n    subset_size = max(1, int(0.3 * n_items))\n    candidate_indices = random.sample(range(n_items), subset_size)\n\n    # Try to swap items in the subset to improve both objectives\n    for i in candidate_indices:\n        if new_solution[i] == 1:\n            # Try removing the item\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                # Accept the removal if it doesn't violate capacity\n                new_solution = temp_solution\n        else:\n            # Try adding the item\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                # Accept the addition if it doesn't violate capacity\n                new_solution = temp_solution\n\n    # Step 3: Perform adaptive perturbation based on objective values\n    current_obj1 = np.sum(value1_lst[new_solution == 1])\n    current_obj2 = np.sum(value2_lst[new_solution == 1])\n\n    # Perturb more aggressively if one objective is significantly worse than the other\n    if current_obj1 * 1.5 < current_obj2 or current_obj2 * 1.5 < current_obj1:\n        # Try to balance the objectives by adding/removing items with high value ratio\n        value_ratio = value1_lst / (value2_lst + 1e-10)  # Avoid division by zero\n        sorted_indices = np.argsort(-value_ratio)  # Sort by descending value ratio\n\n        for i in sorted_indices[:subset_size]:\n            if new_solution[i] == 0:\n                temp_solution = new_solution.copy()\n                temp_solution[i] = 1\n                temp_weight = np.sum(weight_lst[temp_solution == 1])\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 47,
        "algorithm": "{The proposed algorithm intelligently selects a solution from the archive by prioritizing those with the highest potential for local improvement, then applies a hybrid local search that combines adaptive bit-flipping with a novel objective-aware perturbation strategy to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1/(1 + np.sum(s[0])) for s in archive], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Hybrid local search: adaptive bit-flipping with objective-aware perturbation\n    new_solution = base_solution.copy()\n\n    # Step 1: Adaptive bit-flipping (flip bits with high marginal gain)\n    for _ in range(3):  # Number of flips\n        marginal_gains = []\n        for i in range(len(base_solution)):\n            if base_solution[i] == 1:\n                # Calculate marginal gain if removed\n                new_weight = current_weight - weight_lst[i]\n                if new_weight <= capacity:\n                    gain1 = -value1_lst[i]\n                    gain2 = -value2_lst[i]\n                    marginal_gains.append((i, gain1, gain2, new_weight))\n            else:\n                # Calculate marginal gain if added\n                new_weight = current_weight + weight_lst[i]\n                if new_weight <= capacity:\n                    gain1 = value1_lst[i]\n                    gain2 = value2_lst[i]\n                    marginal_gains.append((i, gain1, gain2, new_weight))\n\n        if not marginal_gains:\n            break\n\n        # Select flip with highest combined gain (lexicographic order)\n        marginal_gains.sort(key=lambda x: (-x[1], -x[2]))\n        best_flip = marginal_gains[0]\n        new_solution[best_flip[0]] = 1 - new_solution[best_flip[0]]\n        current_weight = best_flip[3]\n\n    # Step 2: Objective-aware perturbation (flip bits based on objective dominance)\n    if random.random() < 0.3:  # 30% chance to perturb\n        # Identify items that could improve both objectives\n        candidate_indices = []\n        for i in range(len(base_solution)):\n            if base_solution[i] == 1:\n                new_weight = current_weight - weight_lst[i]\n                if new_weight <= capacity:\n                    candidate_indices.append(i)\n            else:\n                new_weight = current_weight + weight_lst[i]\n                if new_weight <= capacity:\n                    candidate_indices.append(i)\n\n        if candidate_indices:\n            # Select items to flip based on objective dominance\n            flip_indices = random.sample(candidate_indices, min(2, len(candidate_indices)))\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.2582672391831487,
            8.946736872196198
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1/(1 + np.sum(s[0])) for s in archive], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Hybrid local search: adaptive bit-flipping with objective-aware perturbation\n    new_solution = base_solution.copy()\n\n    # Step 1: Adaptive bit-flipping (flip bits with high marginal gain)\n    for _ in range(3):  # Number of flips\n        marginal_gains = []\n        for i in range(len(base_solution)):\n            if base_solution[i] == 1:\n                # Calculate marginal gain if removed\n                new_weight = current_weight - weight_lst[i]\n                if new_weight <= capacity:\n                    gain1 = -value1_lst[i]\n                    gain2 = -value2_lst[i]\n                    marginal_gains.append((i, gain1, gain2, new_weight))\n            else:\n                # Calculate marginal gain if added\n                new_weight = current_weight + weight_lst[i]\n                if new_weight <= capacity:\n                    gain1 = value1_lst[i]\n                    gain2 = value2_lst[i]\n                    marginal_gains.append((i, gain1, gain2, new_weight))\n\n        if not marginal_gains:\n            break\n\n        # Select flip with highest combined gain (lexicographic order)\n        marginal_gains.sort(key=lambda x: (-x[1], -x[2]))\n        best_flip = marginal_gains[0]\n        new_solution[best_flip[0]] = 1 - new_solution[best_flip[0]]\n        current_weight = best_flip[3]\n\n    # Step 2: Objective-aware perturbation (flip bits based on objective dominance)\n    if random.random() < 0.3:  # 30% chance to perturb\n        # Identify items that could improve both objectives\n        candidate_indices = []\n        for i in range(len(base_solution)):\n            if base_solution[i] == 1:\n                new_weight = current_weight - weight_lst[i]\n                if new_weight <= capacity:\n                    candidate_indices.append(i)\n            else:\n                new_weight = current_weight + weight_lst[i]\n                if new_weight <= capacity:\n                    candidate_indices.append(i)\n\n        if candidate_indices:\n            # Select items to flip based on objective dominance\n            flip_indices = random.sample(candidate_indices, min(2, len(candidate_indices)))\n            for i in flip_indices:\n                new_solution[i] = 1 - new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 48,
        "algorithm": "{This algorithm intelligently selects a high-potential solution from the archive, applies a hybrid local search combining item swapping and probabilistic flipping to explore diverse neighborhoods while ensuring feasibility, and intelligently selects the best neighbor based on a multi-objective utility score.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligently select a promising solution from the archive\n    # Here, we select the solution with the highest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Probabilistic flipping of items\n    for i in range(len(new_solution)):\n        if np.random.rand() < 0.3:  # 30% chance to flip each item\n            if new_solution[i] == 1:\n                if current_weight > weight_lst[i] and current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    current_value1 -= value1_lst[i]\n                    current_value2 -= value2_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n                    current_value1 += value1_lst[i]\n                    current_value2 += value2_lst[i]\n\n    # Item swapping for further exploration\n    for _ in range(2):  # Perform 2 random swaps\n        candidates = np.where(new_solution == 1)[0]\n        if len(candidates) >= 2:\n            i, j = np.random.choice(candidates, 2, replace=False)\n            if new_solution[i] == 1 and new_solution[j] == 1:\n                # Swap items i and j\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                # If swap would make infeasible, try to find a better swap\n                for k in np.where(new_solution == 0)[0]:\n                    if (current_weight - weight_lst[i] + weight_lst[k] <= capacity and\n                        current_weight - weight_lst[j] + weight_lst[k] <= capacity):\n                        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.34988572130250434,
            5.926986515522003
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligently select a promising solution from the archive\n    # Here, we select the solution with the highest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Probabilistic flipping of items\n    for i in range(len(new_solution)):\n        if np.random.rand() < 0.3:  # 30% chance to flip each item\n            if new_solution[i] == 1:\n                if current_weight > weight_lst[i] and current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    current_value1 -= value1_lst[i]\n                    current_value2 -= value2_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n                    current_value1 += value1_lst[i]\n                    current_value2 += value2_lst[i]\n\n    # Item swapping for further exploration\n    for _ in range(2):  # Perform 2 random swaps\n        candidates = np.where(new_solution == 1)[0]\n        if len(candidates) >= 2:\n            i, j = np.random.choice(candidates, 2, replace=False)\n            if new_solution[i] == 1 and new_solution[j] == 1:\n                # Swap items i and j\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                # If swap would make infeasible, try to find a better swap\n                for k in np.where(new_solution == 0)[0]:\n                    if (current_weight - weight_lst[i] + weight_lst[k] <= capacity and\n                        current_weight - weight_lst[j] + weight_lst[k] <= capacity):\n                        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 49,
        "algorithm": "{The algorithm intelligently selects a solution from the archive with a high potential for improvement by analyzing both objective values and their trade-offs, then applies a hybrid local search operator that combines item swapping with a probabilistic acceptance criterion to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution based on the trade-off between objectives\n    selected_idx = random.choices(range(len(archive)), weights=[v1 + v2 for (v1, v2) in [obj for (sol, obj) in archive]], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search operator: item swapping with probabilistic acceptance\n    new_solution = base_solution.copy()\n    items = np.where(base_solution == 1)[0]\n    non_items = np.where(base_solution == 0)[0]\n\n    if len(items) > 0 and len(non_items) > 0:\n        # Randomly select an item to remove and a non-item to add\n        remove_idx = random.choice(items)\n        add_idx = random.choice(non_items)\n\n        # Check feasibility\n        if current_weight - weight_lst[remove_idx] + weight_lst[add_idx] <= capacity:\n            new_solution[remove_idx] = 0\n            new_solution[add_idx] = 1\n        else:\n            # If swap is infeasible, try to remove only\n            if random.random() < 0.5:\n                new_solution[remove_idx] = 0\n            else:\n                # Try to add only if feasible\n                if current_weight + weight_lst[add_idx] <= capacity:\n                    new_solution[add_idx] = 1\n\n    # Additional diversification: with 20% probability, perform a random flip\n    if random.random() < 0.2:\n        flip_idx = random.randint(0, len(base_solution) - 1)\n        if base_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.43784559648564636,
            4.028106719255447
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution based on the trade-off between objectives\n    selected_idx = random.choices(range(len(archive)), weights=[v1 + v2 for (v1, v2) in [obj for (sol, obj) in archive]], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search operator: item swapping with probabilistic acceptance\n    new_solution = base_solution.copy()\n    items = np.where(base_solution == 1)[0]\n    non_items = np.where(base_solution == 0)[0]\n\n    if len(items) > 0 and len(non_items) > 0:\n        # Randomly select an item to remove and a non-item to add\n        remove_idx = random.choice(items)\n        add_idx = random.choice(non_items)\n\n        # Check feasibility\n        if current_weight - weight_lst[remove_idx] + weight_lst[add_idx] <= capacity:\n            new_solution[remove_idx] = 0\n            new_solution[add_idx] = 1\n        else:\n            # If swap is infeasible, try to remove only\n            if random.random() < 0.5:\n                new_solution[remove_idx] = 0\n            else:\n                # Try to add only if feasible\n                if current_weight + weight_lst[add_idx] <= capacity:\n                    new_solution[add_idx] = 1\n\n    # Additional diversification: with 20% probability, perform a random flip\n    if random.random() < 0.2:\n        flip_idx = random.randint(0, len(base_solution) - 1)\n        if base_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 50,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search that combines item swaps and adaptive perturbation to explore the solution space while ensuring feasibility, balancing both objectives through dynamic weight adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution (e.g., random selection with bias towards high diversity)\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (i + 1) for i in range(len(archive))], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: adaptive item swaps and perturbations\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Adaptive item swaps (prioritize items with high marginal benefit)\n    for _ in range(min(5, n_items // 2)):\n        # Identify items not in the solution\n        zero_indices = np.where(new_solution == 0)[0]\n        if len(zero_indices) == 0:\n            break\n\n        # Select a candidate item to add (based on normalized marginal benefit)\n        marginal_benefits = (value1_lst + value2_lst) / weight_lst\n        candidate_idx = random.choices(zero_indices, weights=marginal_benefits[zero_indices], k=1)[0]\n\n        # Check feasibility\n        if current_weight + weight_lst[candidate_idx] <= capacity:\n            new_solution[candidate_idx] = 1\n            current_weight += weight_lst[candidate_idx]\n\n    # Step 2: Adaptive perturbations (flip items with low marginal contribution)\n    for _ in range(min(3, n_items // 4)):\n        one_indices = np.where(new_solution == 1)[0]\n        if len(one_indices) == 0:\n            break\n\n        # Select an item to remove (based on low marginal contribution)\n        marginal_contributions = (value1_lst + value2_lst) / weight_lst\n        candidate_idx = random.choices(one_indices, weights=1.0 / (marginal_contributions[one_indices] + 1e-6), k=1)[0]\n\n        new_solution[candidate_idx] = 0\n        current_weight -= weight_lst[candidate_idx]\n\n    # Step 3: Random flip to escape local optima\n    if random.random() < 0.3:\n        flip_idx = random.randint(0, n_items - 1)\n        if new_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] >= 0:\n                new_solution[flip_idx] = 0\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.3896147992166208,
            2.701593726873398
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution (e.g., random selection with bias towards high diversity)\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (i + 1) for i in range(len(archive))], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: adaptive item swaps and perturbations\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Adaptive item swaps (prioritize items with high marginal benefit)\n    for _ in range(min(5, n_items // 2)):\n        # Identify items not in the solution\n        zero_indices = np.where(new_solution == 0)[0]\n        if len(zero_indices) == 0:\n            break\n\n        # Select a candidate item to add (based on normalized marginal benefit)\n        marginal_benefits = (value1_lst + value2_lst) / weight_lst\n        candidate_idx = random.choices(zero_indices, weights=marginal_benefits[zero_indices], k=1)[0]\n\n        # Check feasibility\n        if current_weight + weight_lst[candidate_idx] <= capacity:\n            new_solution[candidate_idx] = 1\n            current_weight += weight_lst[candidate_idx]\n\n    # Step 2: Adaptive perturbations (flip items with low marginal contribution)\n    for _ in range(min(3, n_items // 4)):\n        one_indices = np.where(new_solution == 1)[0]\n        if len(one_indices) == 0:\n            break\n\n        # Select an item to remove (based on low marginal contribution)\n        marginal_contributions = (value1_lst + value2_lst) / weight_lst\n        candidate_idx = random.choices(one_indices, weights=1.0 / (marginal_contributions[one_indices] + 1e-6), k=1)[0]\n\n        new_solution[candidate_idx] = 0\n        current_weight -= weight_lst[candidate_idx]\n\n    # Step 3: Random flip to escape local optima\n    if random.random() < 0.3:\n        flip_idx = random.randint(0, n_items - 1)\n        if new_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] >= 0:\n                new_solution[flip_idx] = 0\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 51,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on its potential for local improvement, then applies a hybrid local search operator that combines item swaps with a novel value-weighted perturbation to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (np.max(objectives, axis=0) + 1e-10)  # Avoid division by zero\n    scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n    n_items = len(new_solution)\n\n    # Step 1: Randomly select a subset of items to consider for swaps (value-weighted)\n    item_weights = weight_lst\n    item_values = value1_lst + value2_lst  # Combined value for selection\n    selected_items = np.random.choice(n_items, size=min(5, n_items), p=item_values/np.sum(item_values), replace=False)\n\n    # Step 2: Perform value-weighted swaps\n    for item in selected_items:\n        if new_solution[item] == 1:\n            # Try to remove the item if it doesn't contribute much to the total value\n            if np.random.rand() < 0.3:\n                new_solution[item] = 0\n        else:\n            # Try to add the item if it fits and has high combined value\n            current_weight = np.sum(new_solution * weight_lst)\n            if current_weight + weight_lst[item] <= capacity and np.random.rand() < 0.7:\n                new_solution[item] = 1\n\n    # Step 3: Apply a perturbation (flip a random item with probability based on value)\n    perturbation_item = np.random.choice(n_items, p=item_values/np.sum(item_values))\n    new_solution[perturbation_item] = 1 - new_solution[perturbation_item]\n\n    # Ensure feasibility\n    current_weight = np.sum(new_solution * weight_lst)\n    if current_weight > capacity:\n        # Remove items randomly until feasible\n        excess = current_weight - capacity\n        while excess > 0 and np.sum(new_solution) > 0:\n            remove_candidates = np.where(new_solution == 1)[0]\n            if len(remove_candidates) == 0:\n                break\n            item_to_remove = np.random.choice(remove_candidates)\n            new_solution[item_to_remove] = 0\n            excess -= weight_lst[item_to_remove]\n\n    return new_solution\n\n",
        "score": [
            -0.33528520305879234,
            2.6283037066459656
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (np.max(objectives, axis=0) + 1e-10)  # Avoid division by zero\n    scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n    n_items = len(new_solution)\n\n    # Step 1: Randomly select a subset of items to consider for swaps (value-weighted)\n    item_weights = weight_lst\n    item_values = value1_lst + value2_lst  # Combined value for selection\n    selected_items = np.random.choice(n_items, size=min(5, n_items), p=item_values/np.sum(item_values), replace=False)\n\n    # Step 2: Perform value-weighted swaps\n    for item in selected_items:\n        if new_solution[item] == 1:\n            # Try to remove the item if it doesn't contribute much to the total value\n            if np.random.rand() < 0.3:\n                new_solution[item] = 0\n        else:\n            # Try to add the item if it fits and has high combined value\n            current_weight = np.sum(new_solution * weight_lst)\n            if current_weight + weight_lst[item] <= capacity and np.random.rand() < 0.7:\n                new_solution[item] = 1\n\n    # Step 3: Apply a perturbation (flip a random item with probability based on value)\n    perturbation_item = np.random.choice(n_items, p=item_values/np.sum(item_values))\n    new_solution[perturbation_item] = 1 - new_solution[perturbation_item]\n\n    # Ensure feasibility\n    current_weight = np.sum(new_solution * weight_lst)\n    if current_weight > capacity:\n        # Remove items randomly until feasible\n        excess = current_weight - capacity\n        while excess > 0 and np.sum(new_solution) > 0:\n            remove_candidates = np.where(new_solution == 1)[0]\n            if len(remove_candidates) == 0:\n                break\n            item_to_remove = np.random.choice(remove_candidates)\n            new_solution[item_to_remove] = 0\n            excess -= weight_lst[item_to_remove]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 52,
        "algorithm": "{A novel hybrid local search strategy combines adaptive neighborhood exploration with multi-objective sensitivity analysis to intelligently flip item selections based on their marginal contributions in both objectives, while ensuring feasibility through dynamic weight adjustment and objective-space diversity preservation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.zeros(len(weight_lst), dtype=int)\n\n    # Calculate potential improvement for each solution (normalized)\n    potentials = []\n    for sol, obj in archive:\n        current_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - current_weight\n        if remaining_capacity <= 0:\n            continue\n\n        # Calculate marginal contributions for items not in the solution\n        excluded_items = np.where(sol == 0)[0]\n        if len(excluded_items) == 0:\n            continue\n\n        marginal_weights = weight_lst[excluded_items]\n        marginal_value1 = value1_lst[excluded_items]\n        marginal_value2 = value2_lst[excluded_items]\n\n        # Normalize marginal contributions\n        norm_value1 = marginal_value1 / (marginal_weights + 1e-6)\n        norm_value2 = marginal_value2 / (marginal_weights + 1e-6)\n\n        # Combine normalized contributions (weighted sum)\n        combined_potential = 0.5 * norm_value1 + 0.5 * norm_value2\n        max_potential = np.max(combined_potential)\n\n        potentials.append((max_potential, sol))\n\n    if not potentials:\n        # Fallback: select a random solution if no improvement potential found\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        # Select solution with highest potential\n        base_solution = max(potentials, key=lambda x: x[0])[1].copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Generate neighbor solution using hybrid local search\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Identify items to consider for flipping\n    excluded_items = np.where(new_solution == 0)[0]\n    included_items = np.where(new_solution == 1)[0]\n\n    # Strategy 1: Add items with highest combined normalized value\n    if len(excluded_items) > 0 and remaining_capacity > 0:\n        excluded_weights = weight_lst[excluded_items]\n        excluded_value1 = value1_lst[excluded_items]\n        excluded_value2 = value2_lst[excluded_items]\n\n        # Normalize marginal contributions\n        norm_value1 = excluded_value1 / (excluded_weights + 1e-6)\n        norm_value2 = excluded_value2 / (excluded_weights + 1e-6)\n        combined_values = 0.5 * norm_value1 + 0.5 * norm_value2\n\n        # Sort by combined value (descending)\n        sorted_indices = np.argsort(-combined_values)\n        for idx in sorted_indices:\n            item_idx = excluded_items[idx]\n            if excluded_weights[idx] <= remaining_capacity:\n                new_solution[item_idx] = 1\n                remaining_capacity -= excluded_weights[idx]\n\n    # Strategy 2: Remove items with lowest combined normalized value\n    if len(included_items) > 0:\n        included_weights = weight_lst[included_items]\n        included_value1 = value1_lst[included_items]\n        included_value2 = value2_lst[included_items]\n\n        # Normalize marginal contributions\n        norm_value1 = included_value1 / (included_weights + 1e-6)\n        norm_value2 = included_value2 / (included_weights + 1e-6)\n        combined_values = 0.5 * norm_value1 + 0.5 * norm_value2\n\n        # Sort by combined value (ascending)\n        sorted_indices = np.argsort(combined_values)\n        for idx in sorted_indices:\n            item_idx = included_items[idx]\n            new_solution[item_idx] = 0\n            current_weight -= included_weights[idx]\n            remaining_capacity += included_weights[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8925006224178875,
            6.025281727313995
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.zeros(len(weight_lst), dtype=int)\n\n    # Calculate potential improvement for each solution (normalized)\n    potentials = []\n    for sol, obj in archive:\n        current_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - current_weight\n        if remaining_capacity <= 0:\n            continue\n\n        # Calculate marginal contributions for items not in the solution\n        excluded_items = np.where(sol == 0)[0]\n        if len(excluded_items) == 0:\n            continue\n\n        marginal_weights = weight_lst[excluded_items]\n        marginal_value1 = value1_lst[excluded_items]\n        marginal_value2 = value2_lst[excluded_items]\n\n        # Normalize marginal contributions\n        norm_value1 = marginal_value1 / (marginal_weights + 1e-6)\n        norm_value2 = marginal_value2 / (marginal_weights + 1e-6)\n\n        # Combine normalized contributions (weighted sum)\n        combined_potential = 0.5 * norm_value1 + 0.5 * norm_value2\n        max_potential = np.max(combined_potential)\n\n        potentials.append((max_potential, sol))\n\n    if not potentials:\n        # Fallback: select a random solution if no improvement potential found\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        # Select solution with highest potential\n        base_solution = max(potentials, key=lambda x: x[0])[1].copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Generate neighbor solution using hybrid local search\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Identify items to consider for flipping\n    excluded_items = np.where(new_solution == 0)[0]\n    included_items = np.where(new_solution == 1)[0]\n\n    # Strategy 1: Add items with highest combined normalized value\n    if len(excluded_items) > 0 and remaining_capacity > 0:\n        excluded_weights = weight_lst[excluded_items]\n        excluded_value1 = value1_lst[excluded_items]\n        excluded_value2 = value2_lst[excluded_items]\n\n        # Normalize marginal contributions\n        norm_value1 = excluded_value1 / (excluded_weights + 1e-6)\n        norm_value2 = excluded_value2 / (excluded_weights + 1e-6)\n        combined_values = 0.5 * norm_value1 + 0.5 * norm_value2\n\n        # Sort by combined value (descending)\n        sorted_indices = np.argsort(-combined_values)\n        for idx in sorted_indices:\n            item_idx = excluded_items[idx]\n            if excluded_weights[idx] <= remaining_capacity:\n                new_solution[item_idx] = 1\n                remaining_capacity -= excluded_weights[idx]\n\n    # Strategy 2: Remove items with lowest combined normalized value\n    if len(included_items) > 0:\n        included_weights = weight_lst[included_items]\n        included_value1 = value1_lst[included_items]\n        included_value2 = value2_lst[included_items]\n\n        # Normalize marginal contributions\n        norm_value1 = included_value1 / (included_weights + 1e-6)\n        norm_value2 = included_value2 / (included_weights + 1e-6)\n        combined_values = 0.5 * norm_value1 + 0.5 * norm_value2\n\n        # Sort by combined value (ascending)\n        sorted_indices = np.argsort(combined_values)\n        for idx in sorted_indices:\n            item_idx = included_items[idx]\n            new_solution[item_idx] = 0\n            current_weight -= included_weights[idx]\n            remaining_capacity += included_weights[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 53,
        "algorithm": "{The heuristic selects a solution from the archive with high objective diversity and applies a novel \"guided flip-and-relocate\" local search, which intelligently flips item selections and relocates subsets of items to balance objectives and improve feasibility, ensuring the neighbor remains feasible.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by objective diversity (sum of normalized differences)\n        objectives = np.array([obj for (sol, obj) in archive])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        diversity = np.sum(np.abs(normalized - normalized.mean(axis=0)), axis=1)\n        selected_idx = np.argmax(diversity)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Guided flip-and-relocate local search\n    for _ in range(5):  # Limited iterations for computational efficiency\n        # Step 1: Flip a random subset of items (guided by value ratios)\n        flip_mask = np.random.rand(n_items) < 0.3  # 30% chance to flip\n        flip_indices = np.where(flip_mask)[0]\n        if len(flip_indices) > 0:\n            # Bias flips towards items with high value-to-weight ratios\n            ratios = (value1_lst + value2_lst) / weight_lst\n            top_k = min(5, len(flip_indices))\n            top_indices = np.argsort(ratios[flip_indices])[-top_k:]\n            new_solution[flip_indices[top_indices]] = 1 - new_solution[flip_indices[top_indices]]\n\n        # Step 2: Relocate a subset of items (guided by objective balance)\n        if np.random.rand() < 0.5:  # 50% chance to relocate\n            # Select a random subset of items to relocate\n            relocate_mask = np.random.rand(n_items) < 0.2  # 20% chance per item\n            relocate_indices = np.where(relocate_mask)[0]\n            if len(relocate_indices) > 0:\n                # Calculate current total weight and values\n                current_weight = np.sum(weight_lst[new_solution == 1])\n                current_value1 = np.sum(value1_lst[new_solution == 1])\n                current_value2 = np.sum(value2_lst[new_solution == 1])\n\n                # Try to relocate items to balance objectives\n                for idx in relocate_indices:\n                    if new_solution[idx] == 1:\n                        # Remove item if it's in the solution\n                        new_weight = current_weight - weight_lst[idx]\n                        if new_weight <= capacity:\n                            new_solution[idx] = 0\n                            current_weight = new_weight\n                    else:\n                        # Add item if it's not in the solution and feasible\n                        if (current_weight + weight_lst[idx]) <= capacity:\n                            new_solution[idx] = 1\n                            current_weight += weight_lst[idx]\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # If not feasible, remove items randomly until feasible\n        excess_mask = new_solution == 1\n        excess_indices = np.where(excess_mask)[0]\n        np.random.shuffle(excess_indices)\n        for idx in excess_indices:\n            if total_weight <= capacity:\n                break\n            new_solution[idx] = 0\n            total_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3653386934399227,
            3.213984578847885
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by objective diversity (sum of normalized differences)\n        objectives = np.array([obj for (sol, obj) in archive])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        diversity = np.sum(np.abs(normalized - normalized.mean(axis=0)), axis=1)\n        selected_idx = np.argmax(diversity)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Guided flip-and-relocate local search\n    for _ in range(5):  # Limited iterations for computational efficiency\n        # Step 1: Flip a random subset of items (guided by value ratios)\n        flip_mask = np.random.rand(n_items) < 0.3  # 30% chance to flip\n        flip_indices = np.where(flip_mask)[0]\n        if len(flip_indices) > 0:\n            # Bias flips towards items with high value-to-weight ratios\n            ratios = (value1_lst + value2_lst) / weight_lst\n            top_k = min(5, len(flip_indices))\n            top_indices = np.argsort(ratios[flip_indices])[-top_k:]\n            new_solution[flip_indices[top_indices]] = 1 - new_solution[flip_indices[top_indices]]\n\n        # Step 2: Relocate a subset of items (guided by objective balance)\n        if np.random.rand() < 0.5:  # 50% chance to relocate\n            # Select a random subset of items to relocate\n            relocate_mask = np.random.rand(n_items) < 0.2  # 20% chance per item\n            relocate_indices = np.where(relocate_mask)[0]\n            if len(relocate_indices) > 0:\n                # Calculate current total weight and values\n                current_weight = np.sum(weight_lst[new_solution == 1])\n                current_value1 = np.sum(value1_lst[new_solution == 1])\n                current_value2 = np.sum(value2_lst[new_solution == 1])\n\n                # Try to relocate items to balance objectives\n                for idx in relocate_indices:\n                    if new_solution[idx] == 1:\n                        # Remove item if it's in the solution\n                        new_weight = current_weight - weight_lst[idx]\n                        if new_weight <= capacity:\n                            new_solution[idx] = 0\n                            current_weight = new_weight\n                    else:\n                        # Add item if it's not in the solution and feasible\n                        if (current_weight + weight_lst[idx]) <= capacity:\n                            new_solution[idx] = 1\n                            current_weight += weight_lst[idx]\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # If not feasible, remove items randomly until feasible\n        excess_mask = new_solution == 1\n        excess_indices = np.where(excess_mask)[0]\n        np.random.shuffle(excess_indices)\n        for idx in excess_indices:\n            if total_weight <= capacity:\n                break\n            new_solution[idx] = 0\n            total_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 54,
        "algorithm": "{The heuristic function selects a promising solution from the archive based on its objective values and applies a hybrid local search operator that combines random item swaps and weighted value-based flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n        top_30 = int(0.3 * len(sorted_archive))\n        selected_idx = random.randint(0, min(top_30, len(sorted_archive)-1))\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps and weighted flips\n    for _ in range(2):  # Number of operations\n        # Random swap\n        items = np.where(new_solution == 1)[0]\n        if len(items) >= 2:\n            i, j = random.sample(list(items), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Weighted flip (higher chance for items with higher value)\n        weights = value1_lst + value2_lst\n        weights[new_solution == 0] *= 0.5  # Lower chance to add items\n        weights[new_solution == 1] *= 1.5  # Higher chance to remove items\n        flip_idx = random.choices(np.arange(len(weight_lst)), weights=weights, k=1)[0]\n\n        if new_solution[flip_idx] == 1:\n            # Check if removing the item keeps the solution feasible\n            if np.sum(weight_lst[new_solution == 1]) - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n        else:\n            # Check if adding the item keeps the solution feasible\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.3404604389601078,
            2.78618061542511
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n        top_30 = int(0.3 * len(sorted_archive))\n        selected_idx = random.randint(0, min(top_30, len(sorted_archive)-1))\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps and weighted flips\n    for _ in range(2):  # Number of operations\n        # Random swap\n        items = np.where(new_solution == 1)[0]\n        if len(items) >= 2:\n            i, j = random.sample(list(items), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Weighted flip (higher chance for items with higher value)\n        weights = value1_lst + value2_lst\n        weights[new_solution == 0] *= 0.5  # Lower chance to add items\n        weights[new_solution == 1] *= 1.5  # Higher chance to remove items\n        flip_idx = random.choices(np.arange(len(weight_lst)), weights=weights, k=1)[0]\n\n        if new_solution[flip_idx] == 1:\n            # Check if removing the item keeps the solution feasible\n            if np.sum(weight_lst[new_solution == 1]) - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n        else:\n            # Check if adding the item keeps the solution feasible\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 55,
        "algorithm": "{A hybrid local search algorithm that intelligently selects a solution from the archive, applies a novel neighborhood exploration strategy combining item swaps and adaptive perturbations to balance exploration and exploitation, and ensures feasibility by dynamically adjusting the perturbation size based on the current solution's weight and objective values.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with higher potential for improvement\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate candidate neighbors\n    candidates = []\n    for _ in range(10):  # Generate multiple candidates\n        new_solution = base_solution.copy()\n\n        # Hybrid local search: combination of item swaps and adaptive perturbations\n        if random.random() < 0.7:  # 70% chance for item swap\n            # Select two distinct items: one in the knapsack, one out\n            in_items = np.where(new_solution == 1)[0]\n            out_items = np.where(new_solution == 0)[0]\n\n            if len(in_items) > 0 and len(out_items) > 0:\n                swap_in = random.choice(in_items)\n                swap_out = random.choice(out_items)\n\n                # Check feasibility of swap\n                new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n                if new_weight <= capacity:\n                    new_solution[swap_in], new_solution[swap_out] = new_solution[swap_out], new_solution[swap_in]\n                    candidates.append(new_solution)\n        else:  # 30% chance for adaptive perturbation\n            # Perturb the solution by flipping a random number of items\n            num_flips = min(3, len(base_solution))  # Limit to 3 flips\n            flip_indices = random.sample(range(len(base_solution)), num_flips)\n\n            # Calculate new weight\n            new_weight = current_weight\n            for idx in flip_indices:\n                if new_solution[idx] == 1:\n                    new_weight -= weight_lst[idx]\n                else:\n                    new_weight += weight_lst[idx]\n\n            if new_weight <= capacity:\n                new_solution[flip_indices] = 1 - new_solution[flip_indices]\n                candidates.append(new_solution)\n\n    if not candidates:\n        return base_solution.copy()  # Return original if no feasible neighbors found\n\n    # Select the best candidate based on both objectives\n    best_candidate = None\n    best_score = -np.inf\n    for candidate in candidates:\n        total_value1 = np.sum(value1_lst[candidate == 1])\n        total_value2 = np.sum(value2_lst[candidate == 1])\n        score = total_value1 + total_value2  # Simple combined score\n        if score > best_score:\n            best_score = score\n            best_candidate = candidate\n\n    return best_candidate.copy()\n\n",
        "score": [
            -0.34627552904447845,
            2.3825640082359314
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with higher potential for improvement\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate candidate neighbors\n    candidates = []\n    for _ in range(10):  # Generate multiple candidates\n        new_solution = base_solution.copy()\n\n        # Hybrid local search: combination of item swaps and adaptive perturbations\n        if random.random() < 0.7:  # 70% chance for item swap\n            # Select two distinct items: one in the knapsack, one out\n            in_items = np.where(new_solution == 1)[0]\n            out_items = np.where(new_solution == 0)[0]\n\n            if len(in_items) > 0 and len(out_items) > 0:\n                swap_in = random.choice(in_items)\n                swap_out = random.choice(out_items)\n\n                # Check feasibility of swap\n                new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n                if new_weight <= capacity:\n                    new_solution[swap_in], new_solution[swap_out] = new_solution[swap_out], new_solution[swap_in]\n                    candidates.append(new_solution)\n        else:  # 30% chance for adaptive perturbation\n            # Perturb the solution by flipping a random number of items\n            num_flips = min(3, len(base_solution))  # Limit to 3 flips\n            flip_indices = random.sample(range(len(base_solution)), num_flips)\n\n            # Calculate new weight\n            new_weight = current_weight\n            for idx in flip_indices:\n                if new_solution[idx] == 1:\n                    new_weight -= weight_lst[idx]\n                else:\n                    new_weight += weight_lst[idx]\n\n            if new_weight <= capacity:\n                new_solution[flip_indices] = 1 - new_solution[flip_indices]\n                candidates.append(new_solution)\n\n    if not candidates:\n        return base_solution.copy()  # Return original if no feasible neighbors found\n\n    # Select the best candidate based on both objectives\n    best_candidate = None\n    best_score = -np.inf\n    for candidate in candidates:\n        total_value1 = np.sum(value1_lst[candidate == 1])\n        total_value2 = np.sum(value2_lst[candidate == 1])\n        score = total_value1 + total_value2  # Simple combined score\n        if score > best_score:\n            best_score = score\n            best_candidate = candidate\n\n    return best_candidate.copy()\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 56,
        "algorithm": "{The heuristic selects a solution from the archive with high potential for improvement by prioritizing solutions with high marginal gains in either objective, then applies a hybrid local search that combines item swaps with probabilistic inclusion/exclusion of items based on their value-to-weight ratios, ensuring feasibility and maximizing multi-objective gains.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [s[0] for s in archive]\n    archive_objectives = [s[1] for s in archive]\n\n    # Calculate marginal gains for each solution\n    marginal_gains = []\n    for i, (sol, obj) in enumerate(zip(archive_solutions, archive_objectives)):\n        total_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - total_weight\n        if remaining_capacity <= 0:\n            marginal_gains.append((0, 0))\n            continue\n\n        # Calculate potential marginal gains for adding items\n        potential_adds = (sol == 0) & (weight_lst <= remaining_capacity)\n        marginal_gain1 = np.sum(value1_lst * potential_adds)\n        marginal_gain2 = np.sum(value2_lst * potential_adds)\n        marginal_gains.append((marginal_gain1, marginal_gain2))\n\n    # Select solution with highest marginal gain in either objective\n    max_gain1 = max(g[0] for g in marginal_gains)\n    max_gain2 = max(g[1] for g in marginal_gains)\n    candidate_indices = [i for i, g in enumerate(marginal_gains) if g[0] == max_gain1 or g[1] == max_gain2]\n\n    if not candidate_indices:\n        base_solution = random.choice(archive_solutions).copy()\n    else:\n        base_solution = archive_solutions[random.choice(candidate_indices)].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Probabilistic item inclusion/exclusion based on value-to-weight ratios\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Randomly exclude items with low value-to-weight ratio\n            if random.random() < 0.3:  # 30% chance to consider exclusion\n                v1_ratio = value1_lst[i] / weight_lst[i]\n                v2_ratio = value2_lst[i] / weight_lst[i]\n                if v1_ratio < 0.7 * np.mean(value1_lst / weight_lst) and v2_ratio < 0.7 * np.mean(value2_lst / weight_lst):\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n        else:\n            # Randomly include items with high value-to-weight ratio\n            if random.random() < 0.3:  # 30% chance to consider inclusion\n                if weight_lst[i] <= remaining_capacity:\n                    v1_ratio = value1_lst[i] / weight_lst[i]\n                    v2_ratio = value2_lst[i] / weight_lst[i]\n                    if v1_ratio > 1.3 * np.mean(value1_lst / weight_lst) or v2_ratio > 1.3 * np.mean(value2_lst / weight_lst):\n                        new_solution[i] = 1\n                        current_weight += weight_lst[i]\n                        remaining_capacity -= weight_lst[i]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        # Remove items until feasible\n        items = np.where(new_solution == 1)[0]\n        np.random.shuffle(items)\n        for i in items:\n            if current_weight > capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7982127772869245,
            9.04190593957901
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [s[0] for s in archive]\n    archive_objectives = [s[1] for s in archive]\n\n    # Calculate marginal gains for each solution\n    marginal_gains = []\n    for i, (sol, obj) in enumerate(zip(archive_solutions, archive_objectives)):\n        total_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - total_weight\n        if remaining_capacity <= 0:\n            marginal_gains.append((0, 0))\n            continue\n\n        # Calculate potential marginal gains for adding items\n        potential_adds = (sol == 0) & (weight_lst <= remaining_capacity)\n        marginal_gain1 = np.sum(value1_lst * potential_adds)\n        marginal_gain2 = np.sum(value2_lst * potential_adds)\n        marginal_gains.append((marginal_gain1, marginal_gain2))\n\n    # Select solution with highest marginal gain in either objective\n    max_gain1 = max(g[0] for g in marginal_gains)\n    max_gain2 = max(g[1] for g in marginal_gains)\n    candidate_indices = [i for i, g in enumerate(marginal_gains) if g[0] == max_gain1 or g[1] == max_gain2]\n\n    if not candidate_indices:\n        base_solution = random.choice(archive_solutions).copy()\n    else:\n        base_solution = archive_solutions[random.choice(candidate_indices)].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Probabilistic item inclusion/exclusion based on value-to-weight ratios\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Randomly exclude items with low value-to-weight ratio\n            if random.random() < 0.3:  # 30% chance to consider exclusion\n                v1_ratio = value1_lst[i] / weight_lst[i]\n                v2_ratio = value2_lst[i] / weight_lst[i]\n                if v1_ratio < 0.7 * np.mean(value1_lst / weight_lst) and v2_ratio < 0.7 * np.mean(value2_lst / weight_lst):\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n        else:\n            # Randomly include items with high value-to-weight ratio\n            if random.random() < 0.3:  # 30% chance to consider inclusion\n                if weight_lst[i] <= remaining_capacity:\n                    v1_ratio = value1_lst[i] / weight_lst[i]\n                    v2_ratio = value2_lst[i] / weight_lst[i]\n                    if v1_ratio > 1.3 * np.mean(value1_lst / weight_lst) or v2_ratio > 1.3 * np.mean(value2_lst / weight_lst):\n                        new_solution[i] = 1\n                        current_weight += weight_lst[i]\n                        remaining_capacity -= weight_lst[i]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        # Remove items until feasible\n        items = np.where(new_solution == 1)[0]\n        np.random.shuffle(items)\n        for i in items:\n            if current_weight > capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 57,
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective diversity and local improvement potential, then applies a hybrid local search operator that intelligently combines random item swaps with gradient-based objective improvements to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Select solutions with high objective diversity and local improvement potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Step 2.1: Random item swap with feasibility check\n    for _ in range(5):  # Try up to 5 random swaps\n        if random.random() < 0.5:  # 50% chance to swap\n            i, j = random.sample(range(len(new_solution)), 2)\n            if new_solution[i] != new_solution[j]:\n                # Check feasibility after swap\n                delta_weight = (new_solution[j] - new_solution[i]) * (weight_lst[i] - weight_lst[j])\n                if current_weight + delta_weight <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    current_weight += delta_weight\n\n    # Step 2.2: Gradient-based objective improvement\n    # Calculate marginal gains for each item\n    marginal_gains1 = value1_lst / (weight_lst + 1e-8)  # Avoid division by zero\n    marginal_gains2 = value2_lst / (weight_lst + 1e-8)\n\n    # Combine marginal gains with a weighted approach\n    combined_gains = 0.6 * marginal_gains1 + 0.4 * marginal_gains2\n\n    # Sort items by combined marginal gains\n    sorted_indices = np.argsort(combined_gains)[::-1]\n\n    # Try to add high-gain items not in solution\n    for i in sorted_indices:\n        if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            new_solution[i] = 1\n            current_weight += weight_lst[i]\n\n    # Step 3: Ensure feasibility (in case of rounding errors)\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Remove the lightest item in the solution\n        in_solution = np.where(new_solution == 1)[0]\n        if len(in_solution) > 0:\n            lightest_idx = in_solution[np.argmin(weight_lst[in_solution])]\n            new_solution[lightest_idx] = 0\n        else:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.30780901694676027,
            7.505530089139938
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Select solutions with high objective diversity and local improvement potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Step 2.1: Random item swap with feasibility check\n    for _ in range(5):  # Try up to 5 random swaps\n        if random.random() < 0.5:  # 50% chance to swap\n            i, j = random.sample(range(len(new_solution)), 2)\n            if new_solution[i] != new_solution[j]:\n                # Check feasibility after swap\n                delta_weight = (new_solution[j] - new_solution[i]) * (weight_lst[i] - weight_lst[j])\n                if current_weight + delta_weight <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    current_weight += delta_weight\n\n    # Step 2.2: Gradient-based objective improvement\n    # Calculate marginal gains for each item\n    marginal_gains1 = value1_lst / (weight_lst + 1e-8)  # Avoid division by zero\n    marginal_gains2 = value2_lst / (weight_lst + 1e-8)\n\n    # Combine marginal gains with a weighted approach\n    combined_gains = 0.6 * marginal_gains1 + 0.4 * marginal_gains2\n\n    # Sort items by combined marginal gains\n    sorted_indices = np.argsort(combined_gains)[::-1]\n\n    # Try to add high-gain items not in solution\n    for i in sorted_indices:\n        if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            new_solution[i] = 1\n            current_weight += weight_lst[i]\n\n    # Step 3: Ensure feasibility (in case of rounding errors)\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Remove the lightest item in the solution\n        in_solution = np.where(new_solution == 1)[0]\n        if len(in_solution) > 0:\n            lightest_idx = in_solution[np.argmin(weight_lst[in_solution])]\n            new_solution[lightest_idx] = 0\n        else:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 58,
        "algorithm": "{A hybrid local search algorithm that intelligently selects a solution from the archive based on its potential for improvement, then applies a novel combination of swap and perturbation operations to generate a neighbor solution while ensuring feasibility and maximizing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidate_indices = []\n    for idx, (solution, _) in enumerate(archive):\n        # Calculate the diversity of the solution (number of unique items)\n        diversity = np.sum(solution)\n        # Prefer solutions with moderate diversity (not too sparse or too dense)\n        if diversity > 0 and diversity < len(solution) / 2:\n            candidate_indices.append(idx)\n\n    if not candidate_indices:\n        candidate_indices = list(range(len(archive)))\n\n    selected_idx = random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    # Hybrid of swap and perturbation\n    num_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Step 2.1: Random swap of two items (if feasible)\n    if len(base_solution) >= 2:\n        i, j = random.sample(range(num_items), 2)\n        if base_solution[i] != base_solution[j]:\n            # Swap items i and j\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            # Check feasibility\n            new_weight = total_weight + (weight_lst[j] - weight_lst[i]) * (2 * base_solution[i] - 1)\n            if new_weight <= capacity:\n                return new_solution\n            else:\n                # Revert if infeasible\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2.2: Perturbation - flip a random item (if feasible)\n    k = random.randint(0, num_items - 1)\n    if base_solution[k] == 1:\n        # Try removing item k\n        new_weight = total_weight - weight_lst[k]\n        if new_weight >= 0:\n            new_solution[k] = 0\n            return new_solution\n    else:\n        # Try adding item k\n        new_weight = total_weight + weight_lst[k]\n        if new_weight <= capacity:\n            new_solution[k] = 1\n            return new_solution\n\n    # Step 2.3: If no feasible move, return the base solution\n    return new_solution\n\n",
        "score": [
            -0.34208899515425883,
            5.8565512001514435
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidate_indices = []\n    for idx, (solution, _) in enumerate(archive):\n        # Calculate the diversity of the solution (number of unique items)\n        diversity = np.sum(solution)\n        # Prefer solutions with moderate diversity (not too sparse or too dense)\n        if diversity > 0 and diversity < len(solution) / 2:\n            candidate_indices.append(idx)\n\n    if not candidate_indices:\n        candidate_indices = list(range(len(archive)))\n\n    selected_idx = random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    # Hybrid of swap and perturbation\n    num_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Step 2.1: Random swap of two items (if feasible)\n    if len(base_solution) >= 2:\n        i, j = random.sample(range(num_items), 2)\n        if base_solution[i] != base_solution[j]:\n            # Swap items i and j\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            # Check feasibility\n            new_weight = total_weight + (weight_lst[j] - weight_lst[i]) * (2 * base_solution[i] - 1)\n            if new_weight <= capacity:\n                return new_solution\n            else:\n                # Revert if infeasible\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2.2: Perturbation - flip a random item (if feasible)\n    k = random.randint(0, num_items - 1)\n    if base_solution[k] == 1:\n        # Try removing item k\n        new_weight = total_weight - weight_lst[k]\n        if new_weight >= 0:\n            new_solution[k] = 0\n            return new_solution\n    else:\n        # Try adding item k\n        new_weight = total_weight + weight_lst[k]\n        if new_weight <= capacity:\n            new_solution[k] = 1\n            return new_solution\n\n    # Step 2.3: If no feasible move, return the base solution\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 59,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive item swapping with value-based diversification, prioritizing high-value items while ensuring feasibility through dynamic weight adjustments and objective-aware perturbations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high total value)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_idx = min(int(len(archive) * 0.3), len(archive) - 1)  # Select from top 30% of solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n    current_obj = archive_sorted[selected_idx][1]\n\n    # Create a copy for modification\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Hybrid local search strategy:\n    # 1. Adaptive item swapping based on value-to-weight ratio\n    # 2. Dynamic weight adjustment to ensure feasibility\n    # 3. Objective-aware perturbations\n\n    # Step 1: Identify items to swap (prioritize high-value, low-weight items)\n    value_to_weight1 = value1_lst / (weight_lst + 1e-10)  # Avoid division by zero\n    value_to_weight2 = value2_lst / (weight_lst + 1e-10)\n\n    # Combine objectives for prioritization\n    combined_ratio = 0.7 * value_to_weight1 + 0.3 * value_to_weight2  # Weighted combination\n\n    # Find candidate items to swap (not currently in the solution)\n    candidates = np.where(new_solution == 0)[0]\n    if len(candidates) > 0:\n        # Select top 20% of candidates by combined ratio\n        top_candidates = candidates[np.argsort(combined_ratio[candidates])[-max(1, len(candidates)//5):]]\n\n        # Find items currently in the solution\n        in_solution = np.where(new_solution == 1)[0]\n        if len(in_solution) > 0:\n            # Select items to remove (prioritize low-value, high-weight items)\n            removal_candidates = in_solution[np.argsort(combined_ratio[in_solution])[:max(1, len(in_solution)//5)]]\n\n            # Perform the swap\n            for add_idx in top_candidates:\n                for remove_idx in removal_candidates:\n                    new_weight = current_weight - weight_lst[remove_idx] + weight_lst[add_idx]\n                    if new_weight <= capacity:\n                        new_solution[remove_idx] = 0\n                        new_solution[add_idx] = 1\n                        current_weight = new_weight\n                        break\n\n    # Step 2: Objective-aware perturbations\n    # Randomly flip a small percentage of items to introduce diversity\n    flip_prob = 0.1\n    for i in range(len(new_solution)):\n        if random.random() < flip_prob:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Ensure feasibility (in case of any errors)\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items until feasible\n        in_solution = np.where(new_solution == 1)[0]\n        for i in in_solution:\n            if current_weight <= capacity:\n                break\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.37611965623913596,
            1.7850350439548492
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high total value)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_idx = min(int(len(archive) * 0.3), len(archive) - 1)  # Select from top 30% of solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n    current_obj = archive_sorted[selected_idx][1]\n\n    # Create a copy for modification\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Hybrid local search strategy:\n    # 1. Adaptive item swapping based on value-to-weight ratio\n    # 2. Dynamic weight adjustment to ensure feasibility\n    # 3. Objective-aware perturbations\n\n    # Step 1: Identify items to swap (prioritize high-value, low-weight items)\n    value_to_weight1 = value1_lst / (weight_lst + 1e-10)  # Avoid division by zero\n    value_to_weight2 = value2_lst / (weight_lst + 1e-10)\n\n    # Combine objectives for prioritization\n    combined_ratio = 0.7 * value_to_weight1 + 0.3 * value_to_weight2  # Weighted combination\n\n    # Find candidate items to swap (not currently in the solution)\n    candidates = np.where(new_solution == 0)[0]\n    if len(candidates) > 0:\n        # Select top 20% of candidates by combined ratio\n        top_candidates = candidates[np.argsort(combined_ratio[candidates])[-max(1, len(candidates)//5):]]\n\n        # Find items currently in the solution\n        in_solution = np.where(new_solution == 1)[0]\n        if len(in_solution) > 0:\n            # Select items to remove (prioritize low-value, high-weight items)\n            removal_candidates = in_solution[np.argsort(combined_ratio[in_solution])[:max(1, len(in_solution)//5)]]\n\n            # Perform the swap\n            for add_idx in top_candidates:\n                for remove_idx in removal_candidates:\n                    new_weight = current_weight - weight_lst[remove_idx] + weight_lst[add_idx]\n                    if new_weight <= capacity:\n                        new_solution[remove_idx] = 0\n                        new_solution[add_idx] = 1\n                        current_weight = new_weight\n                        break\n\n    # Step 2: Objective-aware perturbations\n    # Randomly flip a small percentage of items to introduce diversity\n    flip_prob = 0.1\n    for i in range(len(new_solution)):\n        if random.random() < flip_prob:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Ensure feasibility (in case of any errors)\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items until feasible\n        in_solution = np.where(new_solution == 1)[0]\n        for i in in_solution:\n            if current_weight <= capacity:\n                break\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 60,
        "algorithm": "{The heuristic function selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines random item swaps and targeted value maximization to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = [sol for sol, obj in archive if obj[0] < np.sum(value1_lst) or obj[1] < np.sum(value2_lst)]\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n    base_solution = random.choice(candidates).copy()\n\n    # Generate neighbor by hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Randomly select items to flip (swap 0 and 1) with probability based on their value ratio\n    value_ratio = value1_lst / (value2_lst + 1e-6)  # Avoid division by zero\n    for i in range(len(base_solution)):\n        if random.random() < 0.3:  # 30% chance to consider flipping\n            if base_solution[i] == 1:\n                # If removing this item keeps the solution feasible\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # If adding this item keeps the solution feasible\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Further improve by adding high-value items not in the solution\n    remaining_weight = capacity - current_weight\n    candidate_items = np.where(new_solution == 0)[0]\n    candidate_items = candidate_items[weight_lst[candidate_items] <= remaining_weight]\n    if len(candidate_items) > 0:\n        # Select top 20% by value ratio\n        top_items = candidate_items[np.argsort(value_ratio[candidate_items])[-max(1, len(candidate_items) // 5):]]\n        for i in top_items:\n            new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.41249287969499115,
            1.9088636338710785
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = [sol for sol, obj in archive if obj[0] < np.sum(value1_lst) or obj[1] < np.sum(value2_lst)]\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n    base_solution = random.choice(candidates).copy()\n\n    # Generate neighbor by hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Randomly select items to flip (swap 0 and 1) with probability based on their value ratio\n    value_ratio = value1_lst / (value2_lst + 1e-6)  # Avoid division by zero\n    for i in range(len(base_solution)):\n        if random.random() < 0.3:  # 30% chance to consider flipping\n            if base_solution[i] == 1:\n                # If removing this item keeps the solution feasible\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # If adding this item keeps the solution feasible\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Further improve by adding high-value items not in the solution\n    remaining_weight = capacity - current_weight\n    candidate_items = np.where(new_solution == 0)[0]\n    candidate_items = candidate_items[weight_lst[candidate_items] <= remaining_weight]\n    if len(candidate_items) > 0:\n        # Select top 20% by value ratio\n        top_items = candidate_items[np.argsort(value_ratio[candidate_items])[-max(1, len(candidate_items) // 5):]]\n        for i in top_items:\n            new_solution[i] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 61,
        "algorithm": "{A novel local search algorithm that intelligently selects a solution from the archive, performs a hybrid flip-and-shift operation to generate neighbors by flipping a subset of items and shifting their positions to explore non-dominated regions, while ensuring feasibility through dynamic weight adjustment.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_objectives = np.array([(obj[0] / np.max(value1_lst), obj[1] / np.max(value2_lst)) for _, obj in archive])\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor via hybrid flip-and-shift\n    new_solution = base_solution.copy()\n    n_items = len(new_solution)\n\n    # Randomly select a subset of items to flip\n    flip_mask = np.random.rand(n_items) < 0.3  # 30% chance to flip each item\n    new_solution[flip_mask] = 1 - new_solution[flip_mask]\n\n    # Shift a subset of items to explore new regions\n    shift_size = max(1, int(0.2 * n_items))  # Shift 20% of items\n    shift_indices = np.random.choice(n_items, shift_size, replace=False)\n    np.roll(new_solution[shift_indices], 1)\n\n    # Ensure feasibility by removing excess weight\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items with lowest marginal value density until feasible\n        while current_weight > capacity:\n            marginal_density = (value1_lst + value2_lst) / weight_lst\n            candidate_indices = np.where(new_solution == 1)[0]\n            if len(candidate_indices) == 0:\n                break  # No items left to remove\n            remove_idx = candidate_indices[np.argmin(marginal_density[candidate_indices])]\n            new_solution[remove_idx] = 0\n            current_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.39120341449122686,
            4.092606723308563
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_objectives = np.array([(obj[0] / np.max(value1_lst), obj[1] / np.max(value2_lst)) for _, obj in archive])\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor via hybrid flip-and-shift\n    new_solution = base_solution.copy()\n    n_items = len(new_solution)\n\n    # Randomly select a subset of items to flip\n    flip_mask = np.random.rand(n_items) < 0.3  # 30% chance to flip each item\n    new_solution[flip_mask] = 1 - new_solution[flip_mask]\n\n    # Shift a subset of items to explore new regions\n    shift_size = max(1, int(0.2 * n_items))  # Shift 20% of items\n    shift_indices = np.random.choice(n_items, shift_size, replace=False)\n    np.roll(new_solution[shift_indices], 1)\n\n    # Ensure feasibility by removing excess weight\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items with lowest marginal value density until feasible\n        while current_weight > capacity:\n            marginal_density = (value1_lst + value2_lst) / weight_lst\n            candidate_indices = np.where(new_solution == 1)[0]\n            if len(candidate_indices) == 0:\n                break  # No items left to remove\n            remove_idx = candidate_indices[np.argmin(marginal_density[candidate_indices])]\n            new_solution[remove_idx] = 0\n            current_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 62,
        "algorithm": "{The algorithm selects a solution from the archive with the highest potential for improvement by prioritizing those with the highest objective values, then applies a hybrid local search combining random bit flipping and a novel segment-based perturbation to explore neighboring solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of objectives for exploration\n    selected_idx = np.argmax([sum(obj) for (sol, obj) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random bit flipping with segment-based perturbation\n    n_items = len(base_solution)\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n\n    for idx in flip_indices:\n        # Try flipping the bit\n        temp_solution = new_solution.copy()\n        temp_solution[idx] = 1 - temp_solution[idx]\n\n        # Check feasibility\n        if np.dot(temp_solution, weight_lst) <= capacity:\n            new_solution = temp_solution\n\n    # Segment-based perturbation: randomly select a segment and flip all bits\n    if n_items > 1:\n        start = np.random.randint(0, n_items - 1)\n        end = np.random.randint(start + 1, n_items)\n        segment = slice(start, end)\n        temp_solution = new_solution.copy()\n        temp_solution[segment] = 1 - temp_solution[segment]\n\n        # Check feasibility\n        if np.dot(temp_solution, weight_lst) <= capacity:\n            new_solution = temp_solution\n\n    # Ensure at least one bit is different\n    if np.array_equal(new_solution, base_solution):\n        # Fallback: randomly flip one bit\n        idx = np.random.randint(0, n_items)\n        new_solution[idx] = 1 - new_solution[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3375947756951296,
            1.886827290058136
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of objectives for exploration\n    selected_idx = np.argmax([sum(obj) for (sol, obj) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random bit flipping with segment-based perturbation\n    n_items = len(base_solution)\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n\n    for idx in flip_indices:\n        # Try flipping the bit\n        temp_solution = new_solution.copy()\n        temp_solution[idx] = 1 - temp_solution[idx]\n\n        # Check feasibility\n        if np.dot(temp_solution, weight_lst) <= capacity:\n            new_solution = temp_solution\n\n    # Segment-based perturbation: randomly select a segment and flip all bits\n    if n_items > 1:\n        start = np.random.randint(0, n_items - 1)\n        end = np.random.randint(start + 1, n_items)\n        segment = slice(start, end)\n        temp_solution = new_solution.copy()\n        temp_solution[segment] = 1 - temp_solution[segment]\n\n        # Check feasibility\n        if np.dot(temp_solution, weight_lst) <= capacity:\n            new_solution = temp_solution\n\n    # Ensure at least one bit is different\n    if np.array_equal(new_solution, base_solution):\n        # Fallback: randomly flip one bit\n        idx = np.random.randint(0, n_items)\n        new_solution[idx] = 1 - new_solution[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 63,
        "algorithm": "{This algorithm intelligently selects a promising non-dominated solution from the archive, applies a hybrid local search combining item swap and perturbation, then performs a feasibility-aware flip operation to generate a high-quality neighbor solution while ensuring weight constraints are satisfied.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Select a random solution from the top 30% of the archive (sorted by sum of objectives)\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selection_pool = archive_sorted[:max(1, len(archive_sorted) // 3)]\n    selected_idx = random.randint(0, len(selection_pool) - 1)\n    base_solution = selection_pool[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: combine item swap and perturbation\n    for _ in range(5):  # Perform multiple small perturbations\n        # Randomly select two items to swap\n        item1, item2 = random.sample(range(len(new_solution)), 2)\n\n        # Calculate potential changes\n        if new_solution[item1] != new_solution[item2]:\n            delta_weight = (new_solution[item1] * weight_lst[item1] +\n                           new_solution[item2] * weight_lst[item2] -\n                           (1 - new_solution[item1]) * weight_lst[item1] -\n                           (1 - new_solution[item2]) * weight_lst[item2])\n\n            if current_weight + delta_weight <= capacity:\n                # Perform the swap\n                new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n                current_weight += delta_weight\n\n    # Step 3: Perform feasibility-aware flip operation\n    # Find items that can be flipped (added or removed) while maintaining feasibility\n    candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            if current_weight - weight_lst[i] >= 0:\n                candidates.append((i, -1))  # Mark for removal\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                candidates.append((i, 1))  # Mark for addition\n\n    if candidates:\n        # Select a random candidate to flip\n        item_idx, flip = random.choice(candidates)\n        new_solution[item_idx] = 1 - new_solution[item_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3061080378350952,
            2.0797995924949646
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Select a random solution from the top 30% of the archive (sorted by sum of objectives)\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selection_pool = archive_sorted[:max(1, len(archive_sorted) // 3)]\n    selected_idx = random.randint(0, len(selection_pool) - 1)\n    base_solution = selection_pool[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: combine item swap and perturbation\n    for _ in range(5):  # Perform multiple small perturbations\n        # Randomly select two items to swap\n        item1, item2 = random.sample(range(len(new_solution)), 2)\n\n        # Calculate potential changes\n        if new_solution[item1] != new_solution[item2]:\n            delta_weight = (new_solution[item1] * weight_lst[item1] +\n                           new_solution[item2] * weight_lst[item2] -\n                           (1 - new_solution[item1]) * weight_lst[item1] -\n                           (1 - new_solution[item2]) * weight_lst[item2])\n\n            if current_weight + delta_weight <= capacity:\n                # Perform the swap\n                new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n                current_weight += delta_weight\n\n    # Step 3: Perform feasibility-aware flip operation\n    # Find items that can be flipped (added or removed) while maintaining feasibility\n    candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            if current_weight - weight_lst[i] >= 0:\n                candidates.append((i, -1))  # Mark for removal\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                candidates.append((i, 1))  # Mark for addition\n\n    if candidates:\n        # Select a random candidate to flip\n        item_idx, flip = random.choice(candidates)\n        new_solution[item_idx] = 1 - new_solution[item_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 64,
        "algorithm": "{The algorithm selects a promising solution from the archive based on high potential for local improvement, then applies a hybrid local search strategy combining item swapping and adaptive perturbation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.argmax([np.sum(sol[0]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: item swapping + adaptive perturbation\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Item swapping (try to replace an item with another)\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        # Find items to swap\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) == 0 or len(out_items) == 0:\n            break\n\n        # Randomly select items to swap\n        i_in = np.random.choice(in_items)\n        i_out = np.random.choice(out_items)\n\n        # Check feasibility of swap\n        delta_weight = weight_lst[i_out] - weight_lst[i_in]\n        if current_weight + delta_weight <= capacity:\n            new_solution[i_in] = 0\n            new_solution[i_out] = 1\n            current_weight += delta_weight\n\n    # Step 2: Adaptive perturbation (add/remove items based on value density)\n    if np.random.rand() < 0.3:  # 30% chance for perturbation\n        # Calculate value density for each item\n        density1 = value1_lst / weight_lst\n        density2 = value2_lst / weight_lst\n\n        # Sort items by combined density\n        combined_density = density1 + density2\n        sorted_indices = np.argsort(combined_density)[::-1]\n\n        # Try to add high-density items\n        for idx in sorted_indices:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n        # Try to remove low-density items\n        sorted_indices = np.argsort(combined_density)\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                break  # Only remove one low-density item\n\n    return new_solution\n\n",
        "score": [
            -0.34883600240641827,
            7.984449356794357
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.argmax([np.sum(sol[0]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: item swapping + adaptive perturbation\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Item swapping (try to replace an item with another)\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        # Find items to swap\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) == 0 or len(out_items) == 0:\n            break\n\n        # Randomly select items to swap\n        i_in = np.random.choice(in_items)\n        i_out = np.random.choice(out_items)\n\n        # Check feasibility of swap\n        delta_weight = weight_lst[i_out] - weight_lst[i_in]\n        if current_weight + delta_weight <= capacity:\n            new_solution[i_in] = 0\n            new_solution[i_out] = 1\n            current_weight += delta_weight\n\n    # Step 2: Adaptive perturbation (add/remove items based on value density)\n    if np.random.rand() < 0.3:  # 30% chance for perturbation\n        # Calculate value density for each item\n        density1 = value1_lst / weight_lst\n        density2 = value2_lst / weight_lst\n\n        # Sort items by combined density\n        combined_density = density1 + density2\n        sorted_indices = np.argsort(combined_density)[::-1]\n\n        # Try to add high-density items\n        for idx in sorted_indices:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n        # Try to remove low-density items\n        sorted_indices = np.argsort(combined_density)\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                break  # Only remove one low-density item\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 65,
        "algorithm": "{This algorithm selects a promising solution from the archive based on a hybrid of crowding distance and objective diversity, then applies a novel local search operator that combines random flips with a value-to-weight ratio heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select the most promising solution based on crowding distance and objective diversity\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate crowding distance for each solution\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):  # For each objective\n        sorted_idx = np.argsort([obj[i] for obj in objectives])\n        crowding_distances[sorted_idx[0]] = crowding_distances[sorted_idx[-1]] = float('inf')\n        for j in range(1, len(archive) - 1):\n            if objectives[sorted_idx[j+1]][i] == objectives[sorted_idx[j-1]][i]:\n                continue\n            crowding_distances[sorted_idx[j]] += (objectives[sorted_idx[j+1]][i] - objectives[sorted_idx[j-1]][i]) / (objectives[sorted_idx[-1]][i] - objectives[sorted_idx[0]][i])\n\n    # Select the solution with the highest crowding distance (promising for improvement)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = solutions[selected_idx].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate value-to-weight ratios for all items\n    v1_w_ratio = value1_lst / weight_lst\n    v2_w_ratio = value2_lst / weight_lst\n\n    # Randomly select a subset of items to consider for flipping\n    flip_candidates = np.random.choice(len(new_solution), size=min(5, len(new_solution)), replace=False)\n\n    for idx in flip_candidates:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            new_weight = total_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                total_weight = new_weight\n        else:\n            # Try adding the item\n            new_weight = total_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                # Prefer adding items with high value-to-weight ratios\n                if np.random.rand() < 0.7:  # 70% chance to add high-ratio items\n                    if v1_w_ratio[idx] > np.median(v1_w_ratio) or v2_w_ratio[idx] > np.median(v2_w_ratio):\n                        new_solution[idx] = 1\n                        total_weight = new_weight\n                else:\n                    new_solution[idx] = 1\n                    total_weight = new_weight\n\n    return new_solution\n\n",
        "score": [
            -0.6618997593229358,
            1.965502768754959
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select the most promising solution based on crowding distance and objective diversity\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate crowding distance for each solution\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):  # For each objective\n        sorted_idx = np.argsort([obj[i] for obj in objectives])\n        crowding_distances[sorted_idx[0]] = crowding_distances[sorted_idx[-1]] = float('inf')\n        for j in range(1, len(archive) - 1):\n            if objectives[sorted_idx[j+1]][i] == objectives[sorted_idx[j-1]][i]:\n                continue\n            crowding_distances[sorted_idx[j]] += (objectives[sorted_idx[j+1]][i] - objectives[sorted_idx[j-1]][i]) / (objectives[sorted_idx[-1]][i] - objectives[sorted_idx[0]][i])\n\n    # Select the solution with the highest crowding distance (promising for improvement)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = solutions[selected_idx].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate value-to-weight ratios for all items\n    v1_w_ratio = value1_lst / weight_lst\n    v2_w_ratio = value2_lst / weight_lst\n\n    # Randomly select a subset of items to consider for flipping\n    flip_candidates = np.random.choice(len(new_solution), size=min(5, len(new_solution)), replace=False)\n\n    for idx in flip_candidates:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            new_weight = total_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                total_weight = new_weight\n        else:\n            # Try adding the item\n            new_weight = total_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                # Prefer adding items with high value-to-weight ratios\n                if np.random.rand() < 0.7:  # 70% chance to add high-ratio items\n                    if v1_w_ratio[idx] > np.median(v1_w_ratio) or v2_w_ratio[idx] > np.median(v2_w_ratio):\n                        new_solution[idx] = 1\n                        total_weight = new_weight\n                else:\n                    new_solution[idx] = 1\n                    total_weight = new_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 66,
        "algorithm": "{The algorithm selects a promising solution from the archive using a hybrid local search strategy that combines random exploration with objective-aware flipping of items, ensuring feasibility by dynamically adjusting the selection to respect the weight constraint.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n    current_weight = np.sum(weight_lst[selected_solution == 1])\n\n    # Identify items that can be flipped (either included or excluded) while maintaining feasibility\n    candidate_indices = []\n    for i in range(len(selected_solution)):\n        if selected_solution[i] == 1:\n            # Check if excluding this item keeps the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                candidate_indices.append((i, -1))  # -1 indicates exclusion\n        else:\n            # Check if including this item keeps the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                candidate_indices.append((i, 1))  # 1 indicates inclusion\n\n    if not candidate_indices:\n        return selected_solution  # No feasible flip possible\n\n    # Select a random candidate with a bias towards high-value items\n    weights = []\n    for idx, flip in candidate_indices:\n        if flip == 1:\n            # Inclusion: prioritize high value1 or value2 items\n            weights.append(value1_lst[idx] + value2_lst[idx])\n        else:\n            # Exclusion: prioritize low value1 or value2 items (to free up space)\n            weights.append(1.0 / (value1_lst[idx] + value2_lst[idx] + 1e-6))\n\n    weights = np.array(weights)\n    weights = weights / np.sum(weights)  # Normalize to probabilities\n    selected_idx = np.random.choice(len(candidate_indices), p=weights)\n    item_idx, flip = candidate_indices[selected_idx]\n\n    # Apply the flip\n    new_solution = selected_solution.copy()\n    new_solution[item_idx] = flip if flip == 1 else 0\n\n    return new_solution\n\n",
        "score": [
            -0.9573285072955817,
            1.9948509335517883
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n    current_weight = np.sum(weight_lst[selected_solution == 1])\n\n    # Identify items that can be flipped (either included or excluded) while maintaining feasibility\n    candidate_indices = []\n    for i in range(len(selected_solution)):\n        if selected_solution[i] == 1:\n            # Check if excluding this item keeps the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                candidate_indices.append((i, -1))  # -1 indicates exclusion\n        else:\n            # Check if including this item keeps the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                candidate_indices.append((i, 1))  # 1 indicates inclusion\n\n    if not candidate_indices:\n        return selected_solution  # No feasible flip possible\n\n    # Select a random candidate with a bias towards high-value items\n    weights = []\n    for idx, flip in candidate_indices:\n        if flip == 1:\n            # Inclusion: prioritize high value1 or value2 items\n            weights.append(value1_lst[idx] + value2_lst[idx])\n        else:\n            # Exclusion: prioritize low value1 or value2 items (to free up space)\n            weights.append(1.0 / (value1_lst[idx] + value2_lst[idx] + 1e-6))\n\n    weights = np.array(weights)\n    weights = weights / np.sum(weights)  # Normalize to probabilities\n    selected_idx = np.random.choice(len(candidate_indices), p=weights)\n    item_idx, flip = candidate_indices[selected_idx]\n\n    # Apply the flip\n    new_solution = selected_solution.copy()\n    new_solution[item_idx] = flip if flip == 1 else 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 66,
        "algorithm": "{The algorithm selects a promising solution from the archive using a hybrid local search strategy that combines random exploration with objective-aware flipping of items, ensuring feasibility by dynamically adjusting the selection to respect the weight constraint.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n    current_weight = np.sum(weight_lst[selected_solution == 1])\n\n    # Identify items that can be flipped (either included or excluded) while maintaining feasibility\n    candidate_indices = []\n    for i in range(len(selected_solution)):\n        if selected_solution[i] == 1:\n            # Check if excluding this item keeps the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                candidate_indices.append((i, -1))  # -1 indicates exclusion\n        else:\n            # Check if including this item keeps the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                candidate_indices.append((i, 1))  # 1 indicates inclusion\n\n    if not candidate_indices:\n        return selected_solution  # No feasible flip possible\n\n    # Select a random candidate with a bias towards high-value items\n    weights = []\n    for idx, flip in candidate_indices:\n        if flip == 1:\n            # Inclusion: prioritize high value1 or value2 items\n            weights.append(value1_lst[idx] + value2_lst[idx])\n        else:\n            # Exclusion: prioritize low value1 or value2 items (to free up space)\n            weights.append(1.0 / (value1_lst[idx] + value2_lst[idx] + 1e-6))\n\n    weights = np.array(weights)\n    weights = weights / np.sum(weights)  # Normalize to probabilities\n    selected_idx = np.random.choice(len(candidate_indices), p=weights)\n    item_idx, flip = candidate_indices[selected_idx]\n\n    # Apply the flip\n    new_solution = selected_solution.copy()\n    new_solution[item_idx] = flip if flip == 1 else 0\n\n    return new_solution\n\n",
        "score": [
            -0.9573285072955817,
            1.9948509335517883
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n    current_weight = np.sum(weight_lst[selected_solution == 1])\n\n    # Identify items that can be flipped (either included or excluded) while maintaining feasibility\n    candidate_indices = []\n    for i in range(len(selected_solution)):\n        if selected_solution[i] == 1:\n            # Check if excluding this item keeps the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                candidate_indices.append((i, -1))  # -1 indicates exclusion\n        else:\n            # Check if including this item keeps the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                candidate_indices.append((i, 1))  # 1 indicates inclusion\n\n    if not candidate_indices:\n        return selected_solution  # No feasible flip possible\n\n    # Select a random candidate with a bias towards high-value items\n    weights = []\n    for idx, flip in candidate_indices:\n        if flip == 1:\n            # Inclusion: prioritize high value1 or value2 items\n            weights.append(value1_lst[idx] + value2_lst[idx])\n        else:\n            # Exclusion: prioritize low value1 or value2 items (to free up space)\n            weights.append(1.0 / (value1_lst[idx] + value2_lst[idx] + 1e-6))\n\n    weights = np.array(weights)\n    weights = weights / np.sum(weights)  # Normalize to probabilities\n    selected_idx = np.random.choice(len(candidate_indices), p=weights)\n    item_idx, flip = candidate_indices[selected_idx]\n\n    # Apply the flip\n    new_solution = selected_solution.copy()\n    new_solution[item_idx] = flip if flip == 1 else 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 67,
        "algorithm": "{This algorithm selects a promising solution from the archive by prioritizing those with higher objective values, then applies a hybrid local search that combines greedy addition of high-value items and random removal of low-value items to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., top 20% by objective dominance)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_idx = np.random.choice(min(3, len(archive_sorted)), 1)[0]\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: greedy addition of high-value items, then random removal of low-value items\n    # Step 1: Greedy addition of high-value items\n    for i in np.where(new_solution == 0)[0]:\n        if current_weight + weight_lst[i] <= capacity:\n            # Check if adding this item improves both objectives\n            if value1_lst[i] > 0 and value2_lst[i] > 0:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Step 2: Random removal of low-value items to create diversity\n    low_value_indices = np.where((value1_lst <= np.percentile(value1_lst, 30)) &\n                                 (value2_lst <= np.percentile(value2_lst, 30)) &\n                                 (new_solution == 1))[0]\n\n    if len(low_value_indices) > 0:\n        remove_idx = np.random.choice(low_value_indices)\n        new_solution[remove_idx] = 0\n        current_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8890660151210212,
            4.35365504026413
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., top 20% by objective dominance)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_idx = np.random.choice(min(3, len(archive_sorted)), 1)[0]\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: greedy addition of high-value items, then random removal of low-value items\n    # Step 1: Greedy addition of high-value items\n    for i in np.where(new_solution == 0)[0]:\n        if current_weight + weight_lst[i] <= capacity:\n            # Check if adding this item improves both objectives\n            if value1_lst[i] > 0 and value2_lst[i] > 0:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Step 2: Random removal of low-value items to create diversity\n    low_value_indices = np.where((value1_lst <= np.percentile(value1_lst, 30)) &\n                                 (value2_lst <= np.percentile(value2_lst, 30)) &\n                                 (new_solution == 1))[0]\n\n    if len(low_value_indices) > 0:\n        remove_idx = np.random.choice(low_value_indices)\n        new_solution[remove_idx] = 0\n        current_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 68,
        "algorithm": "{A hybrid local search strategy that intelligently combines item swaps, probabilistic flips, and objective-aware perturbations to explore diverse neighborhoods while ensuring feasibility and promoting Pareto-optimal improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too extreme in either objective)\n    objectives = np.array([obj for _, obj in archive])\n    mean_obj = np.mean(objectives, axis=0)\n    distances = np.linalg.norm(objectives - mean_obj, axis=1)\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Calculate current weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Generate neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Step 1: Probabilistic item flip with objective bias\n    for i in range(n_items):\n        if random.random() < 0.3:  # 30% chance to consider flipping\n            flip_weight = weight_lst[i] if new_solution[i] == 0 else -weight_lst[i]\n            if current_weight + flip_weight <= capacity:\n                # Flip based on which objective would benefit more\n                if value1_lst[i] / weight_lst[i] > value2_lst[i] / weight_lst[i]:\n                    new_solution[i] = 1 - new_solution[i]\n                else:\n                    if random.random() < 0.7:  # Higher chance to flip if beneficial for both\n                        new_solution[i] = 1 - new_solution[i]\n\n    # Step 2: Swap items between high and low value categories\n    high_value_items = np.argsort(value1_lst + value2_lst)[-n_items//4:]\n    low_value_items = np.argsort(value1_lst + value2_lst)[:n_items//4]\n\n    for i in high_value_items:\n        if new_solution[i] == 0 and random.random() < 0.4:  # 40% chance to add high-value item\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    for i in low_value_items:\n        if new_solution[i] == 1 and random.random() < 0.2:  # 20% chance to remove low-value item\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    # Step 3: Random perturbation to escape local optima\n    if random.random() < 0.5:  # 50% chance for perturbation\n        perturb_idx = random.choice(np.where(base_solution != new_solution)[0])\n        new_solution[perturb_idx] = 1 - new_solution[perturb_idx]\n        # Ensure feasibility\n        if np.sum(weight_lst * new_solution) > capacity:\n            new_solution[perturb_idx] = base_solution[perturb_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.9486187815235021,
            2.640275865793228
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too extreme in either objective)\n    objectives = np.array([obj for _, obj in archive])\n    mean_obj = np.mean(objectives, axis=0)\n    distances = np.linalg.norm(objectives - mean_obj, axis=1)\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Calculate current weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Generate neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Step 1: Probabilistic item flip with objective bias\n    for i in range(n_items):\n        if random.random() < 0.3:  # 30% chance to consider flipping\n            flip_weight = weight_lst[i] if new_solution[i] == 0 else -weight_lst[i]\n            if current_weight + flip_weight <= capacity:\n                # Flip based on which objective would benefit more\n                if value1_lst[i] / weight_lst[i] > value2_lst[i] / weight_lst[i]:\n                    new_solution[i] = 1 - new_solution[i]\n                else:\n                    if random.random() < 0.7:  # Higher chance to flip if beneficial for both\n                        new_solution[i] = 1 - new_solution[i]\n\n    # Step 2: Swap items between high and low value categories\n    high_value_items = np.argsort(value1_lst + value2_lst)[-n_items//4:]\n    low_value_items = np.argsort(value1_lst + value2_lst)[:n_items//4]\n\n    for i in high_value_items:\n        if new_solution[i] == 0 and random.random() < 0.4:  # 40% chance to add high-value item\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    for i in low_value_items:\n        if new_solution[i] == 1 and random.random() < 0.2:  # 20% chance to remove low-value item\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    # Step 3: Random perturbation to escape local optima\n    if random.random() < 0.5:  # 50% chance for perturbation\n        perturb_idx = random.choice(np.where(base_solution != new_solution)[0])\n        new_solution[perturb_idx] = 1 - new_solution[perturb_idx]\n        # Ensure feasibility\n        if np.sum(weight_lst * new_solution) > capacity:\n            new_solution[perturb_idx] = base_solution[perturb_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 69,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines item swapping, insertion, and removal with adaptive neighborhood exploration to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate a neighbor solution using a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly select a subset of items to consider for modification\n    candidate_items = np.where(base_solution == 1)[0]\n    if len(candidate_items) > 0:\n        # Step 2: Randomly choose one item to remove or swap\n        item_to_modify = random.choice(candidate_items)\n        new_solution[item_to_modify] = 0\n        current_weight -= weight_lst[item_to_modify]\n\n        # Step 3: Randomly select a new item to add (if feasible)\n        available_items = np.where((base_solution == 0) & (weight_lst <= (capacity - current_weight)))[0]\n        if len(available_items) > 0:\n            new_item = random.choice(available_items)\n            new_solution[new_item] = 1\n            current_weight += weight_lst[new_item]\n\n    # Step 4: If no modification was made, perform a different operation (e.g., swap two items)\n    if np.array_equal(new_solution, base_solution):\n        candidate_items = np.where(base_solution == 1)[0]\n        if len(candidate_items) >= 2:\n            item1, item2 = random.sample(list(candidate_items), 2)\n            new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n\n    return new_solution\n\n",
        "score": [
            -0.5204655305334078,
            1.2026958465576172
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate a neighbor solution using a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly select a subset of items to consider for modification\n    candidate_items = np.where(base_solution == 1)[0]\n    if len(candidate_items) > 0:\n        # Step 2: Randomly choose one item to remove or swap\n        item_to_modify = random.choice(candidate_items)\n        new_solution[item_to_modify] = 0\n        current_weight -= weight_lst[item_to_modify]\n\n        # Step 3: Randomly select a new item to add (if feasible)\n        available_items = np.where((base_solution == 0) & (weight_lst <= (capacity - current_weight)))[0]\n        if len(available_items) > 0:\n            new_item = random.choice(available_items)\n            new_solution[new_item] = 1\n            current_weight += weight_lst[new_item]\n\n    # Step 4: If no modification was made, perform a different operation (e.g., swap two items)\n    if np.array_equal(new_solution, base_solution):\n        candidate_items = np.where(base_solution == 1)[0]\n        if len(candidate_items) >= 2:\n            item1, item2 = random.sample(list(candidate_items), 2)\n            new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 69,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines item swapping, insertion, and removal with adaptive neighborhood exploration to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate a neighbor solution using a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly select a subset of items to consider for modification\n    candidate_items = np.where(base_solution == 1)[0]\n    if len(candidate_items) > 0:\n        # Step 2: Randomly choose one item to remove or swap\n        item_to_modify = random.choice(candidate_items)\n        new_solution[item_to_modify] = 0\n        current_weight -= weight_lst[item_to_modify]\n\n        # Step 3: Randomly select a new item to add (if feasible)\n        available_items = np.where((base_solution == 0) & (weight_lst <= (capacity - current_weight)))[0]\n        if len(available_items) > 0:\n            new_item = random.choice(available_items)\n            new_solution[new_item] = 1\n            current_weight += weight_lst[new_item]\n\n    # Step 4: If no modification was made, perform a different operation (e.g., swap two items)\n    if np.array_equal(new_solution, base_solution):\n        candidate_items = np.where(base_solution == 1)[0]\n        if len(candidate_items) >= 2:\n            item1, item2 = random.sample(list(candidate_items), 2)\n            new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n\n    return new_solution\n\n",
        "score": [
            -0.5204655305334078,
            1.2026958465576172
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate a neighbor solution using a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly select a subset of items to consider for modification\n    candidate_items = np.where(base_solution == 1)[0]\n    if len(candidate_items) > 0:\n        # Step 2: Randomly choose one item to remove or swap\n        item_to_modify = random.choice(candidate_items)\n        new_solution[item_to_modify] = 0\n        current_weight -= weight_lst[item_to_modify]\n\n        # Step 3: Randomly select a new item to add (if feasible)\n        available_items = np.where((base_solution == 0) & (weight_lst <= (capacity - current_weight)))[0]\n        if len(available_items) > 0:\n            new_item = random.choice(available_items)\n            new_solution[new_item] = 1\n            current_weight += weight_lst[new_item]\n\n    # Step 4: If no modification was made, perform a different operation (e.g., swap two items)\n    if np.array_equal(new_solution, base_solution):\n        candidate_items = np.where(base_solution == 1)[0]\n        if len(candidate_items) >= 2:\n            item1, item2 = random.sample(list(candidate_items), 2)\n            new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 70,
        "algorithm": "{The algorithm selects a promising solution from the archive using a heuristic that considers both objective values and their potential for local improvement, then applies a hybrid local search strategy that combines random item swaps with objective-aware flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1], -np.sum(x[0] * (value1_lst + value2_lst))), reverse=True)\n    selected_idx = min(3, len(archive) - 1)  # Select from top 3 solutions\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps + objective-aware flips\n    for _ in range(5):  # Perform 5 random operations\n        # Random swap\n        idx1, idx2 = random.sample(range(len(new_solution)), 2)\n        new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n        # Objective-aware flip: try to flip items that improve both objectives\n        for idx in np.where(new_solution == 1)[0]:\n            if np.sum(new_solution * weight_lst) - weight_lst[idx] + weight_lst[random.randint(0, len(weight_lst)-1)] <= capacity:\n                new_solution[idx] = 0\n                new_solution[random.randint(0, len(weight_lst)-1)] = 1\n                break\n\n    # Ensure feasibility\n    total_weight = np.sum(new_solution * weight_lst)\n    while total_weight > capacity:\n        # Remove random items until feasible\n        candidates = np.where(new_solution == 1)[0]\n        if len(candidates) == 0:\n            break\n        idx = random.choice(candidates)\n        new_solution[idx] = 0\n        total_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5027563863145033,
            3.8059456050395966
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1], -np.sum(x[0] * (value1_lst + value2_lst))), reverse=True)\n    selected_idx = min(3, len(archive) - 1)  # Select from top 3 solutions\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps + objective-aware flips\n    for _ in range(5):  # Perform 5 random operations\n        # Random swap\n        idx1, idx2 = random.sample(range(len(new_solution)), 2)\n        new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n        # Objective-aware flip: try to flip items that improve both objectives\n        for idx in np.where(new_solution == 1)[0]:\n            if np.sum(new_solution * weight_lst) - weight_lst[idx] + weight_lst[random.randint(0, len(weight_lst)-1)] <= capacity:\n                new_solution[idx] = 0\n                new_solution[random.randint(0, len(weight_lst)-1)] = 1\n                break\n\n    # Ensure feasibility\n    total_weight = np.sum(new_solution * weight_lst)\n    while total_weight > capacity:\n        # Remove random items until feasible\n        candidates = np.where(new_solution == 1)[0]\n        if len(candidates) == 0:\n            break\n        idx = random.choice(candidates)\n        new_solution[idx] = 0\n        total_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 71,
        "algorithm": "{This algorithm selects a solution from the archive with the highest combined objective value, then applies a hybrid local search operator that combines random item swaps with a probabilistic greedy selection of items based on their marginal utility in both objectives, ensuring feasibility through iterative adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Generate a random subset of items to consider for swaps\n    n_items = len(weight_lst)\n    candidate_indices = np.random.choice(n_items, size=min(10, n_items), replace=False)\n\n    for idx in candidate_indices:\n        # Calculate marginal utility for both objectives\n        if new_solution[idx] == 1:\n            # Item is currently in the solution, consider removing it\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                # Remove the item\n                new_solution[idx] = 0\n                current_weight = new_weight\n        else:\n            # Item is not in the solution, consider adding it\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                # Add the item with a probability based on its marginal utility\n                marginal_value1 = value1_lst[idx]\n                marginal_value2 = value2_lst[idx]\n                prob = (marginal_value1 + marginal_value2) / (np.sum(value1_lst) + np.sum(value2_lst) + 1e-6)\n                if np.random.rand() < prob:\n                    new_solution[idx] = 1\n                    current_weight = new_weight\n\n    # Apply a small random perturbation to escape local optima\n    if np.random.rand() < 0.3:\n        perturb_idx = np.random.choice(n_items)\n        if new_solution[perturb_idx] == 1:\n            new_weight = current_weight - weight_lst[perturb_idx]\n            if new_weight <= capacity:\n                new_solution[perturb_idx] = 0\n        else:\n            new_weight = current_weight + weight_lst[perturb_idx]\n            if new_weight <= capacity:\n                new_solution[perturb_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.4900727353843309,
            1.7586364150047302
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Generate a random subset of items to consider for swaps\n    n_items = len(weight_lst)\n    candidate_indices = np.random.choice(n_items, size=min(10, n_items), replace=False)\n\n    for idx in candidate_indices:\n        # Calculate marginal utility for both objectives\n        if new_solution[idx] == 1:\n            # Item is currently in the solution, consider removing it\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                # Remove the item\n                new_solution[idx] = 0\n                current_weight = new_weight\n        else:\n            # Item is not in the solution, consider adding it\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                # Add the item with a probability based on its marginal utility\n                marginal_value1 = value1_lst[idx]\n                marginal_value2 = value2_lst[idx]\n                prob = (marginal_value1 + marginal_value2) / (np.sum(value1_lst) + np.sum(value2_lst) + 1e-6)\n                if np.random.rand() < prob:\n                    new_solution[idx] = 1\n                    current_weight = new_weight\n\n    # Apply a small random perturbation to escape local optima\n    if np.random.rand() < 0.3:\n        perturb_idx = np.random.choice(n_items)\n        if new_solution[perturb_idx] == 1:\n            new_weight = current_weight - weight_lst[perturb_idx]\n            if new_weight <= capacity:\n                new_solution[perturb_idx] = 0\n        else:\n            new_weight = current_weight + weight_lst[perturb_idx]\n            if new_weight <= capacity:\n                new_solution[perturb_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 72,
        "algorithm": "{The heuristic function selects a promising solution from the archive using a weighted random selection based on the solution's potential for improvement, then applies a hybrid local search operator that combines item swaps and probabilistic flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, _ in archive:\n        current_weight = np.sum(weight_lst * sol)\n        potential = np.sum((weight_lst <= (capacity - current_weight)) * (value1_lst + value2_lst))\n        scores.append(potential)\n    scores = np.array(scores)\n    if np.sum(scores) == 0:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        probs = scores / np.sum(scores)\n        selected_idx = np.random.choice(len(archive), p=probs)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    for _ in range(2):  # Perform 2 iterations of the operator\n        # Step 1: Swap items with high value-to-weight ratios\n        ratios = (value1_lst + value2_lst) / weight_lst\n        sorted_indices = np.argsort(ratios)[::-1]\n\n        for i in sorted_indices:\n            if new_solution[i] == 0:\n                temp_solution = new_solution.copy()\n                temp_solution[i] = 1\n                if np.sum(weight_lst * temp_solution) <= capacity:\n                    new_solution = temp_solution\n                    break\n\n        # Step 2: Probabilistic flip of items based on their contribution\n        for i in range(len(new_solution)):\n            if np.random.rand() < 0.1:  # 10% chance to flip\n                temp_solution = new_solution.copy()\n                temp_solution[i] = 1 - temp_solution[i]\n                if np.sum(weight_lst * temp_solution) <= capacity:\n                    new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.31602436771950815,
            8.9188734292984
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, _ in archive:\n        current_weight = np.sum(weight_lst * sol)\n        potential = np.sum((weight_lst <= (capacity - current_weight)) * (value1_lst + value2_lst))\n        scores.append(potential)\n    scores = np.array(scores)\n    if np.sum(scores) == 0:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        probs = scores / np.sum(scores)\n        selected_idx = np.random.choice(len(archive), p=probs)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    for _ in range(2):  # Perform 2 iterations of the operator\n        # Step 1: Swap items with high value-to-weight ratios\n        ratios = (value1_lst + value2_lst) / weight_lst\n        sorted_indices = np.argsort(ratios)[::-1]\n\n        for i in sorted_indices:\n            if new_solution[i] == 0:\n                temp_solution = new_solution.copy()\n                temp_solution[i] = 1\n                if np.sum(weight_lst * temp_solution) <= capacity:\n                    new_solution = temp_solution\n                    break\n\n        # Step 2: Probabilistic flip of items based on their contribution\n        for i in range(len(new_solution)):\n            if np.random.rand() < 0.1:  # 10% chance to flip\n                temp_solution = new_solution.copy()\n                temp_solution[i] = 1 - temp_solution[i]\n                if np.sum(weight_lst * temp_solution) <= capacity:\n                    new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 73,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high marginal gains in either objective, then performs a novel hybrid local search combining item swaps and adaptive neighborhood exploration to generate a feasible neighbor solution with improved objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on marginal gains\n    selected_solution, selected_objective = random.choice(archive)\n    base_solution = selected_solution.copy()\n    current_value1, current_value2 = selected_objective\n\n    # Calculate marginal gains for each item\n    marginal_gains = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Calculate gain if removed\n            gain1 = -value1_lst[i]\n            gain2 = -value2_lst[i]\n            marginal_gains.append((i, gain1, gain2, -1))  # -1 indicates removal\n        else:\n            # Calculate gain if added (if feasible)\n            if np.dot(weight_lst, base_solution) + weight_lst[i] <= capacity:\n                gain1 = value1_lst[i]\n                gain2 = value2_lst[i]\n                marginal_gains.append((i, gain1, gain2, 1))  # 1 indicates addition\n\n    # Sort by the sum of absolute gains (prioritize items with largest impact)\n    marginal_gains.sort(key=lambda x: abs(x[1]) + abs(x[2]), reverse=True)\n\n    # Apply hybrid local search\n    new_solution = base_solution.copy()\n    max_iterations = min(5, len(marginal_gains))  # Limit iterations to avoid excessive computation\n    for i in range(max_iterations):\n        if not marginal_gains:\n            break\n\n        # Select the most promising item\n        item_idx, gain1, gain2, action = marginal_gains.pop(0)\n\n        if action == 1:  # Add item\n            new_solution[item_idx] = 1\n            # Check feasibility\n            if np.dot(weight_lst, new_solution) > capacity:\n                new_solution[item_idx] = 0  # Revert if infeasible\n        else:  # Remove item\n            new_solution[item_idx] = 0\n\n        # Adaptive neighborhood exploration: randomly flip another item if feasible\n        if random.random() < 0.3:  # 30% chance for exploration\n            candidate_items = [i for i in range(len(new_solution)) if new_solution[i] != base_solution[i]]\n            if candidate_items:\n                flip_idx = random.choice(candidate_items)\n                if new_solution[flip_idx] == 1:\n                    new_solution[flip_idx] = 0\n                else:\n                    if np.dot(weight_lst, new_solution) + weight_lst[flip_idx] <= capacity:\n                        new_solution[flip_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.5376991872932813,
            5.563310503959656
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on marginal gains\n    selected_solution, selected_objective = random.choice(archive)\n    base_solution = selected_solution.copy()\n    current_value1, current_value2 = selected_objective\n\n    # Calculate marginal gains for each item\n    marginal_gains = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Calculate gain if removed\n            gain1 = -value1_lst[i]\n            gain2 = -value2_lst[i]\n            marginal_gains.append((i, gain1, gain2, -1))  # -1 indicates removal\n        else:\n            # Calculate gain if added (if feasible)\n            if np.dot(weight_lst, base_solution) + weight_lst[i] <= capacity:\n                gain1 = value1_lst[i]\n                gain2 = value2_lst[i]\n                marginal_gains.append((i, gain1, gain2, 1))  # 1 indicates addition\n\n    # Sort by the sum of absolute gains (prioritize items with largest impact)\n    marginal_gains.sort(key=lambda x: abs(x[1]) + abs(x[2]), reverse=True)\n\n    # Apply hybrid local search\n    new_solution = base_solution.copy()\n    max_iterations = min(5, len(marginal_gains))  # Limit iterations to avoid excessive computation\n    for i in range(max_iterations):\n        if not marginal_gains:\n            break\n\n        # Select the most promising item\n        item_idx, gain1, gain2, action = marginal_gains.pop(0)\n\n        if action == 1:  # Add item\n            new_solution[item_idx] = 1\n            # Check feasibility\n            if np.dot(weight_lst, new_solution) > capacity:\n                new_solution[item_idx] = 0  # Revert if infeasible\n        else:  # Remove item\n            new_solution[item_idx] = 0\n\n        # Adaptive neighborhood exploration: randomly flip another item if feasible\n        if random.random() < 0.3:  # 30% chance for exploration\n            candidate_items = [i for i in range(len(new_solution)) if new_solution[i] != base_solution[i]]\n            if candidate_items:\n                flip_idx = random.choice(candidate_items)\n                if new_solution[flip_idx] == 1:\n                    new_solution[flip_idx] = 0\n                else:\n                    if np.dot(weight_lst, new_solution) + weight_lst[flip_idx] <= capacity:\n                        new_solution[flip_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 74,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive by prioritizing those with high objective values and low weights, then applies a hybrid local search combining adaptive bit flipping and greedy item swapping to generate a feasible neighbor solution while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (high value, low weight)\n    selected_idx = np.argmax([(obj[0] + obj[1]) / (np.sum(weight_lst * sol) + 1e-6) for sol, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: adaptive bit flipping + greedy swapping\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Phase 1: Adaptive bit flipping\n    for _ in range(min(3, n_items)):\n        idx = random.randint(0, n_items - 1)\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 2: Greedy swapping for both objectives\n    for _ in range(min(5, n_items)):\n        # Select items to swap based on value ratio\n        out_idx = np.where(new_solution == 1)[0]\n        in_idx = np.where(new_solution == 0)[0]\n\n        if len(out_idx) == 0 or len(in_idx) == 0:\n            break\n\n        # Evaluate potential swaps for both objectives\n        out_values1 = value1_lst[out_idx]\n        out_values2 = value2_lst[out_idx]\n        in_values1 = value1_lst[in_idx]\n        in_values2 = value2_lst[in_idx]\n\n        # Calculate marginal gains\n        gains1 = (in_values1[:, None] - out_values1[None, :]).flatten()\n        gains2 = (in_values2[:, None] - out_values2[None, :]).flatten()\n        combined_gains = gains1 + gains2\n\n        if len(combined_gains) == 0:\n            break\n\n        best_swap = np.argmax(combined_gains)\n        i, j = np.unravel_index(best_swap, (len(in_idx), len(out_idx)))\n        in_item = in_idx[i]\n        out_item = out_idx[j]\n\n        # Check feasibility\n        new_weight = current_weight - weight_lst[out_item] + weight_lst[in_item]\n        if new_weight <= capacity:\n            new_solution[out_item] = 0\n            new_solution[in_item] = 1\n            current_weight = new_weight\n\n    return new_solution\n\n",
        "score": [
            -0.3224534169352394,
            10.484787672758102
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (high value, low weight)\n    selected_idx = np.argmax([(obj[0] + obj[1]) / (np.sum(weight_lst * sol) + 1e-6) for sol, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: adaptive bit flipping + greedy swapping\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Phase 1: Adaptive bit flipping\n    for _ in range(min(3, n_items)):\n        idx = random.randint(0, n_items - 1)\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Phase 2: Greedy swapping for both objectives\n    for _ in range(min(5, n_items)):\n        # Select items to swap based on value ratio\n        out_idx = np.where(new_solution == 1)[0]\n        in_idx = np.where(new_solution == 0)[0]\n\n        if len(out_idx) == 0 or len(in_idx) == 0:\n            break\n\n        # Evaluate potential swaps for both objectives\n        out_values1 = value1_lst[out_idx]\n        out_values2 = value2_lst[out_idx]\n        in_values1 = value1_lst[in_idx]\n        in_values2 = value2_lst[in_idx]\n\n        # Calculate marginal gains\n        gains1 = (in_values1[:, None] - out_values1[None, :]).flatten()\n        gains2 = (in_values2[:, None] - out_values2[None, :]).flatten()\n        combined_gains = gains1 + gains2\n\n        if len(combined_gains) == 0:\n            break\n\n        best_swap = np.argmax(combined_gains)\n        i, j = np.unravel_index(best_swap, (len(in_idx), len(out_idx)))\n        in_item = in_idx[i]\n        out_item = out_idx[j]\n\n        # Check feasibility\n        new_weight = current_weight - weight_lst[out_item] + weight_lst[in_item]\n        if new_weight <= capacity:\n            new_solution[out_item] = 0\n            new_solution[in_item] = 1\n            current_weight = new_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 75,
        "algorithm": "{The algorithm selects a promising solution from the archive based on diversity and objective improvement potential, then applies a hybrid local search combining random item swaps and value-driven flips to generate a feasible neighbor solution while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (diverse or not fully explored)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine random swaps and value-driven flips\n    num_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select a subset of items to consider for flipping\n    candidate_indices = np.random.choice(num_items, size=min(5, num_items), replace=False)\n\n    for idx in candidate_indices:\n        # Try adding item if not present\n        if new_solution[idx] == 0 and (current_weight + weight_lst[idx]) <= capacity:\n            if random.random() < 0.7 or (value1_lst[idx] > 0 and value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n        # Try removing item if present\n        elif new_solution[idx] == 1:\n            if random.random() < 0.3 or (value1_lst[idx] < np.median(value1_lst) or value2_lst[idx] < np.median(value2_lst)):\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    # Ensure feasibility\n    if np.sum(weight_lst[new_solution == 1]) > capacity:\n        # If not feasible, remove items randomly until feasible\n        while np.sum(weight_lst[new_solution == 1]) > capacity:\n            included_idx = np.where(new_solution == 1)[0]\n            if len(included_idx) == 0:\n                break\n            remove_idx = np.random.choice(included_idx)\n            new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.3481608442668891,
            3.343442440032959
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (diverse or not fully explored)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine random swaps and value-driven flips\n    num_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select a subset of items to consider for flipping\n    candidate_indices = np.random.choice(num_items, size=min(5, num_items), replace=False)\n\n    for idx in candidate_indices:\n        # Try adding item if not present\n        if new_solution[idx] == 0 and (current_weight + weight_lst[idx]) <= capacity:\n            if random.random() < 0.7 or (value1_lst[idx] > 0 and value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n        # Try removing item if present\n        elif new_solution[idx] == 1:\n            if random.random() < 0.3 or (value1_lst[idx] < np.median(value1_lst) or value2_lst[idx] < np.median(value2_lst)):\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    # Ensure feasibility\n    if np.sum(weight_lst[new_solution == 1]) > capacity:\n        # If not feasible, remove items randomly until feasible\n        while np.sum(weight_lst[new_solution == 1]) > capacity:\n            included_idx = np.where(new_solution == 1)[0]\n            if len(included_idx) == 0:\n                break\n            remove_idx = np.random.choice(included_idx)\n            new_solution[remove_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 76,
        "algorithm": "{The new algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines item swaps and adaptive flips, guided by objective-specific value-to-weight ratios, to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to boundary)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (total_value1, total_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: adaptive flips and swaps\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Adaptive flip: prioritize items with high value-to-weight ratio for the weaker objective\n        if total_value1 < total_value2:\n            value_ratio = value1_lst / weight_lst\n        else:\n            value_ratio = value2_lst / weight_lst\n\n        # Find items to flip (change inclusion/exclusion)\n        flip_candidates = np.where(new_solution == 1)[0]\n        if len(flip_candidates) > 0:\n            flip_idx = random.choice(flip_candidates)\n            if random.random() < 0.7:  # Higher probability to flip high-value items\n                flip_idx = flip_candidates[np.argmax(value_ratio[flip_candidates])]\n\n            # Check if flipping is feasible\n            if new_solution[flip_idx] == 1:\n                new_weight = current_weight - weight_lst[flip_idx]\n                if new_weight <= capacity:\n                    new_solution[flip_idx] = 0\n                    current_weight = new_weight\n\n        # Swap: exchange two items if feasible\n        swap_candidates = np.where(new_solution == 0)[0]\n        if len(swap_candidates) >= 2:\n            swap_idx1, swap_idx2 = random.sample(list(swap_candidates), 2)\n            if random.random() < 0.5:  # Higher probability to swap high-value items\n                swap_idx1 = swap_candidates[np.argmax(value_ratio[swap_candidates])]\n                swap_candidates = np.delete(swap_candidates, np.where(swap_candidates == swap_idx1)[0])\n                if len(swap_candidates) > 0:\n                    swap_idx2 = swap_candidates[np.argmax(value_ratio[swap_candidates])]\n\n            # Check if swap is feasible\n            if new_solution[swap_idx1] == 0 and new_solution[swap_idx2] == 0:\n                new_weight = current_weight + weight_lst[swap_idx1] + weight_lst[swap_idx2]\n                if new_weight <= capacity:\n                    new_solution[swap_idx1] = 1\n                    new_solution[swap_idx2] = 1\n                    current_weight = new_weight\n\n    return new_solution\n\n",
        "score": [
            -0.3225372901410306,
            4.8555790185928345
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to boundary)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (total_value1, total_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: adaptive flips and swaps\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Adaptive flip: prioritize items with high value-to-weight ratio for the weaker objective\n        if total_value1 < total_value2:\n            value_ratio = value1_lst / weight_lst\n        else:\n            value_ratio = value2_lst / weight_lst\n\n        # Find items to flip (change inclusion/exclusion)\n        flip_candidates = np.where(new_solution == 1)[0]\n        if len(flip_candidates) > 0:\n            flip_idx = random.choice(flip_candidates)\n            if random.random() < 0.7:  # Higher probability to flip high-value items\n                flip_idx = flip_candidates[np.argmax(value_ratio[flip_candidates])]\n\n            # Check if flipping is feasible\n            if new_solution[flip_idx] == 1:\n                new_weight = current_weight - weight_lst[flip_idx]\n                if new_weight <= capacity:\n                    new_solution[flip_idx] = 0\n                    current_weight = new_weight\n\n        # Swap: exchange two items if feasible\n        swap_candidates = np.where(new_solution == 0)[0]\n        if len(swap_candidates) >= 2:\n            swap_idx1, swap_idx2 = random.sample(list(swap_candidates), 2)\n            if random.random() < 0.5:  # Higher probability to swap high-value items\n                swap_idx1 = swap_candidates[np.argmax(value_ratio[swap_candidates])]\n                swap_candidates = np.delete(swap_candidates, np.where(swap_candidates == swap_idx1)[0])\n                if len(swap_candidates) > 0:\n                    swap_idx2 = swap_candidates[np.argmax(value_ratio[swap_candidates])]\n\n            # Check if swap is feasible\n            if new_solution[swap_idx1] == 0 and new_solution[swap_idx2] == 0:\n                new_weight = current_weight + weight_lst[swap_idx1] + weight_lst[swap_idx2]\n                if new_weight <= capacity:\n                    new_solution[swap_idx1] = 1\n                    new_solution[swap_idx2] = 1\n                    current_weight = new_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 77,
        "algorithm": "{A novel hybrid local search strategy combines a biased random walk with a dynamic neighborhood exploration, intelligently selecting items to flip based on their marginal contribution to both objectives while ensuring feasibility through a greedy capacity check.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + i) for i in range(len(archive))], k=1)[0]\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Identify items that can be flipped (either added or removed)\n    candidate_indices = np.where(new_solution != base_solution)[0]\n\n    # If no candidates, randomly select one item to flip\n    if len(candidate_indices) == 0:\n        candidate_indices = np.arange(len(weight_lst))\n\n    # Evaluate potential flips based on marginal contribution to both objectives\n    flip_scores = []\n    for idx in candidate_indices:\n        if new_solution[idx] == 1:\n            # If item is currently in the knapsack, consider removing it\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                # Calculate marginal contribution (negative since we're removing)\n                marginal1 = -value1_lst[idx]\n                marginal2 = -value2_lst[idx]\n                flip_scores.append((idx, marginal1, marginal2, new_weight))\n        else:\n            # If item is not in the knapsack, consider adding it\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                marginal1 = value1_lst[idx]\n                marginal2 = value2_lst[idx]\n                flip_scores.append((idx, marginal1, marginal2, new_weight))\n\n    if not flip_scores:\n        # If no feasible flips, return the original solution\n        return base_solution\n\n    # Select the flip with the highest combined marginal contribution (weighted sum)\n    # Using a dynamic weight based on the current solution's position in the Pareto front\n    # Here we use a simple approach: alternate between favoring value1 and value2\n    if random.random() < 0.5:\n        # Favor value1\n        best_flip = max(flip_scores, key=lambda x: x[1])\n    else:\n        # Favor value2\n        best_flip = max(flip_scores, key=lambda x: x[2])\n\n    # Perform the flip\n    new_solution[best_flip[0]] = 1 - new_solution[best_flip[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.8444847221265548,
            2.067265808582306
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + i) for i in range(len(archive))], k=1)[0]\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Identify items that can be flipped (either added or removed)\n    candidate_indices = np.where(new_solution != base_solution)[0]\n\n    # If no candidates, randomly select one item to flip\n    if len(candidate_indices) == 0:\n        candidate_indices = np.arange(len(weight_lst))\n\n    # Evaluate potential flips based on marginal contribution to both objectives\n    flip_scores = []\n    for idx in candidate_indices:\n        if new_solution[idx] == 1:\n            # If item is currently in the knapsack, consider removing it\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                # Calculate marginal contribution (negative since we're removing)\n                marginal1 = -value1_lst[idx]\n                marginal2 = -value2_lst[idx]\n                flip_scores.append((idx, marginal1, marginal2, new_weight))\n        else:\n            # If item is not in the knapsack, consider adding it\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                marginal1 = value1_lst[idx]\n                marginal2 = value2_lst[idx]\n                flip_scores.append((idx, marginal1, marginal2, new_weight))\n\n    if not flip_scores:\n        # If no feasible flips, return the original solution\n        return base_solution\n\n    # Select the flip with the highest combined marginal contribution (weighted sum)\n    # Using a dynamic weight based on the current solution's position in the Pareto front\n    # Here we use a simple approach: alternate between favoring value1 and value2\n    if random.random() < 0.5:\n        # Favor value1\n        best_flip = max(flip_scores, key=lambda x: x[1])\n    else:\n        # Favor value2\n        best_flip = max(flip_scores, key=lambda x: x[2])\n\n    # Perform the flip\n    new_solution[best_flip[0]] = 1 - new_solution[best_flip[0]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 78,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    value1s = [obj[0] for _, obj in archive]\n    value2s = [obj[1] for _, obj in archive]\n\n    # Normalize the values to avoid bias\n    max_value1 = max(value1s) if max(value1s) != 0 else 1\n    max_value2 = max(value2s) if max(value2s) != 0 else 1\n    normalized_value1s = [v1 / max_value1 for v1 in value1s]\n    normalized_value2s = [v2 / max_value2 for v2 in value2s]\n\n    # Calculate a score for each solution (combination of normalized values)\n    scores = [v1 + v2 for v1, v2 in zip(normalized_value1s, normalized_value2s)]\n\n    # Select the solution with the highest score (most promising)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor solution using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly flip a subset of items to explore new regions\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Step 2: Ensure feasibility (if not, undo the changes)\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # If infeasible, revert the changes and apply a more controlled flip\n        new_solution = base_solution.copy()\n        # Flip only one item to maintain feasibility\n        flip_idx = np.random.choice(len(new_solution))\n        new_solution[flip_idx] = 1 - new_solution[flip_idx]\n        total_weight = np.sum(weight_lst * new_solution)\n        if total_weight > capacity:\n            # If still infeasible, flip back\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3456851975759596,
            3.162291169166565
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    value1s = [obj[0] for _, obj in archive]\n    value2s = [obj[1] for _, obj in archive]\n\n    # Normalize the values to avoid bias\n    max_value1 = max(value1s) if max(value1s) != 0 else 1\n    max_value2 = max(value2s) if max(value2s) != 0 else 1\n    normalized_value1s = [v1 / max_value1 for v1 in value1s]\n    normalized_value2s = [v2 / max_value2 for v2 in value2s]\n\n    # Calculate a score for each solution (combination of normalized values)\n    scores = [v1 + v2 for v1, v2 in zip(normalized_value1s, normalized_value2s)]\n\n    # Select the solution with the highest score (most promising)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor solution using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly flip a subset of items to explore new regions\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Step 2: Ensure feasibility (if not, undo the changes)\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # If infeasible, revert the changes and apply a more controlled flip\n        new_solution = base_solution.copy()\n        # Flip only one item to maintain feasibility\n        flip_idx = np.random.choice(len(new_solution))\n        new_solution[flip_idx] = 1 - new_solution[flip_idx]\n        total_weight = np.sum(weight_lst * new_solution)\n        if total_weight > capacity:\n            # If still infeasible, flip back\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 79,
        "algorithm": "{A novel hybrid local search operator combines adaptive item swapping and guided random perturbations to intelligently explore the solution space, balancing exploitation of promising regions and diversification of search while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify items that can be swapped or perturbed\n    included_items = np.where(base_solution == 1)[0]\n    excluded_items = np.where(base_solution == 0)[0]\n\n    # Hybrid local search: adaptive swapping + guided perturbation\n    if len(included_items) > 0 and len(excluded_items) > 0:\n        # Adaptive swapping: try to replace one included item with one excluded item\n        swap_candidate = np.random.choice(included_items)\n        new_item = np.random.choice(excluded_items)\n\n        if current_weight - weight_lst[swap_candidate] + weight_lst[new_item] <= capacity:\n            new_solution[swap_candidate] = 0\n            new_solution[new_item] = 1\n        else:\n            # If swap is not feasible, perform guided perturbation\n            # Try to replace the heaviest included item with the lightest excluded item\n            heaviest_included = included_items[np.argmax(weight_lst[included_items])]\n            lightest_excluded = excluded_items[np.argmin(weight_lst[excluded_items])]\n\n            if weight_lst[lightest_excluded] <= weight_lst[heaviest_included] and \\\n               current_weight - weight_lst[heaviest_included] + weight_lst[lightest_excluded] <= capacity:\n                new_solution[heaviest_included] = 0\n                new_solution[lightest_excluded] = 1\n            else:\n                # If all else fails, perform random flip with feasibility check\n                flip_candidate = np.random.choice(len(new_solution))\n                if new_solution[flip_candidate] == 1:\n                    if current_weight - weight_lst[flip_candidate] <= capacity:\n                        new_solution[flip_candidate] = 0\n                else:\n                    if current_weight + weight_lst[flip_candidate] <= capacity:\n                        new_solution[flip_candidate] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.38766301105598633,
            2.165483683347702
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify items that can be swapped or perturbed\n    included_items = np.where(base_solution == 1)[0]\n    excluded_items = np.where(base_solution == 0)[0]\n\n    # Hybrid local search: adaptive swapping + guided perturbation\n    if len(included_items) > 0 and len(excluded_items) > 0:\n        # Adaptive swapping: try to replace one included item with one excluded item\n        swap_candidate = np.random.choice(included_items)\n        new_item = np.random.choice(excluded_items)\n\n        if current_weight - weight_lst[swap_candidate] + weight_lst[new_item] <= capacity:\n            new_solution[swap_candidate] = 0\n            new_solution[new_item] = 1\n        else:\n            # If swap is not feasible, perform guided perturbation\n            # Try to replace the heaviest included item with the lightest excluded item\n            heaviest_included = included_items[np.argmax(weight_lst[included_items])]\n            lightest_excluded = excluded_items[np.argmin(weight_lst[excluded_items])]\n\n            if weight_lst[lightest_excluded] <= weight_lst[heaviest_included] and \\\n               current_weight - weight_lst[heaviest_included] + weight_lst[lightest_excluded] <= capacity:\n                new_solution[heaviest_included] = 0\n                new_solution[lightest_excluded] = 1\n            else:\n                # If all else fails, perform random flip with feasibility check\n                flip_candidate = np.random.choice(len(new_solution))\n                if new_solution[flip_candidate] == 1:\n                    if current_weight - weight_lst[flip_candidate] <= capacity:\n                        new_solution[flip_candidate] = 0\n                else:\n                    if current_weight + weight_lst[flip_candidate] <= capacity:\n                        new_solution[flip_candidate] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 80,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on a hybrid of diversity and objective-space proximity, then applies a novel local search operator that combines item-wise swaps and constrained random flips to explore the neighborhood while ensuring feasibility, balancing exploration and exploitation of the Pareto front.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.randint(0, 2, size=len(weight_lst))\n\n    # Select a solution with high diversity and potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: constrained random flips with item-wise swaps\n    for _ in range(3):  # Number of flips per iteration\n        # Randomly select a candidate item to flip\n        candidate_idx = np.random.randint(0, len(weight_lst))\n\n        # Attempt to flip the item\n        if new_solution[candidate_idx] == 1:\n            # If item is included, try to remove it\n            if np.sum(weight_lst[new_solution == 1]) - weight_lst[candidate_idx] <= capacity:\n                new_solution[candidate_idx] = 0\n        else:\n            # If item is excluded, try to add it\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[candidate_idx] <= capacity:\n                new_solution[candidate_idx] = 1\n\n    # Additional item-wise swap for better neighborhood exploration\n    if len(weight_lst) >= 2:\n        swap_indices = np.random.choice(len(weight_lst), size=2, replace=False)\n        i, j = swap_indices[0], swap_indices[1]\n\n        # Check feasibility before swapping\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        if new_solution[i] == 1 and new_solution[j] == 0:\n            if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        elif new_solution[i] == 0 and new_solution[j] == 1:\n            if current_weight + weight_lst[i] - weight_lst[j] <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.41594841466576266,
            1.9647990763187408
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.randint(0, 2, size=len(weight_lst))\n\n    # Select a solution with high diversity and potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: constrained random flips with item-wise swaps\n    for _ in range(3):  # Number of flips per iteration\n        # Randomly select a candidate item to flip\n        candidate_idx = np.random.randint(0, len(weight_lst))\n\n        # Attempt to flip the item\n        if new_solution[candidate_idx] == 1:\n            # If item is included, try to remove it\n            if np.sum(weight_lst[new_solution == 1]) - weight_lst[candidate_idx] <= capacity:\n                new_solution[candidate_idx] = 0\n        else:\n            # If item is excluded, try to add it\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[candidate_idx] <= capacity:\n                new_solution[candidate_idx] = 1\n\n    # Additional item-wise swap for better neighborhood exploration\n    if len(weight_lst) >= 2:\n        swap_indices = np.random.choice(len(weight_lst), size=2, replace=False)\n        i, j = swap_indices[0], swap_indices[1]\n\n        # Check feasibility before swapping\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        if new_solution[i] == 1 and new_solution[j] == 0:\n            if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        elif new_solution[i] == 0 and new_solution[j] == 1:\n            if current_weight + weight_lst[i] - weight_lst[j] <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 81,
        "algorithm": "{This algorithm intelligently selects a promising solution from the archive based on its potential for local improvement, then applies a novel hybrid local search strategy that combines item swapping, flipping, and adaptive neighborhood exploration to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Intelligent selection: prioritize solutions with high potential for improvement\n    candidates = []\n    for sol, (v1, v2) in archive:\n        # Calculate potential for improvement (e.g., items not in solution with high value)\n        potential = np.sum((1 - sol) * (value1_lst + value2_lst) / (weight_lst + 1e-6))\n        candidates.append((potential, sol))\n\n    # Select top 3 candidates and choose one randomly\n    candidates.sort(reverse=True, key=lambda x: x[0])\n    selected_sol = random.choice(candidates[:min(3, len(candidates))])[1]\n\n    base_solution = selected_sol.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Step 1: Try to add promising items not in solution\n    candidate_add = np.where((1 - base_solution) * weight_lst <= remaining_capacity)[0]\n    if len(candidate_add) > 0:\n        # Select items with highest combined value\n        values = value1_lst + value2_lst\n        sorted_add = sorted(candidate_add, key=lambda x: -values[x])\n        for item in sorted_add[:min(3, len(sorted_add))]:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                remaining_capacity -= weight_lst[item]\n\n    # Step 2: Try to swap items between solution and not in solution\n    in_sol = np.where(base_solution)[0]\n    out_sol = np.where(1 - base_solution)[0]\n\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        # Select items to remove (lowest value density)\n        value_density = (value1_lst + value2_lst) / weight_lst\n        remove_candidates = sorted(in_sol, key=lambda x: value_density[x])\n        add_candidates = sorted(out_sol, key=lambda x: -value_density[x])\n\n        for remove in remove_candidates[:min(2, len(remove_candidates))]:\n            for add in add_candidates[:min(2, len(add_candidates))]:\n                if (current_weight - weight_lst[remove] + weight_lst[add]) <= capacity:\n                    new_solution[remove] = 0\n                    new_solution[add] = 1\n                    return new_solution\n\n    # Step 3: If no improvement, perform random flip with feasibility check\n    if np.array_equal(new_solution, base_solution):\n        flip_candidates = np.where(weight_lst <= remaining_capacity)[0]\n        if len(flip_candidates) > 0:\n            item = random.choice(flip_candidates)\n            new_solution[item] = 1 - new_solution[item]\n\n    return new_solution\n\n",
        "score": [
            -0.7895456227875945,
            4.534051597118378
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Intelligent selection: prioritize solutions with high potential for improvement\n    candidates = []\n    for sol, (v1, v2) in archive:\n        # Calculate potential for improvement (e.g., items not in solution with high value)\n        potential = np.sum((1 - sol) * (value1_lst + value2_lst) / (weight_lst + 1e-6))\n        candidates.append((potential, sol))\n\n    # Select top 3 candidates and choose one randomly\n    candidates.sort(reverse=True, key=lambda x: x[0])\n    selected_sol = random.choice(candidates[:min(3, len(candidates))])[1]\n\n    base_solution = selected_sol.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Step 1: Try to add promising items not in solution\n    candidate_add = np.where((1 - base_solution) * weight_lst <= remaining_capacity)[0]\n    if len(candidate_add) > 0:\n        # Select items with highest combined value\n        values = value1_lst + value2_lst\n        sorted_add = sorted(candidate_add, key=lambda x: -values[x])\n        for item in sorted_add[:min(3, len(sorted_add))]:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                remaining_capacity -= weight_lst[item]\n\n    # Step 2: Try to swap items between solution and not in solution\n    in_sol = np.where(base_solution)[0]\n    out_sol = np.where(1 - base_solution)[0]\n\n    if len(in_sol) > 0 and len(out_sol) > 0:\n        # Select items to remove (lowest value density)\n        value_density = (value1_lst + value2_lst) / weight_lst\n        remove_candidates = sorted(in_sol, key=lambda x: value_density[x])\n        add_candidates = sorted(out_sol, key=lambda x: -value_density[x])\n\n        for remove in remove_candidates[:min(2, len(remove_candidates))]:\n            for add in add_candidates[:min(2, len(add_candidates))]:\n                if (current_weight - weight_lst[remove] + weight_lst[add]) <= capacity:\n                    new_solution[remove] = 0\n                    new_solution[add] = 1\n                    return new_solution\n\n    # Step 3: If no improvement, perform random flip with feasibility check\n    if np.array_equal(new_solution, base_solution):\n        flip_candidates = np.where(weight_lst <= remaining_capacity)[0]\n        if len(flip_candidates) > 0:\n            item = random.choice(flip_candidates)\n            new_solution[item] = 1 - new_solution[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 82,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: first try to improve one objective, then the other\n    for _ in range(2):\n        # Randomly select an objective to prioritize\n        obj_to_optimize = np.random.choice([0, 1])\n\n        # Find items that can be toggled without violating capacity\n        current_weight = np.sum(weight_lst * base_solution)\n        available_weight = capacity - current_weight\n\n        # Identify candidate items to swap or add\n        if obj_to_optimize == 0:\n            # Prioritize items with high value1\n            candidates = np.argsort(value1_lst)[::-1]\n        else:\n            # Prioritize items with high value2\n            candidates = np.argsort(value2_lst)[::-1]\n\n        for item in candidates:\n            if base_solution[item] == 0 and weight_lst[item] <= available_weight:\n                new_solution[item] = 1\n                break\n            elif base_solution[item] == 1:\n                # Try to replace with another item if feasible\n                for other_item in candidates:\n                    if base_solution[other_item] == 0 and weight_lst[other_item] <= available_weight + weight_lst[item]:\n                        new_solution[item] = 0\n                        new_solution[other_item] = 1\n                        break\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.4842940852117181,
            5.329827755689621
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: first try to improve one objective, then the other\n    for _ in range(2):\n        # Randomly select an objective to prioritize\n        obj_to_optimize = np.random.choice([0, 1])\n\n        # Find items that can be toggled without violating capacity\n        current_weight = np.sum(weight_lst * base_solution)\n        available_weight = capacity - current_weight\n\n        # Identify candidate items to swap or add\n        if obj_to_optimize == 0:\n            # Prioritize items with high value1\n            candidates = np.argsort(value1_lst)[::-1]\n        else:\n            # Prioritize items with high value2\n            candidates = np.argsort(value2_lst)[::-1]\n\n        for item in candidates:\n            if base_solution[item] == 0 and weight_lst[item] <= available_weight:\n                new_solution[item] = 1\n                break\n            elif base_solution[item] == 1:\n                # Try to replace with another item if feasible\n                for other_item in candidates:\n                    if base_solution[other_item] == 0 and weight_lst[other_item] <= available_weight + weight_lst[item]:\n                        new_solution[item] = 0\n                        new_solution[other_item] = 1\n                        break\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 83,
        "algorithm": "{A novel hybrid local search operator combines adaptive item swapping with objective-aware perturbation, guided by a diversity-aware selection mechanism to explore high-potential regions in the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a base solution with a bias towards solutions with high potential for improvement\n    base_solution, _ = max(archive, key=lambda x: np.sum(x[0]) * (1 - np.sum(x[0]) / len(x[0])))\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive swapping and perturbation\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Identify items to consider for swapping\n    included_items = np.where(new_solution == 1)[0]\n    excluded_items = np.where(new_solution == 0)[0]\n\n    # Objective-aware selection: prioritize items that improve both objectives\n    if len(included_items) > 0 and len(excluded_items) > 0:\n        # Randomly select an included item to potentially remove\n        item_to_remove = random.choice(included_items)\n        # Select an excluded item to potentially add based on both objectives\n        candidates = []\n        for item in excluded_items:\n            if weight_lst[item] <= remaining_capacity + weight_lst[item_to_remove]:\n                improvement1 = value1_lst[item] - value1_lst[item_to_remove]\n                improvement2 = value2_lst[item] - value2_lst[item_to_remove]\n                candidates.append((item, improvement1, improvement2))\n        if candidates:\n            # Select the candidate that improves both objectives the most\n            best_candidate = max(candidates, key=lambda x: x[1] + x[2])\n            new_solution[item_to_remove] = 0\n            new_solution[best_candidate[0]] = 1\n\n    # Additional perturbation: randomly flip a small number of items to escape local optima\n    num_flips = min(2, len(new_solution) // 10)\n    for _ in range(num_flips):\n        flip_idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.3373013747422826,
            6.218979328870773
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a base solution with a bias towards solutions with high potential for improvement\n    base_solution, _ = max(archive, key=lambda x: np.sum(x[0]) * (1 - np.sum(x[0]) / len(x[0])))\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive swapping and perturbation\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Identify items to consider for swapping\n    included_items = np.where(new_solution == 1)[0]\n    excluded_items = np.where(new_solution == 0)[0]\n\n    # Objective-aware selection: prioritize items that improve both objectives\n    if len(included_items) > 0 and len(excluded_items) > 0:\n        # Randomly select an included item to potentially remove\n        item_to_remove = random.choice(included_items)\n        # Select an excluded item to potentially add based on both objectives\n        candidates = []\n        for item in excluded_items:\n            if weight_lst[item] <= remaining_capacity + weight_lst[item_to_remove]:\n                improvement1 = value1_lst[item] - value1_lst[item_to_remove]\n                improvement2 = value2_lst[item] - value2_lst[item_to_remove]\n                candidates.append((item, improvement1, improvement2))\n        if candidates:\n            # Select the candidate that improves both objectives the most\n            best_candidate = max(candidates, key=lambda x: x[1] + x[2])\n            new_solution[item_to_remove] = 0\n            new_solution[best_candidate[0]] = 1\n\n    # Additional perturbation: randomly flip a small number of items to escape local optima\n    num_flips = min(2, len(new_solution) // 10)\n    for _ in range(num_flips):\n        flip_idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 84,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its potential for local improvement, then applies a hybrid local search operator that combines item swaps and dynamic neighborhood exploration to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (e.g., one with high potential for improvement)\n    # Here, we select the solution with the highest combined value as a starting point\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply hybrid local search: dynamic neighborhood exploration\n    new_solution = base_solution.copy()\n    N = len(base_solution)\n\n    # Randomly select a subset of items to consider for swapping\n    subset_size = max(1, int(0.2 * N))  # Consider 20% of items\n    candidate_indices = np.random.choice(N, size=subset_size, replace=False)\n\n    for i in candidate_indices:\n        # Try flipping the item (add if not in, remove if in)\n        if base_solution[i] == 1:\n            # Remove item\n            temp_weight = current_weight - weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution[i] = 0\n                current_weight = temp_weight\n        else:\n            # Add item\n            temp_weight = current_weight + weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution[i] = 1\n                current_weight = temp_weight\n\n        # Optional: Perform a small local search around the flipped item\n        for j in range(N):\n            if j == i:\n                continue\n            if base_solution[j] == 1 and base_solution[i] == 0:\n                # Try swapping items\n                temp_weight = current_weight - weight_lst[j] + weight_lst[i]\n                if temp_weight <= capacity:\n                    new_solution[j] = 0\n                    new_solution[i] = 1\n                    current_weight = temp_weight\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.2602620807902107,
            8.895784199237823
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (e.g., one with high potential for improvement)\n    # Here, we select the solution with the highest combined value as a starting point\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Apply hybrid local search: dynamic neighborhood exploration\n    new_solution = base_solution.copy()\n    N = len(base_solution)\n\n    # Randomly select a subset of items to consider for swapping\n    subset_size = max(1, int(0.2 * N))  # Consider 20% of items\n    candidate_indices = np.random.choice(N, size=subset_size, replace=False)\n\n    for i in candidate_indices:\n        # Try flipping the item (add if not in, remove if in)\n        if base_solution[i] == 1:\n            # Remove item\n            temp_weight = current_weight - weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution[i] = 0\n                current_weight = temp_weight\n        else:\n            # Add item\n            temp_weight = current_weight + weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution[i] = 1\n                current_weight = temp_weight\n\n        # Optional: Perform a small local search around the flipped item\n        for j in range(N):\n            if j == i:\n                continue\n            if base_solution[j] == 1 and base_solution[i] == 0:\n                # Try swapping items\n                temp_weight = current_weight - weight_lst[j] + weight_lst[i]\n                if temp_weight <= capacity:\n                    new_solution[j] = 0\n                    new_solution[i] = 1\n                    current_weight = temp_weight\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 85,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a promising solution from the archive, applies a combination of item swaps and diversified flips, and ensures feasibility by dynamically adjusting the neighborhood while prioritizing high-potential items for improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    # Prioritize solutions with high potential for improvement (e.g., solutions near the Pareto front)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate the crowding distance of each solution for selection\n    crowding_distances = []\n    for i in range(len(archive_objectives)):\n        left = max(0, i - 1)\n        right = min(len(archive_objectives) - 1, i + 1)\n        if left == right:\n            crowding_distances.append(float('inf'))\n        else:\n            obj_left = archive_objectives[left]\n            obj_right = archive_objectives[right]\n            dist = (abs(archive_objectives[i][0] - obj_left[0]) + abs(archive_objectives[i][1] - obj_left[1]) +\n                    abs(archive_objectives[i][0] - obj_right[0]) + abs(archive_objectives[i][1] - obj_right[1]))\n            crowding_distances.append(dist)\n\n    # Select a solution with high crowding distance (more potential for improvement)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor solution using a hybrid local search\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Randomly flip a subset of items (diversification)\n    flip_indices = np.where(new_solution == 1)[0]\n    if len(flip_indices) > 0:\n        num_flips = min(3, len(flip_indices))  # Limit flips to avoid excessive changes\n        flip_candidates = random.sample(list(flip_indices), num_flips)\n        for idx in flip_candidates:\n            new_solution[idx] = 0\n            total_weight -= weight_lst[idx]\n\n    # Step 2: Add promising items not in the solution (intensification)\n    candidate_indices = np.where(new_solution == 0)[0]\n    if len(candidate_indices) > 0:\n        # Calculate the \"promise\" of each candidate item (weighted sum of normalized values)\n        normalized_value1 = (value1_lst[candidate_indices] - np.min(value1_lst)) / (np.max(value1_lst) - np.min(value1_lst) + 1e-6)\n        normalized_value2 = (value2_lst[candidate_indices] - np.min(value2_lst)) / (np.max(value2_lst) - np.min(value2_lst) + 1e-6)\n        promise = 0.5 * normalized_value1 + 0.5 * normalized_value2  # Equal weight for both objectives\n        sorted_indices = np.argsort(-promise)  # Sort by descending promise\n        for idx in candidate_indices[sorted_indices]:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    # Step 3: Swap items to improve both objectives (local search)\n    for _ in range(5):  # Limit the number of swaps for efficiency\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n        if len(in_items) == 0 or len(out_items) == 0:\n            break\n        in_idx = random.choice(in_items)\n        out_idx = random.choice(out_items)\n        if weight_lst[in_idx] + weight_lst[out_idx] <= capacity:\n            new_solution[in_idx], new_solution[out_idx] = new_solution[out_idx], new_solution[in_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3271179074892231,
            3.1676095128059387
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    # Prioritize solutions with high potential for improvement (e.g., solutions near the Pareto front)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate the crowding distance of each solution for selection\n    crowding_distances = []\n    for i in range(len(archive_objectives)):\n        left = max(0, i - 1)\n        right = min(len(archive_objectives) - 1, i + 1)\n        if left == right:\n            crowding_distances.append(float('inf'))\n        else:\n            obj_left = archive_objectives[left]\n            obj_right = archive_objectives[right]\n            dist = (abs(archive_objectives[i][0] - obj_left[0]) + abs(archive_objectives[i][1] - obj_left[1]) +\n                    abs(archive_objectives[i][0] - obj_right[0]) + abs(archive_objectives[i][1] - obj_right[1]))\n            crowding_distances.append(dist)\n\n    # Select a solution with high crowding distance (more potential for improvement)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor solution using a hybrid local search\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Randomly flip a subset of items (diversification)\n    flip_indices = np.where(new_solution == 1)[0]\n    if len(flip_indices) > 0:\n        num_flips = min(3, len(flip_indices))  # Limit flips to avoid excessive changes\n        flip_candidates = random.sample(list(flip_indices), num_flips)\n        for idx in flip_candidates:\n            new_solution[idx] = 0\n            total_weight -= weight_lst[idx]\n\n    # Step 2: Add promising items not in the solution (intensification)\n    candidate_indices = np.where(new_solution == 0)[0]\n    if len(candidate_indices) > 0:\n        # Calculate the \"promise\" of each candidate item (weighted sum of normalized values)\n        normalized_value1 = (value1_lst[candidate_indices] - np.min(value1_lst)) / (np.max(value1_lst) - np.min(value1_lst) + 1e-6)\n        normalized_value2 = (value2_lst[candidate_indices] - np.min(value2_lst)) / (np.max(value2_lst) - np.min(value2_lst) + 1e-6)\n        promise = 0.5 * normalized_value1 + 0.5 * normalized_value2  # Equal weight for both objectives\n        sorted_indices = np.argsort(-promise)  # Sort by descending promise\n        for idx in candidate_indices[sorted_indices]:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    # Step 3: Swap items to improve both objectives (local search)\n    for _ in range(5):  # Limit the number of swaps for efficiency\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n        if len(in_items) == 0 or len(out_items) == 0:\n            break\n        in_idx = random.choice(in_items)\n        out_idx = random.choice(out_items)\n        if weight_lst[in_idx] + weight_lst[out_idx] <= capacity:\n            new_solution[in_idx], new_solution[out_idx] = new_solution[out_idx], new_solution[in_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 86,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly flip a subset of items to explore the neighborhood\n    flip_indices = np.random.choice(len(base_solution), size=min(3, len(base_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n\n    # Step 2: Apply a greedy improvement step for one objective\n    objective = np.random.choice([0, 1])\n    if objective == 0:\n        # Improve value1\n        for idx in np.where(new_solution == 0)[0]:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n    else:\n        # Improve value2\n        for idx in np.where(new_solution == 0)[0]:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.41434301114179245,
            6.922760367393494
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly flip a subset of items to explore the neighborhood\n    flip_indices = np.random.choice(len(base_solution), size=min(3, len(base_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n\n    # Step 2: Apply a greedy improvement step for one objective\n    objective = np.random.choice([0, 1])\n    if objective == 0:\n        # Improve value1\n        for idx in np.where(new_solution == 0)[0]:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n    else:\n        # Improve value2\n        for idx in np.where(new_solution == 0)[0]:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 87,
        "algorithm": "{The new algorithm intelligently selects a promising solution from the archive by prioritizing those with high objective values and low weight utilization, then applies a hybrid local search that combines item swaps with probabilistic flips to explore the solution space while ensuring feasibility and diversity in the generated neighbor.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def score(solution_obj):\n        total_weight = np.sum(weight_lst * solution_obj[0])\n        return (solution_obj[1][0] + solution_obj[1][1]) / (1 + total_weight)\n\n    scored_solutions = [(score(sol), sol) for sol in archive]\n    scored_solutions.sort(key=lambda x: -x[0])\n    selected_solution = scored_solutions[0][1][0].copy()\n\n    # Generate a neighbor using hybrid local search\n    new_solution = selected_solution.copy()\n    items = np.where(new_solution == 1)[0]\n    non_items = np.where(new_solution == 0)[0]\n\n    # Step 1: Randomly select a subset of items to potentially remove\n    if len(items) > 0:\n        num_to_remove = min(2, len(items))\n        remove_indices = np.random.choice(items, num_to_remove, replace=False)\n        new_solution[remove_indices] = 0\n\n    # Step 2: Randomly select a subset of non-items to potentially add\n    if len(non_items) > 0:\n        num_to_add = min(2, len(non_items))\n        add_indices = np.random.choice(non_items, num_to_add, replace=False)\n\n        # Check feasibility before adding\n        current_weight = np.sum(weight_lst * new_solution)\n        for idx in add_indices:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 3: Probabilistic flip to introduce diversity\n    for i in range(len(new_solution)):\n        if np.random.rand() < 0.1:  # 10% chance to flip each item\n            if new_solution[i] == 1:\n                if np.sum(weight_lst * new_solution) - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n            else:\n                if np.sum(weight_lst * new_solution) + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.31077222595507387,
            4.487820714712143
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def score(solution_obj):\n        total_weight = np.sum(weight_lst * solution_obj[0])\n        return (solution_obj[1][0] + solution_obj[1][1]) / (1 + total_weight)\n\n    scored_solutions = [(score(sol), sol) for sol in archive]\n    scored_solutions.sort(key=lambda x: -x[0])\n    selected_solution = scored_solutions[0][1][0].copy()\n\n    # Generate a neighbor using hybrid local search\n    new_solution = selected_solution.copy()\n    items = np.where(new_solution == 1)[0]\n    non_items = np.where(new_solution == 0)[0]\n\n    # Step 1: Randomly select a subset of items to potentially remove\n    if len(items) > 0:\n        num_to_remove = min(2, len(items))\n        remove_indices = np.random.choice(items, num_to_remove, replace=False)\n        new_solution[remove_indices] = 0\n\n    # Step 2: Randomly select a subset of non-items to potentially add\n    if len(non_items) > 0:\n        num_to_add = min(2, len(non_items))\n        add_indices = np.random.choice(non_items, num_to_add, replace=False)\n\n        # Check feasibility before adding\n        current_weight = np.sum(weight_lst * new_solution)\n        for idx in add_indices:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 3: Probabilistic flip to introduce diversity\n    for i in range(len(new_solution)):\n        if np.random.rand() < 0.1:  # 10% chance to flip each item\n            if new_solution[i] == 1:\n                if np.sum(weight_lst * new_solution) - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n            else:\n                if np.sum(weight_lst * new_solution) + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 88,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective evolutionary algorithm with a biased random walk heuristic, where solutions are selected based on their dominance and diversity, and neighbors are generated by probabilistically flipping items with high marginal contributions to at least one objective, while ensuring feasibility through weight constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., high diversity or low crowding distance)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Identify items with high marginal contributions to either objective\n    marginal_contributions = []\n    for i in range(len(weight_lst)):\n        if new_solution[i] == 1:\n            # If item is included, consider removing it\n            marginal_contributions.append((-weight_lst[i], i))\n        elif total_weight + weight_lst[i] <= capacity:\n            # If item is excluded and can be added, consider adding it\n            marginal_contributions.append((weight_lst[i] * (value1_lst[i] + value2_lst[i]), i))\n\n    if not marginal_contributions:\n        return new_solution\n\n    # Sort items by marginal contribution (descending)\n    marginal_contributions.sort(reverse=True, key=lambda x: x[0])\n\n    # Select top candidates for flipping\n    top_candidates = [idx for _, idx in marginal_contributions[:max(1, len(marginal_contributions) // 3)]]\n\n    # Randomly select one candidate to flip\n    if top_candidates:\n        flip_idx = np.random.choice(top_candidates)\n        new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8159534275509436,
            2.6786299645900726
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., high diversity or low crowding distance)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Identify items with high marginal contributions to either objective\n    marginal_contributions = []\n    for i in range(len(weight_lst)):\n        if new_solution[i] == 1:\n            # If item is included, consider removing it\n            marginal_contributions.append((-weight_lst[i], i))\n        elif total_weight + weight_lst[i] <= capacity:\n            # If item is excluded and can be added, consider adding it\n            marginal_contributions.append((weight_lst[i] * (value1_lst[i] + value2_lst[i]), i))\n\n    if not marginal_contributions:\n        return new_solution\n\n    # Sort items by marginal contribution (descending)\n    marginal_contributions.sort(reverse=True, key=lambda x: x[0])\n\n    # Select top candidates for flipping\n    top_candidates = [idx for _, idx in marginal_contributions[:max(1, len(marginal_contributions) // 3)]]\n\n    # Randomly select one candidate to flip\n    if top_candidates:\n        flip_idx = np.random.choice(top_candidates)\n        new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 89,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_objectives = np.array([(obj[0] / max(value1_lst), obj[1] / max(value2_lst)) for _, obj in archive])\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor by flipping a random subset of items, ensuring feasibility\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    max_flips = min(5, len(new_solution) // 2)  # Limit the number of flips to avoid excessive changes\n    flip_indices = np.random.choice(len(new_solution), size=max_flips, replace=False)\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Try to remove the item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.31526281569337433,
            6.799777179956436
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_objectives = np.array([(obj[0] / max(value1_lst), obj[1] / max(value2_lst)) for _, obj in archive])\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor by flipping a random subset of items, ensuring feasibility\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    max_flips = min(5, len(new_solution) // 2)  # Limit the number of flips to avoid excessive changes\n    flip_indices = np.random.choice(len(new_solution), size=max_flips, replace=False)\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Try to remove the item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 90,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / np.max(objectives, axis=0)\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[base_solution == 1])\n    remaining_capacity = capacity - total_weight\n\n    # Calculate marginal contributions for each item\n    marginal_value1 = value1_lst / (weight_lst + 1e-6)\n    marginal_value2 = value2_lst / (weight_lst + 1e-6)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Flip items with high marginal contribution and feasible weight\n    for i in np.argsort(combined_marginal)[::-1]:\n        if (base_solution[i] == 0 and weight_lst[i] <= remaining_capacity) or (base_solution[i] == 1):\n            new_solution[i] = 1 - new_solution[i]\n            if base_solution[i] == 0:\n                remaining_capacity -= weight_lst[i]\n            else:\n                remaining_capacity += weight_lst[i]\n            break  # Flip only one item to ensure feasibility\n\n    return new_solution\n\n",
        "score": [
            -0.8444864931693924,
            1.563860535621643
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / np.max(objectives, axis=0)\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[base_solution == 1])\n    remaining_capacity = capacity - total_weight\n\n    # Calculate marginal contributions for each item\n    marginal_value1 = value1_lst / (weight_lst + 1e-6)\n    marginal_value2 = value2_lst / (weight_lst + 1e-6)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Flip items with high marginal contribution and feasible weight\n    for i in np.argsort(combined_marginal)[::-1]:\n        if (base_solution[i] == 0 and weight_lst[i] <= remaining_capacity) or (base_solution[i] == 1):\n            new_solution[i] = 1 - new_solution[i]\n            if base_solution[i] == 0:\n                remaining_capacity -= weight_lst[i]\n            else:\n                remaining_capacity += weight_lst[i]\n            break  # Flip only one item to ensure feasibility\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 91,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a promising solution from the archive and applies a combination of adaptive item swaps, critical item replacements, and dynamic neighborhood exploration to generate high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + i) for i in range(len(archive))], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate a neighbor using a hybrid local search approach\n    new_solution = base_solution.copy()\n\n    # Step 1: Adaptive Item Swap\n    if random.random() < 0.5:  # 50% chance for swap\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Select items to swap based on value-to-weight ratio\n            in_item = random.choice(in_items)\n            out_item = random.choice(out_items)\n\n            # Check if swap is feasible\n            delta_weight = weight_lst[out_item] - weight_lst[in_item]\n            if current_weight + delta_weight <= capacity:\n                new_solution[in_item] = 0\n                new_solution[out_item] = 1\n\n    # Step 2: Critical Item Replacement\n    else:\n        # Identify critical items (those with high value but low weight)\n        critical_items = np.argsort(value1_lst / (weight_lst + 1e-6))[-min(5, len(weight_lst)):]\n\n        for item in critical_items:\n            if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n                # Add critical item if space allows\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                break\n            elif new_solution[item] == 1:\n                # Optionally remove critical item if it's not beneficial\n                if random.random() < 0.3:  # 30% chance to remove\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n                    break\n\n    # Step 3: Dynamic Neighborhood Exploration\n    # Randomly flip a small number of items to explore neighborhood\n    num_flips = min(3, len(weight_lst))\n    flip_indices = random.sample(range(len(weight_lst)), num_flips)\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.41817997433750603,
            1.3940123617649078
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + i) for i in range(len(archive))], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate a neighbor using a hybrid local search approach\n    new_solution = base_solution.copy()\n\n    # Step 1: Adaptive Item Swap\n    if random.random() < 0.5:  # 50% chance for swap\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Select items to swap based on value-to-weight ratio\n            in_item = random.choice(in_items)\n            out_item = random.choice(out_items)\n\n            # Check if swap is feasible\n            delta_weight = weight_lst[out_item] - weight_lst[in_item]\n            if current_weight + delta_weight <= capacity:\n                new_solution[in_item] = 0\n                new_solution[out_item] = 1\n\n    # Step 2: Critical Item Replacement\n    else:\n        # Identify critical items (those with high value but low weight)\n        critical_items = np.argsort(value1_lst / (weight_lst + 1e-6))[-min(5, len(weight_lst)):]\n\n        for item in critical_items:\n            if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n                # Add critical item if space allows\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                break\n            elif new_solution[item] == 1:\n                # Optionally remove critical item if it's not beneficial\n                if random.random() < 0.3:  # 30% chance to remove\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n                    break\n\n    # Step 3: Dynamic Neighborhood Exploration\n    # Randomly flip a small number of items to explore neighborhood\n    num_flips = min(3, len(weight_lst))\n    flip_indices = random.sample(range(len(weight_lst)), num_flips)\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 92,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a promising solution from the archive, then applies a multi-phase perturbation strategy combining item swaps, weighted random flips, and adaptive neighborhood exploration to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = random.choice(archive)\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and potential items to flip\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    available_items = np.where(new_solution == 0)[0]\n    included_items = np.where(new_solution == 1)[0]\n\n    # Phase 1: Random flip of items (with weight-based probability)\n    if len(available_items) > 0 and len(included_items) > 0:\n        # Flip a random item from available items if it fits\n        random_item = random.choice(available_items)\n        if current_weight + weight_lst[random_item] <= capacity:\n            new_solution[random_item] = 1\n            current_weight += weight_lst[random_item]\n\n    # Phase 2: Swap between included and excluded items (if feasible)\n    if len(included_items) > 1:\n        # Select two items: one to remove and one to add\n        item_to_remove = random.choice(included_items)\n        new_weight = current_weight - weight_lst[item_to_remove]\n        if len(available_items) > 0:\n            item_to_add = random.choice(available_items)\n            if new_weight + weight_lst[item_to_add] <= capacity:\n                new_solution[item_to_remove] = 0\n                new_solution[item_to_add] = 1\n\n    # Phase 3: Weighted random flip (higher chance for items with higher normalized value)\n    if len(available_items) > 0:\n        # Calculate normalized value scores for available items\n        value_scores = (value1_lst[available_items] + value2_lst[available_items]) / (weight_lst[available_items] + 1e-6)\n        if np.sum(value_scores) > 0:\n            probs = value_scores / np.sum(value_scores)\n            item_to_flip = np.random.choice(available_items, p=probs)\n            if current_weight + weight_lst[item_to_flip] <= capacity:\n                new_solution[item_to_flip] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.33974537157612217,
            4.536463767290115
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = random.choice(archive)\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and potential items to flip\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    available_items = np.where(new_solution == 0)[0]\n    included_items = np.where(new_solution == 1)[0]\n\n    # Phase 1: Random flip of items (with weight-based probability)\n    if len(available_items) > 0 and len(included_items) > 0:\n        # Flip a random item from available items if it fits\n        random_item = random.choice(available_items)\n        if current_weight + weight_lst[random_item] <= capacity:\n            new_solution[random_item] = 1\n            current_weight += weight_lst[random_item]\n\n    # Phase 2: Swap between included and excluded items (if feasible)\n    if len(included_items) > 1:\n        # Select two items: one to remove and one to add\n        item_to_remove = random.choice(included_items)\n        new_weight = current_weight - weight_lst[item_to_remove]\n        if len(available_items) > 0:\n            item_to_add = random.choice(available_items)\n            if new_weight + weight_lst[item_to_add] <= capacity:\n                new_solution[item_to_remove] = 0\n                new_solution[item_to_add] = 1\n\n    # Phase 3: Weighted random flip (higher chance for items with higher normalized value)\n    if len(available_items) > 0:\n        # Calculate normalized value scores for available items\n        value_scores = (value1_lst[available_items] + value2_lst[available_items]) / (weight_lst[available_items] + 1e-6)\n        if np.sum(value_scores) > 0:\n            probs = value_scores / np.sum(value_scores)\n            item_to_flip = np.random.choice(available_items, p=probs)\n            if current_weight + weight_lst[item_to_flip] <= capacity:\n                new_solution[item_to_flip] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 93,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: combine item swaps and greedy selection\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly select a subset of items to consider for swaps\n    candidate_indices = np.where(base_solution == 1)[0]\n    if len(candidate_indices) > 0:\n        swap_idx = np.random.choice(candidate_indices)\n        new_solution[swap_idx] = 0  # Remove one item\n\n    # Step 2: Greedily add items that improve at least one objective\n    remaining_indices = np.where(new_solution == 0)[0]\n    np.random.shuffle(remaining_indices)\n\n    for idx in remaining_indices:\n        if current_weight + weight_lst[idx] <= capacity:\n            # Check if adding this item improves at least one objective\n            if (value1_lst[idx] > 0) or (value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5240447547131248,
            1.7216720581054688
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: combine item swaps and greedy selection\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly select a subset of items to consider for swaps\n    candidate_indices = np.where(base_solution == 1)[0]\n    if len(candidate_indices) > 0:\n        swap_idx = np.random.choice(candidate_indices)\n        new_solution[swap_idx] = 0  # Remove one item\n\n    # Step 2: Greedily add items that improve at least one objective\n    remaining_indices = np.where(new_solution == 0)[0]\n    np.random.shuffle(remaining_indices)\n\n    for idx in remaining_indices:\n        if current_weight + weight_lst[idx] <= capacity:\n            # Check if adding this item improves at least one objective\n            if (value1_lst[idx] > 0) or (value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 94,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive by prioritizing those with high objective values and low weights, then applies a hybrid local search strategy combining adaptive bit flipping and guided item swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[(obj1 + obj2) / (1 + np.sum(weight_lst * sol)) for sol, (obj1, obj2) in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: adaptive bit flipping with guided swaps\n    new_solution = base_solution.copy()\n\n    # Step 1: Adaptive bit flipping (flip items with high value-to-weight ratio)\n    value_to_weight1 = value1_lst / (weight_lst + 1e-6)\n    value_to_weight2 = value2_lst / (weight_lst + 1e-6)\n    combined_ratio = value_to_weight1 + value_to_weight2\n\n    # Identify items to potentially flip\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        flip_idx = random.choice(flip_candidates)\n        if current_weight - weight_lst[flip_idx] <= capacity:\n            new_solution[flip_idx] = 0\n            current_weight -= weight_lst[flip_idx]\n\n    # Step 2: Guided item swapping (add items with high combined ratio)\n    add_candidates = np.where(new_solution == 0)[0]\n    add_candidates = add_candidates[weight_lst[add_candidates] <= (capacity - current_weight)]\n\n    if len(add_candidates) > 0:\n        # Select top 5% of candidates by combined ratio\n        top_n = max(1, len(add_candidates) // 20)\n        top_indices = np.argpartition(combined_ratio[add_candidates], -top_n)[-top_n:]\n        selected_add = random.choice(add_candidates[top_indices])\n        new_solution[selected_add] = 1\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove random items until feasible\n        while total_weight > capacity:\n            remove_candidates = np.where(new_solution == 1)[0]\n            if len(remove_candidates) == 0:\n                break\n            remove_idx = random.choice(remove_candidates)\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.6026002347434005,
            9.27324441075325
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[(obj1 + obj2) / (1 + np.sum(weight_lst * sol)) for sol, (obj1, obj2) in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: adaptive bit flipping with guided swaps\n    new_solution = base_solution.copy()\n\n    # Step 1: Adaptive bit flipping (flip items with high value-to-weight ratio)\n    value_to_weight1 = value1_lst / (weight_lst + 1e-6)\n    value_to_weight2 = value2_lst / (weight_lst + 1e-6)\n    combined_ratio = value_to_weight1 + value_to_weight2\n\n    # Identify items to potentially flip\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        flip_idx = random.choice(flip_candidates)\n        if current_weight - weight_lst[flip_idx] <= capacity:\n            new_solution[flip_idx] = 0\n            current_weight -= weight_lst[flip_idx]\n\n    # Step 2: Guided item swapping (add items with high combined ratio)\n    add_candidates = np.where(new_solution == 0)[0]\n    add_candidates = add_candidates[weight_lst[add_candidates] <= (capacity - current_weight)]\n\n    if len(add_candidates) > 0:\n        # Select top 5% of candidates by combined ratio\n        top_n = max(1, len(add_candidates) // 20)\n        top_indices = np.argpartition(combined_ratio[add_candidates], -top_n)[-top_n:]\n        selected_add = random.choice(add_candidates[top_indices])\n        new_solution[selected_add] = 1\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove random items until feasible\n        while total_weight > capacity:\n            remove_candidates = np.where(new_solution == 1)[0]\n            if len(remove_candidates) == 0:\n                break\n            remove_idx = random.choice(remove_candidates)\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 95,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive by prioritizing those with high potential for local improvement, then applies a hybrid local search operator that combines item swaps and adaptive perturbations to explore the solution space while ensuring feasibility, and finally evaluates the neighbor to ensure dominance or non-dominance before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions with high potential for improvement (e.g., those not dominated by others)\n    selected_solution, _ = max(archive, key=lambda x: np.sum(x[0] * value1_lst) + np.sum(x[0] * value2_lst))\n    base_solution = selected_solution.copy()\n\n    # Step 2: Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n    current_weight = np.sum(new_solution * weight_lst)\n\n    # Randomly select a subset of items to perturb\n    perturb_indices = np.random.choice(len(weight_lst), size=min(3, len(weight_lst)), replace=False)\n\n    for idx in perturb_indices:\n        # Attempt to swap items or flip bits with feasibility checks\n        if new_solution[idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 3: Ensure the solution is feasible and non-dominated (if possible)\n    # If the solution is infeasible, repair it by removing items with the smallest ratio of (value1 + value2)/weight\n    while current_weight > capacity:\n        # Calculate the ratio for each item in the solution\n        ratios = (value1_lst + value2_lst) / weight_lst\n        # Find the item with the smallest ratio in the solution\n        candidate_indices = np.where(new_solution == 1)[0]\n        if len(candidate_indices) == 0:\n            break\n        min_ratio_idx = candidate_indices[np.argmin(ratios[candidate_indices])]\n        # Remove the item\n        new_solution[min_ratio_idx] = 0\n        current_weight -= weight_lst[min_ratio_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.2820540819515765,
            8.068090945482254
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions with high potential for improvement (e.g., those not dominated by others)\n    selected_solution, _ = max(archive, key=lambda x: np.sum(x[0] * value1_lst) + np.sum(x[0] * value2_lst))\n    base_solution = selected_solution.copy()\n\n    # Step 2: Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n    current_weight = np.sum(new_solution * weight_lst)\n\n    # Randomly select a subset of items to perturb\n    perturb_indices = np.random.choice(len(weight_lst), size=min(3, len(weight_lst)), replace=False)\n\n    for idx in perturb_indices:\n        # Attempt to swap items or flip bits with feasibility checks\n        if new_solution[idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 3: Ensure the solution is feasible and non-dominated (if possible)\n    # If the solution is infeasible, repair it by removing items with the smallest ratio of (value1 + value2)/weight\n    while current_weight > capacity:\n        # Calculate the ratio for each item in the solution\n        ratios = (value1_lst + value2_lst) / weight_lst\n        # Find the item with the smallest ratio in the solution\n        candidate_indices = np.where(new_solution == 1)[0]\n        if len(candidate_indices) == 0:\n            break\n        min_ratio_idx = candidate_indices[np.argmin(ratios[candidate_indices])]\n        # Remove the item\n        new_solution[min_ratio_idx] = 0\n        current_weight -= weight_lst[min_ratio_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 96,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(sol * weight_lst)\n        if total_weight < capacity:\n            candidates.append((sol, obj))\n\n    if not candidates:\n        return archive[0][0].copy()\n\n    # Intelligently select a candidate solution (e.g., one with high value but not fully packed)\n    selected_sol, selected_obj = max(candidates, key=lambda x: (x[1][0] + x[1][1]) / (np.sum(x[0] * weight_lst) + 1e-6))\n\n    new_solution = selected_sol.copy()\n\n    # Apply a hybrid local search: flip items with high marginal value-to-weight ratios\n    marginal_ratio1 = value1_lst / (weight_lst + 1e-6)\n    marginal_ratio2 = value2_lst / (weight_lst + 1e-6)\n    combined_ratio = marginal_ratio1 + marginal_ratio2\n\n    # Identify items that are not in the solution but could improve both objectives\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        # Select an item with high combined marginal ratio\n        best_item = candidate_items[np.argmax(combined_ratio[candidate_items])]\n        # Check if adding this item keeps the solution feasible\n        if np.sum(new_solution * weight_lst) + weight_lst[best_item] <= capacity:\n            new_solution[best_item] = 1\n\n    # Identify items that are in the solution and could be removed to free up capacity\n    candidate_items = np.where(new_solution == 1)[0]\n    if len(candidate_items) > 0:\n        # Select an item with low combined marginal ratio\n        worst_item = candidate_items[np.argmin(combined_ratio[candidate_items])]\n        # Check if removing this item keeps the solution feasible (always true for removal)\n        new_solution[worst_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.8302010489685331,
            4.595915049314499
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(sol * weight_lst)\n        if total_weight < capacity:\n            candidates.append((sol, obj))\n\n    if not candidates:\n        return archive[0][0].copy()\n\n    # Intelligently select a candidate solution (e.g., one with high value but not fully packed)\n    selected_sol, selected_obj = max(candidates, key=lambda x: (x[1][0] + x[1][1]) / (np.sum(x[0] * weight_lst) + 1e-6))\n\n    new_solution = selected_sol.copy()\n\n    # Apply a hybrid local search: flip items with high marginal value-to-weight ratios\n    marginal_ratio1 = value1_lst / (weight_lst + 1e-6)\n    marginal_ratio2 = value2_lst / (weight_lst + 1e-6)\n    combined_ratio = marginal_ratio1 + marginal_ratio2\n\n    # Identify items that are not in the solution but could improve both objectives\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        # Select an item with high combined marginal ratio\n        best_item = candidate_items[np.argmax(combined_ratio[candidate_items])]\n        # Check if adding this item keeps the solution feasible\n        if np.sum(new_solution * weight_lst) + weight_lst[best_item] <= capacity:\n            new_solution[best_item] = 1\n\n    # Identify items that are in the solution and could be removed to free up capacity\n    candidate_items = np.where(new_solution == 1)[0]\n    if len(candidate_items) > 0:\n        # Select an item with low combined marginal ratio\n        worst_item = candidate_items[np.argmin(combined_ratio[candidate_items])]\n        # Check if removing this item keeps the solution feasible (always true for removal)\n        new_solution[worst_item] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 97,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_scores = []\n    for sol, obj in archive:\n        normalized_obj = (obj[0] / np.max(value1_lst), obj[1] / np.max(value2_lst))\n        normalized_scores.append(np.sum(normalized_obj))\n\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor solution using a hybrid local search strategy\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst * base_solution)\n\n    # Randomly select a subset of items to flip (add or remove)\n    flip_indices = np.random.choice(len(base_solution), size=min(3, len(base_solution)), replace=False)\n\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Try to remove the item if feasible\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            # Try to add the item if feasible\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    # Additional local search: swap items to improve both objectives\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            for j in range(len(new_solution)):\n                if new_solution[j] == 0 and weight_lst[j] <= weight_lst[i] + (capacity - total_weight):\n                    # Check if swapping improves at least one objective\n                    delta_value1 = value1_lst[j] - value1_lst[i]\n                    delta_value2 = value2_lst[j] - value2_lst[i]\n                    if delta_value1 > 0 or delta_value2 > 0:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.4616444948802235,
            6.830581456422806
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_scores = []\n    for sol, obj in archive:\n        normalized_obj = (obj[0] / np.max(value1_lst), obj[1] / np.max(value2_lst))\n        normalized_scores.append(np.sum(normalized_obj))\n\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor solution using a hybrid local search strategy\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst * base_solution)\n\n    # Randomly select a subset of items to flip (add or remove)\n    flip_indices = np.random.choice(len(base_solution), size=min(3, len(base_solution)), replace=False)\n\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Try to remove the item if feasible\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            # Try to add the item if feasible\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    # Additional local search: swap items to improve both objectives\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            for j in range(len(new_solution)):\n                if new_solution[j] == 0 and weight_lst[j] <= weight_lst[i] + (capacity - total_weight):\n                    # Check if swapping improves at least one objective\n                    delta_value1 = value1_lst[j] - value1_lst[i]\n                    delta_value2 = value2_lst[j] - value2_lst[i]\n                    if delta_value1 > 0 or delta_value2 > 0:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 98,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[0]))[0].copy()\n\n    # Identify items that could be swapped or flipped to improve objectives\n    current_weight = np.sum(weight_lst[selected_solution == 1])\n    current_value1 = np.sum(value1_lst[selected_solution == 1])\n    current_value2 = np.sum(value2_lst[selected_solution == 1])\n\n    # Find items that are not in the solution but could be added without exceeding capacity\n    candidate_items = np.where(selected_solution == 0)[0]\n    feasible_additions = [i for i in candidate_items if current_weight + weight_lst[i] <= capacity]\n\n    # Find items that are in the solution and could be removed\n    candidate_removals = np.where(selected_solution == 1)[0]\n\n    # Apply a hybrid local search: try adding, removing, or swapping items\n    new_solution = selected_solution.copy()\n\n    if feasible_additions:\n        # Add a random feasible item\n        add_item = np.random.choice(feasible_additions)\n        new_solution[add_item] = 1\n\n    if candidate_removals.size > 0:\n        # Remove a random item\n        remove_item = np.random.choice(candidate_removals)\n        new_solution[remove_item] = 0\n\n    # Ensure feasibility\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        # If not feasible, remove a random item until feasible\n        remove_item = np.random.choice(np.where(new_solution == 1)[0])\n        new_solution[remove_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.9021893536988417,
            5.1125780045986176
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[0]))[0].copy()\n\n    # Identify items that could be swapped or flipped to improve objectives\n    current_weight = np.sum(weight_lst[selected_solution == 1])\n    current_value1 = np.sum(value1_lst[selected_solution == 1])\n    current_value2 = np.sum(value2_lst[selected_solution == 1])\n\n    # Find items that are not in the solution but could be added without exceeding capacity\n    candidate_items = np.where(selected_solution == 0)[0]\n    feasible_additions = [i for i in candidate_items if current_weight + weight_lst[i] <= capacity]\n\n    # Find items that are in the solution and could be removed\n    candidate_removals = np.where(selected_solution == 1)[0]\n\n    # Apply a hybrid local search: try adding, removing, or swapping items\n    new_solution = selected_solution.copy()\n\n    if feasible_additions:\n        # Add a random feasible item\n        add_item = np.random.choice(feasible_additions)\n        new_solution[add_item] = 1\n\n    if candidate_removals.size > 0:\n        # Remove a random item\n        remove_item = np.random.choice(candidate_removals)\n        new_solution[remove_item] = 0\n\n    # Ensure feasibility\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        # If not feasible, remove a random item until feasible\n        remove_item = np.random.choice(np.where(new_solution == 1)[0])\n        new_solution[remove_item] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 99,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by evaluating the ratio of marginal gains in both objectives, then applies a hybrid local search that combines random swaps with objective-aware perturbations to generate a feasible neighbor solution while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_v1, current_v2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: random swaps with objective-aware perturbations\n    for _ in range(10):  # Number of perturbation attempts\n        # Randomly select an item to flip\n        item_idx = random.randint(0, len(weight_lst) - 1)\n\n        if new_solution[item_idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[item_idx] <= capacity:\n                new_solution[item_idx] = 0\n                current_weight -= weight_lst[item_idx]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[item_idx] <= capacity:\n                new_solution[item_idx] = 1\n                current_weight += weight_lst[item_idx]\n\n        # Objective-aware perturbation: bias towards items with high marginal gains\n        if random.random() < 0.3:  # 30% chance of objective-aware move\n            # Calculate marginal gains for all items\n            marginal_gains = []\n            for i in range(len(weight_lst)):\n                if new_solution[i] == 1:\n                    marginal_gain = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n                else:\n                    marginal_gain = -(value1_lst[i] + value2_lst[i]) / weight_lst[i] if current_weight + weight_lst[i] <= capacity else -np.inf\n                marginal_gains.append(marginal_gain)\n\n            # Select item with highest marginal gain\n            best_item = np.argmax(marginal_gains)\n            if marginal_gains[best_item] > 0:\n                if new_solution[best_item] == 0 and current_weight + weight_lst[best_item] <= capacity:\n                    new_solution[best_item] = 1\n                    current_weight += weight_lst[best_item]\n                elif new_solution[best_item] == 1:\n                    new_solution[best_item] = 0\n                    current_weight -= weight_lst[best_item]\n\n    return new_solution\n\n",
        "score": [
            -0.3456765264363941,
            4.302493780851364
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_v1, current_v2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: random swaps with objective-aware perturbations\n    for _ in range(10):  # Number of perturbation attempts\n        # Randomly select an item to flip\n        item_idx = random.randint(0, len(weight_lst) - 1)\n\n        if new_solution[item_idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[item_idx] <= capacity:\n                new_solution[item_idx] = 0\n                current_weight -= weight_lst[item_idx]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[item_idx] <= capacity:\n                new_solution[item_idx] = 1\n                current_weight += weight_lst[item_idx]\n\n        # Objective-aware perturbation: bias towards items with high marginal gains\n        if random.random() < 0.3:  # 30% chance of objective-aware move\n            # Calculate marginal gains for all items\n            marginal_gains = []\n            for i in range(len(weight_lst)):\n                if new_solution[i] == 1:\n                    marginal_gain = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n                else:\n                    marginal_gain = -(value1_lst[i] + value2_lst[i]) / weight_lst[i] if current_weight + weight_lst[i] <= capacity else -np.inf\n                marginal_gains.append(marginal_gain)\n\n            # Select item with highest marginal gain\n            best_item = np.argmax(marginal_gains)\n            if marginal_gains[best_item] > 0:\n                if new_solution[best_item] == 0 and current_weight + weight_lst[best_item] <= capacity:\n                    new_solution[best_item] = 1\n                    current_weight += weight_lst[best_item]\n                elif new_solution[best_item] == 1:\n                    new_solution[best_item] = 0\n                    current_weight -= weight_lst[best_item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 100,
        "algorithm": "{A novel hybrid local search algorithm that intelligently combines random item swaps with guided objective-based exploration to generate high-quality neighbors by dynamically balancing the trade-off between the two objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution: prioritize those with high total value in either objective\n    archive_solutions = [s for s, _ in archive]\n    archive_values = np.array([v for _, v in archive])\n\n    # Normalize objectives for selection\n    max_values = archive_values.max(axis=0)\n    if np.any(max_values == 0):\n        normalized_values = archive_values\n    else:\n        normalized_values = archive_values / max_values\n\n    # Select a solution with high combined normalized value\n    combined_scores = normalized_values.sum(axis=1)\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid approach: random swaps + guided objective exploration\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Determine which objective to prioritize for improvement\n    if np.random.rand() < 0.5:\n        # Prioritize value1 improvement\n        candidate_items = np.where(new_solution == 0)[0]\n        np.random.shuffle(candidate_items)\n        for item in candidate_items:\n            if current_weight + weight_lst[item] <= capacity:\n                # Check if adding this item improves value1 without sacrificing too much value2\n                new_value1 = current_value1 + value1_lst[item]\n                new_value2 = current_value2 + value2_lst[item]\n                if new_value1 > current_value1 and new_value2 >= current_value2:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n                    break\n    else:\n        # Prioritize value2 improvement\n        candidate_items = np.where(new_solution == 0)[0]\n        np.random.shuffle(candidate_items)\n        for item in candidate_items:\n            if current_weight + weight_lst[item] <= capacity:\n                # Check if adding this item improves value2 without sacrificing too much value1\n                new_value1 = current_value1 + value1_lst[item]\n                new_value2 = current_value2 + value2_lst[item]\n                if new_value2 > current_value2 and new_value1 >= current_value1:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n                    break\n\n    # Randomly remove items to create diversity and maintain feasibility\n    items_in_solution = np.where(new_solution == 1)[0]\n    if len(items_in_solution) > 1:\n        np.random.shuffle(items_in_solution)\n        for item in items_in_solution[:max(1, len(items_in_solution) // 4)]:\n            if current_weight - weight_lst[item] >= 0:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8971498129742512,
            2.092454880475998
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution: prioritize those with high total value in either objective\n    archive_solutions = [s for s, _ in archive]\n    archive_values = np.array([v for _, v in archive])\n\n    # Normalize objectives for selection\n    max_values = archive_values.max(axis=0)\n    if np.any(max_values == 0):\n        normalized_values = archive_values\n    else:\n        normalized_values = archive_values / max_values\n\n    # Select a solution with high combined normalized value\n    combined_scores = normalized_values.sum(axis=1)\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid approach: random swaps + guided objective exploration\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Determine which objective to prioritize for improvement\n    if np.random.rand() < 0.5:\n        # Prioritize value1 improvement\n        candidate_items = np.where(new_solution == 0)[0]\n        np.random.shuffle(candidate_items)\n        for item in candidate_items:\n            if current_weight + weight_lst[item] <= capacity:\n                # Check if adding this item improves value1 without sacrificing too much value2\n                new_value1 = current_value1 + value1_lst[item]\n                new_value2 = current_value2 + value2_lst[item]\n                if new_value1 > current_value1 and new_value2 >= current_value2:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n                    break\n    else:\n        # Prioritize value2 improvement\n        candidate_items = np.where(new_solution == 0)[0]\n        np.random.shuffle(candidate_items)\n        for item in candidate_items:\n            if current_weight + weight_lst[item] <= capacity:\n                # Check if adding this item improves value2 without sacrificing too much value1\n                new_value1 = current_value1 + value1_lst[item]\n                new_value2 = current_value2 + value2_lst[item]\n                if new_value2 > current_value2 and new_value1 >= current_value1:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n                    break\n\n    # Randomly remove items to create diversity and maintain feasibility\n    items_in_solution = np.where(new_solution == 1)[0]\n    if len(items_in_solution) > 1:\n        np.random.shuffle(items_in_solution)\n        for item in items_in_solution[:max(1, len(items_in_solution) // 4)]:\n            if current_weight - weight_lst[item] >= 0:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 101,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high objective values and low crowding distance, then applies a hybrid local search combining item swapping and path relinking to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros(len(weight_lst), dtype=int)\n\n    # Select a promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly select a subset of items to flip (with probability based on their value)\n    flip_probs = (value1_lst + value2_lst) / (value1_lst.max() + value2_lst.max() + 1e-10)\n    flip_mask = np.random.rand(n_items) < flip_probs\n    candidate_items = np.where(flip_mask)[0]\n\n    # Step 2: Try to flip items while maintaining feasibility\n    for item in candidate_items:\n        if new_solution[item] == 1:\n            new_solution[item] = 0\n            if np.dot(new_solution, weight_lst) <= capacity:\n                continue\n            else:\n                new_solution[item] = 1\n        else:\n            new_solution[item] = 1\n            if np.dot(new_solution, weight_lst) <= capacity:\n                continue\n            else:\n                new_solution[item] = 0\n\n    # Step 3: If no improvement, perform path relinking with another solution\n    if np.array_equal(new_solution, base_solution):\n        other_idx = np.random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        # Find differing items\n        diff_items = np.where(new_solution != other_solution)[0]\n\n        if len(diff_items) > 0:\n            # Randomly select a subset to flip\n            n_flip = min(3, len(diff_items))\n            flip_items = np.random.choice(diff_items, n_flip, replace=False)\n\n            for item in flip_items:\n                new_solution[item] = 1 - new_solution[item]\n                if np.dot(new_solution, weight_lst) > capacity:\n                    new_solution[item] = 1 - new_solution[item]\n\n    return new_solution\n\n",
        "score": [
            -0.37466842973480385,
            4.599390655755997
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros(len(weight_lst), dtype=int)\n\n    # Select a promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly select a subset of items to flip (with probability based on their value)\n    flip_probs = (value1_lst + value2_lst) / (value1_lst.max() + value2_lst.max() + 1e-10)\n    flip_mask = np.random.rand(n_items) < flip_probs\n    candidate_items = np.where(flip_mask)[0]\n\n    # Step 2: Try to flip items while maintaining feasibility\n    for item in candidate_items:\n        if new_solution[item] == 1:\n            new_solution[item] = 0\n            if np.dot(new_solution, weight_lst) <= capacity:\n                continue\n            else:\n                new_solution[item] = 1\n        else:\n            new_solution[item] = 1\n            if np.dot(new_solution, weight_lst) <= capacity:\n                continue\n            else:\n                new_solution[item] = 0\n\n    # Step 3: If no improvement, perform path relinking with another solution\n    if np.array_equal(new_solution, base_solution):\n        other_idx = np.random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        # Find differing items\n        diff_items = np.where(new_solution != other_solution)[0]\n\n        if len(diff_items) > 0:\n            # Randomly select a subset to flip\n            n_flip = min(3, len(diff_items))\n            flip_items = np.random.choice(diff_items, n_flip, replace=False)\n\n            for item in flip_items:\n                new_solution[item] = 1 - new_solution[item]\n                if np.dot(new_solution, weight_lst) > capacity:\n                    new_solution[item] = 1 - new_solution[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 102,
        "algorithm": "{This algorithm intelligently selects a solution from the archive by prioritizing those with high objective values and low weight utilization, then applies a hybrid local search combining randomized item swaps and marginal value-based flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution (highest sum of objectives, low weight utilization)\n    selected_idx = max(\n        range(len(archive)),\n        key=lambda i: archive[i][1][0] + archive[i][1][1] - 0.5 * np.sum(weight_lst * archive[i][0])\n    )\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomized swaps + marginal value flips\n    for _ in range(5):  # Number of attempts\n        # Random swap\n        if len(new_solution) >= 2:\n            i, j = random.sample(range(len(new_solution)), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Check feasibility\n        if np.sum(weight_lst * new_solution) <= capacity:\n            continue\n\n        # Marginal value flip: remove worst item if over capacity\n        current_weight = np.sum(weight_lst * new_solution)\n        if current_weight > capacity:\n            # Calculate marginal values for each objective\n            marginal1 = value1_lst * new_solution\n            marginal2 = value2_lst * new_solution\n            # Remove item with lowest combined marginal value\n            combined_marginal = marginal1 + marginal2\n            worst_item = np.argmax(combined_marginal)\n            if new_solution[worst_item] == 1:\n                new_solution[worst_item] = 0\n\n    # Ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Remove random item if still over capacity\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) == 0:\n            break\n        item_to_remove = random.choice(included_items)\n        new_solution[item_to_remove] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.5727704017425178,
            4.110081374645233
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution (highest sum of objectives, low weight utilization)\n    selected_idx = max(\n        range(len(archive)),\n        key=lambda i: archive[i][1][0] + archive[i][1][1] - 0.5 * np.sum(weight_lst * archive[i][0])\n    )\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomized swaps + marginal value flips\n    for _ in range(5):  # Number of attempts\n        # Random swap\n        if len(new_solution) >= 2:\n            i, j = random.sample(range(len(new_solution)), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Check feasibility\n        if np.sum(weight_lst * new_solution) <= capacity:\n            continue\n\n        # Marginal value flip: remove worst item if over capacity\n        current_weight = np.sum(weight_lst * new_solution)\n        if current_weight > capacity:\n            # Calculate marginal values for each objective\n            marginal1 = value1_lst * new_solution\n            marginal2 = value2_lst * new_solution\n            # Remove item with lowest combined marginal value\n            combined_marginal = marginal1 + marginal2\n            worst_item = np.argmax(combined_marginal)\n            if new_solution[worst_item] == 1:\n                new_solution[worst_item] = 0\n\n    # Ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Remove random item if still over capacity\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) == 0:\n            break\n        item_to_remove = random.choice(included_items)\n        new_solution[item_to_remove] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 103,
        "algorithm": "{The algorithm intelligently selects a solution from the archive with high potential for improvement by evaluating the diversity and dominance of solutions, then applies a hybrid local search combining item swapping and adaptive perturbation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution (intelligent random selection)\n    # Prioritize solutions with lower total weight to leave room for improvement\n    archive_sorted = sorted(archive, key=lambda x: np.sum(weight_lst[x[0] == 1]))\n    selected_idx = min(int(len(archive_sorted) * 0.3), len(archive_sorted) - 1)\n    selected_solution, _ = archive_sorted[selected_idx]\n    base_solution = selected_solution.copy()\n\n    # Step 2: Hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 2.1: Item swapping (swap in-out items with high marginal gains)\n    in_items = np.where(new_solution == 1)[0]\n    out_items = np.where(new_solution == 0)[0]\n\n    if len(in_items) > 0 and len(out_items) > 0:\n        # Calculate marginal gains for swapping\n        in_values1 = value1_lst[in_items]\n        in_values2 = value2_lst[in_items]\n        out_values1 = value1_lst[out_items]\n        out_values2 = value2_lst[out_items]\n\n        # Rank items by marginal gain (value per weight)\n        in_marginal_gain = (in_values1 + in_values2) / weight_lst[in_items]\n        out_marginal_gain = (out_values1 + out_values2) / weight_lst[out_items]\n\n        best_in_idx = np.argmax(in_marginal_gain)\n        best_out_idx = np.argmax(out_marginal_gain)\n\n        # Check if swap is feasible\n        if (current_weight - weight_lst[in_items[best_in_idx]] + weight_lst[out_items[best_out_idx]]) <= capacity:\n            new_solution[in_items[best_in_idx]] = 0\n            new_solution[out_items[best_out_idx]] = 1\n\n    # Step 2.2: Adaptive perturbation (flip items based on marginal gains)\n    if random.random() < 0.3:  # 30% chance of perturbation\n        candidate_items = np.where(new_solution == 1)[0]\n        if len(candidate_items) > 0:\n            # Flip items with lowest marginal gain\n            marginal_gain = (value1_lst[candidate_items] + value2_lst[candidate_items]) / weight_lst[candidate_items]\n            worst_item = candidate_items[np.argmin(marginal_gain)]\n\n            if (current_weight - weight_lst[worst_item]) <= capacity:\n                new_solution[worst_item] = 0\n\n    # Step 2.3: Ensure feasibility\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        # Remove items until feasible\n        excess_weight = current_weight - capacity\n        in_items = np.where(new_solution == 1)[0]\n        in_weights = weight_lst[in_items]\n        in_marginal_gain = (value1_lst[in_items] + value2_lst[in_items]) / in_weights\n\n        # Remove items with lowest marginal gain until feasible\n        for item_idx in np.argsort(in_marginal_gain):\n            if excess_weight <= 0:\n                break\n            new_solution[in_items[item_idx]] = 0\n            excess_weight -= in_weights[item_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7569550530913364,
            2.919756442308426
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution (intelligent random selection)\n    # Prioritize solutions with lower total weight to leave room for improvement\n    archive_sorted = sorted(archive, key=lambda x: np.sum(weight_lst[x[0] == 1]))\n    selected_idx = min(int(len(archive_sorted) * 0.3), len(archive_sorted) - 1)\n    selected_solution, _ = archive_sorted[selected_idx]\n    base_solution = selected_solution.copy()\n\n    # Step 2: Hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 2.1: Item swapping (swap in-out items with high marginal gains)\n    in_items = np.where(new_solution == 1)[0]\n    out_items = np.where(new_solution == 0)[0]\n\n    if len(in_items) > 0 and len(out_items) > 0:\n        # Calculate marginal gains for swapping\n        in_values1 = value1_lst[in_items]\n        in_values2 = value2_lst[in_items]\n        out_values1 = value1_lst[out_items]\n        out_values2 = value2_lst[out_items]\n\n        # Rank items by marginal gain (value per weight)\n        in_marginal_gain = (in_values1 + in_values2) / weight_lst[in_items]\n        out_marginal_gain = (out_values1 + out_values2) / weight_lst[out_items]\n\n        best_in_idx = np.argmax(in_marginal_gain)\n        best_out_idx = np.argmax(out_marginal_gain)\n\n        # Check if swap is feasible\n        if (current_weight - weight_lst[in_items[best_in_idx]] + weight_lst[out_items[best_out_idx]]) <= capacity:\n            new_solution[in_items[best_in_idx]] = 0\n            new_solution[out_items[best_out_idx]] = 1\n\n    # Step 2.2: Adaptive perturbation (flip items based on marginal gains)\n    if random.random() < 0.3:  # 30% chance of perturbation\n        candidate_items = np.where(new_solution == 1)[0]\n        if len(candidate_items) > 0:\n            # Flip items with lowest marginal gain\n            marginal_gain = (value1_lst[candidate_items] + value2_lst[candidate_items]) / weight_lst[candidate_items]\n            worst_item = candidate_items[np.argmin(marginal_gain)]\n\n            if (current_weight - weight_lst[worst_item]) <= capacity:\n                new_solution[worst_item] = 0\n\n    # Step 2.3: Ensure feasibility\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        # Remove items until feasible\n        excess_weight = current_weight - capacity\n        in_items = np.where(new_solution == 1)[0]\n        in_weights = weight_lst[in_items]\n        in_marginal_gain = (value1_lst[in_items] + value2_lst[in_items]) / in_weights\n\n        # Remove items with lowest marginal gain until feasible\n        for item_idx in np.argsort(in_marginal_gain):\n            if excess_weight <= 0:\n                break\n            new_solution[in_items[item_idx]] = 0\n            excess_weight -= in_weights[item_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 104,
        "algorithm": "{The algorithm intelligently selects a non-dominated solution from the archive based on the most crowded region in the objective space, then applies a hybrid local search operator that combines random swaps, guided by the marginal value ratios of the objectives, to generate a feasible neighbor solution while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution based on the most crowded region in the objective space\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) == 1:\n        selected_idx = 0\n    else:\n        # Compute crowding distance to identify the most crowded region\n        sorted_indices = np.argsort(objectives[:, 0])\n        objectives_sorted = objectives[sorted_indices]\n        crowding = np.zeros(len(objectives_sorted))\n        crowding[1:-1] = (objectives_sorted[2:, 0] - objectives_sorted[:-2, 0]) / (objectives_sorted[-1, 0] - objectives_sorted[0, 0])\n        selected_idx = np.argmax(crowding)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search operator\n    # Compute marginal value ratios for each item\n    marginal_ratios = (value1_lst / value2_lst) * (1 + 0.1 * np.random.randn(len(weight_lst)))  # Add noise for diversity\n\n    # Select items to flip based on marginal ratios and current solution\n    items = np.where(new_solution == 1)[0]\n    if len(items) > 0:\n        # Randomly select an item to flip\n        item_to_flip = random.choice(items)\n        new_solution[item_to_flip] = 0\n    else:\n        # If no items are selected, randomly select an item to add\n        items = np.where(new_solution == 0)[0]\n        if len(items) > 0:\n            item_to_flip = random.choice(items)\n            new_solution[item_to_flip] = 1\n\n    # Ensure feasibility by checking weight constraint\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # If over capacity, randomly remove items until feasible\n        while total_weight > capacity and np.sum(new_solution) > 0:\n            items_in = np.where(new_solution == 1)[0]\n            item_to_remove = random.choice(items_in)\n            new_solution[item_to_remove] = 0\n            total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # If still over capacity (e.g., single heavy item), revert to base solution\n    if np.sum(weight_lst[new_solution == 1]) > capacity:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9475741825899993,
            1.7888003289699554
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution based on the most crowded region in the objective space\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) == 1:\n        selected_idx = 0\n    else:\n        # Compute crowding distance to identify the most crowded region\n        sorted_indices = np.argsort(objectives[:, 0])\n        objectives_sorted = objectives[sorted_indices]\n        crowding = np.zeros(len(objectives_sorted))\n        crowding[1:-1] = (objectives_sorted[2:, 0] - objectives_sorted[:-2, 0]) / (objectives_sorted[-1, 0] - objectives_sorted[0, 0])\n        selected_idx = np.argmax(crowding)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search operator\n    # Compute marginal value ratios for each item\n    marginal_ratios = (value1_lst / value2_lst) * (1 + 0.1 * np.random.randn(len(weight_lst)))  # Add noise for diversity\n\n    # Select items to flip based on marginal ratios and current solution\n    items = np.where(new_solution == 1)[0]\n    if len(items) > 0:\n        # Randomly select an item to flip\n        item_to_flip = random.choice(items)\n        new_solution[item_to_flip] = 0\n    else:\n        # If no items are selected, randomly select an item to add\n        items = np.where(new_solution == 0)[0]\n        if len(items) > 0:\n            item_to_flip = random.choice(items)\n            new_solution[item_to_flip] = 1\n\n    # Ensure feasibility by checking weight constraint\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # If over capacity, randomly remove items until feasible\n        while total_weight > capacity and np.sum(new_solution) > 0:\n            items_in = np.where(new_solution == 1)[0]\n            item_to_remove = random.choice(items_in)\n            new_solution[item_to_remove] = 0\n            total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # If still over capacity (e.g., single heavy item), revert to base solution\n    if np.sum(weight_lst[new_solution == 1]) > capacity:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 105,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a hybrid of crowding distance and objective diversity, then applies a novel local search operator that combines item swapping and strategic flipping to generate a feasible neighbor solution with improved potential in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (prioritize solutions with high crowding distance and objective diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (base_val1, base_val2) = archive[selected_idx]\n\n    # Step 2: Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Strategy: Randomly select a subset of items to flip, with bias towards items that improve both objectives\n    flip_indices = np.random.choice(n_items, size=min(5, n_items), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            temp_solution = new_solution.copy()\n            temp_solution[idx] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                temp_val1 = np.sum(value1_lst[temp_solution == 1])\n                temp_val2 = np.sum(value2_lst[temp_solution == 1])\n                if (temp_val1 > base_val1 and temp_val2 > base_val2) or \\\n                   (temp_val1 > base_val1 and np.random.rand() < 0.3) or \\\n                   (temp_val2 > base_val2 and np.random.rand() < 0.3):\n                    new_solution = temp_solution\n                    base_val1, base_val2 = temp_val1, temp_val2\n        else:\n            # Try adding the item\n            temp_solution = new_solution.copy()\n            temp_solution[idx] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                temp_val1 = np.sum(value1_lst[temp_solution == 1])\n                temp_val2 = np.sum(value2_lst[temp_solution == 1])\n                if (temp_val1 > base_val1 and temp_val2 > base_val2) or \\\n                   (temp_val1 > base_val1 and np.random.rand() < 0.3) or \\\n                   (temp_val2 > base_val2 and np.random.rand() < 0.3):\n                    new_solution = temp_solution\n                    base_val1, base_val2 = temp_val1, temp_val2\n\n    # Additional strategy: Swap items between two positions if it improves both objectives\n    if n_items >= 2:\n        i, j = np.random.choice(n_items, size=2, replace=False)\n        if new_solution[i] != new_solution[j]:\n            temp_solution = new_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                temp_val1 = np.sum(value1_lst[temp_solution == 1])\n                temp_val2 = np.sum(value2_lst[temp_solution == 1])\n                if (temp_val1 > base_val1 and temp_val2 > base_val2) or \\\n                   (temp_val1 > base_val1 and np.random.rand() < 0.3) or \\\n                   (temp_val2 > base_val2 and np.random.rand() < 0.3):\n                    new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.29359757091001837,
            7.612877309322357
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (prioritize solutions with high crowding distance and objective diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (base_val1, base_val2) = archive[selected_idx]\n\n    # Step 2: Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Strategy: Randomly select a subset of items to flip, with bias towards items that improve both objectives\n    flip_indices = np.random.choice(n_items, size=min(5, n_items), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            temp_solution = new_solution.copy()\n            temp_solution[idx] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                temp_val1 = np.sum(value1_lst[temp_solution == 1])\n                temp_val2 = np.sum(value2_lst[temp_solution == 1])\n                if (temp_val1 > base_val1 and temp_val2 > base_val2) or \\\n                   (temp_val1 > base_val1 and np.random.rand() < 0.3) or \\\n                   (temp_val2 > base_val2 and np.random.rand() < 0.3):\n                    new_solution = temp_solution\n                    base_val1, base_val2 = temp_val1, temp_val2\n        else:\n            # Try adding the item\n            temp_solution = new_solution.copy()\n            temp_solution[idx] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                temp_val1 = np.sum(value1_lst[temp_solution == 1])\n                temp_val2 = np.sum(value2_lst[temp_solution == 1])\n                if (temp_val1 > base_val1 and temp_val2 > base_val2) or \\\n                   (temp_val1 > base_val1 and np.random.rand() < 0.3) or \\\n                   (temp_val2 > base_val2 and np.random.rand() < 0.3):\n                    new_solution = temp_solution\n                    base_val1, base_val2 = temp_val1, temp_val2\n\n    # Additional strategy: Swap items between two positions if it improves both objectives\n    if n_items >= 2:\n        i, j = np.random.choice(n_items, size=2, replace=False)\n        if new_solution[i] != new_solution[j]:\n            temp_solution = new_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                temp_val1 = np.sum(value1_lst[temp_solution == 1])\n                temp_val2 = np.sum(value2_lst[temp_solution == 1])\n                if (temp_val1 > base_val1 and temp_val2 > base_val2) or \\\n                   (temp_val1 > base_val1 and np.random.rand() < 0.3) or \\\n                   (temp_val2 > base_val2 and np.random.rand() < 0.3):\n                    new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 106,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: swap items based on marginal utility and randomness\n    num_items = len(weight_lst)\n    for _ in range(2):  # Perform multiple swaps\n        # Identify items to swap: one included and one excluded\n        included = np.where(selected_solution == 1)[0]\n        excluded = np.where(selected_solution == 0)[0]\n        if len(included) == 0 or len(excluded) == 0:\n            break\n\n        # Select items with highest marginal utility for swapping\n        swap_in = np.random.choice(included) if np.random.rand() < 0.7 else np.argmax(value1_lst[included] + value2_lst[included])\n        swap_out = np.random.choice(excluded) if np.random.rand() < 0.7 else np.argmin(weight_lst[excluded])\n\n        # Check feasibility before swapping\n        current_weight = np.sum(weight_lst[selected_solution == 1])\n        if current_weight - weight_lst[swap_in] + weight_lst[swap_out] <= capacity:\n            new_solution[swap_in], new_solution[swap_out] = 0, 1\n\n    return new_solution\n\n",
        "score": [
            -0.28497056360032896,
            4.347109645605087
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: swap items based on marginal utility and randomness\n    num_items = len(weight_lst)\n    for _ in range(2):  # Perform multiple swaps\n        # Identify items to swap: one included and one excluded\n        included = np.where(selected_solution == 1)[0]\n        excluded = np.where(selected_solution == 0)[0]\n        if len(included) == 0 or len(excluded) == 0:\n            break\n\n        # Select items with highest marginal utility for swapping\n        swap_in = np.random.choice(included) if np.random.rand() < 0.7 else np.argmax(value1_lst[included] + value2_lst[included])\n        swap_out = np.random.choice(excluded) if np.random.rand() < 0.7 else np.argmin(weight_lst[excluded])\n\n        # Check feasibility before swapping\n        current_weight = np.sum(weight_lst[selected_solution == 1])\n        if current_weight - weight_lst[swap_in] + weight_lst[swap_out] <= capacity:\n            new_solution[swap_in], new_solution[swap_out] = 0, 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 107,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify items that could be flipped (added or removed)\n    candidate_indices = np.where(base_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.where(base_solution == 0)[0]\n\n    # Randomly select an item to flip\n    flip_idx = np.random.choice(candidate_indices)\n\n    # Flip the item and check feasibility\n    new_solution[flip_idx] = 1 - new_solution[flip_idx]\n    current_weight = np.sum(new_solution * weight_lst)\n\n    # If infeasible, flip back or try another item\n    if current_weight > capacity:\n        new_solution[flip_idx] = 1 - new_solution[flip_idx]\n        # Try another item if possible\n        remaining_indices = np.setdiff1d(candidate_indices, [flip_idx])\n        if len(remaining_indices) > 0:\n            flip_idx = np.random.choice(remaining_indices)\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n            current_weight = np.sum(new_solution * weight_lst)\n            if current_weight > capacity:\n                new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.9137589905173253,
            1.0811117887496948
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify items that could be flipped (added or removed)\n    candidate_indices = np.where(base_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.where(base_solution == 0)[0]\n\n    # Randomly select an item to flip\n    flip_idx = np.random.choice(candidate_indices)\n\n    # Flip the item and check feasibility\n    new_solution[flip_idx] = 1 - new_solution[flip_idx]\n    current_weight = np.sum(new_solution * weight_lst)\n\n    # If infeasible, flip back or try another item\n    if current_weight > capacity:\n        new_solution[flip_idx] = 1 - new_solution[flip_idx]\n        # Try another item if possible\n        remaining_indices = np.setdiff1d(candidate_indices, [flip_idx])\n        if len(remaining_indices) > 0:\n            flip_idx = np.random.choice(remaining_indices)\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n            current_weight = np.sum(new_solution * weight_lst)\n            if current_weight > capacity:\n                new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 107,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify items that could be flipped (added or removed)\n    candidate_indices = np.where(base_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.where(base_solution == 0)[0]\n\n    # Randomly select an item to flip\n    flip_idx = np.random.choice(candidate_indices)\n\n    # Flip the item and check feasibility\n    new_solution[flip_idx] = 1 - new_solution[flip_idx]\n    current_weight = np.sum(new_solution * weight_lst)\n\n    # If infeasible, flip back or try another item\n    if current_weight > capacity:\n        new_solution[flip_idx] = 1 - new_solution[flip_idx]\n        # Try another item if possible\n        remaining_indices = np.setdiff1d(candidate_indices, [flip_idx])\n        if len(remaining_indices) > 0:\n            flip_idx = np.random.choice(remaining_indices)\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n            current_weight = np.sum(new_solution * weight_lst)\n            if current_weight > capacity:\n                new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.9137589905173253,
            1.0811117887496948
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify items that could be flipped (added or removed)\n    candidate_indices = np.where(base_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.where(base_solution == 0)[0]\n\n    # Randomly select an item to flip\n    flip_idx = np.random.choice(candidate_indices)\n\n    # Flip the item and check feasibility\n    new_solution[flip_idx] = 1 - new_solution[flip_idx]\n    current_weight = np.sum(new_solution * weight_lst)\n\n    # If infeasible, flip back or try another item\n    if current_weight > capacity:\n        new_solution[flip_idx] = 1 - new_solution[flip_idx]\n        # Try another item if possible\n        remaining_indices = np.setdiff1d(candidate_indices, [flip_idx])\n        if len(remaining_indices) > 0:\n            flip_idx = np.random.choice(remaining_indices)\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n            current_weight = np.sum(new_solution * weight_lst)\n            if current_weight > capacity:\n                new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 108,
        "algorithm": "{A hybrid local search algorithm that intelligently selects a solution from the archive, applies a dynamic neighborhood exploration strategy (combining swap and flip operations) to generate neighbors, and ensures feasibility by dynamically adjusting item selections based on weight and objective trade-offs.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Intelligently select a solution with high potential for improvement\n    # Here, we select the solution with the highest combined objective score\n    combined_scores = [sum(obj) for (_, obj) in archive]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n    N = len(weight_lst)\n\n    # Step 1: Randomly select a subset of items to consider for swapping or flipping\n    num_candidates = min(5, N)  # Limit the number of candidates for efficiency\n    candidate_indices = np.random.choice(N, size=num_candidates, replace=False)\n\n    # Step 2: Evaluate the impact of flipping each candidate item\n    best_improvement = 0\n    best_flip = None\n\n    for idx in candidate_indices:\n        # Calculate the new weight and objectives if we flip this item\n        if new_solution[idx] == 1:\n            new_weight = np.sum(weight_lst * new_solution) - weight_lst[idx]\n            new_value1 = np.sum(value1_lst * new_solution) - value1_lst[idx]\n            new_value2 = np.sum(value2_lst * new_solution) - value2_lst[idx]\n        else:\n            new_weight = np.sum(weight_lst * new_solution) + weight_lst[idx]\n            new_value1 = np.sum(value1_lst * new_solution) + value1_lst[idx]\n            new_value2 = np.sum(value2_lst * new_solution) + value2_lst[idx]\n\n        # Check feasibility\n        if new_weight <= capacity:\n            # Calculate the combined improvement (sum of both objectives)\n            current_value1, current_value2 = archive[selected_idx][1]\n            improvement = (new_value1 - current_value1) + (new_value2 - current_value2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_flip = idx\n\n    # Apply the best flip if found\n    if best_flip is not None:\n        new_solution[best_flip] = 1 - new_solution[best_flip]\n\n    # Step 3: Perform a dynamic swap if no flip improves the solution\n    if best_improvement <= 0:\n        # Randomly select two items to swap\n        swap_indices = np.random.choice(N, size=2, replace=False)\n        i, j = swap_indices[0], swap_indices[1]\n\n        # Check if swapping improves the solution\n        if new_solution[i] != new_solution[j]:\n            # Calculate the new weight and objectives after swapping\n            if new_solution[i] == 1:\n                new_weight = np.sum(weight_lst * new_solution) - weight_lst[i] + weight_lst[j]\n            else:\n                new_weight = np.sum(weight_lst * new_solution) + weight_lst[i] - weight_lst[j]\n\n            if new_weight <= capacity:\n                # Perform the swap\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.2931747578298127,
            8.465026706457138
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Intelligently select a solution with high potential for improvement\n    # Here, we select the solution with the highest combined objective score\n    combined_scores = [sum(obj) for (_, obj) in archive]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n    N = len(weight_lst)\n\n    # Step 1: Randomly select a subset of items to consider for swapping or flipping\n    num_candidates = min(5, N)  # Limit the number of candidates for efficiency\n    candidate_indices = np.random.choice(N, size=num_candidates, replace=False)\n\n    # Step 2: Evaluate the impact of flipping each candidate item\n    best_improvement = 0\n    best_flip = None\n\n    for idx in candidate_indices:\n        # Calculate the new weight and objectives if we flip this item\n        if new_solution[idx] == 1:\n            new_weight = np.sum(weight_lst * new_solution) - weight_lst[idx]\n            new_value1 = np.sum(value1_lst * new_solution) - value1_lst[idx]\n            new_value2 = np.sum(value2_lst * new_solution) - value2_lst[idx]\n        else:\n            new_weight = np.sum(weight_lst * new_solution) + weight_lst[idx]\n            new_value1 = np.sum(value1_lst * new_solution) + value1_lst[idx]\n            new_value2 = np.sum(value2_lst * new_solution) + value2_lst[idx]\n\n        # Check feasibility\n        if new_weight <= capacity:\n            # Calculate the combined improvement (sum of both objectives)\n            current_value1, current_value2 = archive[selected_idx][1]\n            improvement = (new_value1 - current_value1) + (new_value2 - current_value2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_flip = idx\n\n    # Apply the best flip if found\n    if best_flip is not None:\n        new_solution[best_flip] = 1 - new_solution[best_flip]\n\n    # Step 3: Perform a dynamic swap if no flip improves the solution\n    if best_improvement <= 0:\n        # Randomly select two items to swap\n        swap_indices = np.random.choice(N, size=2, replace=False)\n        i, j = swap_indices[0], swap_indices[1]\n\n        # Check if swapping improves the solution\n        if new_solution[i] != new_solution[j]:\n            # Calculate the new weight and objectives after swapping\n            if new_solution[i] == 1:\n                new_weight = np.sum(weight_lst * new_solution) - weight_lst[i] + weight_lst[j]\n            else:\n                new_weight = np.sum(weight_lst * new_solution) + weight_lst[i] - weight_lst[j]\n\n            if new_weight <= capacity:\n                # Perform the swap\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 109,
        "algorithm": "{The heuristic function selects a promising solution from the archive by prioritizing those with high objective values and low weight, then applies a hybrid local search combining item swaps and random perturbations to generate a feasible neighbor solution while avoiding standard 2-opt strategies.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([(obj[0] + obj[1]) / (np.sum(weight_lst[sol]) + 1e-6) for sol, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: item swaps and random perturbations\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select a subset of items to consider for swaps\n    subset_size = min(10, n_items)\n    candidate_indices = np.random.choice(n_items, subset_size, replace=False)\n\n    for i in candidate_indices:\n        if new_solution[i] == 1:  # Item is currently included\n            # Try removing it\n            temp_weight = current_weight - weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution[i] = 0\n                current_weight = temp_weight\n        else:  # Item is currently excluded\n            # Try adding it\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Random perturbation: flip a random bit if it doesn't violate capacity\n    if random.random() < 0.3:  # 30% chance of perturbation\n        flip_idx = random.randint(0, n_items - 1)\n        if new_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.32138122942369923,
            3.8902309834957123
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([(obj[0] + obj[1]) / (np.sum(weight_lst[sol]) + 1e-6) for sol, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: item swaps and random perturbations\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select a subset of items to consider for swaps\n    subset_size = min(10, n_items)\n    candidate_indices = np.random.choice(n_items, subset_size, replace=False)\n\n    for i in candidate_indices:\n        if new_solution[i] == 1:  # Item is currently included\n            # Try removing it\n            temp_weight = current_weight - weight_lst[i]\n            if temp_weight <= capacity:\n                new_solution[i] = 0\n                current_weight = temp_weight\n        else:  # Item is currently excluded\n            # Try adding it\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Random perturbation: flip a random bit if it doesn't violate capacity\n    if random.random() < 0.3:  # 30% chance of perturbation\n        flip_idx = random.randint(0, n_items - 1)\n        if new_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 110,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high marginal gains in both objectives, then applies a hybrid local search that combines item swaps and random perturbations to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    # Prioritize solutions with high marginal gains in both objectives\n    candidates = []\n    for sol, (v1, v2) in archive:\n        current_weight = np.sum(weight_lst * sol)\n        marginal_gain1 = v1 / (current_weight + 1e-6)\n        marginal_gain2 = v2 / (current_weight + 1e-6)\n        candidates.append((sol, marginal_gain1, marginal_gain2))\n\n    # Sort by combined marginal gain\n    candidates.sort(key=lambda x: -(x[1] + x[2]))\n    base_solution = candidates[0][0].copy()\n\n    # Hybrid local search: swap items and random perturbations\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly select a subset of items to consider for swapping\n    swap_indices = random.sample(range(n_items), min(5, n_items))\n\n    # Step 2: For each selected item, consider swapping with another random item\n    for i in swap_indices:\n        if random.random() < 0.5:  # 50% chance to swap\n            j = random.randint(0, n_items - 1)\n            if i != j:\n                temp = new_solution[i]\n                new_solution[i] = new_solution[j]\n                new_solution[j] = temp\n\n    # Step 3: Randomly flip a few items to introduce diversity\n    flip_indices = random.sample(range(n_items), min(3, n_items))\n    for i in flip_indices:\n        new_solution[i] = 1 - new_solution[i]\n\n    # Ensure feasibility by removing items that exceed capacity\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        excess_weight = total_weight - capacity\n        while excess_weight > 0 and np.sum(new_solution) > 0:\n            # Select a random item to remove\n            remove_idx = random.choice(np.where(new_solution == 1)[0])\n            new_solution[remove_idx] = 0\n            excess_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.2987516213428779,
            4.383346378803253
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    # Prioritize solutions with high marginal gains in both objectives\n    candidates = []\n    for sol, (v1, v2) in archive:\n        current_weight = np.sum(weight_lst * sol)\n        marginal_gain1 = v1 / (current_weight + 1e-6)\n        marginal_gain2 = v2 / (current_weight + 1e-6)\n        candidates.append((sol, marginal_gain1, marginal_gain2))\n\n    # Sort by combined marginal gain\n    candidates.sort(key=lambda x: -(x[1] + x[2]))\n    base_solution = candidates[0][0].copy()\n\n    # Hybrid local search: swap items and random perturbations\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly select a subset of items to consider for swapping\n    swap_indices = random.sample(range(n_items), min(5, n_items))\n\n    # Step 2: For each selected item, consider swapping with another random item\n    for i in swap_indices:\n        if random.random() < 0.5:  # 50% chance to swap\n            j = random.randint(0, n_items - 1)\n            if i != j:\n                temp = new_solution[i]\n                new_solution[i] = new_solution[j]\n                new_solution[j] = temp\n\n    # Step 3: Randomly flip a few items to introduce diversity\n    flip_indices = random.sample(range(n_items), min(3, n_items))\n    for i in flip_indices:\n        new_solution[i] = 1 - new_solution[i]\n\n    # Ensure feasibility by removing items that exceed capacity\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        excess_weight = total_weight - capacity\n        while excess_weight > 0 and np.sum(new_solution) > 0:\n            # Select a random item to remove\n            remove_idx = random.choice(np.where(new_solution == 1)[0])\n            new_solution[remove_idx] = 0\n            excess_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 111,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_combined = -1\n    selected_solution = None\n    for sol, (v1, v2) in archive:\n        combined = v1 + v2\n        if combined > max_combined:\n            max_combined = combined\n            selected_solution = sol\n\n    # Step 2: Generate a neighbor solution using a hybrid local search strategy\n    # This strategy combines flip-based and swap-based moves to explore diverse neighborhoods\n    new_solution = selected_solution.copy()\n\n    # Flip-based move: Randomly flip a subset of items to explore local changes\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Check if removing the item keeps the solution feasible\n            if np.sum(weight_lst[new_solution == 1]) - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            # Check if adding the item keeps the solution feasible\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Swap-based move: Randomly swap two items to explore structural changes\n    if len(new_solution) >= 2:\n        swap_indices = np.random.choice(len(new_solution), size=2, replace=False)\n        # Ensure the swap maintains feasibility\n        total_weight = np.sum(weight_lst[new_solution == 1])\n        if new_solution[swap_indices[0]] != new_solution[swap_indices[1]]:\n            # Calculate the weight change if we swap\n            weight_change = (weight_lst[swap_indices[1]] - weight_lst[swap_indices[0]]) * (new_solution[swap_indices[1]] - new_solution[swap_indices[0]])\n            if total_weight + weight_change <= capacity:\n                new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.32062640083777405,
            5.081288725137711
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_combined = -1\n    selected_solution = None\n    for sol, (v1, v2) in archive:\n        combined = v1 + v2\n        if combined > max_combined:\n            max_combined = combined\n            selected_solution = sol\n\n    # Step 2: Generate a neighbor solution using a hybrid local search strategy\n    # This strategy combines flip-based and swap-based moves to explore diverse neighborhoods\n    new_solution = selected_solution.copy()\n\n    # Flip-based move: Randomly flip a subset of items to explore local changes\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Check if removing the item keeps the solution feasible\n            if np.sum(weight_lst[new_solution == 1]) - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            # Check if adding the item keeps the solution feasible\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Swap-based move: Randomly swap two items to explore structural changes\n    if len(new_solution) >= 2:\n        swap_indices = np.random.choice(len(new_solution), size=2, replace=False)\n        # Ensure the swap maintains feasibility\n        total_weight = np.sum(weight_lst[new_solution == 1])\n        if new_solution[swap_indices[0]] != new_solution[swap_indices[1]]:\n            # Calculate the weight change if we swap\n            weight_change = (weight_lst[swap_indices[1]] - weight_lst[swap_indices[0]]) * (new_solution[swap_indices[1]] - new_solution[swap_indices[0]])\n            if total_weight + weight_change <= capacity:\n                new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 112,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a weighted diversity and objective trade-off metric, then applies a hybrid local search operator that combines item swapping and dynamic neighborhood exploration to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # We use a weighted selection that considers both objective values and diversity\n    objectives = np.array([obj for (sol, obj) in archive])\n    norms = np.linalg.norm(objectives, axis=1)\n    weights = 1.0 / (norms + 1e-6)  # Avoid division by zero\n    weights = weights / np.sum(weights)  # Normalize to probabilities\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    # Step 2: Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Hybrid operator: item swapping with dynamic neighborhood exploration\n    for _ in range(5):  # Number of attempts to find a valid neighbor\n        # Randomly select a subset of items to consider\n        subset_size = min(5, n_items)\n        items_to_swap = np.random.choice(n_items, size=subset_size, replace=False)\n\n        # Try to swap items in the subset\n        for i in items_to_swap:\n            if new_solution[i] == 0:\n                # Try to add item i\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n            else:\n                # Try to remove item i\n                new_solution[i] = 0\n\n        # Check feasibility\n        if np.sum(weight_lst[new_solution == 1]) <= capacity:\n            break\n\n    # If no valid neighbor found, perform a random flip\n    if np.sum(weight_lst[new_solution == 1]) > capacity:\n        # Find items to remove to make it feasible\n        excess = np.sum(weight_lst[new_solution == 1]) - capacity\n        items_in_solution = np.where(new_solution == 1)[0]\n        if len(items_in_solution) > 0:\n            items_to_remove = np.random.choice(items_in_solution, size=min(len(items_in_solution), 3), replace=False)\n            new_solution[items_to_remove] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.4158866128333751,
            5.47975292801857
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # We use a weighted selection that considers both objective values and diversity\n    objectives = np.array([obj for (sol, obj) in archive])\n    norms = np.linalg.norm(objectives, axis=1)\n    weights = 1.0 / (norms + 1e-6)  # Avoid division by zero\n    weights = weights / np.sum(weights)  # Normalize to probabilities\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    # Step 2: Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Hybrid operator: item swapping with dynamic neighborhood exploration\n    for _ in range(5):  # Number of attempts to find a valid neighbor\n        # Randomly select a subset of items to consider\n        subset_size = min(5, n_items)\n        items_to_swap = np.random.choice(n_items, size=subset_size, replace=False)\n\n        # Try to swap items in the subset\n        for i in items_to_swap:\n            if new_solution[i] == 0:\n                # Try to add item i\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n            else:\n                # Try to remove item i\n                new_solution[i] = 0\n\n        # Check feasibility\n        if np.sum(weight_lst[new_solution == 1]) <= capacity:\n            break\n\n    # If no valid neighbor found, perform a random flip\n    if np.sum(weight_lst[new_solution == 1]) > capacity:\n        # Find items to remove to make it feasible\n        excess = np.sum(weight_lst[new_solution == 1]) - capacity\n        items_in_solution = np.where(new_solution == 1)[0]\n        if len(items_in_solution) > 0:\n            items_to_remove = np.random.choice(items_in_solution, size=min(len(items_in_solution), 3), replace=False)\n            new_solution[items_to_remove] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 113,
        "algorithm": "{The algorithm selects the most promising solution from the archive based on a hybrid local search strategy that combines adaptive bit-flipping with objective-specific perturbations, ensuring feasibility and maximizing both objectives through iterative refinement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the most promising solution (e.g., highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst * base_solution)\n\n    # Step 1: Adaptive bit-flipping (flip items with high marginal contribution)\n    marginal_contributions = (value1_lst + value2_lst) / (weight_lst + 1e-8)\n    sorted_indices = np.argsort(marginal_contributions)[::-1]\n\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            # Try adding the item\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    # Step 2: Objective-specific perturbation (randomly flip one item to diversify)\n    if len(archive) > 1:\n        rand_idx = np.random.choice(len(archive))\n        rand_solution = archive[rand_idx][0]\n        diff_indices = np.where(new_solution != rand_solution)[0]\n\n        if len(diff_indices) > 0:\n            flip_idx = np.random.choice(diff_indices)\n            if new_solution[flip_idx] == 1:\n                if total_weight - weight_lst[flip_idx] <= capacity:\n                    new_solution[flip_idx] = 0\n            else:\n                if total_weight + weight_lst[flip_idx] <= capacity:\n                    new_solution[flip_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.7392000520552133,
            7.787732928991318
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the most promising solution (e.g., highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst * base_solution)\n\n    # Step 1: Adaptive bit-flipping (flip items with high marginal contribution)\n    marginal_contributions = (value1_lst + value2_lst) / (weight_lst + 1e-8)\n    sorted_indices = np.argsort(marginal_contributions)[::-1]\n\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            # Try adding the item\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    # Step 2: Objective-specific perturbation (randomly flip one item to diversify)\n    if len(archive) > 1:\n        rand_idx = np.random.choice(len(archive))\n        rand_solution = archive[rand_idx][0]\n        diff_indices = np.where(new_solution != rand_solution)[0]\n\n        if len(diff_indices) > 0:\n            flip_idx = np.random.choice(diff_indices)\n            if new_solution[flip_idx] == 1:\n                if total_weight - weight_lst[flip_idx] <= capacity:\n                    new_solution[flip_idx] = 0\n            else:\n                if total_weight + weight_lst[flip_idx] <= capacity:\n                    new_solution[flip_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 114,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a solution from the archive based on its potential for improvement, then applies a probabilistic item swap and flip operator to generate a neighbor solution while ensuring feasibility and balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the highest sum of objectives)\n    archive_with_scores = [(sol, obj, obj[0] + obj[1]) for sol, obj in archive]\n    archive_with_scores.sort(key=lambda x: x[2], reverse=True)\n    base_solution, _, _ = archive_with_scores[0]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: probabilistic item swap and flip\n    n_items = len(weight_lst)\n    for _ in range(10):  # Number of attempts to find a valid neighbor\n        # Randomly select two items\n        i, j = random.sample(range(n_items), 2)\n\n        # Calculate new weight if we swap or flip\n        if new_solution[i] == new_solution[j]:\n            # Flip one item\n            item = random.choice([i, j])\n            new_weight = current_weight + (1 - 2 * new_solution[item]) * weight_lst[item]\n            if new_weight <= capacity:\n                new_solution[item] = 1 - new_solution[item]\n                current_weight = new_weight\n                break\n        else:\n            # Swap two items\n            delta_weight = (weight_lst[i] - weight_lst[j]) * (new_solution[i] - new_solution[j])\n            new_weight = current_weight + delta_weight\n            if new_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight = new_weight\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.5412914246240004,
            3.7059457302093506
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the highest sum of objectives)\n    archive_with_scores = [(sol, obj, obj[0] + obj[1]) for sol, obj in archive]\n    archive_with_scores.sort(key=lambda x: x[2], reverse=True)\n    base_solution, _, _ = archive_with_scores[0]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: probabilistic item swap and flip\n    n_items = len(weight_lst)\n    for _ in range(10):  # Number of attempts to find a valid neighbor\n        # Randomly select two items\n        i, j = random.sample(range(n_items), 2)\n\n        # Calculate new weight if we swap or flip\n        if new_solution[i] == new_solution[j]:\n            # Flip one item\n            item = random.choice([i, j])\n            new_weight = current_weight + (1 - 2 * new_solution[item]) * weight_lst[item]\n            if new_weight <= capacity:\n                new_solution[item] = 1 - new_solution[item]\n                current_weight = new_weight\n                break\n        else:\n            # Swap two items\n            delta_weight = (weight_lst[i] - weight_lst[j]) * (new_solution[i] - new_solution[j])\n            new_weight = current_weight + delta_weight\n            if new_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight = new_weight\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 115,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search combining random item swaps and objective-weighted perturbations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select a solution with the highest combined objective value\n        selected_idx = np.argmax([sum(obj) for _, obj in archive])\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine random swaps and objective-weighted perturbations\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select a subset of items to consider for swap\n    candidate_items = np.where(new_solution == 1)[0]\n    if len(candidate_items) > 0:\n        # Randomly select an item to remove\n        remove_idx = random.choice(candidate_items)\n        new_solution[remove_idx] = 0\n        current_weight -= weight_lst[remove_idx]\n\n        # Find items that can be added without exceeding capacity\n        available_items = np.where(new_solution == 0)[0]\n        feasible_items = [i for i in available_items if weight_lst[i] <= capacity - current_weight]\n\n        if feasible_items:\n            # Select item to add based on weighted probability (value1 + value2)\n            weights = [(value1_lst[i] + value2_lst[i]) for i in feasible_items]\n            selected_item = random.choices(feasible_items, weights=weights, k=1)[0]\n            new_solution[selected_item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.5074995922784532,
            5.479888886213303
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select a solution with the highest combined objective value\n        selected_idx = np.argmax([sum(obj) for _, obj in archive])\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine random swaps and objective-weighted perturbations\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select a subset of items to consider for swap\n    candidate_items = np.where(new_solution == 1)[0]\n    if len(candidate_items) > 0:\n        # Randomly select an item to remove\n        remove_idx = random.choice(candidate_items)\n        new_solution[remove_idx] = 0\n        current_weight -= weight_lst[remove_idx]\n\n        # Find items that can be added without exceeding capacity\n        available_items = np.where(new_solution == 0)[0]\n        feasible_items = [i for i in available_items if weight_lst[i] <= capacity - current_weight]\n\n        if feasible_items:\n            # Select item to add based on weighted probability (value1 + value2)\n            weights = [(value1_lst[i] + value2_lst[i]) for i in feasible_items]\n            selected_item = random.choices(feasible_items, weights=weights, k=1)[0]\n            new_solution[selected_item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 116,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a combination of diversity and objective improvement potential, then applies a hybrid local search operator that combines random item swaps with greedy objective-driven flips to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with high potential for improvement\n    base_solution, base_objective = max(\n        archive,\n        key=lambda x: (x[1][0] + x[1][1]) * (1 + random.uniform(0, 0.1))\n    )\n    base_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: combine random swaps with greedy flips\n    new_solution = base_solution.copy()\n\n    # First, perform random swaps (exploration)\n    for _ in range(3):\n        if random.random() < 0.5:\n            # Try to flip a random item\n            idx = random.randint(0, len(new_solution) - 1)\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    # Then perform greedy flips (exploitation)\n    for _ in range(2):\n        # Calculate potential improvements for each item\n        improvements = []\n        for i in range(len(new_solution)):\n            if new_solution[i] == 1:\n                # Calculate improvement if we remove this item\n                new_weight = current_weight - weight_lst[i]\n                if new_weight <= capacity:\n                    improvement1 = value1_lst[i]\n                    improvement2 = value2_lst[i]\n                    improvements.append((-improvement1 - improvement2, i, 0))  # 0 means remove\n            else:\n                # Calculate improvement if we add this item\n                new_weight = current_weight + weight_lst[i]\n                if new_weight <= capacity:\n                    improvement1 = value1_lst[i]\n                    improvement2 = value2_lst[i]\n                    improvements.append((-improvement1 - improvement2, i, 1))  # 1 means add\n\n        if improvements:\n            # Select the best improvement\n            improvements.sort()\n            best_improvement = improvements[0]\n            if best_improvement[2] == 1:\n                new_solution[best_improvement[1]] = 1\n                current_weight += weight_lst[best_improvement[1]]\n            else:\n                new_solution[best_improvement[1]] = 0\n                current_weight -= weight_lst[best_improvement[1]]\n\n    return new_solution\n\n",
        "score": [
            -0.30738222151816563,
            9.656336009502411
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with high potential for improvement\n    base_solution, base_objective = max(\n        archive,\n        key=lambda x: (x[1][0] + x[1][1]) * (1 + random.uniform(0, 0.1))\n    )\n    base_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: combine random swaps with greedy flips\n    new_solution = base_solution.copy()\n\n    # First, perform random swaps (exploration)\n    for _ in range(3):\n        if random.random() < 0.5:\n            # Try to flip a random item\n            idx = random.randint(0, len(new_solution) - 1)\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    # Then perform greedy flips (exploitation)\n    for _ in range(2):\n        # Calculate potential improvements for each item\n        improvements = []\n        for i in range(len(new_solution)):\n            if new_solution[i] == 1:\n                # Calculate improvement if we remove this item\n                new_weight = current_weight - weight_lst[i]\n                if new_weight <= capacity:\n                    improvement1 = value1_lst[i]\n                    improvement2 = value2_lst[i]\n                    improvements.append((-improvement1 - improvement2, i, 0))  # 0 means remove\n            else:\n                # Calculate improvement if we add this item\n                new_weight = current_weight + weight_lst[i]\n                if new_weight <= capacity:\n                    improvement1 = value1_lst[i]\n                    improvement2 = value2_lst[i]\n                    improvements.append((-improvement1 - improvement2, i, 1))  # 1 means add\n\n        if improvements:\n            # Select the best improvement\n            improvements.sort()\n            best_improvement = improvements[0]\n            if best_improvement[2] == 1:\n                new_solution[best_improvement[1]] = 1\n                current_weight += weight_lst[best_improvement[1]]\n            else:\n                new_solution[best_improvement[1]] = 0\n                current_weight -= weight_lst[best_improvement[1]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 117,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify items in the solution and not in the solution\n    in_solution = np.where(base_solution == 1)[0]\n    not_in_solution = np.where(base_solution == 0)[0]\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[in_solution])\n\n    # Hybrid local search: remove low-value items and add high-value items\n    if len(in_solution) > 0:\n        # Remove items with the lowest value in either objective\n        value1 = value1_lst[in_solution]\n        value2 = value2_lst[in_solution]\n        combined_value = value1 + value2\n        min_value_idx = np.argmin(combined_value)\n        new_solution[in_solution[min_value_idx]] = 0\n\n    # Add items with the highest value in either objective\n    if len(not_in_solution) > 0:\n        value1 = value1_lst[not_in_solution]\n        value2 = value2_lst[not_in_solution]\n        combined_value = value1 + value2\n        max_value_idx = np.argmax(combined_value)\n        candidate_item = not_in_solution[max_value_idx]\n\n        # Check if adding the item keeps the solution feasible\n        if current_weight + weight_lst[candidate_item] <= capacity:\n            new_solution[candidate_item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.9306880830231619,
            2.3372616171836853
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify items in the solution and not in the solution\n    in_solution = np.where(base_solution == 1)[0]\n    not_in_solution = np.where(base_solution == 0)[0]\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[in_solution])\n\n    # Hybrid local search: remove low-value items and add high-value items\n    if len(in_solution) > 0:\n        # Remove items with the lowest value in either objective\n        value1 = value1_lst[in_solution]\n        value2 = value2_lst[in_solution]\n        combined_value = value1 + value2\n        min_value_idx = np.argmin(combined_value)\n        new_solution[in_solution[min_value_idx]] = 0\n\n    # Add items with the highest value in either objective\n    if len(not_in_solution) > 0:\n        value1 = value1_lst[not_in_solution]\n        value2 = value2_lst[not_in_solution]\n        combined_value = value1 + value2\n        max_value_idx = np.argmax(combined_value)\n        candidate_item = not_in_solution[max_value_idx]\n\n        # Check if adding the item keeps the solution feasible\n        if current_weight + weight_lst[candidate_item] <= capacity:\n            new_solution[candidate_item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 118,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by evaluating the objective diversity and weight utilization, then applies a hybrid local search combining item swaps and random flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + np.linalg.norm(archive[i][1])) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Initialize new solution\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: item swaps and random flips\n    for _ in range(10):  # Number of attempts\n        # Random flip\n        flip_idx = random.randint(0, len(base_solution) - 1)\n        if base_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n                current_weight -= weight_lst[flip_idx]\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n                current_weight += weight_lst[flip_idx]\n\n        # Item swap\n        swap_idx1, swap_idx2 = random.sample(range(len(base_solution)), 2)\n        if base_solution[swap_idx1] != base_solution[swap_idx2]:\n            delta_weight = weight_lst[swap_idx2] - weight_lst[swap_idx1]\n            if current_weight + delta_weight <= capacity:\n                new_solution[swap_idx1], new_solution[swap_idx2] = new_solution[swap_idx2], new_solution[swap_idx1]\n                current_weight += delta_weight\n\n    # Ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Randomly remove items until feasible\n        excess_items = np.where(new_solution == 1)[0]\n        if len(excess_items) == 0:\n            break\n        remove_idx = random.choice(excess_items)\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.37009261004954935,
            4.606500625610352
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + np.linalg.norm(archive[i][1])) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Initialize new solution\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: item swaps and random flips\n    for _ in range(10):  # Number of attempts\n        # Random flip\n        flip_idx = random.randint(0, len(base_solution) - 1)\n        if base_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n                current_weight -= weight_lst[flip_idx]\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n                current_weight += weight_lst[flip_idx]\n\n        # Item swap\n        swap_idx1, swap_idx2 = random.sample(range(len(base_solution)), 2)\n        if base_solution[swap_idx1] != base_solution[swap_idx2]:\n            delta_weight = weight_lst[swap_idx2] - weight_lst[swap_idx1]\n            if current_weight + delta_weight <= capacity:\n                new_solution[swap_idx1], new_solution[swap_idx2] = new_solution[swap_idx2], new_solution[swap_idx1]\n                current_weight += delta_weight\n\n    # Ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Randomly remove items until feasible\n        excess_items = np.where(new_solution == 1)[0]\n        if len(excess_items) == 0:\n            break\n        remove_idx = random.choice(excess_items)\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 119,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive based on its potential for improvement, then applies a hybrid local search that combines item swapping and diversification moves to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution (e.g., one with high potential for improvement)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items or flip based on potential improvement\n    for _ in range(10):  # Perform multiple attempts\n        # Randomly select two items\n        i, j = random.sample(range(len(weight_lst)), 2)\n\n        # Case 1: Swap items if feasible\n        if new_solution[i] != new_solution[j]:\n            delta_weight = (weight_lst[j] - weight_lst[i]) if new_solution[i] else (weight_lst[i] - weight_lst[j])\n            if current_weight + delta_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight += delta_weight\n                continue\n\n        # Case 2: Flip an item if feasible\n        if new_solution[i]:\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.46706403132187624,
            2.708748012781143
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution (e.g., one with high potential for improvement)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items or flip based on potential improvement\n    for _ in range(10):  # Perform multiple attempts\n        # Randomly select two items\n        i, j = random.sample(range(len(weight_lst)), 2)\n\n        # Case 1: Swap items if feasible\n        if new_solution[i] != new_solution[j]:\n            delta_weight = (weight_lst[j] - weight_lst[i]) if new_solution[i] else (weight_lst[i] - weight_lst[j])\n            if current_weight + delta_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight += delta_weight\n                continue\n\n        # Case 2: Flip an item if feasible\n        if new_solution[i]:\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 120,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution = archive[0][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search strategy\n    # 1. Randomly select a subset of items to flip (1 to 3 items)\n    n_items = len(selected_solution)\n    flip_indices = np.random.choice(n_items, size=np.random.randint(1, 4), replace=False)\n\n    # 2. Flip the selected items and check feasibility\n    new_solution = selected_solution.copy()\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # 3. If the new solution is infeasible, perform a repair step\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove the heaviest items until feasible\n        while total_weight > capacity:\n            # Identify items that are in the new solution but not in the original\n            candidate_indices = np.where(new_solution != selected_solution)[0]\n            if len(candidate_indices) == 0:\n                break  # No items to remove\n            # Remove the heaviest candidate item\n            heaviest_idx = candidate_indices[np.argmax(weight_lst[candidate_indices])]\n            new_solution[heaviest_idx] = selected_solution[heaviest_idx]\n            total_weight = np.sum(weight_lst * new_solution)\n\n    # 4. If the repair fails (unlikely due to step 3), revert to the original solution\n    if np.sum(weight_lst * new_solution) > capacity:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.298710885875166,
            4.365157395601273
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution = archive[0][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search strategy\n    # 1. Randomly select a subset of items to flip (1 to 3 items)\n    n_items = len(selected_solution)\n    flip_indices = np.random.choice(n_items, size=np.random.randint(1, 4), replace=False)\n\n    # 2. Flip the selected items and check feasibility\n    new_solution = selected_solution.copy()\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # 3. If the new solution is infeasible, perform a repair step\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove the heaviest items until feasible\n        while total_weight > capacity:\n            # Identify items that are in the new solution but not in the original\n            candidate_indices = np.where(new_solution != selected_solution)[0]\n            if len(candidate_indices) == 0:\n                break  # No items to remove\n            # Remove the heaviest candidate item\n            heaviest_idx = candidate_indices[np.argmax(weight_lst[candidate_indices])]\n            new_solution[heaviest_idx] = selected_solution[heaviest_idx]\n            total_weight = np.sum(weight_lst * new_solution)\n\n    # 4. If the repair fails (unlikely due to step 3), revert to the original solution\n    if np.sum(weight_lst * new_solution) > capacity:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 121,
        "algorithm": "{The heuristic function selects a promising solution from the archive by prioritizing those with high objective values and low weight utilization, then applies a hybrid local search operator that combines item swaps and dynamic subset perturbations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution from the archive\n    selected_idx = np.random.choice(len(archive))\n    base_solution, _ = archive[selected_idx]\n    current_weight = np.sum(weight_lst * base_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Hybrid local search: item swaps + dynamic subset perturbations\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly select a subset of items to consider for swaps\n    subset_size = max(1, int(np.sqrt(n_items)))\n    subset_indices = np.random.choice(n_items, size=subset_size, replace=False)\n\n    # Step 2: Perform item swaps within the subset\n    for i in subset_indices:\n        if new_solution[i] == 1:\n            # Try to remove the item if feasible\n            if current_weight - weight_lst[i] >= 0:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            # Try to add the item if feasible\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Step 3: Dynamic subset perturbations\n    perturbation_size = max(1, int(np.log2(n_items)))\n    perturbation_indices = np.random.choice(n_items, size=perturbation_size, replace=False)\n\n    for i in perturbation_indices:\n        if new_solution[i] == 1:\n            # Flip with probability based on value density\n            value_density = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n            if np.random.rand() < 1 / (1 + np.exp(-value_density)):\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            # Flip with probability based on value density\n            value_density = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n            if np.random.rand() < 1 / (1 + np.exp(-value_density)) and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.4064743840039935,
            4.307817608118057
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution from the archive\n    selected_idx = np.random.choice(len(archive))\n    base_solution, _ = archive[selected_idx]\n    current_weight = np.sum(weight_lst * base_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Hybrid local search: item swaps + dynamic subset perturbations\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly select a subset of items to consider for swaps\n    subset_size = max(1, int(np.sqrt(n_items)))\n    subset_indices = np.random.choice(n_items, size=subset_size, replace=False)\n\n    # Step 2: Perform item swaps within the subset\n    for i in subset_indices:\n        if new_solution[i] == 1:\n            # Try to remove the item if feasible\n            if current_weight - weight_lst[i] >= 0:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            # Try to add the item if feasible\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Step 3: Dynamic subset perturbations\n    perturbation_size = max(1, int(np.log2(n_items)))\n    perturbation_indices = np.random.choice(n_items, size=perturbation_size, replace=False)\n\n    for i in perturbation_indices:\n        if new_solution[i] == 1:\n            # Flip with probability based on value density\n            value_density = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n            if np.random.rand() < 1 / (1 + np.exp(-value_density)):\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            # Flip with probability based on value density\n            value_density = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n            if np.random.rand() < 1 / (1 + np.exp(-value_density)) and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 122,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high objective values, then applies a hybrid local search strategy that combines item swaps and adaptive perturbations to explore the solution space while ensuring feasibility, balancing exploration and exploitation for improved multi-objective outcomes.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol_obj[0] for sol_obj in archive]\n    archive_values = [sol_obj[1] for sol_obj in archive]\n\n    # Calculate a score for each solution (normalized sum of objectives)\n    scores = [(v1 + v2) for v1, v2 in archive_values]\n    max_score = max(scores) if scores else 1.0\n    probabilities = [(score / max_score) ** 2 for score in scores]  # Squared to favor high-value solutions\n    probabilities = [p / sum(probabilities) for p in probabilities]  # Normalize to probabilities\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive_solutions[selected_idx].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: combine item swaps and adaptive perturbations\n    new_solution = base_solution.copy()\n\n    # Step 1: Item swaps (exploration)\n    for _ in range(min(5, len(weight_lst))):  # Limit swaps to avoid excessive computation\n        if random.random() < 0.7:  # 70% chance for swap\n            # Select two items: one in the solution, one out\n            in_items = np.where(new_solution == 1)[0]\n            out_items = np.where(new_solution == 0)[0]\n\n            if len(in_items) > 0 and len(out_items) > 0:\n                swap_in = random.choice(in_items)\n                swap_out = random.choice(out_items)\n\n                # Check feasibility after swap\n                new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n                if new_weight <= capacity:\n                    new_solution[swap_in] = 0\n                    new_solution[swap_out] = 1\n                    current_weight = new_weight\n\n    # Step 2: Adaptive perturbations (exploitation)\n    for _ in range(3):  # Fixed number of perturbations\n        if random.random() < 0.5:  # 50% chance for perturbation\n            # Randomly flip a small number of items (1-3)\n            flip_indices = random.sample(range(len(new_solution)), random.randint(1, 3))\n            for idx in flip_indices:\n                if new_solution[idx] == 1:\n                    # Try to remove item if feasible\n                    if current_weight - weight_lst[idx] >= 0:\n                        new_solution[idx] = 0\n                        current_weight -= weight_lst[idx]\n                else:\n                    # Try to add item if feasible\n                    if current_weight + weight_lst[idx] <= capacity:\n                        new_solution[idx] = 1\n                        current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3910311823455688,
            5.160764187574387
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol_obj[0] for sol_obj in archive]\n    archive_values = [sol_obj[1] for sol_obj in archive]\n\n    # Calculate a score for each solution (normalized sum of objectives)\n    scores = [(v1 + v2) for v1, v2 in archive_values]\n    max_score = max(scores) if scores else 1.0\n    probabilities = [(score / max_score) ** 2 for score in scores]  # Squared to favor high-value solutions\n    probabilities = [p / sum(probabilities) for p in probabilities]  # Normalize to probabilities\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive_solutions[selected_idx].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: combine item swaps and adaptive perturbations\n    new_solution = base_solution.copy()\n\n    # Step 1: Item swaps (exploration)\n    for _ in range(min(5, len(weight_lst))):  # Limit swaps to avoid excessive computation\n        if random.random() < 0.7:  # 70% chance for swap\n            # Select two items: one in the solution, one out\n            in_items = np.where(new_solution == 1)[0]\n            out_items = np.where(new_solution == 0)[0]\n\n            if len(in_items) > 0 and len(out_items) > 0:\n                swap_in = random.choice(in_items)\n                swap_out = random.choice(out_items)\n\n                # Check feasibility after swap\n                new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n                if new_weight <= capacity:\n                    new_solution[swap_in] = 0\n                    new_solution[swap_out] = 1\n                    current_weight = new_weight\n\n    # Step 2: Adaptive perturbations (exploitation)\n    for _ in range(3):  # Fixed number of perturbations\n        if random.random() < 0.5:  # 50% chance for perturbation\n            # Randomly flip a small number of items (1-3)\n            flip_indices = random.sample(range(len(new_solution)), random.randint(1, 3))\n            for idx in flip_indices:\n                if new_solution[idx] == 1:\n                    # Try to remove item if feasible\n                    if current_weight - weight_lst[idx] >= 0:\n                        new_solution[idx] = 0\n                        current_weight -= weight_lst[idx]\n                else:\n                    # Try to add item if feasible\n                    if current_weight + weight_lst[idx] <= capacity:\n                        new_solution[idx] = 1\n                        current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 123,
        "algorithm": "{The algorithm intelligently selects a non-dominated solution from the archive, identifies critical items with high marginal utility, and applies a hybrid local search that combines item swaps and guided perturbations to balance exploration and exploitation while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_v1, current_v2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate marginal utilities\n    included = new_solution == 1\n    excluded = new_solution == 0\n\n    # Calculate marginal gains for excluded items\n    marginal_v1 = value1_lst[excluded] / weight_lst[excluded]\n    marginal_v2 = value2_lst[excluded] / weight_lst[excluded]\n\n    # Rank excluded items by combined marginal utility\n    combined_marginal = marginal_v1 + marginal_v2\n    top_indices = np.argsort(combined_marginal)[-min(5, len(combined_marginal)):]\n\n    # Apply hybrid local search: swap items and flip critical ones\n    for idx in top_indices:\n        original_idx = np.where(excluded)[0][idx]\n        if weight_lst[original_idx] + np.sum(weight_lst[included]) <= capacity:\n            new_solution[original_idx] = 1\n            included = new_solution == 1\n\n    # Flip some included items to maintain diversity\n    flip_candidates = np.where(included)[0]\n    if len(flip_candidates) > 0:\n        flip_idx = np.random.choice(flip_candidates)\n        if np.sum(weight_lst[included]) - weight_lst[flip_idx] <= capacity:\n            new_solution[flip_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.8216519304846394,
            4.486630588769913
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_v1, current_v2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate marginal utilities\n    included = new_solution == 1\n    excluded = new_solution == 0\n\n    # Calculate marginal gains for excluded items\n    marginal_v1 = value1_lst[excluded] / weight_lst[excluded]\n    marginal_v2 = value2_lst[excluded] / weight_lst[excluded]\n\n    # Rank excluded items by combined marginal utility\n    combined_marginal = marginal_v1 + marginal_v2\n    top_indices = np.argsort(combined_marginal)[-min(5, len(combined_marginal)):]\n\n    # Apply hybrid local search: swap items and flip critical ones\n    for idx in top_indices:\n        original_idx = np.where(excluded)[0][idx]\n        if weight_lst[original_idx] + np.sum(weight_lst[included]) <= capacity:\n            new_solution[original_idx] = 1\n            included = new_solution == 1\n\n    # Flip some included items to maintain diversity\n    flip_candidates = np.where(included)[0]\n    if len(flip_candidates) > 0:\n        flip_idx = np.random.choice(flip_candidates)\n        if np.sum(weight_lst[included]) - weight_lst[flip_idx] <= capacity:\n            new_solution[flip_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 124,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on its potential for local improvement, then applies a hybrid local search operator that combines item swaps and adaptive perturbations to explore the solution space while ensuring feasibility and maximizing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objective values\n        sorted_archive = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n        # Select a solution with high potential (e.g., top 30%)\n        selected_idx = min(int(0.3 * len(sorted_archive)), len(sorted_archive) - 1)\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and values\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Hybrid local search: item swaps and adaptive perturbations\n    for _ in range(10):  # Number of perturbation attempts\n        # Randomly select two items\n        item1, item2 = random.sample(range(len(new_solution)), 2)\n\n        # Calculate potential changes\n        if new_solution[item1] == 1 and new_solution[item2] == 0:\n            # Swap item1 (remove) and item2 (add)\n            new_weight = current_weight - weight_lst[item1] + weight_lst[item2]\n            if new_weight <= capacity:\n                new_solution[item1] = 0\n                new_solution[item2] = 1\n                current_weight = new_weight\n                current_value1 = current_value1 - value1_lst[item1] + value1_lst[item2]\n                current_value2 = current_value2 - value2_lst[item1] + value2_lst[item2]\n        elif new_solution[item1] == 0 and new_solution[item2] == 1:\n            # Swap item1 (add) and item2 (remove)\n            new_weight = current_weight + weight_lst[item1] - weight_lst[item2]\n            if new_weight <= capacity:\n                new_solution[item1] = 1\n                new_solution[item2] = 0\n                current_weight = new_weight\n                current_value1 = current_value1 + value1_lst[item1] - value1_lst[item2]\n                current_value2 = current_value2 + value2_lst[item1] - value2_lst[item2]\n\n    # Adaptive perturbation: add or remove a random item if capacity allows\n    if random.random() < 0.3:  # 30% chance for adaptive perturbation\n        # Try to add a new item\n        available_items = np.where(new_solution == 0)[0]\n        if len(available_items) > 0:\n            item = random.choice(available_items)\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n        # Try to remove an item\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            item = random.choice(included_items)\n            new_solution[item] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.6485101786807901,
            3.609758496284485
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objective values\n        sorted_archive = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n        # Select a solution with high potential (e.g., top 30%)\n        selected_idx = min(int(0.3 * len(sorted_archive)), len(sorted_archive) - 1)\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and values\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Hybrid local search: item swaps and adaptive perturbations\n    for _ in range(10):  # Number of perturbation attempts\n        # Randomly select two items\n        item1, item2 = random.sample(range(len(new_solution)), 2)\n\n        # Calculate potential changes\n        if new_solution[item1] == 1 and new_solution[item2] == 0:\n            # Swap item1 (remove) and item2 (add)\n            new_weight = current_weight - weight_lst[item1] + weight_lst[item2]\n            if new_weight <= capacity:\n                new_solution[item1] = 0\n                new_solution[item2] = 1\n                current_weight = new_weight\n                current_value1 = current_value1 - value1_lst[item1] + value1_lst[item2]\n                current_value2 = current_value2 - value2_lst[item1] + value2_lst[item2]\n        elif new_solution[item1] == 0 and new_solution[item2] == 1:\n            # Swap item1 (add) and item2 (remove)\n            new_weight = current_weight + weight_lst[item1] - weight_lst[item2]\n            if new_weight <= capacity:\n                new_solution[item1] = 1\n                new_solution[item2] = 0\n                current_weight = new_weight\n                current_value1 = current_value1 + value1_lst[item1] - value1_lst[item2]\n                current_value2 = current_value2 + value2_lst[item1] - value2_lst[item2]\n\n    # Adaptive perturbation: add or remove a random item if capacity allows\n    if random.random() < 0.3:  # 30% chance for adaptive perturbation\n        # Try to add a new item\n        available_items = np.where(new_solution == 0)[0]\n        if len(available_items) > 0:\n            item = random.choice(available_items)\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n        # Try to remove an item\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            item = random.choice(included_items)\n            new_solution[item] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 125,
        "algorithm": "{A novel hybrid local search operator combines adaptive item swapping with probabilistic item replacement, guided by objective-specific improvement potential and weight constraints, to intelligently explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = random.choice(archive)\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Identify items to potentially swap or replace\n    zero_indices = np.where(new_solution == 0)[0]\n    one_indices = np.where(new_solution == 1)[0]\n\n    # Hybrid local search: adaptive swapping with probabilistic replacement\n    if len(zero_indices) > 0 and len(one_indices) > 0:\n        # Try swapping one item from zero_indices with one from one_indices\n        swap_idx1 = random.choice(zero_indices)\n        swap_idx2 = random.choice(one_indices)\n\n        # Check if swapping would keep solution feasible\n        if (current_weight - weight_lst[swap_idx2] + weight_lst[swap_idx1]) <= capacity:\n            new_solution[swap_idx1], new_solution[swap_idx2] = 1, 0\n        else:\n            # If swap not feasible, try replacing an item with a higher value item\n            for idx in one_indices:\n                for candidate_idx in zero_indices:\n                    if (current_weight - weight_lst[idx] + weight_lst[candidate_idx]) <= capacity:\n                        if (value1_lst[candidate_idx] > value1_lst[idx] or value2_lst[candidate_idx] > value2_lst[idx]):\n                            new_solution[idx], new_solution[candidate_idx] = 0, 1\n                            break\n    else:\n        # If no swaps possible, try adding a new item if feasible\n        for idx in zero_indices:\n            if (current_weight + weight_lst[idx]) <= capacity:\n                new_solution[idx] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.5900606885607662,
            4.406732082366943
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = random.choice(archive)\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Identify items to potentially swap or replace\n    zero_indices = np.where(new_solution == 0)[0]\n    one_indices = np.where(new_solution == 1)[0]\n\n    # Hybrid local search: adaptive swapping with probabilistic replacement\n    if len(zero_indices) > 0 and len(one_indices) > 0:\n        # Try swapping one item from zero_indices with one from one_indices\n        swap_idx1 = random.choice(zero_indices)\n        swap_idx2 = random.choice(one_indices)\n\n        # Check if swapping would keep solution feasible\n        if (current_weight - weight_lst[swap_idx2] + weight_lst[swap_idx1]) <= capacity:\n            new_solution[swap_idx1], new_solution[swap_idx2] = 1, 0\n        else:\n            # If swap not feasible, try replacing an item with a higher value item\n            for idx in one_indices:\n                for candidate_idx in zero_indices:\n                    if (current_weight - weight_lst[idx] + weight_lst[candidate_idx]) <= capacity:\n                        if (value1_lst[candidate_idx] > value1_lst[idx] or value2_lst[candidate_idx] > value2_lst[idx]):\n                            new_solution[idx], new_solution[candidate_idx] = 0, 1\n                            break\n    else:\n        # If no swaps possible, try adding a new item if feasible\n        for idx in zero_indices:\n            if (current_weight + weight_lst[idx]) <= capacity:\n                new_solution[idx] = 1\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 126,
        "algorithm": "{The algorithm intelligently selects a solution from the archive with high potential for local improvement by evaluating the diversity and sparsity of solutions in the objective space, then applies a hybrid local search operator combining adaptive bit-flipping with a novel multi-objective perturbation strategy to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.argmax([np.sum(sol[0]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    # Step 1: Adaptive bit-flipping\n    for _ in range(3):  # Perform multiple flips\n        flip_idx = np.random.choice(len(base_solution))\n        if base_solution[flip_idx] == 1:\n            if np.sum(new_solution * weight_lst) - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n        else:\n            if np.sum(new_solution * weight_lst) + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    # Step 2: Multi-objective perturbation\n    if random.random() < 0.3:  # 30% chance for perturbation\n        # Identify items with high marginal contribution in either objective\n        marginal1 = value1_lst / (weight_lst + 1e-6)\n        marginal2 = value2_lst / (weight_lst + 1e-6)\n        combined_marginal = marginal1 + marginal2\n\n        # Select top 20% of items by combined marginal value\n        top_items = np.argsort(combined_marginal)[-max(1, len(combined_marginal) // 5):]\n\n        for idx in top_items:\n            if new_solution[idx] == 0 and np.sum(new_solution * weight_lst) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.3393226517450434,
            8.430882662534714
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.argmax([np.sum(sol[0]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    # Step 1: Adaptive bit-flipping\n    for _ in range(3):  # Perform multiple flips\n        flip_idx = np.random.choice(len(base_solution))\n        if base_solution[flip_idx] == 1:\n            if np.sum(new_solution * weight_lst) - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n        else:\n            if np.sum(new_solution * weight_lst) + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    # Step 2: Multi-objective perturbation\n    if random.random() < 0.3:  # 30% chance for perturbation\n        # Identify items with high marginal contribution in either objective\n        marginal1 = value1_lst / (weight_lst + 1e-6)\n        marginal2 = value2_lst / (weight_lst + 1e-6)\n        combined_marginal = marginal1 + marginal2\n\n        # Select top 20% of items by combined marginal value\n        top_items = np.argsort(combined_marginal)[-max(1, len(combined_marginal) // 5):]\n\n        for idx in top_items:\n            if new_solution[idx] == 0 and np.sum(new_solution * weight_lst) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 127,
        "algorithm": "{The algorithm selects a promising solution from the archive by evaluating their potential for local improvement using a hybrid of marginal value-based and diversity-aware selection, then applies a novel path-relinking-inspired local search with adaptive neighborhood exploration to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution using a hybrid of marginal value and diversity\n    selected_idx = np.random.choice(len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate marginal values for each item\n    total_weight = np.sum(weight_lst[base_solution == 1])\n    marginal_value1 = value1_lst * (1 - base_solution)\n    marginal_value2 = value2_lst * (1 - base_solution)\n    marginal_weight = weight_lst * (1 - base_solution)\n\n    # Identify items that can be added without exceeding capacity\n    feasible_add = (total_weight + marginal_weight <= capacity) & (base_solution == 0)\n\n    if np.any(feasible_add):\n        # Path-relinking-inspired local search: explore a path between current and a hypothetical better solution\n        candidates = np.where(feasible_add)[0]\n        for item in candidates:\n            if np.random.rand() < 0.7:  # Adaptive probability\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n                if total_weight > capacity:\n                    # Remove items to restore feasibility\n                    excess = total_weight - capacity\n                    remove_candidates = np.where((base_solution == 1) & (weight_lst <= excess))[0]\n                    if len(remove_candidates) > 0:\n                        remove_item = np.random.choice(remove_candidates)\n                        new_solution[remove_item] = 0\n                        total_weight -= weight_lst[remove_item]\n                    else:\n                        new_solution[item] = 0\n                        total_weight -= weight_lst[item]\n    else:\n        # If no items can be added, try removing items with low marginal value\n        remove_candidates = np.where(base_solution == 1)[0]\n        if len(remove_candidates) > 0:\n            # Remove items with lowest marginal value in either objective\n            marginal_values = marginal_value1 + marginal_value2\n            sorted_indices = np.argsort(marginal_values[remove_candidates])\n            for idx in sorted_indices[:max(1, len(remove_candidates) // 2)]:\n                item = remove_candidates[idx]\n                new_solution[item] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.9895879167708521,
            2.1358187198638916
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution using a hybrid of marginal value and diversity\n    selected_idx = np.random.choice(len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate marginal values for each item\n    total_weight = np.sum(weight_lst[base_solution == 1])\n    marginal_value1 = value1_lst * (1 - base_solution)\n    marginal_value2 = value2_lst * (1 - base_solution)\n    marginal_weight = weight_lst * (1 - base_solution)\n\n    # Identify items that can be added without exceeding capacity\n    feasible_add = (total_weight + marginal_weight <= capacity) & (base_solution == 0)\n\n    if np.any(feasible_add):\n        # Path-relinking-inspired local search: explore a path between current and a hypothetical better solution\n        candidates = np.where(feasible_add)[0]\n        for item in candidates:\n            if np.random.rand() < 0.7:  # Adaptive probability\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n                if total_weight > capacity:\n                    # Remove items to restore feasibility\n                    excess = total_weight - capacity\n                    remove_candidates = np.where((base_solution == 1) & (weight_lst <= excess))[0]\n                    if len(remove_candidates) > 0:\n                        remove_item = np.random.choice(remove_candidates)\n                        new_solution[remove_item] = 0\n                        total_weight -= weight_lst[remove_item]\n                    else:\n                        new_solution[item] = 0\n                        total_weight -= weight_lst[item]\n    else:\n        # If no items can be added, try removing items with low marginal value\n        remove_candidates = np.where(base_solution == 1)[0]\n        if len(remove_candidates) > 0:\n            # Remove items with lowest marginal value in either objective\n            marginal_values = marginal_value1 + marginal_value2\n            sorted_indices = np.argsort(marginal_values[remove_candidates])\n            for idx in sorted_indices[:max(1, len(remove_candidates) // 2)]:\n                item = remove_candidates[idx]\n                new_solution[item] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 127,
        "algorithm": "{The algorithm selects a promising solution from the archive by evaluating their potential for local improvement using a hybrid of marginal value-based and diversity-aware selection, then applies a novel path-relinking-inspired local search with adaptive neighborhood exploration to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution using a hybrid of marginal value and diversity\n    selected_idx = np.random.choice(len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate marginal values for each item\n    total_weight = np.sum(weight_lst[base_solution == 1])\n    marginal_value1 = value1_lst * (1 - base_solution)\n    marginal_value2 = value2_lst * (1 - base_solution)\n    marginal_weight = weight_lst * (1 - base_solution)\n\n    # Identify items that can be added without exceeding capacity\n    feasible_add = (total_weight + marginal_weight <= capacity) & (base_solution == 0)\n\n    if np.any(feasible_add):\n        # Path-relinking-inspired local search: explore a path between current and a hypothetical better solution\n        candidates = np.where(feasible_add)[0]\n        for item in candidates:\n            if np.random.rand() < 0.7:  # Adaptive probability\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n                if total_weight > capacity:\n                    # Remove items to restore feasibility\n                    excess = total_weight - capacity\n                    remove_candidates = np.where((base_solution == 1) & (weight_lst <= excess))[0]\n                    if len(remove_candidates) > 0:\n                        remove_item = np.random.choice(remove_candidates)\n                        new_solution[remove_item] = 0\n                        total_weight -= weight_lst[remove_item]\n                    else:\n                        new_solution[item] = 0\n                        total_weight -= weight_lst[item]\n    else:\n        # If no items can be added, try removing items with low marginal value\n        remove_candidates = np.where(base_solution == 1)[0]\n        if len(remove_candidates) > 0:\n            # Remove items with lowest marginal value in either objective\n            marginal_values = marginal_value1 + marginal_value2\n            sorted_indices = np.argsort(marginal_values[remove_candidates])\n            for idx in sorted_indices[:max(1, len(remove_candidates) // 2)]:\n                item = remove_candidates[idx]\n                new_solution[item] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.9895879167708521,
            2.1358187198638916
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution using a hybrid of marginal value and diversity\n    selected_idx = np.random.choice(len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate marginal values for each item\n    total_weight = np.sum(weight_lst[base_solution == 1])\n    marginal_value1 = value1_lst * (1 - base_solution)\n    marginal_value2 = value2_lst * (1 - base_solution)\n    marginal_weight = weight_lst * (1 - base_solution)\n\n    # Identify items that can be added without exceeding capacity\n    feasible_add = (total_weight + marginal_weight <= capacity) & (base_solution == 0)\n\n    if np.any(feasible_add):\n        # Path-relinking-inspired local search: explore a path between current and a hypothetical better solution\n        candidates = np.where(feasible_add)[0]\n        for item in candidates:\n            if np.random.rand() < 0.7:  # Adaptive probability\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n                if total_weight > capacity:\n                    # Remove items to restore feasibility\n                    excess = total_weight - capacity\n                    remove_candidates = np.where((base_solution == 1) & (weight_lst <= excess))[0]\n                    if len(remove_candidates) > 0:\n                        remove_item = np.random.choice(remove_candidates)\n                        new_solution[remove_item] = 0\n                        total_weight -= weight_lst[remove_item]\n                    else:\n                        new_solution[item] = 0\n                        total_weight -= weight_lst[item]\n    else:\n        # If no items can be added, try removing items with low marginal value\n        remove_candidates = np.where(base_solution == 1)[0]\n        if len(remove_candidates) > 0:\n            # Remove items with lowest marginal value in either objective\n            marginal_values = marginal_value1 + marginal_value2\n            sorted_indices = np.argsort(marginal_values[remove_candidates])\n            for idx in sorted_indices[:max(1, len(remove_candidates) // 2)]:\n                item = remove_candidates[idx]\n                new_solution[item] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 128,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive based on its potential for local improvement, then applies a hybrid local search operator that combines random item swaps with a novel adaptive neighborhood exploration strategy to generate high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution (here, we select one with higher potential for improvement)\n    # In practice, you might use more sophisticated criteria (e.g., crowding distance, marginal gains)\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor solution using hybrid local search\n    new_solution = selected_solution.copy()\n    n_items = len(new_solution)\n\n    # Step 1: Randomly select a subset of items to flip (1-3 items)\n    flip_indices = random.sample(range(n_items), min(3, n_items))\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 2: Flip selected items with feasibility check\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Remove item if it's in the solution\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Add item if it fits\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 3: Adaptive neighborhood exploration (flip items with high marginal gains)\n    # Calculate marginal gains for each item\n    marginal_gains = []\n    for i in range(n_items):\n        if new_solution[i] == 1:\n            # Marginal gain for removing item i\n            gain = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n            marginal_gains.append((gain, i, -1))  # -1 indicates removal\n        else:\n            # Marginal gain for adding item i\n            if current_weight + weight_lst[i] <= capacity:\n                gain = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n                marginal_gains.append((gain, i, 1))  # 1 indicates addition\n\n    # Sort by marginal gain (descending)\n    marginal_gains.sort(reverse=True, key=lambda x: x[0])\n\n    # Apply top 2 marginal gain flips (if feasible)\n    for gain, i, action in marginal_gains[:2]:\n        if action == 1 and new_solution[i] == 0:\n            new_solution[i] = 1\n            current_weight += weight_lst[i]\n        elif action == -1 and new_solution[i] == 1:\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.38287629887681873,
            4.093853920698166
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution (here, we select one with higher potential for improvement)\n    # In practice, you might use more sophisticated criteria (e.g., crowding distance, marginal gains)\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor solution using hybrid local search\n    new_solution = selected_solution.copy()\n    n_items = len(new_solution)\n\n    # Step 1: Randomly select a subset of items to flip (1-3 items)\n    flip_indices = random.sample(range(n_items), min(3, n_items))\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 2: Flip selected items with feasibility check\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Remove item if it's in the solution\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Add item if it fits\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 3: Adaptive neighborhood exploration (flip items with high marginal gains)\n    # Calculate marginal gains for each item\n    marginal_gains = []\n    for i in range(n_items):\n        if new_solution[i] == 1:\n            # Marginal gain for removing item i\n            gain = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n            marginal_gains.append((gain, i, -1))  # -1 indicates removal\n        else:\n            # Marginal gain for adding item i\n            if current_weight + weight_lst[i] <= capacity:\n                gain = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n                marginal_gains.append((gain, i, 1))  # 1 indicates addition\n\n    # Sort by marginal gain (descending)\n    marginal_gains.sort(reverse=True, key=lambda x: x[0])\n\n    # Apply top 2 marginal gain flips (if feasible)\n    for gain, i, action in marginal_gains[:2]:\n        if action == 1 and new_solution[i] == 0:\n            new_solution[i] = 1\n            current_weight += weight_lst[i]\n        elif action == -1 and new_solution[i] == 1:\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 129,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search strategy combining item swaps, flips, and probabilistic segment exchanges to generate a feasible neighbor solution while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = []\n    for sol, obj in archive:\n        current_weight = np.sum(weight_lst * sol)\n        if current_weight < capacity * 0.95:  # Not fully packed\n            candidates.append((sol, obj))\n\n    if not candidates:\n        candidates = archive  # Fallback to all solutions if none are promising\n\n    # Select a solution with high potential (e.g., high objective values or high diversity)\n    selected_idx = random.randint(0, len(candidates) - 1)\n    base_solution = candidates[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n\n    # Strategy 1: Probabilistic item flips (with weight consideration)\n    for i in range(len(new_solution)):\n        if random.random() < 0.3:  # 30% chance to flip\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    # Strategy 2: Swap with a random item from the complement\n    if random.random() < 0.5:  # 50% chance to apply swap\n        zero_indices = np.where(base_solution == 0)[0]\n        one_indices = np.where(base_solution == 1)[0]\n\n        if len(zero_indices) > 0 and len(one_indices) > 0:\n            swap_out = random.choice(one_indices)\n            swap_in = random.choice(zero_indices)\n\n            if current_weight - weight_lst[swap_out] + weight_lst[swap_in] <= capacity:\n                new_solution[swap_out] = 0\n                new_solution[swap_in] = 1\n\n    # Strategy 3: Segment exchange (random contiguous block)\n    if random.random() < 0.4:  # 40% chance to apply segment exchange\n        n_items = len(base_solution)\n        seg_length = random.randint(1, min(5, n_items // 2))  # Random segment length (1-5)\n        start_pos = random.randint(0, n_items - seg_length)\n\n        segment = base_solution[start_pos:start_pos + seg_length]\n        new_segment = 1 - segment  # Flip the segment\n\n        # Check feasibility\n        delta_weight = np.sum(weight_lst[start_pos:start_pos + seg_length] * (new_segment - segment))\n        if current_weight + delta_weight <= capacity:\n            new_solution[start_pos:start_pos + seg_length] = new_segment\n\n    # Ensure feasibility (fallback if needed)\n    new_weight = np.sum(weight_lst * new_solution)\n    if new_weight > capacity:\n        # Remove random items until feasible\n        excess = new_weight - capacity\n        while excess > 0:\n            selected_items = np.where(new_solution == 1)[0]\n            if len(selected_items) == 0:\n                break\n            item_to_remove = random.choice(selected_items)\n            new_solution[item_to_remove] = 0\n            excess -= weight_lst[item_to_remove]\n\n    return new_solution\n\n",
        "score": [
            -0.8599929985004677,
            4.882568299770355
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = []\n    for sol, obj in archive:\n        current_weight = np.sum(weight_lst * sol)\n        if current_weight < capacity * 0.95:  # Not fully packed\n            candidates.append((sol, obj))\n\n    if not candidates:\n        candidates = archive  # Fallback to all solutions if none are promising\n\n    # Select a solution with high potential (e.g., high objective values or high diversity)\n    selected_idx = random.randint(0, len(candidates) - 1)\n    base_solution = candidates[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n\n    # Strategy 1: Probabilistic item flips (with weight consideration)\n    for i in range(len(new_solution)):\n        if random.random() < 0.3:  # 30% chance to flip\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    # Strategy 2: Swap with a random item from the complement\n    if random.random() < 0.5:  # 50% chance to apply swap\n        zero_indices = np.where(base_solution == 0)[0]\n        one_indices = np.where(base_solution == 1)[0]\n\n        if len(zero_indices) > 0 and len(one_indices) > 0:\n            swap_out = random.choice(one_indices)\n            swap_in = random.choice(zero_indices)\n\n            if current_weight - weight_lst[swap_out] + weight_lst[swap_in] <= capacity:\n                new_solution[swap_out] = 0\n                new_solution[swap_in] = 1\n\n    # Strategy 3: Segment exchange (random contiguous block)\n    if random.random() < 0.4:  # 40% chance to apply segment exchange\n        n_items = len(base_solution)\n        seg_length = random.randint(1, min(5, n_items // 2))  # Random segment length (1-5)\n        start_pos = random.randint(0, n_items - seg_length)\n\n        segment = base_solution[start_pos:start_pos + seg_length]\n        new_segment = 1 - segment  # Flip the segment\n\n        # Check feasibility\n        delta_weight = np.sum(weight_lst[start_pos:start_pos + seg_length] * (new_segment - segment))\n        if current_weight + delta_weight <= capacity:\n            new_solution[start_pos:start_pos + seg_length] = new_segment\n\n    # Ensure feasibility (fallback if needed)\n    new_weight = np.sum(weight_lst * new_solution)\n    if new_weight > capacity:\n        # Remove random items until feasible\n        excess = new_weight - capacity\n        while excess > 0:\n            selected_items = np.where(new_solution == 1)[0]\n            if len(selected_items) == 0:\n                break\n            item_to_remove = random.choice(selected_items)\n            new_solution[item_to_remove] = 0\n            excess -= weight_lst[item_to_remove]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 130,
        "algorithm": "{The heuristic function selects a promising solution from the archive by prioritizing those with high objective values and low weight utilization, then applies a novel hybrid local search that combines item swapping with adaptive perturbation to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (highest sum of objectives and lowest weight utilization)\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight <= capacity:\n            candidates.append((sol, obj, total_weight))\n\n    if not candidates:\n        raise ValueError(\"No feasible solutions in archive\")\n\n    # Sort by objective sum and weight utilization\n    candidates.sort(key=lambda x: (-(x[1][0] + x[1][1]), x[2]))\n    selected_sol = candidates[0][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = selected_sol.copy()\n    n_items = len(new_solution)\n\n    # Step 1: Randomly select a subset of items to consider for perturbation\n    k = min(3, n_items)  # Number of items to consider for swapping\n    indices = random.sample(range(n_items), k)\n\n    # Step 2: For each selected item, try to swap it with another item\n    for i in indices:\n        if new_solution[i] == 1:\n            # Try to remove this item and add another\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            current_weight = np.sum(weight_lst * temp_solution)\n            available_weight = capacity - current_weight\n\n            # Find items that can be added without exceeding capacity\n            possible_additions = np.where((weight_lst <= available_weight) & (new_solution == 0))[0]\n            if len(possible_additions) > 0:\n                j = random.choice(possible_additions)\n                temp_solution[j] = 1\n                # Check if this is better than current solution\n                new_weight = np.sum(weight_lst * temp_solution)\n                if new_weight <= capacity:\n                    new_solution = temp_solution\n        else:\n            # Try to add this item if it improves objectives\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 1\n            new_weight = np.sum(weight_lst * temp_solution)\n            if new_weight <= capacity:\n                new_solution = temp_solution\n\n    # Step 3: Adaptive perturbation - flip a small number of items\n    perturbation_size = min(2, n_items)\n    flip_indices = random.sample(range(n_items), perturbation_size)\n    for i in flip_indices:\n        temp_solution = new_solution.copy()\n        temp_solution[i] = 1 - temp_solution[i]\n        new_weight = np.sum(weight_lst * temp_solution)\n        if new_weight <= capacity:\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.30651361961191403,
            5.860221415758133
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (highest sum of objectives and lowest weight utilization)\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight <= capacity:\n            candidates.append((sol, obj, total_weight))\n\n    if not candidates:\n        raise ValueError(\"No feasible solutions in archive\")\n\n    # Sort by objective sum and weight utilization\n    candidates.sort(key=lambda x: (-(x[1][0] + x[1][1]), x[2]))\n    selected_sol = candidates[0][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = selected_sol.copy()\n    n_items = len(new_solution)\n\n    # Step 1: Randomly select a subset of items to consider for perturbation\n    k = min(3, n_items)  # Number of items to consider for swapping\n    indices = random.sample(range(n_items), k)\n\n    # Step 2: For each selected item, try to swap it with another item\n    for i in indices:\n        if new_solution[i] == 1:\n            # Try to remove this item and add another\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            current_weight = np.sum(weight_lst * temp_solution)\n            available_weight = capacity - current_weight\n\n            # Find items that can be added without exceeding capacity\n            possible_additions = np.where((weight_lst <= available_weight) & (new_solution == 0))[0]\n            if len(possible_additions) > 0:\n                j = random.choice(possible_additions)\n                temp_solution[j] = 1\n                # Check if this is better than current solution\n                new_weight = np.sum(weight_lst * temp_solution)\n                if new_weight <= capacity:\n                    new_solution = temp_solution\n        else:\n            # Try to add this item if it improves objectives\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 1\n            new_weight = np.sum(weight_lst * temp_solution)\n            if new_weight <= capacity:\n                new_solution = temp_solution\n\n    # Step 3: Adaptive perturbation - flip a small number of items\n    perturbation_size = min(2, n_items)\n    flip_indices = random.sample(range(n_items), perturbation_size)\n    for i in flip_indices:\n        temp_solution = new_solution.copy()\n        temp_solution[i] = 1 - temp_solution[i]\n        new_weight = np.sum(weight_lst * temp_solution)\n        if new_weight <= capacity:\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 131,
        "algorithm": "{A hybrid local search strategy that combines intelligent random selection of promising solutions with a novel \"value-aware flip\" operator, which flips a subset of items based on their marginal contribution to both objectives, while ensuring feasibility by dynamically adjusting the selection to respect the capacity constraint.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    promising_solutions = sorted(archive, key=lambda x: x[1][0] + x[1][1], reverse=True)\n    base_solution = promising_solutions[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Identify items that can be flipped (either included or excluded)\n    candidate_items = np.where((base_solution == 1) | (base_solution == 0))[0]\n\n    # Calculate marginal contribution for each objective\n    marginal_value1 = value1_lst[candidate_items] / weight_lst[candidate_items]\n    marginal_value2 = value2_lst[candidate_items] / weight_lst[candidate_items]\n\n    # Combine marginal contributions (normalized)\n    combined_marginal = (marginal_value1 + marginal_value2) / 2\n\n    # Rank items by combined marginal contribution\n    ranked_items = np.argsort(combined_marginal)[::-1]\n\n    # Try to flip items in order of their marginal contribution\n    for item in ranked_items:\n        if base_solution[item] == 1:\n            # If item is included, try to exclude it\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # If item is excluded, try to include it\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8323613008470103,
            3.321215510368347
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    promising_solutions = sorted(archive, key=lambda x: x[1][0] + x[1][1], reverse=True)\n    base_solution = promising_solutions[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Identify items that can be flipped (either included or excluded)\n    candidate_items = np.where((base_solution == 1) | (base_solution == 0))[0]\n\n    # Calculate marginal contribution for each objective\n    marginal_value1 = value1_lst[candidate_items] / weight_lst[candidate_items]\n    marginal_value2 = value2_lst[candidate_items] / weight_lst[candidate_items]\n\n    # Combine marginal contributions (normalized)\n    combined_marginal = (marginal_value1 + marginal_value2) / 2\n\n    # Rank items by combined marginal contribution\n    ranked_items = np.argsort(combined_marginal)[::-1]\n\n    # Try to flip items in order of their marginal contribution\n    for item in ranked_items:\n        if base_solution[item] == 1:\n            # If item is included, try to exclude it\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # If item is excluded, try to include it\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 132,
        "algorithm": "{A novel hybrid local search algorithm is designed to intelligently select a promising solution from the archive and generate a neighbor by combining random item swaps, greedy marginal improvements, and adaptive perturbation to escape local optima while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[(1 - np.sum(s[0]) / len(s[0])) for s in archive])[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor via hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    items = np.arange(len(weight_lst))\n    np.random.shuffle(items)\n\n    # Phase 1: Random swap with feasibility check\n    for i in items:\n        if new_solution[i] == 1:\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Phase 2: Greedy marginal improvement\n    for _ in range(3):  # Limited iterations to balance exploration/exploitation\n        marginal_value1 = value1_lst * (1 - 2 * new_solution)\n        marginal_value2 = value2_lst * (1 - 2 * new_solution)\n        marginal_ratio = marginal_value1 / (marginal_value2 + 1e-10)  # Avoid division by zero\n\n        candidate_items = np.argsort(marginal_ratio)[-5:]  # Top 5 items by marginal ratio\n        for i in candidate_items:\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n            elif new_solution[i] == 1:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Phase 3: Adaptive perturbation (small random changes)\n    if random.random() < 0.3:  # 30% chance of perturbation\n        perturb_items = np.random.choice(len(weight_lst), size=2, replace=False)\n        for i in perturb_items:\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n            elif new_solution[i] == 1:\n                new_solution[i] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.42393370914396517,
            5.26872193813324
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[(1 - np.sum(s[0]) / len(s[0])) for s in archive])[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor via hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    items = np.arange(len(weight_lst))\n    np.random.shuffle(items)\n\n    # Phase 1: Random swap with feasibility check\n    for i in items:\n        if new_solution[i] == 1:\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Phase 2: Greedy marginal improvement\n    for _ in range(3):  # Limited iterations to balance exploration/exploitation\n        marginal_value1 = value1_lst * (1 - 2 * new_solution)\n        marginal_value2 = value2_lst * (1 - 2 * new_solution)\n        marginal_ratio = marginal_value1 / (marginal_value2 + 1e-10)  # Avoid division by zero\n\n        candidate_items = np.argsort(marginal_ratio)[-5:]  # Top 5 items by marginal ratio\n        for i in candidate_items:\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n            elif new_solution[i] == 1:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Phase 3: Adaptive perturbation (small random changes)\n    if random.random() < 0.3:  # 30% chance of perturbation\n        perturb_items = np.random.choice(len(weight_lst), size=2, replace=False)\n        for i in perturb_items:\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n            elif new_solution[i] == 1:\n                new_solution[i] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 133,
        "algorithm": "{A novel hybrid local search operator combines adaptive item swapping with probabilistic item flipping, guided by both objective values and solution density in the archive to intelligently explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution based on a combination of objective values and solution density\n    def selection_score(sol_obj):\n        sol, obj = sol_obj\n        # Normalize objectives for comparison\n        max_v1 = max(o[0] for _, o in archive) if archive else 1.0\n        max_v2 = max(o[1] for _, o in archive) if archive else 1.0\n        norm_v1 = obj[0] / max_v1 if max_v1 > 0 else 0.0\n        norm_v2 = obj[1] / max_v2 if max_v2 > 0 else 0.0\n        # Combine with solution density (count of 1s)\n        density = np.sum(sol) / len(sol)\n        return norm_v1 * 0.4 + norm_v2 * 0.4 + density * 0.2\n\n    # Sort solutions by score and select top 30% for random choice\n    scored_solutions = [(sol_obj, selection_score(sol_obj)) for sol_obj in archive]\n    scored_solutions.sort(key=lambda x: x[1], reverse=True)\n    top_solutions = [sol_obj[0] for sol_obj in scored_solutions[:max(1, len(scored_solutions) // 3)]]\n    base_solution, base_obj = top_solutions[np.random.randint(0, len(top_solutions))]\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Step 1: Adaptive item swapping (try to swap items between objectives)\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        # Find items to potentially swap\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) == 0 or len(out_items) == 0:\n            break\n\n        # Select a random item to remove and a random item to add\n        remove_idx = np.random.choice(in_items)\n        add_idx = np.random.choice(out_items)\n\n        # Check feasibility of swap\n        new_weight = current_weight - weight_lst[remove_idx] + weight_lst[add_idx]\n        if new_weight <= capacity:\n            # Accept swap if it improves at least one objective\n            new_value1 = current_value1 - value1_lst[remove_idx] + value1_lst[add_idx]\n            new_value2 = current_value2 - value2_lst[remove_idx] + value2_lst[add_idx]\n\n            if (new_value1 > current_value1) or (new_value2 > current_value2):\n                new_solution[remove_idx] = 0\n                new_solution[add_idx] = 1\n                current_weight = new_weight\n                current_value1 = new_value1\n                current_value2 = new_value2\n\n    # Step 2: Probabilistic item flipping (small perturbations)\n    for idx in range(len(new_solution)):\n        if np.random.random() < 0.1:  # 10% chance to flip each item\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] >= 0:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.4301232181438195,
            6.200871616601944
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution based on a combination of objective values and solution density\n    def selection_score(sol_obj):\n        sol, obj = sol_obj\n        # Normalize objectives for comparison\n        max_v1 = max(o[0] for _, o in archive) if archive else 1.0\n        max_v2 = max(o[1] for _, o in archive) if archive else 1.0\n        norm_v1 = obj[0] / max_v1 if max_v1 > 0 else 0.0\n        norm_v2 = obj[1] / max_v2 if max_v2 > 0 else 0.0\n        # Combine with solution density (count of 1s)\n        density = np.sum(sol) / len(sol)\n        return norm_v1 * 0.4 + norm_v2 * 0.4 + density * 0.2\n\n    # Sort solutions by score and select top 30% for random choice\n    scored_solutions = [(sol_obj, selection_score(sol_obj)) for sol_obj in archive]\n    scored_solutions.sort(key=lambda x: x[1], reverse=True)\n    top_solutions = [sol_obj[0] for sol_obj in scored_solutions[:max(1, len(scored_solutions) // 3)]]\n    base_solution, base_obj = top_solutions[np.random.randint(0, len(top_solutions))]\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Step 1: Adaptive item swapping (try to swap items between objectives)\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        # Find items to potentially swap\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) == 0 or len(out_items) == 0:\n            break\n\n        # Select a random item to remove and a random item to add\n        remove_idx = np.random.choice(in_items)\n        add_idx = np.random.choice(out_items)\n\n        # Check feasibility of swap\n        new_weight = current_weight - weight_lst[remove_idx] + weight_lst[add_idx]\n        if new_weight <= capacity:\n            # Accept swap if it improves at least one objective\n            new_value1 = current_value1 - value1_lst[remove_idx] + value1_lst[add_idx]\n            new_value2 = current_value2 - value2_lst[remove_idx] + value2_lst[add_idx]\n\n            if (new_value1 > current_value1) or (new_value2 > current_value2):\n                new_solution[remove_idx] = 0\n                new_solution[add_idx] = 1\n                current_weight = new_weight\n                current_value1 = new_value1\n                current_value2 = new_value2\n\n    # Step 2: Probabilistic item flipping (small perturbations)\n    for idx in range(len(new_solution)):\n        if np.random.random() < 0.1:  # 10% chance to flip each item\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] >= 0:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 134,
        "algorithm": "{A novel hybrid local search operator that combines adaptive item swapping, objective-aware perturbation, and diversity-preserving moves to intelligently explore the solution space while ensuring feasibility and promoting Pareto front progression.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution with high potential for improvement\n    def potential_score(solution, objective):\n        current_weight = np.sum(weight_lst * solution)\n        potential1 = np.sum(value1_lst * (1 - solution))\n        potential2 = np.sum(value2_lst * (1 - solution))\n        return (potential1 + potential2) * (1 - current_weight / capacity)\n\n    scored_solutions = [(solution, objective, potential_score(solution, objective)) for solution, objective in archive]\n    scored_solutions.sort(key=lambda x: x[2], reverse=True)\n\n    # Select top 20% of solutions for further consideration\n    top_solutions = scored_solutions[:max(1, len(scored_solutions) // 5)]\n    selected = random.choice(top_solutions)[0].copy()\n\n    # Hybrid local search operator\n    new_solution = selected.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 1: Objective-aware item swapping\n    for _ in range(3):  # Perform 3 swaps\n        # Find items to swap based on objective dominance\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Select items with high value in either objective\n            in_item = random.choice(in_items)\n            out_item = random.choice(out_items)\n\n            # Check if swap is feasible\n            temp_weight = current_weight - weight_lst[in_item] + weight_lst[out_item]\n            if temp_weight <= capacity:\n                new_solution[in_item] = 0\n                new_solution[out_item] = 1\n                current_weight = temp_weight\n\n    # Step 2: Adaptive perturbation\n    # Randomly flip items to escape local optima\n    for _ in range(2):  # Perform 2 flips\n        candidates = np.where(weight_lst <= capacity - current_weight + np.sum(weight_lst * new_solution))[0]\n        if len(candidates) > 0:\n            item = random.choice(candidates)\n            new_solution[item] = 1 - new_solution[item]\n\n    # Ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        in_items = np.where(new_solution == 1)[0]\n        if len(in_items) > 0:\n            item = random.choice(in_items)\n            new_solution[item] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.3711270134221961,
            4.874007761478424
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution with high potential for improvement\n    def potential_score(solution, objective):\n        current_weight = np.sum(weight_lst * solution)\n        potential1 = np.sum(value1_lst * (1 - solution))\n        potential2 = np.sum(value2_lst * (1 - solution))\n        return (potential1 + potential2) * (1 - current_weight / capacity)\n\n    scored_solutions = [(solution, objective, potential_score(solution, objective)) for solution, objective in archive]\n    scored_solutions.sort(key=lambda x: x[2], reverse=True)\n\n    # Select top 20% of solutions for further consideration\n    top_solutions = scored_solutions[:max(1, len(scored_solutions) // 5)]\n    selected = random.choice(top_solutions)[0].copy()\n\n    # Hybrid local search operator\n    new_solution = selected.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 1: Objective-aware item swapping\n    for _ in range(3):  # Perform 3 swaps\n        # Find items to swap based on objective dominance\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Select items with high value in either objective\n            in_item = random.choice(in_items)\n            out_item = random.choice(out_items)\n\n            # Check if swap is feasible\n            temp_weight = current_weight - weight_lst[in_item] + weight_lst[out_item]\n            if temp_weight <= capacity:\n                new_solution[in_item] = 0\n                new_solution[out_item] = 1\n                current_weight = temp_weight\n\n    # Step 2: Adaptive perturbation\n    # Randomly flip items to escape local optima\n    for _ in range(2):  # Perform 2 flips\n        candidates = np.where(weight_lst <= capacity - current_weight + np.sum(weight_lst * new_solution))[0]\n        if len(candidates) > 0:\n            item = random.choice(candidates)\n            new_solution[item] = 1 - new_solution[item]\n\n    # Ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        in_items = np.where(new_solution == 1)[0]\n        if len(in_items) > 0:\n            item = random.choice(in_items)\n            new_solution[item] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 135,
        "algorithm": "{The heuristic function selects a promising solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search strategy that combines item swapping and adaptive flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not too close to the frontier)\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[(max(v1, v2) - min(v1, v2)) for (_, (v1, v2)) in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Hybrid local search: adaptive flipping + item swapping\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Adaptive flipping: flip items with high marginal utility\n    marginal_utility1 = value1_lst / weight_lst\n    marginal_utility2 = value2_lst / weight_lst\n    combined_utility = marginal_utility1 + marginal_utility2\n\n    for i in np.argsort(combined_utility)[::-1]:\n        if new_solution[i] == 1:\n            if total_weight - weight_lst[i] >= 0:\n                new_solution[i] = 0\n                total_weight -= weight_lst[i]\n        else:\n            if total_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                total_weight += weight_lst[i]\n\n    # Item swapping: swap items between included and excluded\n    included = np.where(new_solution == 1)[0]\n    excluded = np.where(new_solution == 0)[0]\n\n    if len(included) > 0 and len(excluded) > 0:\n        swap_candidate1 = random.choice(included)\n        swap_candidate2 = random.choice(excluded)\n\n        if (total_weight - weight_lst[swap_candidate1] + weight_lst[swap_candidate2]) <= capacity:\n            new_solution[swap_candidate1] = 0\n            new_solution[swap_candidate2] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8901497298681227,
            4.590007454156876
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not too close to the frontier)\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[(max(v1, v2) - min(v1, v2)) for (_, (v1, v2)) in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Hybrid local search: adaptive flipping + item swapping\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Adaptive flipping: flip items with high marginal utility\n    marginal_utility1 = value1_lst / weight_lst\n    marginal_utility2 = value2_lst / weight_lst\n    combined_utility = marginal_utility1 + marginal_utility2\n\n    for i in np.argsort(combined_utility)[::-1]:\n        if new_solution[i] == 1:\n            if total_weight - weight_lst[i] >= 0:\n                new_solution[i] = 0\n                total_weight -= weight_lst[i]\n        else:\n            if total_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                total_weight += weight_lst[i]\n\n    # Item swapping: swap items between included and excluded\n    included = np.where(new_solution == 1)[0]\n    excluded = np.where(new_solution == 0)[0]\n\n    if len(included) > 0 and len(excluded) > 0:\n        swap_candidate1 = random.choice(included)\n        swap_candidate2 = random.choice(excluded)\n\n        if (total_weight - weight_lst[swap_candidate1] + weight_lst[swap_candidate2]) <= capacity:\n            new_solution[swap_candidate1] = 0\n            new_solution[swap_candidate2] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 136,
        "algorithm": "{The heuristic function selects a promising solution from the archive based on its potential for local improvement, then applies a hybrid local search strategy that combines item swapping and adaptive neighborhood exploration to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by a combination of objective values and solution density\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / np.sum(x[0]))\n        # Select a solution that is not too crowded\n        selected_idx = min(len(archive_sorted) // 2, len(archive_sorted) - 1)\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: combine item swapping and adaptive neighborhood exploration\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Randomly select an item to flip (swap in/out)\n        candidate_items = np.where(base_solution == 1)[0]\n        if len(candidate_items) == 0:\n            candidate_items = np.arange(len(base_solution))\n        item_to_flip = random.choice(candidate_items)\n\n        # Calculate potential change in weight\n        delta_weight = weight_lst[item_to_flip] * (-1 if base_solution[item_to_flip] == 1 else 1)\n\n        # Check feasibility\n        if current_weight + delta_weight <= capacity:\n            new_solution[item_to_flip] = 1 - new_solution[item_to_flip]\n            current_weight += delta_weight\n\n            # Adaptive neighborhood exploration: add/remove related items\n            if new_solution[item_to_flip] == 1:\n                # Add items with high value-to-weight ratio\n                remaining_items = np.where(new_solution == 0)[0]\n                if len(remaining_items) > 0:\n                    value_ratios = (value1_lst[remaining_items] + value2_lst[remaining_items]) / weight_lst[remaining_items]\n                    best_add = remaining_items[np.argmax(value_ratios)]\n                    if current_weight + weight_lst[best_add] <= capacity:\n                        new_solution[best_add] = 1\n                        current_weight += weight_lst[best_add]\n            else:\n                # Remove items with low value-to-weight ratio\n                included_items = np.where(new_solution == 1)[0]\n                if len(included_items) > 0:\n                    value_ratios = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n                    worst_remove = included_items[np.argmin(value_ratios)]\n                    new_solution[worst_remove] = 0\n                    current_weight -= weight_lst[worst_remove]\n\n    return new_solution\n\n",
        "score": [
            -0.8197529672133055,
            7.357125222682953
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by a combination of objective values and solution density\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / np.sum(x[0]))\n        # Select a solution that is not too crowded\n        selected_idx = min(len(archive_sorted) // 2, len(archive_sorted) - 1)\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: combine item swapping and adaptive neighborhood exploration\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Randomly select an item to flip (swap in/out)\n        candidate_items = np.where(base_solution == 1)[0]\n        if len(candidate_items) == 0:\n            candidate_items = np.arange(len(base_solution))\n        item_to_flip = random.choice(candidate_items)\n\n        # Calculate potential change in weight\n        delta_weight = weight_lst[item_to_flip] * (-1 if base_solution[item_to_flip] == 1 else 1)\n\n        # Check feasibility\n        if current_weight + delta_weight <= capacity:\n            new_solution[item_to_flip] = 1 - new_solution[item_to_flip]\n            current_weight += delta_weight\n\n            # Adaptive neighborhood exploration: add/remove related items\n            if new_solution[item_to_flip] == 1:\n                # Add items with high value-to-weight ratio\n                remaining_items = np.where(new_solution == 0)[0]\n                if len(remaining_items) > 0:\n                    value_ratios = (value1_lst[remaining_items] + value2_lst[remaining_items]) / weight_lst[remaining_items]\n                    best_add = remaining_items[np.argmax(value_ratios)]\n                    if current_weight + weight_lst[best_add] <= capacity:\n                        new_solution[best_add] = 1\n                        current_weight += weight_lst[best_add]\n            else:\n                # Remove items with low value-to-weight ratio\n                included_items = np.where(new_solution == 1)[0]\n                if len(included_items) > 0:\n                    value_ratios = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n                    worst_remove = included_items[np.argmin(value_ratios)]\n                    new_solution[worst_remove] = 0\n                    current_weight -= weight_lst[worst_remove]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 137,
        "algorithm": "{A hybrid local search algorithm that intelligently selects a solution from the archive, then applies a novel two-phase perturbation: first, it flips a random subset of items to explore the neighborhood, and second, it performs a greedy repair to ensure feasibility while maximizing marginal gains in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Sort solutions by the sum of normalized objectives to identify promising candidates\n        normalized_objs = [(obj[0] + obj[1]) / (np.sum(value1_lst) + np.sum(value2_lst)) for _, obj in archive]\n        sorted_indices = np.argsort(normalized_objs)[::-1]  # Descending order\n        # Select from top 30% of solutions\n        top_k = max(1, len(archive) // 3)\n        selected_idx = random.choice(sorted_indices[:top_k])\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    # Phase 1: Random perturbation (flip a random subset of items)\n    num_items = len(weight_lst)\n    flip_indices = random.sample(range(num_items), min(num_items // 4, num_items))  # Flip up to 25% of items\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Phase 2: Greedy repair to ensure feasibility and maximize marginal gains\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items until feasible, prioritizing those with lowest marginal gain\n        excess = current_weight - capacity\n        items_sorted = np.argsort((value1_lst + value2_lst) * new_solution)  # Sort by total value\n        for idx in items_sorted[::-1]:  # Remove highest-value items first\n            if new_solution[idx] == 1 and excess <= 0:\n                break\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                excess -= weight_lst[idx]\n\n    # Add items if possible to improve objectives (greedy addition)\n    remaining_weight = capacity - np.sum(weight_lst * new_solution)\n    if remaining_weight > 0:\n        # Sort by marginal gain (value1 + value2) / weight\n        marginal_gains = (value1_lst + value2_lst) / (weight_lst + 1e-10)  # Avoid division by zero\n        items_sorted = np.argsort(marginal_gains)[::-1]  # Descending order\n        for idx in items_sorted:\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_weight:\n                new_solution[idx] = 1\n                remaining_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5360135407111197,
            4.397190630435944
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Sort solutions by the sum of normalized objectives to identify promising candidates\n        normalized_objs = [(obj[0] + obj[1]) / (np.sum(value1_lst) + np.sum(value2_lst)) for _, obj in archive]\n        sorted_indices = np.argsort(normalized_objs)[::-1]  # Descending order\n        # Select from top 30% of solutions\n        top_k = max(1, len(archive) // 3)\n        selected_idx = random.choice(sorted_indices[:top_k])\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    # Phase 1: Random perturbation (flip a random subset of items)\n    num_items = len(weight_lst)\n    flip_indices = random.sample(range(num_items), min(num_items // 4, num_items))  # Flip up to 25% of items\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Phase 2: Greedy repair to ensure feasibility and maximize marginal gains\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items until feasible, prioritizing those with lowest marginal gain\n        excess = current_weight - capacity\n        items_sorted = np.argsort((value1_lst + value2_lst) * new_solution)  # Sort by total value\n        for idx in items_sorted[::-1]:  # Remove highest-value items first\n            if new_solution[idx] == 1 and excess <= 0:\n                break\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                excess -= weight_lst[idx]\n\n    # Add items if possible to improve objectives (greedy addition)\n    remaining_weight = capacity - np.sum(weight_lst * new_solution)\n    if remaining_weight > 0:\n        # Sort by marginal gain (value1 + value2) / weight\n        marginal_gains = (value1_lst + value2_lst) / (weight_lst + 1e-10)  # Avoid division by zero\n        items_sorted = np.argsort(marginal_gains)[::-1]  # Descending order\n        for idx in items_sorted:\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_weight:\n                new_solution[idx] = 1\n                remaining_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 138,
        "algorithm": "{The algorithm selects a promising solution from the archive by evaluating their potential for local improvement through a hybrid strategy combining item swaps and probabilistic flips, ensuring feasibility while maximizing both objectives through iterative refinement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution from the archive with a bias towards higher potential\n    selected_idx = random.choices(range(len(archive)), weights=[(1 - (i / len(archive))) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: swap items or flip based on potential improvement\n    new_solution = base_solution.copy()\n\n    # First, try to swap items to improve both objectives\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        # Select two random items to swap\n        item1, item2 = random.sample(range(len(base_solution)), 2)\n\n        # Check if swapping would improve both objectives\n        if base_solution[item1] != base_solution[item2]:\n            temp_weight = current_weight - weight_lst[item1] + weight_lst[item2]\n            if temp_weight <= capacity:\n                new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n                current_weight = temp_weight\n                break\n\n    # If no swap improved, try probabilistic flips\n    for _ in range(3):\n        item = random.randint(0, len(base_solution) - 1)\n        if base_solution[item] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.32970791605094707,
            2.927681624889374
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution from the archive with a bias towards higher potential\n    selected_idx = random.choices(range(len(archive)), weights=[(1 - (i / len(archive))) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: swap items or flip based on potential improvement\n    new_solution = base_solution.copy()\n\n    # First, try to swap items to improve both objectives\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        # Select two random items to swap\n        item1, item2 = random.sample(range(len(base_solution)), 2)\n\n        # Check if swapping would improve both objectives\n        if base_solution[item1] != base_solution[item2]:\n            temp_weight = current_weight - weight_lst[item1] + weight_lst[item2]\n            if temp_weight <= capacity:\n                new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n                current_weight = temp_weight\n                break\n\n    # If no swap improved, try probabilistic flips\n    for _ in range(3):\n        item = random.randint(0, len(base_solution) - 1)\n        if base_solution[item] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 139,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high objective values, then applies a hybrid local search operator that combines item swaps and multi-objective-aware perturbations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine item swaps and multi-objective perturbations\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Randomly swap items between included and excluded\n    for _ in range(2):  # Perform 2 swaps\n        included = np.where(new_solution == 1)[0]\n        excluded = np.where(new_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            swap_in = np.random.choice(included)\n            swap_out = np.random.choice(excluded)\n\n            # Check feasibility\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n                current_weight = new_weight\n\n    # Step 2: Multi-objective-aware perturbation\n    # Identify items with high marginal contribution to either objective\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n\n    # Combine marginal contributions with a random weight to balance objectives\n    alpha = np.random.random()\n    combined_marginal = alpha * marginal1 + (1 - alpha) * marginal2\n\n    # Select top items to consider adding (if not already included)\n    top_items = np.argsort(combined_marginal)[-3:]  # Consider top 3 items\n\n    for item in top_items:\n        if new_solution[item] == 0 and (current_weight + weight_lst[item] <= capacity):\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.33055776978246987,
            9.06116795539856
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine item swaps and multi-objective perturbations\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Randomly swap items between included and excluded\n    for _ in range(2):  # Perform 2 swaps\n        included = np.where(new_solution == 1)[0]\n        excluded = np.where(new_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            swap_in = np.random.choice(included)\n            swap_out = np.random.choice(excluded)\n\n            # Check feasibility\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n                current_weight = new_weight\n\n    # Step 2: Multi-objective-aware perturbation\n    # Identify items with high marginal contribution to either objective\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n\n    # Combine marginal contributions with a random weight to balance objectives\n    alpha = np.random.random()\n    combined_marginal = alpha * marginal1 + (1 - alpha) * marginal2\n\n    # Select top items to consider adding (if not already included)\n    top_items = np.argsort(combined_marginal)[-3:]  # Consider top 3 items\n\n    for item in top_items:\n        if new_solution[item] == 0 and (current_weight + weight_lst[item] <= capacity):\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 140,
        "algorithm": "{A novel hybrid local search strategy is designed to intelligently select a promising solution from the archive, then apply a combination of item swaps and cluster-based perturbations to explore high-quality neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Intelligently select a solution with high potential for improvement\n        # Here, we select the solution with the highest sum of normalized objective values\n        objectives = np.array([obj for _, obj in archive])\n        normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n        scores = np.sum(normalized, axis=1)\n        selected_idx = np.argmax(scores)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    # Hybrid approach: combination of item swaps and cluster-based perturbations\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Cluster-based perturbation: group items and flip a cluster\n    if n_items > 1:\n        # Create clusters based on value ratios (value1/value2)\n        value_ratios = value1_lst / (value2_lst + 1e-10)\n        sorted_indices = np.argsort(value_ratios)\n        cluster_size = max(1, n_items // 5)  # Dynamic cluster size\n        cluster_start = random.randint(0, n_items - cluster_size)\n        cluster_indices = sorted_indices[cluster_start:cluster_start + cluster_size]\n\n        # Flip the cluster with feasibility check\n        for idx in cluster_indices:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] >= 0:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    # Additional item swaps for fine-tuning\n    if n_items > 1:\n        # Select two random items to swap\n        idx1, idx2 = random.sample(range(n_items), 2)\n        if new_solution[idx1] != new_solution[idx2]:\n            # Check feasibility before swapping\n            if new_solution[idx1] == 1 and new_solution[idx2] == 0:\n                if current_weight - weight_lst[idx1] + weight_lst[idx2] <= capacity:\n                    new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n            elif new_solution[idx1] == 0 and new_solution[idx2] == 1:\n                if current_weight + weight_lst[idx1] - weight_lst[idx2] <= capacity:\n                    new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    return new_solution\n\n",
        "score": [
            -0.34029351811852315,
            4.032483249902725
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Intelligently select a solution with high potential for improvement\n        # Here, we select the solution with the highest sum of normalized objective values\n        objectives = np.array([obj for _, obj in archive])\n        normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n        scores = np.sum(normalized, axis=1)\n        selected_idx = np.argmax(scores)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    # Hybrid approach: combination of item swaps and cluster-based perturbations\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Cluster-based perturbation: group items and flip a cluster\n    if n_items > 1:\n        # Create clusters based on value ratios (value1/value2)\n        value_ratios = value1_lst / (value2_lst + 1e-10)\n        sorted_indices = np.argsort(value_ratios)\n        cluster_size = max(1, n_items // 5)  # Dynamic cluster size\n        cluster_start = random.randint(0, n_items - cluster_size)\n        cluster_indices = sorted_indices[cluster_start:cluster_start + cluster_size]\n\n        # Flip the cluster with feasibility check\n        for idx in cluster_indices:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] >= 0:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    # Additional item swaps for fine-tuning\n    if n_items > 1:\n        # Select two random items to swap\n        idx1, idx2 = random.sample(range(n_items), 2)\n        if new_solution[idx1] != new_solution[idx2]:\n            # Check feasibility before swapping\n            if new_solution[idx1] == 1 and new_solution[idx2] == 0:\n                if current_weight - weight_lst[idx1] + weight_lst[idx2] <= capacity:\n                    new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n            elif new_solution[idx1] == 0 and new_solution[idx2] == 1:\n                if current_weight + weight_lst[idx1] - weight_lst[idx2] <= capacity:\n                    new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 141,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive based on its objective values and applies a hybrid local search operator that combines swap-based moves with a novel adaptive perturbation strategy to generate high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    def selection_criterion(sol_obj):\n        # Prioritize solutions with higher total objective values\n        return sol_obj[1][0] + sol_obj[1][1]\n\n    # Sort solutions by the selection criterion\n    sorted_archive = sorted(archive, key=selection_criterion, reverse=True)\n    # Select top 20% of solutions\n    top_solutions = sorted_archive[:max(1, len(sorted_archive) // 5)]\n    # Randomly select one from top solutions\n    selected = random.choice(top_solutions)\n    base_solution = selected[0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Swap-based move (swap two items)\n    items_in = np.where(new_solution == 1)[0]\n    items_out = np.where(new_solution == 0)[0]\n\n    if len(items_in) > 1 and len(items_out) > 0:\n        # Randomly select two items to swap\n        item_to_remove = random.choice(items_in)\n        item_to_add = random.choice(items_out)\n\n        # Calculate weight difference\n        weight_diff = weight_lst[item_to_add] - weight_lst[item_to_remove]\n\n        # Check feasibility\n        if current_weight + weight_diff <= capacity:\n            new_solution[item_to_remove] = 0\n            new_solution[item_to_add] = 1\n            current_weight += weight_diff\n\n    # Step 2: Adaptive perturbation (flip a small number of items)\n    perturbation_size = min(3, len(new_solution) // 10)  # Adaptive size\n    candidates = np.where(new_solution == 1)[0]\n    if len(candidates) > perturbation_size:\n        # Randomly select items to flip\n        items_to_flip = random.sample(list(candidates), perturbation_size)\n        for item in items_to_flip:\n            # Calculate weight difference\n            weight_diff = -weight_lst[item]\n            if current_weight + weight_diff <= capacity:\n                new_solution[item] = 0\n                current_weight += weight_diff\n\n    # Step 3: Add one more item if possible\n    items_out = np.where(new_solution == 0)[0]\n    if len(items_out) > 0:\n        item_to_add = random.choice(items_out)\n        if current_weight + weight_lst[item_to_add] <= capacity:\n            new_solution[item_to_add] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.504303600062142,
            2.365375727415085
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    def selection_criterion(sol_obj):\n        # Prioritize solutions with higher total objective values\n        return sol_obj[1][0] + sol_obj[1][1]\n\n    # Sort solutions by the selection criterion\n    sorted_archive = sorted(archive, key=selection_criterion, reverse=True)\n    # Select top 20% of solutions\n    top_solutions = sorted_archive[:max(1, len(sorted_archive) // 5)]\n    # Randomly select one from top solutions\n    selected = random.choice(top_solutions)\n    base_solution = selected[0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Swap-based move (swap two items)\n    items_in = np.where(new_solution == 1)[0]\n    items_out = np.where(new_solution == 0)[0]\n\n    if len(items_in) > 1 and len(items_out) > 0:\n        # Randomly select two items to swap\n        item_to_remove = random.choice(items_in)\n        item_to_add = random.choice(items_out)\n\n        # Calculate weight difference\n        weight_diff = weight_lst[item_to_add] - weight_lst[item_to_remove]\n\n        # Check feasibility\n        if current_weight + weight_diff <= capacity:\n            new_solution[item_to_remove] = 0\n            new_solution[item_to_add] = 1\n            current_weight += weight_diff\n\n    # Step 2: Adaptive perturbation (flip a small number of items)\n    perturbation_size = min(3, len(new_solution) // 10)  # Adaptive size\n    candidates = np.where(new_solution == 1)[0]\n    if len(candidates) > perturbation_size:\n        # Randomly select items to flip\n        items_to_flip = random.sample(list(candidates), perturbation_size)\n        for item in items_to_flip:\n            # Calculate weight difference\n            weight_diff = -weight_lst[item]\n            if current_weight + weight_diff <= capacity:\n                new_solution[item] = 0\n                current_weight += weight_diff\n\n    # Step 3: Add one more item if possible\n    items_out = np.where(new_solution == 0)[0]\n    if len(items_out) > 0:\n        item_to_add = random.choice(items_out)\n        if current_weight + weight_lst[item_to_add] <= capacity:\n            new_solution[item_to_add] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 142,
        "algorithm": "{The heuristic function selects a promising solution from the archive based on a diversity-aware fitness score, then applies a hybrid local search operator combining bit-flip and swap moves to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a base solution with a bias toward diversity\n    base_solution, _ = max(archive, key=lambda x: np.sum(x[0] != archive[0][0]))\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: probabilistic bit-flip and swap\n    for _ in range(min(5, len(new_solution))):\n        # Probabilistic bit-flip\n        if random.random() < 0.7:\n            idx = random.randint(0, len(new_solution)-1)\n            if new_solution[idx] == 1:\n                if np.sum(new_solution * weight_lst) - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n            else:\n                if np.sum(new_solution * weight_lst) + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n\n        # Probabilistic swap\n        if random.random() < 0.3:\n            idx1, idx2 = random.sample(range(len(new_solution)), 2)\n            if new_solution[idx1] != new_solution[idx2]:\n                # Check feasibility after swap\n                if (new_solution[idx1] == 1 and np.sum(new_solution * weight_lst) - weight_lst[idx1] + weight_lst[idx2] <= capacity) or \\\n                   (new_solution[idx2] == 1 and np.sum(new_solution * weight_lst) - weight_lst[idx2] + weight_lst[idx1] <= capacity):\n                    new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    return new_solution\n\n",
        "score": [
            -0.7262889916527024,
            7.2123900055885315
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a base solution with a bias toward diversity\n    base_solution, _ = max(archive, key=lambda x: np.sum(x[0] != archive[0][0]))\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: probabilistic bit-flip and swap\n    for _ in range(min(5, len(new_solution))):\n        # Probabilistic bit-flip\n        if random.random() < 0.7:\n            idx = random.randint(0, len(new_solution)-1)\n            if new_solution[idx] == 1:\n                if np.sum(new_solution * weight_lst) - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n            else:\n                if np.sum(new_solution * weight_lst) + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n\n        # Probabilistic swap\n        if random.random() < 0.3:\n            idx1, idx2 = random.sample(range(len(new_solution)), 2)\n            if new_solution[idx1] != new_solution[idx2]:\n                # Check feasibility after swap\n                if (new_solution[idx1] == 1 and np.sum(new_solution * weight_lst) - weight_lst[idx1] + weight_lst[idx2] <= capacity) or \\\n                   (new_solution[idx2] == 1 and np.sum(new_solution * weight_lst) - weight_lst[idx2] + weight_lst[idx1] <= capacity):\n                    new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 143,
        "algorithm": "{A novel hybrid local search strategy combines adaptive neighborhood exploration with probabilistic item swaps, guided by a dynamic utility function that balances marginal gains in both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, randomly for simplicity, but can be enhanced)\n    selected_solution, _ = random.choice(archive)\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Identify items to consider for swapping\n    items = np.arange(len(new_solution))\n    in_knapsack = items[new_solution == 1]\n    out_knapsack = items[new_solution == 0]\n\n    # Adaptive neighborhood exploration\n    for _ in range(5):  # Number of attempts to find a better neighbor\n        if len(in_knapsack) > 0 and len(out_knapsack) > 0:\n            # Randomly select one item to remove and one to add\n            item_to_remove = random.choice(in_knapsack)\n            item_to_add = random.choice(out_knapsack)\n\n            # Check feasibility\n            new_weight = current_weight - weight_lst[item_to_remove] + weight_lst[item_to_add]\n            if new_weight <= capacity:\n                # Calculate marginal gains\n                marginal_gain1 = value1_lst[item_to_add] - value1_lst[item_to_remove]\n                marginal_gain2 = value2_lst[item_to_add] - value2_lst[item_to_remove]\n\n                # Apply probabilistic acceptance based on marginal gains\n                if marginal_gain1 > 0 or marginal_gain2 > 0:\n                    new_solution[item_to_remove] = 0\n                    new_solution[item_to_add] = 1\n                    current_weight = new_weight\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.44194447874209797,
            2.9081555008888245
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, randomly for simplicity, but can be enhanced)\n    selected_solution, _ = random.choice(archive)\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Identify items to consider for swapping\n    items = np.arange(len(new_solution))\n    in_knapsack = items[new_solution == 1]\n    out_knapsack = items[new_solution == 0]\n\n    # Adaptive neighborhood exploration\n    for _ in range(5):  # Number of attempts to find a better neighbor\n        if len(in_knapsack) > 0 and len(out_knapsack) > 0:\n            # Randomly select one item to remove and one to add\n            item_to_remove = random.choice(in_knapsack)\n            item_to_add = random.choice(out_knapsack)\n\n            # Check feasibility\n            new_weight = current_weight - weight_lst[item_to_remove] + weight_lst[item_to_add]\n            if new_weight <= capacity:\n                # Calculate marginal gains\n                marginal_gain1 = value1_lst[item_to_add] - value1_lst[item_to_remove]\n                marginal_gain2 = value2_lst[item_to_add] - value2_lst[item_to_remove]\n\n                # Apply probabilistic acceptance based on marginal gains\n                if marginal_gain1 > 0 or marginal_gain2 > 0:\n                    new_solution[item_to_remove] = 0\n                    new_solution[item_to_add] = 1\n                    current_weight = new_weight\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 144,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive to perform a hybrid local search by combining item swaps with a probabilistic reinsertion of items based on their marginal contributions to both objectives, ensuring feasibility and diversity in the generated neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Rank solutions by their combined objective values\n        ranked_solutions = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n        # Select top 30% for potential selection\n        top_candidates = ranked_solutions[:max(1, len(ranked_solutions) // 3)]\n        # Select a random candidate from the top 30%\n        base_solution = random.choice(top_candidates)[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Get current weight and values\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Identify items not in the solution\n    excluded_items = np.where(new_solution == 0)[0]\n\n    # Hybrid local search: swap items or reinsert with probability\n    if len(excluded_items) > 0 and random.random() < 0.7:  # 70% chance to reinsert\n        # Select an item to potentially add\n        candidate_item = random.choice(excluded_items)\n        if current_weight + weight_lst[candidate_item] <= capacity:\n            new_solution[candidate_item] = 1\n            current_weight += weight_lst[candidate_item]\n            current_value1 += value1_lst[candidate_item]\n            current_value2 += value2_lst[candidate_item]\n\n            # Optionally remove an item to maintain diversity\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) > 1 and random.random() < 0.5:  # 50% chance to remove\n                item_to_remove = random.choice(included_items)\n                new_solution[item_to_remove] = 0\n                current_weight -= weight_lst[item_to_remove]\n                current_value1 -= value1_lst[item_to_remove]\n                current_value2 -= value2_lst[item_to_remove]\n    else:\n        # Perform a swap between included and excluded items\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0 and len(excluded_items) > 0:\n            item_in = random.choice(included_items)\n            item_out = random.choice(excluded_items)\n\n            # Check feasibility of swap\n            if (current_weight - weight_lst[item_in] + weight_lst[item_out]) <= capacity:\n                new_solution[item_in] = 0\n                new_solution[item_out] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.28110856234530424,
            10.540932208299637
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Rank solutions by their combined objective values\n        ranked_solutions = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n        # Select top 30% for potential selection\n        top_candidates = ranked_solutions[:max(1, len(ranked_solutions) // 3)]\n        # Select a random candidate from the top 30%\n        base_solution = random.choice(top_candidates)[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Get current weight and values\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Identify items not in the solution\n    excluded_items = np.where(new_solution == 0)[0]\n\n    # Hybrid local search: swap items or reinsert with probability\n    if len(excluded_items) > 0 and random.random() < 0.7:  # 70% chance to reinsert\n        # Select an item to potentially add\n        candidate_item = random.choice(excluded_items)\n        if current_weight + weight_lst[candidate_item] <= capacity:\n            new_solution[candidate_item] = 1\n            current_weight += weight_lst[candidate_item]\n            current_value1 += value1_lst[candidate_item]\n            current_value2 += value2_lst[candidate_item]\n\n            # Optionally remove an item to maintain diversity\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) > 1 and random.random() < 0.5:  # 50% chance to remove\n                item_to_remove = random.choice(included_items)\n                new_solution[item_to_remove] = 0\n                current_weight -= weight_lst[item_to_remove]\n                current_value1 -= value1_lst[item_to_remove]\n                current_value2 -= value2_lst[item_to_remove]\n    else:\n        # Perform a swap between included and excluded items\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0 and len(excluded_items) > 0:\n            item_in = random.choice(included_items)\n            item_out = random.choice(excluded_items)\n\n            # Check feasibility of swap\n            if (current_weight - weight_lst[item_in] + weight_lst[item_out]) <= capacity:\n                new_solution[item_in] = 0\n                new_solution[item_out] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 145,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive based on diversity and potential for improvement, then applies a hybrid local search operator that combines item swaps with adaptive perturbation to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 0:\n        selected_idx = random.randint(0, len(archive) - 1)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = np.zeros_like(weight_lst, dtype=int)\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: item swaps with adaptive perturbation\n    num_items = len(weight_lst)\n    if num_items < 2:\n        return new_solution\n\n    # Step 1: Randomly select a subset of items to consider for swapping\n    subset_size = min(10, num_items)\n    subset_indices = random.sample(range(num_items), subset_size)\n\n    # Step 2: Evaluate potential swaps (flip 0 to 1 or 1 to 0) and choose the best feasible swap\n    best_swap = None\n    best_improvement = 0\n\n    for idx in subset_indices:\n        current_status = new_solution[idx]\n        new_status = 1 - current_status\n\n        # Calculate new weight and values\n        delta_weight = (new_status - current_status) * weight_lst[idx]\n        new_weight = np.sum(new_solution * weight_lst) + delta_weight\n\n        if new_weight > capacity:\n            continue  # Skip if infeasible\n\n        delta_value1 = (new_status - current_status) * value1_lst[idx]\n        delta_value2 = (new_status - current_status) * value2_lst[idx]\n\n        # Simple improvement metric (sum of normalized improvements)\n        improvement = (delta_value1 / (np.sum(value1_lst) + 1e-6)) + (delta_value2 / (np.sum(value2_lst) + 1e-6))\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_swap = idx\n\n    # Apply the best swap if found\n    if best_swap is not None:\n        new_solution[best_swap] = 1 - new_solution[best_swap]\n\n    # Step 3: Adaptive perturbation - randomly flip a small number of items if no improvement\n    if best_improvement <= 0:\n        perturbation_size = min(3, num_items)\n        perturbation_indices = random.sample(range(num_items), perturbation_size)\n\n        for idx in perturbation_indices:\n            if random.random() < 0.5:  # Randomly decide to flip\n                if new_solution[idx] == 0 and (np.sum(new_solution * weight_lst) + weight_lst[idx]) <= capacity:\n                    new_solution[idx] = 1\n                elif new_solution[idx] == 1:\n                    new_solution[idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.3822602986837591,
            6.470383584499359
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 0:\n        selected_idx = random.randint(0, len(archive) - 1)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = np.zeros_like(weight_lst, dtype=int)\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: item swaps with adaptive perturbation\n    num_items = len(weight_lst)\n    if num_items < 2:\n        return new_solution\n\n    # Step 1: Randomly select a subset of items to consider for swapping\n    subset_size = min(10, num_items)\n    subset_indices = random.sample(range(num_items), subset_size)\n\n    # Step 2: Evaluate potential swaps (flip 0 to 1 or 1 to 0) and choose the best feasible swap\n    best_swap = None\n    best_improvement = 0\n\n    for idx in subset_indices:\n        current_status = new_solution[idx]\n        new_status = 1 - current_status\n\n        # Calculate new weight and values\n        delta_weight = (new_status - current_status) * weight_lst[idx]\n        new_weight = np.sum(new_solution * weight_lst) + delta_weight\n\n        if new_weight > capacity:\n            continue  # Skip if infeasible\n\n        delta_value1 = (new_status - current_status) * value1_lst[idx]\n        delta_value2 = (new_status - current_status) * value2_lst[idx]\n\n        # Simple improvement metric (sum of normalized improvements)\n        improvement = (delta_value1 / (np.sum(value1_lst) + 1e-6)) + (delta_value2 / (np.sum(value2_lst) + 1e-6))\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_swap = idx\n\n    # Apply the best swap if found\n    if best_swap is not None:\n        new_solution[best_swap] = 1 - new_solution[best_swap]\n\n    # Step 3: Adaptive perturbation - randomly flip a small number of items if no improvement\n    if best_improvement <= 0:\n        perturbation_size = min(3, num_items)\n        perturbation_indices = random.sample(range(num_items), perturbation_size)\n\n        for idx in perturbation_indices:\n            if random.random() < 0.5:  # Randomly decide to flip\n                if new_solution[idx] == 0 and (np.sum(new_solution * weight_lst) + weight_lst[idx]) <= capacity:\n                    new_solution[idx] = 1\n                elif new_solution[idx] == 1:\n                    new_solution[idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 146,
        "algorithm": "{This algorithm intelligently selects a non-dominated solution from the archive, prioritizes items with high marginal gains in both objectives, and performs a hybrid local search by combining item swaps with probabilistic flips to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too crowded in the objective space)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Calculate marginal gains for each item\n    marginal_gain1 = value1_lst / weight_lst\n    marginal_gain2 = value2_lst / weight_lst\n    combined_gain = marginal_gain1 + marginal_gain2\n\n    # Identify items to consider for flipping (high marginal gain or currently excluded)\n    candidate_items = np.where((base_solution == 1) | (combined_gain > np.median(combined_gain)))[0]\n\n    if len(candidate_items) == 0:\n        return base_solution.copy()  # No candidates, return original\n\n    # Perform a hybrid local search: swap two items or flip one with high probability\n    new_solution = base_solution.copy()\n\n    if np.random.rand() < 0.7:  # Higher probability for swap\n        # Select two distinct items to swap\n        item1, item2 = np.random.choice(candidate_items, size=2, replace=False)\n\n        # Check if swapping is feasible\n        if base_solution[item1] == base_solution[item2]:\n            # Both are in or out, swap directly\n            new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n        else:\n            # One is in, one is out: swap only if weight difference is manageable\n            weight_diff = weight_lst[item1] - weight_lst[item2]\n            if current_weight + weight_diff <= capacity:\n                new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n    else:\n        # Perform a flip (add or remove) with high marginal gain\n        item = np.random.choice(candidate_items)\n        if base_solution[item] == 1:\n            # Remove item if it's in the solution\n            new_solution[item] = 0\n        else:\n            # Add item if it fits\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.32000394168350704,
            6.41756284236908
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too crowded in the objective space)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Calculate marginal gains for each item\n    marginal_gain1 = value1_lst / weight_lst\n    marginal_gain2 = value2_lst / weight_lst\n    combined_gain = marginal_gain1 + marginal_gain2\n\n    # Identify items to consider for flipping (high marginal gain or currently excluded)\n    candidate_items = np.where((base_solution == 1) | (combined_gain > np.median(combined_gain)))[0]\n\n    if len(candidate_items) == 0:\n        return base_solution.copy()  # No candidates, return original\n\n    # Perform a hybrid local search: swap two items or flip one with high probability\n    new_solution = base_solution.copy()\n\n    if np.random.rand() < 0.7:  # Higher probability for swap\n        # Select two distinct items to swap\n        item1, item2 = np.random.choice(candidate_items, size=2, replace=False)\n\n        # Check if swapping is feasible\n        if base_solution[item1] == base_solution[item2]:\n            # Both are in or out, swap directly\n            new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n        else:\n            # One is in, one is out: swap only if weight difference is manageable\n            weight_diff = weight_lst[item1] - weight_lst[item2]\n            if current_weight + weight_diff <= capacity:\n                new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n    else:\n        # Perform a flip (add or remove) with high marginal gain\n        item = np.random.choice(candidate_items)\n        if base_solution[item] == 1:\n            # Remove item if it's in the solution\n            new_solution[item] = 0\n        else:\n            # Add item if it fits\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 147,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive.sort(key=lambda x: -sum(x[0]))  # Sort by number of items (heuristic for diversity)\n    base_solution, _ = archive[0]\n\n    # Generate a neighbor by flipping a subset of items based on marginal gains\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Calculate marginal gains for each item\n    marginal_gains = []\n    for i in range(n_items):\n        if base_solution[i] == 1:\n            # If item is in the solution, consider removing it\n            marginal_gains.append((i, -weight_lst[i], -value1_lst[i], -value2_lst[i]))\n        else:\n            # If item is not in the solution, consider adding it if feasible\n            if total_weight + weight_lst[i] <= capacity:\n                marginal_gains.append((i, weight_lst[i], value1_lst[i], value2_lst[i]))\n            else:\n                marginal_gains.append((i, 0, 0, 0))  # Mark as infeasible\n\n    # Sort by combined marginal gain (weighted sum of value1 and value2)\n    marginal_gains.sort(key=lambda x: -(x[2] + x[3]), reverse=True)\n\n    # Flip the top k items (k=3 for diversity)\n    k = min(3, len(marginal_gains))\n    for i in range(k):\n        idx = marginal_gains[i][0]\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        # If infeasible, remove items with smallest marginal gains until feasible\n        while current_weight > capacity:\n            for i in range(len(marginal_gains)-1, -1, -1):\n                idx = marginal_gains[i][0]\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8526426931178923,
            8.524840950965881
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive.sort(key=lambda x: -sum(x[0]))  # Sort by number of items (heuristic for diversity)\n    base_solution, _ = archive[0]\n\n    # Generate a neighbor by flipping a subset of items based on marginal gains\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Calculate marginal gains for each item\n    marginal_gains = []\n    for i in range(n_items):\n        if base_solution[i] == 1:\n            # If item is in the solution, consider removing it\n            marginal_gains.append((i, -weight_lst[i], -value1_lst[i], -value2_lst[i]))\n        else:\n            # If item is not in the solution, consider adding it if feasible\n            if total_weight + weight_lst[i] <= capacity:\n                marginal_gains.append((i, weight_lst[i], value1_lst[i], value2_lst[i]))\n            else:\n                marginal_gains.append((i, 0, 0, 0))  # Mark as infeasible\n\n    # Sort by combined marginal gain (weighted sum of value1 and value2)\n    marginal_gains.sort(key=lambda x: -(x[2] + x[3]), reverse=True)\n\n    # Flip the top k items (k=3 for diversity)\n    k = min(3, len(marginal_gains))\n    for i in range(k):\n        idx = marginal_gains[i][0]\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        # If infeasible, remove items with smallest marginal gains until feasible\n        while current_weight > capacity:\n            for i in range(len(marginal_gains)-1, -1, -1):\n                idx = marginal_gains[i][0]\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 148,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines item swaps, probabilistic flips, and objective-aware perturbations to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Step 1: Probabilistic flip of items based on their contribution to each objective\n    for i in range(len(new_solution)):\n        if random.random() < 0.3:  # 30% chance to flip\n            if new_solution[i] == 1:\n                # If removing, check if it improves at least one objective\n                if (current_weight - weight_lst[i] <= capacity and\n                    (value1_lst[i] < 0 or value2_lst[i] < 0)):\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # If adding, check if it doesn't exceed capacity\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Step 2: Objective-aware swaps (swap items that improve at least one objective)\n    for _ in range(3):  # Perform 3 swaps\n        i, j = random.sample(range(len(new_solution)), 2)\n        if new_solution[i] != new_solution[j]:\n            delta_weight = weight_lst[j] - weight_lst[i]\n            if (current_weight + delta_weight <= capacity and\n                (value1_lst[j] > value1_lst[i] or value2_lst[j] > value2_lst[i])):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight += delta_weight\n\n    # Step 3: Add or remove a random item that improves at least one objective\n    if random.random() < 0.5:  # 50% chance to add/remove\n        if random.random() < 0.5:  # Add\n            candidates = [i for i in range(len(new_solution))\n                         if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity]\n            if candidates:\n                i = random.choice(candidates)\n                if value1_lst[i] > 0 or value2_lst[i] > 0:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n        else:  # Remove\n            candidates = [i for i in range(len(new_solution)) if new_solution[i] == 1]\n            if candidates:\n                i = random.choice(candidates)\n                if value1_lst[i] < 0 or value2_lst[i] < 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.4327289786868472,
            5.677996844053268
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Step 1: Probabilistic flip of items based on their contribution to each objective\n    for i in range(len(new_solution)):\n        if random.random() < 0.3:  # 30% chance to flip\n            if new_solution[i] == 1:\n                # If removing, check if it improves at least one objective\n                if (current_weight - weight_lst[i] <= capacity and\n                    (value1_lst[i] < 0 or value2_lst[i] < 0)):\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # If adding, check if it doesn't exceed capacity\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Step 2: Objective-aware swaps (swap items that improve at least one objective)\n    for _ in range(3):  # Perform 3 swaps\n        i, j = random.sample(range(len(new_solution)), 2)\n        if new_solution[i] != new_solution[j]:\n            delta_weight = weight_lst[j] - weight_lst[i]\n            if (current_weight + delta_weight <= capacity and\n                (value1_lst[j] > value1_lst[i] or value2_lst[j] > value2_lst[i])):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight += delta_weight\n\n    # Step 3: Add or remove a random item that improves at least one objective\n    if random.random() < 0.5:  # 50% chance to add/remove\n        if random.random() < 0.5:  # Add\n            candidates = [i for i in range(len(new_solution))\n                         if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity]\n            if candidates:\n                i = random.choice(candidates)\n                if value1_lst[i] > 0 or value2_lst[i] > 0:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n        else:  # Remove\n            candidates = [i for i in range(len(new_solution)) if new_solution[i] == 1]\n            if candidates:\n                i = random.choice(candidates)\n                if value1_lst[i] < 0 or value2_lst[i] < 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 149,
        "algorithm": "{A novel hybrid local search strategy that intelligently combines item swaps, adaptive perturbations, and objective-biased selection to generate high-quality neighbors by prioritizing items with the highest marginal gains in both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (higher is better)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n        # Select top 30% of solutions\n        top_solutions = archive_sorted[:max(1, len(archive) // 3)]\n        # Randomly select a solution from the top solutions\n        selected_idx = random.randint(0, len(top_solutions) - 1)\n        base_solution = top_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Identify items to consider for swap (items not in the solution)\n    zero_indices = np.where(new_solution == 0)[0]\n\n    # Calculate marginal gains for each zero item\n    marginal_gains1 = value1_lst[zero_indices]\n    marginal_gains2 = value2_lst[zero_indices]\n    marginal_weights = weight_lst[zero_indices]\n\n    # Calculate combined marginal gain (weighted sum of both objectives)\n    combined_gains = marginal_gains1 + marginal_gains2\n\n    # Filter feasible items (those that can be added without exceeding capacity)\n    feasible_indices = np.where((current_weight + marginal_weights) <= capacity)[0]\n\n    if len(feasible_indices) > 0:\n        # Select top 20% of feasible items with highest combined marginal gain\n        top_feasible = feasible_indices[np.argsort(combined_gains[feasible_indices])[-max(1, len(feasible_indices) // 5):]]\n\n        if len(top_feasible) > 0:\n            # Randomly select one of the top feasible items to add\n            selected_item = zero_indices[top_feasible[random.randint(0, len(top_feasible) - 1)]]\n            new_solution[selected_item] = 1\n\n    # Now consider removing items to make space for better items\n    one_indices = np.where(new_solution == 1)[0]\n    if len(one_indices) > 0:\n        # Calculate marginal gains for each one item (if removed)\n        marginal_gains1_remove = -value1_lst[one_indices]\n        marginal_gains2_remove = -value2_lst[one_indices]\n        combined_gains_remove = marginal_gains1_remove + marginal_gains2_remove\n\n        # Select items with lowest combined marginal gain (removing them frees up space)\n        worst_items = one_indices[np.argsort(combined_gains_remove)[:max(1, len(one_indices) // 3)]]\n\n        if len(worst_items) > 0:\n            # Randomly select one of the worst items to remove\n            selected_remove = worst_items[random.randint(0, len(worst_items) - 1)]\n            new_solution[selected_remove] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.9158373823365775,
            2.221989780664444
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (higher is better)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n        # Select top 30% of solutions\n        top_solutions = archive_sorted[:max(1, len(archive) // 3)]\n        # Randomly select a solution from the top solutions\n        selected_idx = random.randint(0, len(top_solutions) - 1)\n        base_solution = top_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Identify items to consider for swap (items not in the solution)\n    zero_indices = np.where(new_solution == 0)[0]\n\n    # Calculate marginal gains for each zero item\n    marginal_gains1 = value1_lst[zero_indices]\n    marginal_gains2 = value2_lst[zero_indices]\n    marginal_weights = weight_lst[zero_indices]\n\n    # Calculate combined marginal gain (weighted sum of both objectives)\n    combined_gains = marginal_gains1 + marginal_gains2\n\n    # Filter feasible items (those that can be added without exceeding capacity)\n    feasible_indices = np.where((current_weight + marginal_weights) <= capacity)[0]\n\n    if len(feasible_indices) > 0:\n        # Select top 20% of feasible items with highest combined marginal gain\n        top_feasible = feasible_indices[np.argsort(combined_gains[feasible_indices])[-max(1, len(feasible_indices) // 5):]]\n\n        if len(top_feasible) > 0:\n            # Randomly select one of the top feasible items to add\n            selected_item = zero_indices[top_feasible[random.randint(0, len(top_feasible) - 1)]]\n            new_solution[selected_item] = 1\n\n    # Now consider removing items to make space for better items\n    one_indices = np.where(new_solution == 1)[0]\n    if len(one_indices) > 0:\n        # Calculate marginal gains for each one item (if removed)\n        marginal_gains1_remove = -value1_lst[one_indices]\n        marginal_gains2_remove = -value2_lst[one_indices]\n        combined_gains_remove = marginal_gains1_remove + marginal_gains2_remove\n\n        # Select items with lowest combined marginal gain (removing them frees up space)\n        worst_items = one_indices[np.argsort(combined_gains_remove)[:max(1, len(one_indices) // 3)]]\n\n        if len(worst_items) > 0:\n            # Randomly select one of the worst items to remove\n            selected_remove = worst_items[random.randint(0, len(worst_items) - 1)]\n            new_solution[selected_remove] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 150,
        "algorithm": "{The algorithm intelligently selects a high-potential solution from the archive, then applies a hybrid local search combining item swap and random perturbation while ensuring feasibility, and finally evaluates the neighbor to prioritize high-quality solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items with high potential and random perturbation\n    for _ in range(5):  # Limit number of attempts to avoid long computation\n        # Find items to swap (prioritize those with high value-to-weight ratio)\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) == 0 or len(excluded) == 0:\n            break\n\n        # Calculate value-to-weight ratios\n        included_ratios = (value1_lst[included] + value2_lst[included]) / weight_lst[included]\n        excluded_ratios = (value1_lst[excluded] + value2_lst[excluded]) / weight_lst[excluded]\n\n        # Select items with highest ratios\n        best_included = included[np.argmax(included_ratios)]\n        best_excluded = excluded[np.argmax(excluded_ratios)]\n\n        # Try swap\n        temp_solution = new_solution.copy()\n        temp_solution[best_included] = 0\n        temp_solution[best_excluded] = 1\n        temp_weight = current_weight - weight_lst[best_included] + weight_lst[best_excluded]\n\n        if temp_weight <= capacity:\n            new_solution = temp_solution\n            current_weight = temp_weight\n            break\n\n    # Random perturbation to escape local optima\n    for _ in range(3):\n        if random.random() < 0.3:  # 30% chance to perturb\n            temp_solution = new_solution.copy()\n            idx = random.randint(0, len(temp_solution) - 1)\n            if temp_solution[idx] == 1:\n                temp_solution[idx] = 0\n                temp_weight = current_weight - weight_lst[idx]\n            else:\n                temp_solution[idx] = 1\n                temp_weight = current_weight + weight_lst[idx]\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -0.4402134801658731,
            5.724331080913544
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items with high potential and random perturbation\n    for _ in range(5):  # Limit number of attempts to avoid long computation\n        # Find items to swap (prioritize those with high value-to-weight ratio)\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) == 0 or len(excluded) == 0:\n            break\n\n        # Calculate value-to-weight ratios\n        included_ratios = (value1_lst[included] + value2_lst[included]) / weight_lst[included]\n        excluded_ratios = (value1_lst[excluded] + value2_lst[excluded]) / weight_lst[excluded]\n\n        # Select items with highest ratios\n        best_included = included[np.argmax(included_ratios)]\n        best_excluded = excluded[np.argmax(excluded_ratios)]\n\n        # Try swap\n        temp_solution = new_solution.copy()\n        temp_solution[best_included] = 0\n        temp_solution[best_excluded] = 1\n        temp_weight = current_weight - weight_lst[best_included] + weight_lst[best_excluded]\n\n        if temp_weight <= capacity:\n            new_solution = temp_solution\n            current_weight = temp_weight\n            break\n\n    # Random perturbation to escape local optima\n    for _ in range(3):\n        if random.random() < 0.3:  # 30% chance to perturb\n            temp_solution = new_solution.copy()\n            idx = random.randint(0, len(temp_solution) - 1)\n            if temp_solution[idx] == 1:\n                temp_solution[idx] = 0\n                temp_weight = current_weight - weight_lst[idx]\n            else:\n                temp_solution[idx] = 1\n                temp_weight = current_weight + weight_lst[idx]\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 151,
        "algorithm": "{This algorithm intelligently selects a solution from the archive and generates a neighbor by applying a hybrid local search strategy that combines random item swaps with a probabilistic acceptance of solutions that improve at least one objective, ensuring feasibility by dynamically adjusting the selection based on the remaining capacity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: Randomly swap items with probabilistic acceptance\n    for _ in range(10):  # Number of trials\n        # Randomly select two items\n        item1, item2 = random.sample(range(len(new_solution)), 2)\n\n        # Swap their inclusion status\n        temp = new_solution[item1]\n        new_solution[item1] = new_solution[item2]\n        new_solution[item2] = temp\n\n        # Calculate new weight and values\n        new_weight = np.sum(weight_lst[new_solution == 1])\n        new_value1 = np.sum(value1_lst[new_solution == 1])\n        new_value2 = np.sum(value2_lst[new_solution == 1])\n\n        # Check feasibility and improvement\n        if new_weight <= capacity and (new_value1 > current_value1 or new_value2 > current_value2):\n            current_value1, current_value2 = new_value1, new_value2\n            current_weight = new_weight\n        else:\n            # Revert if no improvement or infeasible\n            new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n\n    return new_solution\n\n",
        "score": [
            -0.5483067633012513,
            9.182197958230972
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: Randomly swap items with probabilistic acceptance\n    for _ in range(10):  # Number of trials\n        # Randomly select two items\n        item1, item2 = random.sample(range(len(new_solution)), 2)\n\n        # Swap their inclusion status\n        temp = new_solution[item1]\n        new_solution[item1] = new_solution[item2]\n        new_solution[item2] = temp\n\n        # Calculate new weight and values\n        new_weight = np.sum(weight_lst[new_solution == 1])\n        new_value1 = np.sum(value1_lst[new_solution == 1])\n        new_value2 = np.sum(value2_lst[new_solution == 1])\n\n        # Check feasibility and improvement\n        if new_weight <= capacity and (new_value1 > current_value1 or new_value2 > current_value2):\n            current_value1, current_value2 = new_value1, new_value2\n            current_weight = new_weight\n        else:\n            # Revert if no improvement or infeasible\n            new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 152,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive by prioritizing those with high diversity or marginal improvement potential, then applies a hybrid local search operator that combines item swapping with a novel probabilistic flip mechanism to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on diversity and potential improvement\n    def calculate_diversity(solution):\n        total_weight = np.sum(weight_lst[solution == 1])\n        total_value1 = np.sum(value1_lst[solution == 1])\n        total_value2 = np.sum(value2_lst[solution == 1])\n        return total_weight, total_value1, total_value2\n\n    # Calculate diversity scores for each solution in the archive\n    diversity_scores = []\n    for sol, _ in archive:\n        weight, val1, val2 = calculate_diversity(sol)\n        diversity_scores.append((weight, val1, val2))\n\n    # Select a solution with high diversity or potential improvement\n    selected_idx = random.choices(range(len(archive)), weights=[(w + v1 + v2) for w, v1, v2 in diversity_scores], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    # Step 1: Item swapping with probabilistic flip\n    for _ in range(2):  # Number of swaps\n        # Find items to swap (one in, one out)\n        in_items = np.where(base_solution == 0)[0]\n        out_items = np.where(base_solution == 1)[0]\n\n        if len(in_items) == 0 or len(out_items) == 0:\n            break\n\n        # Select items with higher value-to-weight ratio\n        in_item = random.choice(in_items)\n        out_item = random.choice(out_items)\n\n        # Check feasibility\n        current_weight = np.sum(weight_lst[base_solution == 1])\n        new_weight = current_weight - weight_lst[out_item] + weight_lst[in_item]\n\n        if new_weight <= capacity:\n            new_solution[out_item] = 0\n            new_solution[in_item] = 1\n\n    # Step 2: Probabilistic flip for marginal improvement\n    for i in range(len(new_solution)):\n        if random.random() < 0.3:  # Probability of flip\n            if new_solution[i] == 1:\n                # Check if removing the item keeps the solution feasible\n                current_weight = np.sum(weight_lst[new_solution == 1])\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n            else:\n                # Check if adding the item keeps the solution feasible\n                current_weight = np.sum(weight_lst[new_solution == 1])\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.3582475042092928,
            10.939569473266602
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on diversity and potential improvement\n    def calculate_diversity(solution):\n        total_weight = np.sum(weight_lst[solution == 1])\n        total_value1 = np.sum(value1_lst[solution == 1])\n        total_value2 = np.sum(value2_lst[solution == 1])\n        return total_weight, total_value1, total_value2\n\n    # Calculate diversity scores for each solution in the archive\n    diversity_scores = []\n    for sol, _ in archive:\n        weight, val1, val2 = calculate_diversity(sol)\n        diversity_scores.append((weight, val1, val2))\n\n    # Select a solution with high diversity or potential improvement\n    selected_idx = random.choices(range(len(archive)), weights=[(w + v1 + v2) for w, v1, v2 in diversity_scores], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    # Step 1: Item swapping with probabilistic flip\n    for _ in range(2):  # Number of swaps\n        # Find items to swap (one in, one out)\n        in_items = np.where(base_solution == 0)[0]\n        out_items = np.where(base_solution == 1)[0]\n\n        if len(in_items) == 0 or len(out_items) == 0:\n            break\n\n        # Select items with higher value-to-weight ratio\n        in_item = random.choice(in_items)\n        out_item = random.choice(out_items)\n\n        # Check feasibility\n        current_weight = np.sum(weight_lst[base_solution == 1])\n        new_weight = current_weight - weight_lst[out_item] + weight_lst[in_item]\n\n        if new_weight <= capacity:\n            new_solution[out_item] = 0\n            new_solution[in_item] = 1\n\n    # Step 2: Probabilistic flip for marginal improvement\n    for i in range(len(new_solution)):\n        if random.random() < 0.3:  # Probability of flip\n            if new_solution[i] == 1:\n                # Check if removing the item keeps the solution feasible\n                current_weight = np.sum(weight_lst[new_solution == 1])\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n            else:\n                # Check if adding the item keeps the solution feasible\n                current_weight = np.sum(weight_lst[new_solution == 1])\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 153,
        "algorithm": "{A hybrid local search strategy that intelligently selects a promising solution from the archive and applies a novel multi-objective perturbation operator, combining item swaps and value-driven flips to explore the neighborhood while ensuring feasibility and diversity in the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Identify items to consider for flipping\n    included_items = np.where(base_solution == 1)[0]\n    excluded_items = np.where(base_solution == 0)[0]\n\n    # Hybrid local search operator: value-driven flips and swaps\n    if len(included_items) > 0 and len(excluded_items) > 0:\n        # Select a random item to flip (value-driven)\n        flip_candidate = np.random.choice(included_items)\n        if (current_weight - weight_lst[flip_candidate] + np.random.choice(weight_lst[excluded_items])) <= capacity:\n            new_solution[flip_candidate] = 0\n            swap_candidate = np.random.choice(excluded_items)\n            new_solution[swap_candidate] = 1\n        else:\n            # If flip is not feasible, try a swap\n            swap_candidate1 = np.random.choice(included_items)\n            swap_candidate2 = np.random.choice(excluded_items)\n            if (current_weight - weight_lst[swap_candidate1] + weight_lst[swap_candidate2]) <= capacity:\n                new_solution[swap_candidate1] = 0\n                new_solution[swap_candidate2] = 1\n    else:\n        # If all items are included or excluded, perform a random flip\n        if len(included_items) > 0:\n            flip_candidate = np.random.choice(included_items)\n            new_solution[flip_candidate] = 0\n        elif len(excluded_items) > 0:\n            flip_candidate = np.random.choice(excluded_items)\n            if (current_weight + weight_lst[flip_candidate]) <= capacity:\n                new_solution[flip_candidate] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.5358448085295919,
            7.506309300661087
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Identify items to consider for flipping\n    included_items = np.where(base_solution == 1)[0]\n    excluded_items = np.where(base_solution == 0)[0]\n\n    # Hybrid local search operator: value-driven flips and swaps\n    if len(included_items) > 0 and len(excluded_items) > 0:\n        # Select a random item to flip (value-driven)\n        flip_candidate = np.random.choice(included_items)\n        if (current_weight - weight_lst[flip_candidate] + np.random.choice(weight_lst[excluded_items])) <= capacity:\n            new_solution[flip_candidate] = 0\n            swap_candidate = np.random.choice(excluded_items)\n            new_solution[swap_candidate] = 1\n        else:\n            # If flip is not feasible, try a swap\n            swap_candidate1 = np.random.choice(included_items)\n            swap_candidate2 = np.random.choice(excluded_items)\n            if (current_weight - weight_lst[swap_candidate1] + weight_lst[swap_candidate2]) <= capacity:\n                new_solution[swap_candidate1] = 0\n                new_solution[swap_candidate2] = 1\n    else:\n        # If all items are included or excluded, perform a random flip\n        if len(included_items) > 0:\n            flip_candidate = np.random.choice(included_items)\n            new_solution[flip_candidate] = 0\n        elif len(excluded_items) > 0:\n            flip_candidate = np.random.choice(excluded_items)\n            if (current_weight + weight_lst[flip_candidate]) <= capacity:\n                new_solution[flip_candidate] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 154,
        "algorithm": "{The algorithm selects a promising solution from the archive by evaluating the crowding distance of each solution in the objective space, then applies a hybrid local search operator that combines item swaps and probabilistic flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution based on crowding distance\n    def calculate_crowding_distance(archive):\n        if len(archive) < 3:\n            return [1.0] * len(archive)\n        objectives = np.array([obj for _, obj in archive])\n        sorted_indices = np.argsort(objectives[:, 0])\n        objectives = objectives[sorted_indices]\n        distances = np.zeros(len(archive))\n        for i in range(2):\n            sorted_indices = np.argsort(objectives[:, i])\n            objectives_sorted = objectives[sorted_indices]\n            distances[sorted_indices[0]] = np.inf\n            distances[sorted_indices[-1]] = np.inf\n            for j in range(1, len(archive) - 1):\n                if objectives_sorted[-1, i] == objectives_sorted[0, i]:\n                    distances[sorted_indices[j]] += 0\n                else:\n                    distances[sorted_indices[j]] += (objectives_sorted[j+1, i] - objectives_sorted[j-1, i]) / (objectives_sorted[-1, i] - objectives_sorted[0, i])\n        return distances\n\n    distances = calculate_crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search operator\n    def hybrid_local_search(solution, weight_lst, value1_lst, value2_lst, capacity):\n        new_solution = solution.copy()\n        n_items = len(solution)\n\n        # Randomly select a subset of items to consider for flip\n        flip_indices = np.random.choice(n_items, size=min(5, n_items), replace=False)\n\n        for idx in flip_indices:\n            if new_solution[idx] == 1:\n                # Try to remove the item\n                temp_solution = new_solution.copy()\n                temp_solution[idx] = 0\n                if np.dot(temp_solution, weight_lst) <= capacity:\n                    new_solution = temp_solution\n            else:\n                # Try to add the item\n                temp_solution = new_solution.copy()\n                temp_solution[idx] = 1\n                if np.dot(temp_solution, weight_lst) <= capacity:\n                    new_solution = temp_solution\n\n        # Randomly swap two items if feasible\n        if n_items >= 2:\n            i, j = np.random.choice(n_items, size=2, replace=False)\n            if new_solution[i] != new_solution[j]:\n                temp_solution = new_solution.copy()\n                temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n                if np.dot(temp_solution, weight_lst) <= capacity:\n                    new_solution = temp_solution\n\n        # Probabilistic flip for diversification\n        for idx in range(n_items):\n            if np.random.rand() < 0.1:  # 10% chance to flip\n                temp_solution = new_solution.copy()\n                temp_solution[idx] = 1 - temp_solution[idx]\n                if np.dot(temp_solution, weight_lst) <= capacity:\n                    new_solution = temp_solution\n\n        return new_solution\n\n    new_solution = hybrid_local_search(base_solution, weight_lst, value1_lst, value2_lst, capacity)\n    return new_solution\n\n",
        "score": [
            -0.4582442341889537,
            10.802555441856384
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution based on crowding distance\n    def calculate_crowding_distance(archive):\n        if len(archive) < 3:\n            return [1.0] * len(archive)\n        objectives = np.array([obj for _, obj in archive])\n        sorted_indices = np.argsort(objectives[:, 0])\n        objectives = objectives[sorted_indices]\n        distances = np.zeros(len(archive))\n        for i in range(2):\n            sorted_indices = np.argsort(objectives[:, i])\n            objectives_sorted = objectives[sorted_indices]\n            distances[sorted_indices[0]] = np.inf\n            distances[sorted_indices[-1]] = np.inf\n            for j in range(1, len(archive) - 1):\n                if objectives_sorted[-1, i] == objectives_sorted[0, i]:\n                    distances[sorted_indices[j]] += 0\n                else:\n                    distances[sorted_indices[j]] += (objectives_sorted[j+1, i] - objectives_sorted[j-1, i]) / (objectives_sorted[-1, i] - objectives_sorted[0, i])\n        return distances\n\n    distances = calculate_crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search operator\n    def hybrid_local_search(solution, weight_lst, value1_lst, value2_lst, capacity):\n        new_solution = solution.copy()\n        n_items = len(solution)\n\n        # Randomly select a subset of items to consider for flip\n        flip_indices = np.random.choice(n_items, size=min(5, n_items), replace=False)\n\n        for idx in flip_indices:\n            if new_solution[idx] == 1:\n                # Try to remove the item\n                temp_solution = new_solution.copy()\n                temp_solution[idx] = 0\n                if np.dot(temp_solution, weight_lst) <= capacity:\n                    new_solution = temp_solution\n            else:\n                # Try to add the item\n                temp_solution = new_solution.copy()\n                temp_solution[idx] = 1\n                if np.dot(temp_solution, weight_lst) <= capacity:\n                    new_solution = temp_solution\n\n        # Randomly swap two items if feasible\n        if n_items >= 2:\n            i, j = np.random.choice(n_items, size=2, replace=False)\n            if new_solution[i] != new_solution[j]:\n                temp_solution = new_solution.copy()\n                temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n                if np.dot(temp_solution, weight_lst) <= capacity:\n                    new_solution = temp_solution\n\n        # Probabilistic flip for diversification\n        for idx in range(n_items):\n            if np.random.rand() < 0.1:  # 10% chance to flip\n                temp_solution = new_solution.copy()\n                temp_solution[idx] = 1 - temp_solution[idx]\n                if np.dot(temp_solution, weight_lst) <= capacity:\n                    new_solution = temp_solution\n\n        return new_solution\n\n    new_solution = hybrid_local_search(base_solution, weight_lst, value1_lst, value2_lst, capacity)\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 155,
        "algorithm": "{A novel hybrid local search strategy combines elite solution selection with a dynamic item swapping mechanism that prioritizes high-value items while ensuring feasibility, balancing exploration of the solution space with exploitation of promising regions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Prioritize solutions with lower total weight (more room for improvement)\n        archive_sorted = sorted(archive, key=lambda x: np.sum(weight_lst[x[0] == 1]))\n        selected_idx = min(3, len(archive_sorted) - 1)\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: dynamic item swapping\n    # Step 1: Identify candidate items to swap out (low value, high weight)\n    in_items = np.where(new_solution == 1)[0]\n    out_items = np.where(new_solution == 0)[0]\n\n    # Calculate value-to-weight ratios for in-items\n    if len(in_items) > 0:\n        value1_in = value1_lst[in_items]\n        value2_in = value2_lst[in_items]\n        weight_in = weight_lst[in_items]\n        # Normalize values for combined objective\n        norm_value1 = (value1_in - np.min(value1_in)) / (np.max(value1_in) - np.min(value1_in) + 1e-6)\n        norm_value2 = (value2_in - np.min(value2_in)) / (np.max(value2_in) - np.min(value2_in) + 1e-6)\n        combined_value = norm_value1 + norm_value2\n        value_ratio = combined_value / weight_in\n\n        # Select items with lowest value-to-weight ratio to potentially remove\n        swap_out_candidates = in_items[np.argsort(value_ratio)[:max(1, len(in_items)//3)]]\n    else:\n        swap_out_candidates = []\n\n    # Step 2: Identify candidate items to swap in (high value, low weight)\n    if len(out_items) > 0:\n        value1_out = value1_lst[out_items]\n        value2_out = value2_lst[out_items]\n        weight_out = weight_lst[out_items]\n        # Normalize values for combined objective\n        norm_value1_out = (value1_out - np.min(value1_out)) / (np.max(value1_out) - np.min(value1_out) + 1e-6)\n        norm_value2_out = (value2_out - np.min(value2_out)) / (np.max(value2_out) - np.min(value2_out) + 1e-6)\n        combined_value_out = norm_value1_out + norm_value2_out\n        value_ratio_out = combined_value_out / weight_out\n\n        # Select items with highest value-to-weight ratio to potentially add\n        swap_in_candidates = out_items[np.argsort(value_ratio_out)[-max(1, len(out_items)//3):]]\n    else:\n        swap_in_candidates = []\n\n    # Perform the swap\n    if len(swap_out_candidates) > 0 and len(swap_in_candidates) > 0:\n        # Randomly select one item to remove and one to add\n        item_to_remove = random.choice(swap_out_candidates)\n        item_to_add = random.choice(swap_in_candidates)\n\n        # Check if the swap is feasible\n        new_weight = current_weight - weight_lst[item_to_remove] + weight_lst[item_to_add]\n        if new_weight <= capacity:\n            new_solution[item_to_remove] = 0\n            new_solution[item_to_add] = 1\n        else:\n            # If swap is not feasible, try to remove only\n            if current_weight - weight_lst[item_to_remove] <= capacity:\n                new_solution[item_to_remove] = 0\n    else:\n        # If no candidates, randomly flip one item (if feasible)\n        flip_candidates = [i for i in range(len(new_solution)) if\n                          (new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity) or\n                          (new_solution[i] == 1 and current_weight - weight_lst[i] <= capacity)]\n        if flip_candidates:\n            item_to_flip = random.choice(flip_candidates)\n            new_solution[item_to_flip] = 1 - new_solution[item_to_flip]\n\n    return new_solution\n\n",
        "score": [
            -0.7820054507020724,
            8.860724210739136
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Prioritize solutions with lower total weight (more room for improvement)\n        archive_sorted = sorted(archive, key=lambda x: np.sum(weight_lst[x[0] == 1]))\n        selected_idx = min(3, len(archive_sorted) - 1)\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: dynamic item swapping\n    # Step 1: Identify candidate items to swap out (low value, high weight)\n    in_items = np.where(new_solution == 1)[0]\n    out_items = np.where(new_solution == 0)[0]\n\n    # Calculate value-to-weight ratios for in-items\n    if len(in_items) > 0:\n        value1_in = value1_lst[in_items]\n        value2_in = value2_lst[in_items]\n        weight_in = weight_lst[in_items]\n        # Normalize values for combined objective\n        norm_value1 = (value1_in - np.min(value1_in)) / (np.max(value1_in) - np.min(value1_in) + 1e-6)\n        norm_value2 = (value2_in - np.min(value2_in)) / (np.max(value2_in) - np.min(value2_in) + 1e-6)\n        combined_value = norm_value1 + norm_value2\n        value_ratio = combined_value / weight_in\n\n        # Select items with lowest value-to-weight ratio to potentially remove\n        swap_out_candidates = in_items[np.argsort(value_ratio)[:max(1, len(in_items)//3)]]\n    else:\n        swap_out_candidates = []\n\n    # Step 2: Identify candidate items to swap in (high value, low weight)\n    if len(out_items) > 0:\n        value1_out = value1_lst[out_items]\n        value2_out = value2_lst[out_items]\n        weight_out = weight_lst[out_items]\n        # Normalize values for combined objective\n        norm_value1_out = (value1_out - np.min(value1_out)) / (np.max(value1_out) - np.min(value1_out) + 1e-6)\n        norm_value2_out = (value2_out - np.min(value2_out)) / (np.max(value2_out) - np.min(value2_out) + 1e-6)\n        combined_value_out = norm_value1_out + norm_value2_out\n        value_ratio_out = combined_value_out / weight_out\n\n        # Select items with highest value-to-weight ratio to potentially add\n        swap_in_candidates = out_items[np.argsort(value_ratio_out)[-max(1, len(out_items)//3):]]\n    else:\n        swap_in_candidates = []\n\n    # Perform the swap\n    if len(swap_out_candidates) > 0 and len(swap_in_candidates) > 0:\n        # Randomly select one item to remove and one to add\n        item_to_remove = random.choice(swap_out_candidates)\n        item_to_add = random.choice(swap_in_candidates)\n\n        # Check if the swap is feasible\n        new_weight = current_weight - weight_lst[item_to_remove] + weight_lst[item_to_add]\n        if new_weight <= capacity:\n            new_solution[item_to_remove] = 0\n            new_solution[item_to_add] = 1\n        else:\n            # If swap is not feasible, try to remove only\n            if current_weight - weight_lst[item_to_remove] <= capacity:\n                new_solution[item_to_remove] = 0\n    else:\n        # If no candidates, randomly flip one item (if feasible)\n        flip_candidates = [i for i in range(len(new_solution)) if\n                          (new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity) or\n                          (new_solution[i] == 1 and current_weight - weight_lst[i] <= capacity)]\n        if flip_candidates:\n            item_to_flip = random.choice(flip_candidates)\n            new_solution[item_to_flip] = 1 - new_solution[item_to_flip]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 156,
        "algorithm": "{This algorithm selects a promising solution from the archive by prioritizing those with high objective values and low weight utilization, then applies a hybrid local search combining random flips and objective-driven swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.zeros_like(weight_lst)\n\n    # Prioritize solutions with high objective values and low weight utilization\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight > capacity:\n            continue  # Skip infeasible solutions\n        score = (obj[0] + obj[1]) / (total_weight + 1)  # Balance between objectives and weight\n        scores.append(score)\n\n    if not scores:\n        return archive[0][0].copy()  # Fallback if all are infeasible\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random flips and objective-driven swaps\n    for _ in range(5):  # Number of perturbations\n        # Random flip\n        flip_idx = random.randint(0, len(new_solution) - 1)\n        new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n        # Ensure feasibility\n        total_weight = np.sum(weight_lst * new_solution)\n        if total_weight > capacity:\n            # If flip makes it infeasible, undo and try a swap\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n            # Find a candidate item to swap out\n            for i in range(len(new_solution)):\n                if new_solution[i] == 1:\n                    temp_sol = new_solution.copy()\n                    temp_sol[i] = 0\n                    temp_weight = np.sum(weight_lst * temp_sol)\n                    if temp_weight <= capacity:\n                        new_solution = temp_sol\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.40656894439696656,
            3.7135848104953766
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.zeros_like(weight_lst)\n\n    # Prioritize solutions with high objective values and low weight utilization\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight > capacity:\n            continue  # Skip infeasible solutions\n        score = (obj[0] + obj[1]) / (total_weight + 1)  # Balance between objectives and weight\n        scores.append(score)\n\n    if not scores:\n        return archive[0][0].copy()  # Fallback if all are infeasible\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random flips and objective-driven swaps\n    for _ in range(5):  # Number of perturbations\n        # Random flip\n        flip_idx = random.randint(0, len(new_solution) - 1)\n        new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n        # Ensure feasibility\n        total_weight = np.sum(weight_lst * new_solution)\n        if total_weight > capacity:\n            # If flip makes it infeasible, undo and try a swap\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n            # Find a candidate item to swap out\n            for i in range(len(new_solution)):\n                if new_solution[i] == 1:\n                    temp_sol = new_solution.copy()\n                    temp_sol[i] = 0\n                    temp_weight = np.sum(weight_lst * temp_sol)\n                    if temp_weight <= capacity:\n                        new_solution = temp_sol\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 157,
        "algorithm": "{The algorithm first identifies the most promising solution in the archive by evaluating their potential for local improvement, then applies a hybrid local search combining random item swaps and value-based flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most promising solution based on potential improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: random swaps and value-based flips\n    new_solution = base_solution.copy()\n\n    # Randomly select a number of items to flip (1 to 3)\n    num_flips = random.randint(1, min(3, len(base_solution)))\n\n    for _ in range(num_flips):\n        # Randomly select an item to flip\n        item_idx = random.randint(0, len(base_solution) - 1)\n\n        if new_solution[item_idx] == 1:\n            # If item is included, try to remove it\n            if current_weight - weight_lst[item_idx] >= 0:\n                new_solution[item_idx] = 0\n                current_weight -= weight_lst[item_idx]\n        else:\n            # If item is excluded, try to add it\n            if current_weight + weight_lst[item_idx] <= capacity:\n                new_solution[item_idx] = 1\n                current_weight += weight_lst[item_idx]\n\n    # Additional value-based flip: flip items with high value-to-weight ratio\n    value_to_weight = (value1_lst + value2_lst) / weight_lst\n    sorted_items = np.argsort(-value_to_weight)  # Sort descending\n\n    for item_idx in sorted_items:\n        if new_solution[item_idx] == 0 and current_weight + weight_lst[item_idx] <= capacity:\n            new_solution[item_idx] = 1\n            current_weight += weight_lst[item_idx]\n        elif new_solution[item_idx] == 1 and current_weight - weight_lst[item_idx] >= 0:\n            new_solution[item_idx] = 0\n            current_weight -= weight_lst[item_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5207262440678199,
            3.8420349955558777
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most promising solution based on potential improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: random swaps and value-based flips\n    new_solution = base_solution.copy()\n\n    # Randomly select a number of items to flip (1 to 3)\n    num_flips = random.randint(1, min(3, len(base_solution)))\n\n    for _ in range(num_flips):\n        # Randomly select an item to flip\n        item_idx = random.randint(0, len(base_solution) - 1)\n\n        if new_solution[item_idx] == 1:\n            # If item is included, try to remove it\n            if current_weight - weight_lst[item_idx] >= 0:\n                new_solution[item_idx] = 0\n                current_weight -= weight_lst[item_idx]\n        else:\n            # If item is excluded, try to add it\n            if current_weight + weight_lst[item_idx] <= capacity:\n                new_solution[item_idx] = 1\n                current_weight += weight_lst[item_idx]\n\n    # Additional value-based flip: flip items with high value-to-weight ratio\n    value_to_weight = (value1_lst + value2_lst) / weight_lst\n    sorted_items = np.argsort(-value_to_weight)  # Sort descending\n\n    for item_idx in sorted_items:\n        if new_solution[item_idx] == 0 and current_weight + weight_lst[item_idx] <= capacity:\n            new_solution[item_idx] = 1\n            current_weight += weight_lst[item_idx]\n        elif new_solution[item_idx] == 1 and current_weight - weight_lst[item_idx] >= 0:\n            new_solution[item_idx] = 0\n            current_weight -= weight_lst[item_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 158,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive by prioritizing those with high objective values, then applies a hybrid local search operator that combines item swaps with probabilistic flips to explore diverse neighborhoods while ensuring feasibility through dynamic weight adjustment.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized.sum(axis=1)\n    best_idx = np.argmax(scores)\n    base_solution = archive[best_idx][0].copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: item swaps with probabilistic flips\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # First, perform a random swap between two items\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        # Check if swap maintains feasibility\n        delta = (weight_lst[j] - weight_lst[i]) * (new_solution[j] - new_solution[i])\n        if current_weight + delta <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Then, perform probabilistic flips for items not in solution\n    for i in range(n_items):\n        if not new_solution[i] and random.random() < 0.3:  # 30% chance to flip\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n\n    # Finally, perform a random flip for an item in solution\n    included = np.where(new_solution == 1)[0]\n    if len(included) > 0:\n        i = random.choice(included)\n        new_solution[i] = 0  # Always feasible since we're removing\n\n    return new_solution\n\n",
        "score": [
            -0.4176003525722636,
            6.269397705793381
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized.sum(axis=1)\n    best_idx = np.argmax(scores)\n    base_solution = archive[best_idx][0].copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: item swaps with probabilistic flips\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # First, perform a random swap between two items\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        # Check if swap maintains feasibility\n        delta = (weight_lst[j] - weight_lst[i]) * (new_solution[j] - new_solution[i])\n        if current_weight + delta <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Then, perform probabilistic flips for items not in solution\n    for i in range(n_items):\n        if not new_solution[i] and random.random() < 0.3:  # 30% chance to flip\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n\n    # Finally, perform a random flip for an item in solution\n    included = np.where(new_solution == 1)[0]\n    if len(included) > 0:\n        i = random.choice(included)\n        new_solution[i] = 0  # Always feasible since we're removing\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 159,
        "algorithm": "{This algorithm intelligently selects a solution from the archive by prioritizing those with high diversity or marginal improvement potential, then applies a hybrid local search combining item swaps and simulated annealing-inspired moves to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions with higher diversity or marginal improvement potential\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (i + 1) for i in range(len(archive))])[0]\n    base_solution, (base_val1, base_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    # Option 1: Random item swap (if feasible)\n    if random.random() < 0.5:\n        # Find items that can be swapped (one in, one out)\n        in_items = np.where(base_solution == 1)[0]\n        out_items = np.where(base_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            swap_in = random.choice(in_items)\n            swap_out = random.choice(out_items)\n\n            # Check feasibility\n            current_weight = np.sum(weight_lst[base_solution == 1])\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n\n    # Option 2: Simulated annealing-inspired flip (allow temporary infeasibility with probability)\n    else:\n        # Randomly select an item to flip\n        flip_idx = random.randint(0, len(weight_lst) - 1)\n\n        if base_solution[flip_idx] == 1:\n            # Check if removing this item keeps solution feasible\n            if np.sum(weight_lst[base_solution == 1]) - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n        else:\n            # Check if adding this item keeps solution feasible\n            if np.sum(weight_lst[base_solution == 1]) + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.33723812277567244,
            4.966503858566284
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions with higher diversity or marginal improvement potential\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (i + 1) for i in range(len(archive))])[0]\n    base_solution, (base_val1, base_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    # Option 1: Random item swap (if feasible)\n    if random.random() < 0.5:\n        # Find items that can be swapped (one in, one out)\n        in_items = np.where(base_solution == 1)[0]\n        out_items = np.where(base_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            swap_in = random.choice(in_items)\n            swap_out = random.choice(out_items)\n\n            # Check feasibility\n            current_weight = np.sum(weight_lst[base_solution == 1])\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n\n    # Option 2: Simulated annealing-inspired flip (allow temporary infeasibility with probability)\n    else:\n        # Randomly select an item to flip\n        flip_idx = random.randint(0, len(weight_lst) - 1)\n\n        if base_solution[flip_idx] == 1:\n            # Check if removing this item keeps solution feasible\n            if np.sum(weight_lst[base_solution == 1]) - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n        else:\n            # Check if adding this item keeps solution feasible\n            if np.sum(weight_lst[base_solution == 1]) + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 160,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with the highest combined objective values, then applies a hybrid local search combining random swaps and objective-aware flips to generate a feasible neighbor solution while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_idx = random.randint(0, min(2, len(archive_sorted) - 1))\n    base_solution = archive_sorted[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Generate neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    items = list(range(len(weight_lst)))\n\n    # Random swaps with feasibility check\n    for _ in range(5):\n        random.shuffle(items)\n        for i in items:\n            if new_solution[i] == 1:\n                new_weight = current_weight - weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 0\n                    current_weight = new_weight\n                    break\n            else:\n                new_weight = current_weight + weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 1\n                    current_weight = new_weight\n                    break\n\n    # Objective-aware flips\n    for _ in range(3):\n        # Try to improve value1\n        if random.random() < 0.5:\n            candidates = [i for i in items if new_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity]\n            if candidates:\n                best_candidate = max(candidates, key=lambda x: value1_lst[x] / weight_lst[x])\n                new_solution[best_candidate] = 1\n                current_weight += weight_lst[best_candidate]\n        else:\n            candidates = [i for i in items if new_solution[i] == 1]\n            if candidates:\n                best_candidate = min(candidates, key=lambda x: value1_lst[x] / weight_lst[x])\n                new_solution[best_candidate] = 0\n                current_weight -= weight_lst[best_candidate]\n\n        # Try to improve value2\n        if random.random() < 0.5:\n            candidates = [i for i in items if new_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity]\n            if candidates:\n                best_candidate = max(candidates, key=lambda x: value2_lst[x] / weight_lst[x])\n                new_solution[best_candidate] = 1\n                current_weight += weight_lst[best_candidate]\n        else:\n            candidates = [i for i in items if new_solution[i] == 1]\n            if candidates:\n                best_candidate = min(candidates, key=lambda x: value2_lst[x] / weight_lst[x])\n                new_solution[best_candidate] = 0\n                current_weight -= weight_lst[best_candidate]\n\n    return new_solution\n\n",
        "score": [
            -0.32848948901526337,
            11.081637173891068
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_idx = random.randint(0, min(2, len(archive_sorted) - 1))\n    base_solution = archive_sorted[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Generate neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    items = list(range(len(weight_lst)))\n\n    # Random swaps with feasibility check\n    for _ in range(5):\n        random.shuffle(items)\n        for i in items:\n            if new_solution[i] == 1:\n                new_weight = current_weight - weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 0\n                    current_weight = new_weight\n                    break\n            else:\n                new_weight = current_weight + weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 1\n                    current_weight = new_weight\n                    break\n\n    # Objective-aware flips\n    for _ in range(3):\n        # Try to improve value1\n        if random.random() < 0.5:\n            candidates = [i for i in items if new_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity]\n            if candidates:\n                best_candidate = max(candidates, key=lambda x: value1_lst[x] / weight_lst[x])\n                new_solution[best_candidate] = 1\n                current_weight += weight_lst[best_candidate]\n        else:\n            candidates = [i for i in items if new_solution[i] == 1]\n            if candidates:\n                best_candidate = min(candidates, key=lambda x: value1_lst[x] / weight_lst[x])\n                new_solution[best_candidate] = 0\n                current_weight -= weight_lst[best_candidate]\n\n        # Try to improve value2\n        if random.random() < 0.5:\n            candidates = [i for i in items if new_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity]\n            if candidates:\n                best_candidate = max(candidates, key=lambda x: value2_lst[x] / weight_lst[x])\n                new_solution[best_candidate] = 1\n                current_weight += weight_lst[best_candidate]\n        else:\n            candidates = [i for i in items if new_solution[i] == 1]\n            if candidates:\n                best_candidate = min(candidates, key=lambda x: value2_lst[x] / weight_lst[x])\n                new_solution[best_candidate] = 0\n                current_weight -= weight_lst[best_candidate]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 161,
        "algorithm": "{A novel local search algorithm that intelligently selects a solution from the archive, identifies a subset of items with high marginal gains in both objectives, and performs a hybrid flip-and-swap operation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a combination of objective values and diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (base_val1, base_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Identify items that could be flipped (added or removed)\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    candidate_items = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if removing this item keeps the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                candidate_items.append((i, 'remove'))\n        else:\n            # Check if adding this item keeps the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                candidate_items.append((i, 'add'))\n\n    if not candidate_items:\n        return new_solution\n\n    # Select a subset of items with high marginal gains\n    marginal_gains = []\n    for item, action in candidate_items:\n        if action == 'remove':\n            gain1 = -value1_lst[item]\n            gain2 = -value2_lst[item]\n        else:\n            gain1 = value1_lst[item]\n            gain2 = value2_lst[item]\n        marginal_gains.append((item, gain1, gain2))\n\n    # Sort by combined gain (simple heuristic)\n    marginal_gains.sort(key=lambda x: (x[1] + x[2]), reverse=True)\n    selected_items = marginal_gains[:min(3, len(marginal_gains))]\n\n    # Perform hybrid flip-and-swap operation\n    for item, _, _ in selected_items:\n        if base_solution[item] == 1:\n            # Try to remove and add another item\n            new_solution[item] = 0\n            # Find another item to add with complementary gains\n            for other_item, _, _ in selected_items:\n                if other_item != item and base_solution[other_item] == 0:\n                    if np.sum(weight_lst[new_solution == 1]) + weight_lst[other_item] <= capacity:\n                        new_solution[other_item] = 1\n                        break\n        else:\n            # Try to add\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.9015928538236999,
            3.0160026252269745
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a combination of objective values and diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (base_val1, base_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Identify items that could be flipped (added or removed)\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    candidate_items = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if removing this item keeps the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                candidate_items.append((i, 'remove'))\n        else:\n            # Check if adding this item keeps the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                candidate_items.append((i, 'add'))\n\n    if not candidate_items:\n        return new_solution\n\n    # Select a subset of items with high marginal gains\n    marginal_gains = []\n    for item, action in candidate_items:\n        if action == 'remove':\n            gain1 = -value1_lst[item]\n            gain2 = -value2_lst[item]\n        else:\n            gain1 = value1_lst[item]\n            gain2 = value2_lst[item]\n        marginal_gains.append((item, gain1, gain2))\n\n    # Sort by combined gain (simple heuristic)\n    marginal_gains.sort(key=lambda x: (x[1] + x[2]), reverse=True)\n    selected_items = marginal_gains[:min(3, len(marginal_gains))]\n\n    # Perform hybrid flip-and-swap operation\n    for item, _, _ in selected_items:\n        if base_solution[item] == 1:\n            # Try to remove and add another item\n            new_solution[item] = 0\n            # Find another item to add with complementary gains\n            for other_item, _, _ in selected_items:\n                if other_item != item and base_solution[other_item] == 0:\n                    if np.sum(weight_lst[new_solution == 1]) + weight_lst[other_item] <= capacity:\n                        new_solution[other_item] = 1\n                        break\n        else:\n            # Try to add\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 162,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: np.sum(x[0]) * np.sum(weight_lst[x[0].astype(bool)] < capacity))\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Randomly select a subset of items to consider for flipping\n    candidate_indices = np.where(base_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.where(base_solution == 0)[0]\n\n    # Randomly select a subset of items to flip\n    flip_indices = np.random.choice(candidate_indices, size=min(3, len(candidate_indices)), replace=False)\n\n    # Calculate potential impact of flipping each candidate item\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # If item is currently included, check if removing it improves both objectives\n            new_weight = np.sum(weight_lst[new_solution.astype(bool)]) - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n        else:\n            # If item is currently excluded, check if adding it improves both objectives\n            new_weight = np.sum(weight_lst[new_solution.astype(bool)]) + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n\n    # Step 3: Apply a diversification step to escape local optima\n    # Randomly flip one additional item to ensure exploration\n    if len(candidate_indices) > 0:\n        random_idx = np.random.choice(candidate_indices)\n        if base_solution[random_idx] == 1:\n            new_weight = np.sum(weight_lst[new_solution.astype(bool)]) - weight_lst[random_idx]\n            if new_weight <= capacity:\n                new_solution[random_idx] = 0\n        else:\n            new_weight = np.sum(weight_lst[new_solution.astype(bool)]) + weight_lst[random_idx]\n            if new_weight <= capacity:\n                new_solution[random_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.9288460182696726,
            7.212852478027344
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: np.sum(x[0]) * np.sum(weight_lst[x[0].astype(bool)] < capacity))\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Randomly select a subset of items to consider for flipping\n    candidate_indices = np.where(base_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.where(base_solution == 0)[0]\n\n    # Randomly select a subset of items to flip\n    flip_indices = np.random.choice(candidate_indices, size=min(3, len(candidate_indices)), replace=False)\n\n    # Calculate potential impact of flipping each candidate item\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # If item is currently included, check if removing it improves both objectives\n            new_weight = np.sum(weight_lst[new_solution.astype(bool)]) - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n        else:\n            # If item is currently excluded, check if adding it improves both objectives\n            new_weight = np.sum(weight_lst[new_solution.astype(bool)]) + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n\n    # Step 3: Apply a diversification step to escape local optima\n    # Randomly flip one additional item to ensure exploration\n    if len(candidate_indices) > 0:\n        random_idx = np.random.choice(candidate_indices)\n        if base_solution[random_idx] == 1:\n            new_weight = np.sum(weight_lst[new_solution.astype(bool)]) - weight_lst[random_idx]\n            if new_weight <= capacity:\n                new_solution[random_idx] = 0\n        else:\n            new_weight = np.sum(weight_lst[new_solution.astype(bool)]) + weight_lst[random_idx]\n            if new_weight <= capacity:\n                new_solution[random_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 163,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a promising solution from the archive, performs a multi-objective swap-based perturbation to explore high-potential regions, and ensures feasibility by dynamically adjusting the neighborhood to respect the capacity constraint.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with high potential for improvement\n    candidates = []\n    for sol, _ in archive:\n        total_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - total_weight\n        if remaining_capacity > 0:\n            candidates.append(sol)\n\n    if not candidates:\n        return archive[0][0].copy()  # Fallback if no feasible candidates\n\n    # Intelligent random selection based on potential improvement\n    selected_sol = random.choice(candidates)\n    new_solution = selected_sol.copy()\n\n    # Hybrid local search: multi-objective swap-based perturbation\n    n_items = len(weight_lst)\n    for _ in range(min(5, n_items // 2)):  # Limit the number of swaps\n        # Identify items to swap (prioritize high-value items)\n        high_value_indices1 = np.argsort(-value1_lst)[np.where(selected_sol == 1)[0]]\n        high_value_indices2 = np.argsort(-value2_lst)[np.where(selected_sol == 1)[0]]\n        low_value_indices1 = np.argsort(value1_lst)[np.where(selected_sol == 0)[0]]\n        low_value_indices2 = np.argsort(value2_lst)[np.where(selected_sol == 0)[0]]\n\n        # Perform swaps in a balanced way\n        if len(high_value_indices1) > 0 and len(low_value_indices1) > 0:\n            swap_idx1 = random.choice(high_value_indices1)\n            swap_idx2 = random.choice(low_value_indices1)\n            new_solution[swap_idx1], new_solution[swap_idx2] = new_solution[swap_idx2], new_solution[swap_idx1]\n\n        if len(high_value_indices2) > 0 and len(low_value_indices2) > 0:\n            swap_idx1 = random.choice(high_value_indices2)\n            swap_idx2 = random.choice(low_value_indices2)\n            new_solution[swap_idx1], new_solution[swap_idx2] = new_solution[swap_idx2], new_solution[swap_idx1]\n\n        # Ensure feasibility\n        total_weight = np.sum(weight_lst * new_solution)\n        if total_weight > capacity:\n            # Remove excess weight by removing low-value items\n            excess = total_weight - capacity\n            for idx in np.argsort(value1_lst + value2_lst)[::-1]:\n                if new_solution[idx] == 1 and excess > 0:\n                    new_solution[idx] = 0\n                    excess -= weight_lst[idx]\n                    if excess <= 0:\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.5157035043458985,
            7.551794111728668
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with high potential for improvement\n    candidates = []\n    for sol, _ in archive:\n        total_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - total_weight\n        if remaining_capacity > 0:\n            candidates.append(sol)\n\n    if not candidates:\n        return archive[0][0].copy()  # Fallback if no feasible candidates\n\n    # Intelligent random selection based on potential improvement\n    selected_sol = random.choice(candidates)\n    new_solution = selected_sol.copy()\n\n    # Hybrid local search: multi-objective swap-based perturbation\n    n_items = len(weight_lst)\n    for _ in range(min(5, n_items // 2)):  # Limit the number of swaps\n        # Identify items to swap (prioritize high-value items)\n        high_value_indices1 = np.argsort(-value1_lst)[np.where(selected_sol == 1)[0]]\n        high_value_indices2 = np.argsort(-value2_lst)[np.where(selected_sol == 1)[0]]\n        low_value_indices1 = np.argsort(value1_lst)[np.where(selected_sol == 0)[0]]\n        low_value_indices2 = np.argsort(value2_lst)[np.where(selected_sol == 0)[0]]\n\n        # Perform swaps in a balanced way\n        if len(high_value_indices1) > 0 and len(low_value_indices1) > 0:\n            swap_idx1 = random.choice(high_value_indices1)\n            swap_idx2 = random.choice(low_value_indices1)\n            new_solution[swap_idx1], new_solution[swap_idx2] = new_solution[swap_idx2], new_solution[swap_idx1]\n\n        if len(high_value_indices2) > 0 and len(low_value_indices2) > 0:\n            swap_idx1 = random.choice(high_value_indices2)\n            swap_idx2 = random.choice(low_value_indices2)\n            new_solution[swap_idx1], new_solution[swap_idx2] = new_solution[swap_idx2], new_solution[swap_idx1]\n\n        # Ensure feasibility\n        total_weight = np.sum(weight_lst * new_solution)\n        if total_weight > capacity:\n            # Remove excess weight by removing low-value items\n            excess = total_weight - capacity\n            for idx in np.argsort(value1_lst + value2_lst)[::-1]:\n                if new_solution[idx] == 1 and excess > 0:\n                    new_solution[idx] = 0\n                    excess -= weight_lst[idx]\n                    if excess <= 0:\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 164,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a diversity-aware heuristic, then applies a novel hybrid local search combining adaptive bit flipping and simulated annealing, ensuring feasibility by dynamically adjusting the neighborhood exploration to maintain weight constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution based on diversity and potential improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: adaptive bit flip with simulated annealing\n    new_solution = base_solution.copy()\n    temperature = 1.0\n    cooling_rate = 0.95\n    max_iter = 100\n\n    for _ in range(max_iter):\n        # Select a random item to flip\n        candidate_items = np.where(new_solution == 1)[0]\n        if len(candidate_items) > 0:\n            item_to_remove = random.choice(candidate_items)\n            new_weight = current_weight - weight_lst[item_to_remove]\n            if new_weight >= 0:\n                new_solution[item_to_remove] = 0\n                current_weight = new_weight\n                continue\n\n        # Try to add a new item if possible\n        candidate_items = np.where(new_solution == 0)[0]\n        if len(candidate_items) > 0:\n            item_to_add = random.choice(candidate_items)\n            new_weight = current_weight + weight_lst[item_to_add]\n            if new_weight <= capacity:\n                new_solution[item_to_add] = 1\n                current_weight = new_weight\n                continue\n\n        # If no feasible move found, try simulated annealing\n        if temperature > 0.1:\n            # Randomly select an item to flip (may violate capacity)\n            item_idx = random.randint(0, len(new_solution) - 1)\n            if new_solution[item_idx] == 1:\n                new_weight = current_weight - weight_lst[item_idx]\n            else:\n                new_weight = current_weight + weight_lst[item_idx]\n\n            # Acceptance probability\n            delta = abs(new_weight - capacity) if new_weight > capacity else 0\n            if delta == 0 or random.random() < np.exp(-delta / temperature):\n                new_solution[item_idx] = 1 - new_solution[item_idx]\n                current_weight = new_weight\n\n            temperature *= cooling_rate\n\n    return new_solution\n\n",
        "score": [
            -0.8817819347464285,
            8.441828161478043
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution based on diversity and potential improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: adaptive bit flip with simulated annealing\n    new_solution = base_solution.copy()\n    temperature = 1.0\n    cooling_rate = 0.95\n    max_iter = 100\n\n    for _ in range(max_iter):\n        # Select a random item to flip\n        candidate_items = np.where(new_solution == 1)[0]\n        if len(candidate_items) > 0:\n            item_to_remove = random.choice(candidate_items)\n            new_weight = current_weight - weight_lst[item_to_remove]\n            if new_weight >= 0:\n                new_solution[item_to_remove] = 0\n                current_weight = new_weight\n                continue\n\n        # Try to add a new item if possible\n        candidate_items = np.where(new_solution == 0)[0]\n        if len(candidate_items) > 0:\n            item_to_add = random.choice(candidate_items)\n            new_weight = current_weight + weight_lst[item_to_add]\n            if new_weight <= capacity:\n                new_solution[item_to_add] = 1\n                current_weight = new_weight\n                continue\n\n        # If no feasible move found, try simulated annealing\n        if temperature > 0.1:\n            # Randomly select an item to flip (may violate capacity)\n            item_idx = random.randint(0, len(new_solution) - 1)\n            if new_solution[item_idx] == 1:\n                new_weight = current_weight - weight_lst[item_idx]\n            else:\n                new_weight = current_weight + weight_lst[item_idx]\n\n            # Acceptance probability\n            delta = abs(new_weight - capacity) if new_weight > capacity else 0\n            if delta == 0 or random.random() < np.exp(-delta / temperature):\n                new_solution[item_idx] = 1 - new_solution[item_idx]\n                current_weight = new_weight\n\n            temperature *= cooling_rate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 165,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high objective values and low weight, then applies a hybrid local search strategy combining item swapping and probabilistic flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Prioritize solutions with high objective values and low weight\n    def score(sol_obj):\n        sol, obj = sol_obj\n        total_weight = np.sum(weight_lst[sol == 1])\n        # Score is a combination of normalized objectives and weight\n        score_val = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        return score_val\n\n    archive_sorted = sorted(archive, key=score, reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n\n    # Generate a neighbor solution using a hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Strategy 1: Randomly flip a subset of items (probabilistic flipping)\n    for i in range(n_items):\n        if random.random() < 0.2:  # 20% chance to flip\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n            else:\n                # Check feasibility before adding\n                current_weight = np.sum(weight_lst[new_solution == 1])\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    # Strategy 2: Swap two items (if feasible)\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] != new_solution[j]:\n            # Check feasibility before swapping\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            delta = (weight_lst[j] - weight_lst[i]) if new_solution[i] == 1 else (weight_lst[i] - weight_lst[j])\n            if current_weight + delta <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.37280946425559147,
            6.116921573877335
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Prioritize solutions with high objective values and low weight\n    def score(sol_obj):\n        sol, obj = sol_obj\n        total_weight = np.sum(weight_lst[sol == 1])\n        # Score is a combination of normalized objectives and weight\n        score_val = (obj[0] + obj[1]) / (total_weight + 1e-6)\n        return score_val\n\n    archive_sorted = sorted(archive, key=score, reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n\n    # Generate a neighbor solution using a hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Strategy 1: Randomly flip a subset of items (probabilistic flipping)\n    for i in range(n_items):\n        if random.random() < 0.2:  # 20% chance to flip\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n            else:\n                # Check feasibility before adding\n                current_weight = np.sum(weight_lst[new_solution == 1])\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    # Strategy 2: Swap two items (if feasible)\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] != new_solution[j]:\n            # Check feasibility before swapping\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            delta = (weight_lst[j] - weight_lst[i]) if new_solution[i] == 1 else (weight_lst[i] - weight_lst[j])\n            if current_weight + delta <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 166,
        "algorithm": "{This algorithm selects a promising solution from the archive based on a hybrid of crowding distance and objective diversity, then applies a novel local search that combines item swapping and greedy addition to explore high-potential regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution using crowding distance and objective diversity\n    def crowding_distance(solutions):\n        if len(solutions) < 3:\n            return [0.0] * len(solutions)\n\n        objectives = np.array([obj for (_, obj) in solutions])\n        distances = np.zeros(len(solutions))\n\n        for m in range(objectives.shape[1]):\n            sorted_idx = np.argsort(objectives[:, m])\n            sorted_obj = objectives[sorted_idx, m]\n            distances[sorted_idx[0]] = distances[sorted_idx[-1]] = float('inf')\n\n            for i in range(1, len(solutions)-1):\n                if sorted_obj[-1] == sorted_obj[0]:\n                    continue\n                distances[sorted_idx[i]] += (sorted_obj[i+1] - sorted_obj[i-1]) / (sorted_obj[-1] - sorted_obj[0])\n\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search operator\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 2a: Randomly select a subset of items to consider for swapping\n    swap_candidates = random.sample(range(n_items), min(5, n_items))\n\n    for i in swap_candidates:\n        if new_solution[i] == 1:\n            # Try removing this item\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n        else:\n            # Try adding this item\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n\n    # Step 2b: Greedy addition of promising items not in the solution\n    remaining_items = [i for i in range(n_items) if new_solution[i] == 0]\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    for i in remaining_items:\n        if current_weight + weight_lst[i] <= capacity:\n            # Evaluate both objectives for potential addition\n            value1_improvement = value1_lst[i]\n            value2_improvement = value2_lst[i]\n\n            # Simple heuristic: prefer items that improve both objectives or at least one significantly\n            if (value1_improvement > 0 and value2_improvement > 0) or \\\n               (value1_improvement > np.mean(value1_lst) and value2_improvement > np.mean(value2_lst)):\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.44019430977460317,
            7.244097709655762
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution using crowding distance and objective diversity\n    def crowding_distance(solutions):\n        if len(solutions) < 3:\n            return [0.0] * len(solutions)\n\n        objectives = np.array([obj for (_, obj) in solutions])\n        distances = np.zeros(len(solutions))\n\n        for m in range(objectives.shape[1]):\n            sorted_idx = np.argsort(objectives[:, m])\n            sorted_obj = objectives[sorted_idx, m]\n            distances[sorted_idx[0]] = distances[sorted_idx[-1]] = float('inf')\n\n            for i in range(1, len(solutions)-1):\n                if sorted_obj[-1] == sorted_obj[0]:\n                    continue\n                distances[sorted_idx[i]] += (sorted_obj[i+1] - sorted_obj[i-1]) / (sorted_obj[-1] - sorted_obj[0])\n\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search operator\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 2a: Randomly select a subset of items to consider for swapping\n    swap_candidates = random.sample(range(n_items), min(5, n_items))\n\n    for i in swap_candidates:\n        if new_solution[i] == 1:\n            # Try removing this item\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n        else:\n            # Try adding this item\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n\n    # Step 2b: Greedy addition of promising items not in the solution\n    remaining_items = [i for i in range(n_items) if new_solution[i] == 0]\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    for i in remaining_items:\n        if current_weight + weight_lst[i] <= capacity:\n            # Evaluate both objectives for potential addition\n            value1_improvement = value1_lst[i]\n            value2_improvement = value2_lst[i]\n\n            # Simple heuristic: prefer items that improve both objectives or at least one significantly\n            if (value1_improvement > 0 and value2_improvement > 0) or \\\n               (value1_improvement > np.mean(value1_lst) and value2_improvement > np.mean(value2_lst)):\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 167,
        "algorithm": "{The heuristic function selects a promising solution from the archive by prioritizing those with high objective values and low crowding distance, then applies a hybrid local search operator that combines item swaps and probabilistic flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution using a combination of objective values and crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    # Compute crowding distance for each solution\n    for i in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive) - 1):\n            crowding_distances[sorted_idx[j]] += (objectives[sorted_idx[j + 1], i] - objectives[sorted_idx[j - 1], i])\n\n    # Select a solution with high crowding distance and high objective values\n    scores = objectives[:, 0] + objectives[:, 1] + crowding_distances\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor solution using a hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Randomly select a subset of items to flip or swap\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n    swap_indices = np.random.choice(n_items, size=min(2, n_items), replace=False)\n\n    # Apply probabilistic flips\n    for idx in flip_indices:\n        if np.random.rand() < 0.5:  # 50% chance to flip\n            if new_solution[idx] == 1:\n                if total_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    total_weight -= weight_lst[idx]\n            else:\n                if total_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    total_weight += weight_lst[idx]\n\n    # Apply item swaps if feasible\n    if len(swap_indices) == 2:\n        i, j = swap_indices\n        if new_solution[i] != new_solution[j]:\n            if new_solution[i] == 1 and new_solution[j] == 0:\n                if total_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            elif new_solution[i] == 0 and new_solution[j] == 1:\n                if total_weight + weight_lst[i] - weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6898713813921367,
            8.85537376999855
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution using a combination of objective values and crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    # Compute crowding distance for each solution\n    for i in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive) - 1):\n            crowding_distances[sorted_idx[j]] += (objectives[sorted_idx[j + 1], i] - objectives[sorted_idx[j - 1], i])\n\n    # Select a solution with high crowding distance and high objective values\n    scores = objectives[:, 0] + objectives[:, 1] + crowding_distances\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor solution using a hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Randomly select a subset of items to flip or swap\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n    swap_indices = np.random.choice(n_items, size=min(2, n_items), replace=False)\n\n    # Apply probabilistic flips\n    for idx in flip_indices:\n        if np.random.rand() < 0.5:  # 50% chance to flip\n            if new_solution[idx] == 1:\n                if total_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    total_weight -= weight_lst[idx]\n            else:\n                if total_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    total_weight += weight_lst[idx]\n\n    # Apply item swaps if feasible\n    if len(swap_indices) == 2:\n        i, j = swap_indices\n        if new_solution[i] != new_solution[j]:\n            if new_solution[i] == 1 and new_solution[j] == 0:\n                if total_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            elif new_solution[i] == 0 and new_solution[j] == 1:\n                if total_weight + weight_lst[i] - weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 168,
        "algorithm": "{A novel hybrid local search strategy that alternates between critical item swaps and adaptive neighborhood exploration, guided by a dynamic trade-off factor to balance exploration and exploitation, while ensuring feasibility through constrained random perturbations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Intelligent random selection based on solution quality and diversity\n        selected_indices = random.sample(range(len(archive)), min(5, len(archive)))\n        selected_solutions = [archive[i][0] for i in selected_indices]\n        selected_objectives = [archive[i][1] for i in selected_indices]\n\n        # Calculate crowding distance for selection\n        crowding_distances = []\n        for i in range(len(selected_solutions)):\n            distances = []\n            for j in range(len(selected_solutions)):\n                if i != j:\n                    dist = np.sqrt((selected_objectives[i][0] - selected_objectives[j][0])**2 +\n                                 (selected_objectives[i][1] - selected_objectives[j][1])**2)\n                    distances.append(dist)\n            crowding_distances.append(np.mean(distances) if distances else float('inf'))\n\n        # Select solution with highest crowding distance (promising for improvement)\n        selected_idx = np.argmax(crowding_distances)\n        base_solution = selected_solutions[selected_idx].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Determine trade-off factor (dynamic based on solution quality)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n    trade_off = total_value1 / (total_value1 + total_value2 + 1e-10) if (total_value1 + total_value2) > 0 else 0.5\n\n    # Hybrid local search strategy\n    if random.random() < 0.7:  # 70% chance for critical item swap\n        # Identify critical items (high value/weight ratio)\n        value_ratio1 = value1_lst / (weight_lst + 1e-10)\n        value_ratio2 = value2_lst / (weight_lst + 1e-10)\n\n        # Combine ratios with trade-off factor\n        combined_ratio = trade_off * value_ratio1 + (1 - trade_off) * value_ratio2\n\n        # Sort items by combined ratio\n        sorted_indices = np.argsort(combined_ratio)[::-1]\n\n        # Try to swap top items\n        for idx in sorted_indices[:5]:  # Check top 5 items\n            if new_solution[idx] == 1:\n                # Try to remove this item\n                temp_solution = new_solution.copy()\n                temp_solution[idx] = 0\n                temp_weight = current_weight - weight_lst[idx]\n\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n                    break\n            else:\n                # Try to add this item\n                temp_solution = new_solution.copy()\n                temp_solution[idx] = 1\n                temp_weight = current_weight + weight_lst[idx]\n\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n                    break\n    else:  # Adaptive neighborhood exploration\n        # Randomly select a subset of items to perturb\n        num_items = len(new_solution)\n        num_to_perturb = min(3, num_items)  # Perturb up to 3 items\n        perturb_indices = random.sample(range(num_items), num_to_perturb)\n\n        for idx in perturb_indices:\n            if new_solution[idx] == 1:\n                # Try to remove\n                temp_solution = new_solution.copy()\n                temp_solution[idx] = 0\n                temp_weight = current_weight - weight_lst[idx]\n\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n            else:\n                # Try to add\n                temp_solution = new_solution.copy()\n                temp_solution[idx] = 1\n                temp_weight = current_weight + weight_lst[idx]\n\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -0.3837377508208656,
            4.098197191953659
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Intelligent random selection based on solution quality and diversity\n        selected_indices = random.sample(range(len(archive)), min(5, len(archive)))\n        selected_solutions = [archive[i][0] for i in selected_indices]\n        selected_objectives = [archive[i][1] for i in selected_indices]\n\n        # Calculate crowding distance for selection\n        crowding_distances = []\n        for i in range(len(selected_solutions)):\n            distances = []\n            for j in range(len(selected_solutions)):\n                if i != j:\n                    dist = np.sqrt((selected_objectives[i][0] - selected_objectives[j][0])**2 +\n                                 (selected_objectives[i][1] - selected_objectives[j][1])**2)\n                    distances.append(dist)\n            crowding_distances.append(np.mean(distances) if distances else float('inf'))\n\n        # Select solution with highest crowding distance (promising for improvement)\n        selected_idx = np.argmax(crowding_distances)\n        base_solution = selected_solutions[selected_idx].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Determine trade-off factor (dynamic based on solution quality)\n    total_value1 = np.sum(value1_lst * new_solution)\n    total_value2 = np.sum(value2_lst * new_solution)\n    trade_off = total_value1 / (total_value1 + total_value2 + 1e-10) if (total_value1 + total_value2) > 0 else 0.5\n\n    # Hybrid local search strategy\n    if random.random() < 0.7:  # 70% chance for critical item swap\n        # Identify critical items (high value/weight ratio)\n        value_ratio1 = value1_lst / (weight_lst + 1e-10)\n        value_ratio2 = value2_lst / (weight_lst + 1e-10)\n\n        # Combine ratios with trade-off factor\n        combined_ratio = trade_off * value_ratio1 + (1 - trade_off) * value_ratio2\n\n        # Sort items by combined ratio\n        sorted_indices = np.argsort(combined_ratio)[::-1]\n\n        # Try to swap top items\n        for idx in sorted_indices[:5]:  # Check top 5 items\n            if new_solution[idx] == 1:\n                # Try to remove this item\n                temp_solution = new_solution.copy()\n                temp_solution[idx] = 0\n                temp_weight = current_weight - weight_lst[idx]\n\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n                    break\n            else:\n                # Try to add this item\n                temp_solution = new_solution.copy()\n                temp_solution[idx] = 1\n                temp_weight = current_weight + weight_lst[idx]\n\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n                    break\n    else:  # Adaptive neighborhood exploration\n        # Randomly select a subset of items to perturb\n        num_items = len(new_solution)\n        num_to_perturb = min(3, num_items)  # Perturb up to 3 items\n        perturb_indices = random.sample(range(num_items), num_to_perturb)\n\n        for idx in perturb_indices:\n            if new_solution[idx] == 1:\n                # Try to remove\n                temp_solution = new_solution.copy()\n                temp_solution[idx] = 0\n                temp_weight = current_weight - weight_lst[idx]\n\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n            else:\n                # Try to add\n                temp_solution = new_solution.copy()\n                temp_solution[idx] = 1\n                temp_weight = current_weight + weight_lst[idx]\n\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 169,
        "algorithm": "{The heuristic selects a solution from the archive with the highest combined objective value, then applies a novel local search operator that intelligently flips subsets of items based on their marginal contribution to both objectives, ensuring feasibility while balancing exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify items that can be flipped (either included or excluded) while maintaining feasibility\n    candidate_indices = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if removing this item would keep the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                candidate_indices.append((i, -1))  # -1 means exclude\n        else:\n            # Check if adding this item would keep the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                candidate_indices.append((i, 1))  # 1 means include\n\n    if not candidate_indices:\n        return base_solution  # No feasible moves\n\n    # Select a random candidate to flip\n    idx, flip = random.choice(candidate_indices)\n    new_solution = base_solution.copy()\n    new_solution[idx] = flip\n\n    # Further refine by flipping a subset of items based on marginal contribution\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal2 = value2_lst / (weight_lst + 1e-6)\n\n    # Combine marginal contributions and select top candidates\n    combined_marginal = marginal1 + marginal2\n    top_indices = np.argsort(combined_marginal)[-min(5, len(combined_marginal)):]  # Top 5 items\n\n    for i in top_indices:\n        if i in [x[0] for x in candidate_indices]:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8553702015482026,
            6.621552646160126
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify items that can be flipped (either included or excluded) while maintaining feasibility\n    candidate_indices = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if removing this item would keep the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                candidate_indices.append((i, -1))  # -1 means exclude\n        else:\n            # Check if adding this item would keep the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                candidate_indices.append((i, 1))  # 1 means include\n\n    if not candidate_indices:\n        return base_solution  # No feasible moves\n\n    # Select a random candidate to flip\n    idx, flip = random.choice(candidate_indices)\n    new_solution = base_solution.copy()\n    new_solution[idx] = flip\n\n    # Further refine by flipping a subset of items based on marginal contribution\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal2 = value2_lst / (weight_lst + 1e-6)\n\n    # Combine marginal contributions and select top candidates\n    combined_marginal = marginal1 + marginal2\n    top_indices = np.argsort(combined_marginal)[-min(5, len(combined_marginal)):]  # Top 5 items\n\n    for i in top_indices:\n        if i in [x[0] for x in candidate_indices]:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 170,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a solution from the archive based on its potential for improvement, then applies a dynamic neighborhood exploration strategy combining random flips, value-based swaps, and capacity-aware perturbations to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution from the archive\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor solution using a hybrid approach\n    new_solution = base_solution.copy()\n\n    # Step 1: Random flip with value-based probability\n    for i in range(len(new_solution)):\n        if random.random() < 0.3:  # 30% chance to consider flipping\n            if new_solution[i] == 1:\n                # More likely to remove items with low value ratio\n                value_ratio = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n                if random.random() < (1 - value_ratio / np.max(value1_lst + value2_lst)) or current_weight + weight_lst[i] > capacity:\n                    new_solution[i] = 0\n            else:\n                # More likely to add items with high value ratio\n                if current_weight + weight_lst[i] <= capacity:\n                    value_ratio = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n                    if random.random() < value_ratio / np.max(value1_lst + value2_lst):\n                        new_solution[i] = 1\n\n    # Step 2: Value-based swap if feasible\n    if random.random() < 0.5:  # 50% chance for swap\n        # Find items to swap (one in, one out)\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Select items with high value ratio for potential inclusion\n            in_candidates = sorted(in_items, key=lambda x: -(value1_lst[x] + value2_lst[x]) / weight_lst[x])\n            out_candidates = sorted(out_items, key=lambda x: (value1_lst[x] + value2_lst[x]) / weight_lst[x])\n\n            for in_item in in_candidates[:3]:  # Consider top 3 candidates\n                for out_item in out_candidates[:3]:\n                    new_weight = current_weight - weight_lst[out_item] + weight_lst[in_item]\n                    if new_weight <= capacity:\n                        new_solution[out_item], new_solution[in_item] = 0, 1\n                        break\n                else:\n                    continue\n                break\n\n    # Step 3: Capacity-aware perturbation\n    if random.random() < 0.2:  # 20% chance for perturbation\n        # Randomly remove items to free up space\n        excess_weight = np.sum(weight_lst * new_solution) - capacity\n        if excess_weight > 0:\n            items_to_remove = np.where(new_solution == 1)[0]\n            np.random.shuffle(items_to_remove)\n            for i in items_to_remove:\n                if excess_weight <= 0:\n                    break\n                new_solution[i] = 0\n                excess_weight -= weight_lst[i]\n\n    # Ensure solution is feasible\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Remove random item if over capacity\n        selected = np.where(new_solution == 1)[0]\n        if len(selected) == 0:\n            break\n        idx = random.choice(selected)\n        new_solution[idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.8139417521848776,
            6.343157589435577
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution from the archive\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor solution using a hybrid approach\n    new_solution = base_solution.copy()\n\n    # Step 1: Random flip with value-based probability\n    for i in range(len(new_solution)):\n        if random.random() < 0.3:  # 30% chance to consider flipping\n            if new_solution[i] == 1:\n                # More likely to remove items with low value ratio\n                value_ratio = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n                if random.random() < (1 - value_ratio / np.max(value1_lst + value2_lst)) or current_weight + weight_lst[i] > capacity:\n                    new_solution[i] = 0\n            else:\n                # More likely to add items with high value ratio\n                if current_weight + weight_lst[i] <= capacity:\n                    value_ratio = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n                    if random.random() < value_ratio / np.max(value1_lst + value2_lst):\n                        new_solution[i] = 1\n\n    # Step 2: Value-based swap if feasible\n    if random.random() < 0.5:  # 50% chance for swap\n        # Find items to swap (one in, one out)\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Select items with high value ratio for potential inclusion\n            in_candidates = sorted(in_items, key=lambda x: -(value1_lst[x] + value2_lst[x]) / weight_lst[x])\n            out_candidates = sorted(out_items, key=lambda x: (value1_lst[x] + value2_lst[x]) / weight_lst[x])\n\n            for in_item in in_candidates[:3]:  # Consider top 3 candidates\n                for out_item in out_candidates[:3]:\n                    new_weight = current_weight - weight_lst[out_item] + weight_lst[in_item]\n                    if new_weight <= capacity:\n                        new_solution[out_item], new_solution[in_item] = 0, 1\n                        break\n                else:\n                    continue\n                break\n\n    # Step 3: Capacity-aware perturbation\n    if random.random() < 0.2:  # 20% chance for perturbation\n        # Randomly remove items to free up space\n        excess_weight = np.sum(weight_lst * new_solution) - capacity\n        if excess_weight > 0:\n            items_to_remove = np.where(new_solution == 1)[0]\n            np.random.shuffle(items_to_remove)\n            for i in items_to_remove:\n                if excess_weight <= 0:\n                    break\n                new_solution[i] = 0\n                excess_weight -= weight_lst[i]\n\n    # Ensure solution is feasible\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Remove random item if over capacity\n        selected = np.where(new_solution == 1)[0]\n        if len(selected) == 0:\n            break\n        idx = random.choice(selected)\n        new_solution[idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 171,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on its potential for local improvement, then applies a hybrid local search operator that combines item swapping and targeted flipping to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Select a solution with high potential for improvement\n        # Here, we select a solution that is not too close to the boundary\n        # and has a good balance between the two objectives\n        candidates = []\n        for sol, _ in archive:\n            total_weight = np.sum(weight_lst * sol)\n            if total_weight < 0.9 * capacity and total_weight > 0.1 * capacity:\n                candidates.append(sol)\n        if candidates:\n            base_solution = random.choice(candidates).copy()\n        else:\n            base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    # Step 1: Identify items with high value-to-weight ratio for each objective\n    included = np.where(new_solution == 1)[0]\n    excluded = np.where(new_solution == 0)[0]\n\n    # Step 2: Perform targeted flipping\n    if len(included) > 0:\n        # Flip a low-value item in the knapsack\n        included_values = value1_lst[included] + value2_lst[included]\n        min_idx = np.argmin(included_values)\n        new_solution[included[min_idx]] = 0\n\n    # Step 3: Add a high-value item not in the knapsack\n    if len(excluded) > 0:\n        # Calculate remaining capacity\n        current_weight = np.sum(weight_lst * new_solution)\n        remaining_capacity = capacity - current_weight\n\n        # Filter items that can be added without exceeding capacity\n        feasible_excluded = [i for i in excluded if weight_lst[i] <= remaining_capacity]\n\n        if feasible_excluded:\n            # Select item with highest combined value\n            excluded_values = value1_lst[feasible_excluded] + value2_lst[feasible_excluded]\n            max_idx = np.argmax(excluded_values)\n            new_solution[feasible_excluded[max_idx]] = 1\n\n    # Step 4: Perform a random swap if no improvement is possible\n    if np.array_equal(new_solution, base_solution):\n        if len(included) > 1:\n            # Swap two items in the knapsack\n            i, j = random.sample(included, 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8412848477039757,
            6.0188272297382355
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Select a solution with high potential for improvement\n        # Here, we select a solution that is not too close to the boundary\n        # and has a good balance between the two objectives\n        candidates = []\n        for sol, _ in archive:\n            total_weight = np.sum(weight_lst * sol)\n            if total_weight < 0.9 * capacity and total_weight > 0.1 * capacity:\n                candidates.append(sol)\n        if candidates:\n            base_solution = random.choice(candidates).copy()\n        else:\n            base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    # Step 1: Identify items with high value-to-weight ratio for each objective\n    included = np.where(new_solution == 1)[0]\n    excluded = np.where(new_solution == 0)[0]\n\n    # Step 2: Perform targeted flipping\n    if len(included) > 0:\n        # Flip a low-value item in the knapsack\n        included_values = value1_lst[included] + value2_lst[included]\n        min_idx = np.argmin(included_values)\n        new_solution[included[min_idx]] = 0\n\n    # Step 3: Add a high-value item not in the knapsack\n    if len(excluded) > 0:\n        # Calculate remaining capacity\n        current_weight = np.sum(weight_lst * new_solution)\n        remaining_capacity = capacity - current_weight\n\n        # Filter items that can be added without exceeding capacity\n        feasible_excluded = [i for i in excluded if weight_lst[i] <= remaining_capacity]\n\n        if feasible_excluded:\n            # Select item with highest combined value\n            excluded_values = value1_lst[feasible_excluded] + value2_lst[feasible_excluded]\n            max_idx = np.argmax(excluded_values)\n            new_solution[feasible_excluded[max_idx]] = 1\n\n    # Step 4: Perform a random swap if no improvement is possible\n    if np.array_equal(new_solution, base_solution):\n        if len(included) > 1:\n            # Swap two items in the knapsack\n            i, j = random.sample(included, 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 172,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high marginal gains in both objectives, then applies a hybrid local search combining item swaps and neighborhood exploration to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., one with high marginal gains)\n    selected_idx = random.choices(range(len(archive)), weights=[sum(sol[1]) for sol in archive], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Hybrid local search: combination of item swaps and neighborhood exploration\n    new_solution = base_solution.copy()\n    items = np.where(new_solution == 1)[0]\n    non_items = np.where(new_solution == 0)[0]\n\n    # Swap an item with a non-item if feasible\n    if len(items) > 0 and len(non_items) > 0:\n        swap_item = random.choice(items)\n        swap_non_item = random.choice(non_items)\n        if current_weight - weight_lst[swap_item] + weight_lst[swap_non_item] <= capacity:\n            new_solution[swap_item], new_solution[swap_non_item] = new_solution[swap_non_item], new_solution[swap_item]\n\n    # Add or remove items to explore neighborhood\n    if random.random() < 0.5 and len(non_items) > 0:\n        add_item = random.choice(non_items)\n        if current_weight + weight_lst[add_item] <= capacity:\n            new_solution[add_item] = 1\n    elif len(items) > 0:\n        remove_item = random.choice(items)\n        new_solution[remove_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.3163405286484738,
            3.5546703338623047
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., one with high marginal gains)\n    selected_idx = random.choices(range(len(archive)), weights=[sum(sol[1]) for sol in archive], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Hybrid local search: combination of item swaps and neighborhood exploration\n    new_solution = base_solution.copy()\n    items = np.where(new_solution == 1)[0]\n    non_items = np.where(new_solution == 0)[0]\n\n    # Swap an item with a non-item if feasible\n    if len(items) > 0 and len(non_items) > 0:\n        swap_item = random.choice(items)\n        swap_non_item = random.choice(non_items)\n        if current_weight - weight_lst[swap_item] + weight_lst[swap_non_item] <= capacity:\n            new_solution[swap_item], new_solution[swap_non_item] = new_solution[swap_non_item], new_solution[swap_item]\n\n    # Add or remove items to explore neighborhood\n    if random.random() < 0.5 and len(non_items) > 0:\n        add_item = random.choice(non_items)\n        if current_weight + weight_lst[add_item] <= capacity:\n            new_solution[add_item] = 1\n    elif len(items) > 0:\n        remove_item = random.choice(items)\n        new_solution[remove_item] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 173,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its potential for local improvement, then applies a hybrid local search strategy combining item swaps and probabilistic flips to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly select a subset of items to consider for flipping\n    flip_candidates = np.where(base_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        flip_idx = random.choice(flip_candidates)\n        # Flip the selected item\n        new_solution[flip_idx] = 0\n\n    # Step 2: Add new items with high potential for both objectives\n    remaining_weight = capacity - np.sum(weight_lst[new_solution == 1])\n    potential_items = np.where((weight_lst <= remaining_weight) & (base_solution == 0))[0]\n\n    if len(potential_items) > 0:\n        # Select items with high combined value\n        combined_value = value1_lst + value2_lst\n        sorted_items = sorted(potential_items, key=lambda x: combined_value[x], reverse=True)\n        for item in sorted_items:\n            if weight_lst[item] <= remaining_weight:\n                new_solution[item] = 1\n                remaining_weight -= weight_lst[item]\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        excess_items = np.where(new_solution == 1)[0]\n        while total_weight > capacity and len(excess_items) > 0:\n            remove_idx = random.choice(excess_items)\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n            excess_items = np.where(new_solution == 1)[0]\n\n    return new_solution\n\n",
        "score": [
            -0.375051513879188,
            2.313081920146942
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly select a subset of items to consider for flipping\n    flip_candidates = np.where(base_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        flip_idx = random.choice(flip_candidates)\n        # Flip the selected item\n        new_solution[flip_idx] = 0\n\n    # Step 2: Add new items with high potential for both objectives\n    remaining_weight = capacity - np.sum(weight_lst[new_solution == 1])\n    potential_items = np.where((weight_lst <= remaining_weight) & (base_solution == 0))[0]\n\n    if len(potential_items) > 0:\n        # Select items with high combined value\n        combined_value = value1_lst + value2_lst\n        sorted_items = sorted(potential_items, key=lambda x: combined_value[x], reverse=True)\n        for item in sorted_items:\n            if weight_lst[item] <= remaining_weight:\n                new_solution[item] = 1\n                remaining_weight -= weight_lst[item]\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        excess_items = np.where(new_solution == 1)[0]\n        while total_weight > capacity and len(excess_items) > 0:\n            remove_idx = random.choice(excess_items)\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n            excess_items = np.where(new_solution == 1)[0]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 174,
        "algorithm": "{The algorithm intelligently selects a solution from the archive with high potential for local improvement by evaluating the diversity and non-dominated status of each solution, then applies a hybrid local search operator that combines random flipping of items with a greedy selection of items based on their marginal value contributions to both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: random flip with greedy selection\n    new_solution = base_solution.copy()\n\n    # Randomly flip a subset of items\n    flip_indices = np.random.choice(len(new_solution), size=min(5, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Remove item if it doesn't violate capacity\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Add item if it doesn't violate capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Greedy selection of items based on marginal value\n    for idx in range(len(new_solution)):\n        if new_solution[idx] == 0:\n            if current_weight + weight_lst[idx] <= capacity:\n                # Calculate marginal value for both objectives\n                marginal_value1 = value1_lst[idx]\n                marginal_value2 = value2_lst[idx]\n\n                # If adding this item improves both objectives, add it\n                if marginal_value1 > 0 and marginal_value2 > 0:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.423034322381096,
            4.780873894691467
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: random flip with greedy selection\n    new_solution = base_solution.copy()\n\n    # Randomly flip a subset of items\n    flip_indices = np.random.choice(len(new_solution), size=min(5, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Remove item if it doesn't violate capacity\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Add item if it doesn't violate capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Greedy selection of items based on marginal value\n    for idx in range(len(new_solution)):\n        if new_solution[idx] == 0:\n            if current_weight + weight_lst[idx] <= capacity:\n                # Calculate marginal value for both objectives\n                marginal_value1 = value1_lst[idx]\n                marginal_value2 = value2_lst[idx]\n\n                # If adding this item improves both objectives, add it\n                if marginal_value1 > 0 and marginal_value2 > 0:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 175,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on diversity and potential improvement, then applies a hybrid local search combining random item swaps and guided value-based flips to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a base solution with high diversity and potential for improvement\n    diversity_scores = []\n    for sol, _ in archive:\n        diversity = np.sum(sol != archive[0][0]) / len(sol)\n        diversity_scores.append(diversity)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine random swaps and value-guided flips\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Random swap with feasibility check\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        if new_solution[i] != new_solution[j]:\n            delta_weight = (weight_lst[j] - weight_lst[i]) if new_solution[i] else (weight_lst[i] - weight_lst[j])\n            if current_weight + delta_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Value-guided flip (prioritize high-value items)\n    if random.random() < 0.7:  # 70% chance for value-guided flip\n        # Calculate marginal gains\n        included = np.where(new_solution == 1)[0]\n        excluded = np.where(new_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Calculate value ratios for included items\n            value_ratios = (value1_lst[included] + value2_lst[included]) / weight_lst[included]\n            worst_included = included[np.argmin(value_ratios)]\n\n            # Calculate value ratios for excluded items\n            value_ratios = (value1_lst[excluded] + value2_lst[excluded]) / weight_lst[excluded]\n            best_excluded = excluded[np.argmax(value_ratios)]\n\n            # Flip if beneficial\n            if weight_lst[best_excluded] <= weight_lst[worst_included]:\n                if current_weight - weight_lst[worst_included] + weight_lst[best_excluded] <= capacity:\n                    new_solution[worst_included] = 0\n                    new_solution[best_excluded] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.663403440950436,
            8.021336793899536
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a base solution with high diversity and potential for improvement\n    diversity_scores = []\n    for sol, _ in archive:\n        diversity = np.sum(sol != archive[0][0]) / len(sol)\n        diversity_scores.append(diversity)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine random swaps and value-guided flips\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Random swap with feasibility check\n    if len(new_solution) > 1:\n        i, j = random.sample(range(len(new_solution)), 2)\n        if new_solution[i] != new_solution[j]:\n            delta_weight = (weight_lst[j] - weight_lst[i]) if new_solution[i] else (weight_lst[i] - weight_lst[j])\n            if current_weight + delta_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Value-guided flip (prioritize high-value items)\n    if random.random() < 0.7:  # 70% chance for value-guided flip\n        # Calculate marginal gains\n        included = np.where(new_solution == 1)[0]\n        excluded = np.where(new_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Calculate value ratios for included items\n            value_ratios = (value1_lst[included] + value2_lst[included]) / weight_lst[included]\n            worst_included = included[np.argmin(value_ratios)]\n\n            # Calculate value ratios for excluded items\n            value_ratios = (value1_lst[excluded] + value2_lst[excluded]) / weight_lst[excluded]\n            best_excluded = excluded[np.argmax(value_ratios)]\n\n            # Flip if beneficial\n            if weight_lst[best_excluded] <= weight_lst[worst_included]:\n                if current_weight - weight_lst[worst_included] + weight_lst[best_excluded] <= capacity:\n                    new_solution[worst_included] = 0\n                    new_solution[best_excluded] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 176,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([np.sum(sol[0]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and margins\n    current_weight = np.sum(weight_lst * base_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Identify items to swap: flip items with low marginal contribution in one objective and high in the other\n    marginal_value1 = value1_lst - np.sum(value1_lst * base_solution) / np.sum(base_solution)\n    marginal_value2 = value2_lst - np.sum(value2_lst * base_solution) / np.sum(base_solution)\n\n    # Candidate items to flip: those that are in the solution and have low marginal value in one objective\n    candidate_items = np.where((base_solution == 1) &\n                              ((marginal_value1 < 0) | (marginal_value2 < 0)))[0]\n\n    if len(candidate_items) > 0:\n        # Select a random candidate to flip\n        flip_item = np.random.choice(candidate_items)\n        new_solution[flip_item] = 1 - new_solution[flip_item]\n\n        # Ensure feasibility by removing items if weight exceeds capacity\n        if np.sum(weight_lst * new_solution) > capacity:\n            # Remove items with lowest marginal value until feasible\n            while np.sum(weight_lst * new_solution) > capacity:\n                # Find items in the solution with lowest marginal value in either objective\n                in_solution = np.where(new_solution == 1)[0]\n                if len(in_solution) == 0:\n                    break\n                marginal_values = np.minimum(marginal_value1[in_solution], marginal_value2[in_solution])\n                worst_item = in_solution[np.argmin(marginal_values)]\n                new_solution[worst_item] = 0\n\n    # If no candidates, try adding items with high marginal value in either objective\n    else:\n        candidate_items = np.where((base_solution == 0) &\n                                  ((marginal_value1 > 0) | (marginal_value2 > 0)))[0]\n\n        if len(candidate_items) > 0:\n            # Select a random candidate to add\n            add_item = np.random.choice(candidate_items)\n            if np.sum(weight_lst[add_item] + current_weight) <= capacity:\n                new_solution[add_item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.768113733525144,
            5.682633012533188
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([np.sum(sol[0]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and margins\n    current_weight = np.sum(weight_lst * base_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Identify items to swap: flip items with low marginal contribution in one objective and high in the other\n    marginal_value1 = value1_lst - np.sum(value1_lst * base_solution) / np.sum(base_solution)\n    marginal_value2 = value2_lst - np.sum(value2_lst * base_solution) / np.sum(base_solution)\n\n    # Candidate items to flip: those that are in the solution and have low marginal value in one objective\n    candidate_items = np.where((base_solution == 1) &\n                              ((marginal_value1 < 0) | (marginal_value2 < 0)))[0]\n\n    if len(candidate_items) > 0:\n        # Select a random candidate to flip\n        flip_item = np.random.choice(candidate_items)\n        new_solution[flip_item] = 1 - new_solution[flip_item]\n\n        # Ensure feasibility by removing items if weight exceeds capacity\n        if np.sum(weight_lst * new_solution) > capacity:\n            # Remove items with lowest marginal value until feasible\n            while np.sum(weight_lst * new_solution) > capacity:\n                # Find items in the solution with lowest marginal value in either objective\n                in_solution = np.where(new_solution == 1)[0]\n                if len(in_solution) == 0:\n                    break\n                marginal_values = np.minimum(marginal_value1[in_solution], marginal_value2[in_solution])\n                worst_item = in_solution[np.argmin(marginal_values)]\n                new_solution[worst_item] = 0\n\n    # If no candidates, try adding items with high marginal value in either objective\n    else:\n        candidate_items = np.where((base_solution == 0) &\n                                  ((marginal_value1 > 0) | (marginal_value2 > 0)))[0]\n\n        if len(candidate_items) > 0:\n            # Select a random candidate to add\n            add_item = np.random.choice(candidate_items)\n            if np.sum(weight_lst[add_item] + current_weight) <= capacity:\n                new_solution[add_item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 177,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its potential for local improvement, then applies a hybrid local search strategy combining random item swaps, targeted flips of items with high marginal utility, and a probabilistic exploration of neighboring solutions to ensure feasibility and multi-objective optimization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the utility of each solution as the sum of normalized objectives\n    utilities = []\n    for sol, (v1, v2) in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight > capacity:\n            utilities.append(0)  # Penalize infeasible solutions\n        else:\n            # Normalize objectives and compute utility\n            max_v1 = np.sum(value1_lst) if capacity >= np.sum(weight_lst) else np.max(value1_lst)\n            max_v2 = np.sum(value2_lst) if capacity >= np.sum(weight_lst) else np.max(value2_lst)\n            normalized_v1 = v1 / max_v1 if max_v1 > 0 else 0\n            normalized_v2 = v2 / max_v2 if max_v2 > 0 else 0\n            utilities.append(normalized_v1 + normalized_v2)\n\n    # Select a solution with probability proportional to its utility\n    selected_idx = random.choices(range(len(archive)), weights=utilities, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n\n    # Step 1: Random item swap (basic exploration)\n    if len(new_solution) >= 2:\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Targeted flip of items with high marginal utility\n    total_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - total_weight\n\n    # Calculate marginal utility for each item\n    marginal_v1 = value1_lst / weight_lst if remaining_capacity > 0 else -np.inf\n    marginal_v2 = value2_lst / weight_lst if remaining_capacity > 0 else -np.inf\n\n    # Flip items with highest marginal utility if they fit\n    for _ in range(3):  # Try up to 3 flips\n        # Prioritize items that improve both objectives\n        combined_marginal = marginal_v1 + marginal_v2\n        best_item = np.argmax(combined_marginal)\n\n        if weight_lst[best_item] <= remaining_capacity:\n            new_solution[best_item] = 1 - new_solution[best_item]\n            remaining_capacity -= weight_lst[best_item] * (2 * new_solution[best_item] - 1)\n        else:\n            break\n\n    # Step 3: Probabilistic exploration of neighboring solutions\n    for i in range(len(new_solution)):\n        if random.random() < 0.2:  # 20% chance to flip each item\n            if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n            elif new_solution[i] == 1:\n                new_solution[i] = 0\n                remaining_capacity += weight_lst[i]\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        while total_weight > capacity:\n            items_in = np.where(new_solution == 1)[0]\n            if len(items_in) == 0:\n                break\n            item_to_remove = random.choice(items_in)\n            new_solution[item_to_remove] = 0\n            total_weight -= weight_lst[item_to_remove]\n\n    return new_solution\n\n",
        "score": [
            -0.38715860806331276,
            6.296506494283676
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the utility of each solution as the sum of normalized objectives\n    utilities = []\n    for sol, (v1, v2) in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight > capacity:\n            utilities.append(0)  # Penalize infeasible solutions\n        else:\n            # Normalize objectives and compute utility\n            max_v1 = np.sum(value1_lst) if capacity >= np.sum(weight_lst) else np.max(value1_lst)\n            max_v2 = np.sum(value2_lst) if capacity >= np.sum(weight_lst) else np.max(value2_lst)\n            normalized_v1 = v1 / max_v1 if max_v1 > 0 else 0\n            normalized_v2 = v2 / max_v2 if max_v2 > 0 else 0\n            utilities.append(normalized_v1 + normalized_v2)\n\n    # Select a solution with probability proportional to its utility\n    selected_idx = random.choices(range(len(archive)), weights=utilities, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n\n    # Step 1: Random item swap (basic exploration)\n    if len(new_solution) >= 2:\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Targeted flip of items with high marginal utility\n    total_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - total_weight\n\n    # Calculate marginal utility for each item\n    marginal_v1 = value1_lst / weight_lst if remaining_capacity > 0 else -np.inf\n    marginal_v2 = value2_lst / weight_lst if remaining_capacity > 0 else -np.inf\n\n    # Flip items with highest marginal utility if they fit\n    for _ in range(3):  # Try up to 3 flips\n        # Prioritize items that improve both objectives\n        combined_marginal = marginal_v1 + marginal_v2\n        best_item = np.argmax(combined_marginal)\n\n        if weight_lst[best_item] <= remaining_capacity:\n            new_solution[best_item] = 1 - new_solution[best_item]\n            remaining_capacity -= weight_lst[best_item] * (2 * new_solution[best_item] - 1)\n        else:\n            break\n\n    # Step 3: Probabilistic exploration of neighboring solutions\n    for i in range(len(new_solution)):\n        if random.random() < 0.2:  # 20% chance to flip each item\n            if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n            elif new_solution[i] == 1:\n                new_solution[i] = 0\n                remaining_capacity += weight_lst[i]\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        while total_weight > capacity:\n            items_in = np.where(new_solution == 1)[0]\n            if len(items_in) == 0:\n                break\n            item_to_remove = random.choice(items_in)\n            new_solution[item_to_remove] = 0\n            total_weight -= weight_lst[item_to_remove]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 178,
        "algorithm": "{A novel hybrid local search heuristic selects a solution from the archive based on objective diversity and iteratively applies a dynamic item swapping and perturbation strategy to explore promising regions while ensuring feasibility through adaptive weight adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    objectives = np.array([obj for _, obj in archive])\n    mean_obj = np.mean(objectives, axis=0)\n    distances = np.linalg.norm(objectives - mean_obj, axis=1)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using dynamic swapping and perturbation\n    new_solution = base_solution.copy()\n    items_in = np.where(new_solution == 1)[0]\n    items_out = np.where(new_solution == 0)[0]\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select items to swap (with higher probability for items with high marginal value)\n    if len(items_in) > 0 and len(items_out) > 0:\n        # Calculate marginal values for items in the knapsack\n        marginal_values1 = value1_lst[items_in] / (weight_lst[items_in] + 1e-6)\n        marginal_values2 = value2_lst[items_in] / (weight_lst[items_in] + 1e-6)\n\n        # Combine marginal values and normalize\n        combined_marginal = marginal_values1 + marginal_values2\n        probs = combined_marginal / np.sum(combined_marginal)\n        swap_item_in = np.random.choice(items_in, p=probs)\n\n        # Select an item to swap out based on weight and value tradeoff\n        potential_out = []\n        potential_out_values = []\n        for item_out in items_out:\n            new_weight = current_weight - weight_lst[swap_item_in] + weight_lst[item_out]\n            if new_weight <= capacity:\n                potential_out.append(item_out)\n                potential_out_values.append(value1_lst[item_out] + value2_lst[item_out])\n\n        if potential_out:\n            # Select item with highest combined value\n            best_out = potential_out[np.argmax(potential_out_values)]\n            new_solution[swap_item_in] = 0\n            new_solution[best_out] = 1\n\n    # Apply small perturbation with probability 0.2\n    if random.random() < 0.2 and len(items_in) > 1:\n        swap_indices = random.sample(range(len(items_in)), 2)\n        item1, item2 = items_in[swap_indices[0]], items_in[swap_indices[1]]\n        new_weight = current_weight - weight_lst[item1] + weight_lst[item2]\n        if new_weight <= capacity:\n            new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n\n    return new_solution\n\n",
        "score": [
            -0.5779947429696168,
            4.642939925193787
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    objectives = np.array([obj for _, obj in archive])\n    mean_obj = np.mean(objectives, axis=0)\n    distances = np.linalg.norm(objectives - mean_obj, axis=1)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using dynamic swapping and perturbation\n    new_solution = base_solution.copy()\n    items_in = np.where(new_solution == 1)[0]\n    items_out = np.where(new_solution == 0)[0]\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select items to swap (with higher probability for items with high marginal value)\n    if len(items_in) > 0 and len(items_out) > 0:\n        # Calculate marginal values for items in the knapsack\n        marginal_values1 = value1_lst[items_in] / (weight_lst[items_in] + 1e-6)\n        marginal_values2 = value2_lst[items_in] / (weight_lst[items_in] + 1e-6)\n\n        # Combine marginal values and normalize\n        combined_marginal = marginal_values1 + marginal_values2\n        probs = combined_marginal / np.sum(combined_marginal)\n        swap_item_in = np.random.choice(items_in, p=probs)\n\n        # Select an item to swap out based on weight and value tradeoff\n        potential_out = []\n        potential_out_values = []\n        for item_out in items_out:\n            new_weight = current_weight - weight_lst[swap_item_in] + weight_lst[item_out]\n            if new_weight <= capacity:\n                potential_out.append(item_out)\n                potential_out_values.append(value1_lst[item_out] + value2_lst[item_out])\n\n        if potential_out:\n            # Select item with highest combined value\n            best_out = potential_out[np.argmax(potential_out_values)]\n            new_solution[swap_item_in] = 0\n            new_solution[best_out] = 1\n\n    # Apply small perturbation with probability 0.2\n    if random.random() < 0.2 and len(items_in) > 1:\n        swap_indices = random.sample(range(len(items_in)), 2)\n        item1, item2 = items_in[swap_indices[0]], items_in[swap_indices[1]]\n        new_weight = current_weight - weight_lst[item1] + weight_lst[item2]\n        if new_weight <= capacity:\n            new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 179,
        "algorithm": "{This algorithm intelligently selects a non-dominated solution from the archive, applies a hybrid local search strategy combining random item swaps, value-based perturbations, and capacity-aware adjustments to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Hybrid local search strategy\n    # Step 1: Random swap of items\n    if len(base_solution) >= 2:\n        i, j = random.sample(range(len(base_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Value-based perturbation - add high-value items if capacity allows\n    remaining_capacity = capacity - np.sum(weight_lst * new_solution)\n    if remaining_capacity > 0:\n        # Select items with high combined value ratio (value1 + value2) / weight\n        value_ratios = (value1_lst + value2_lst) / weight_lst\n        sorted_indices = np.argsort(value_ratios)[::-1]\n        for idx in sorted_indices:\n            if weight_lst[idx] <= remaining_capacity and new_solution[idx] == 0:\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n                break\n\n    # Step 3: Remove low-value items if solution is over capacity\n    if np.sum(weight_lst * new_solution) > capacity:\n        # Remove items with lowest (value1 + value2) / weight ratio\n        value_ratios = (value1_lst + value2_lst) / weight_lst\n        sorted_indices = np.argsort(value_ratios)\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                if np.sum(weight_lst * new_solution) <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.31759952360662813,
            6.8301621079444885
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Hybrid local search strategy\n    # Step 1: Random swap of items\n    if len(base_solution) >= 2:\n        i, j = random.sample(range(len(base_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Value-based perturbation - add high-value items if capacity allows\n    remaining_capacity = capacity - np.sum(weight_lst * new_solution)\n    if remaining_capacity > 0:\n        # Select items with high combined value ratio (value1 + value2) / weight\n        value_ratios = (value1_lst + value2_lst) / weight_lst\n        sorted_indices = np.argsort(value_ratios)[::-1]\n        for idx in sorted_indices:\n            if weight_lst[idx] <= remaining_capacity and new_solution[idx] == 0:\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n                break\n\n    # Step 3: Remove low-value items if solution is over capacity\n    if np.sum(weight_lst * new_solution) > capacity:\n        # Remove items with lowest (value1 + value2) / weight ratio\n        value_ratios = (value1_lst + value2_lst) / weight_lst\n        sorted_indices = np.argsort(value_ratios)\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                if np.sum(weight_lst * new_solution) <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 180,
        "algorithm": "{A novel hybrid local search strategy that intelligently selects a solution from the archive, performs a weighted random swap of items between the solution and a randomly generated subset, and then applies a greedy improvement step to ensure feasibility and local optimality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate weights for selection based on objective values\n    weights = [sum(obj) for _, obj in archive]\n    total_weight = sum(weights)\n    if total_weight == 0:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [w / total_weight for w in weights]\n\n    base_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[base_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a random subset of items to consider for swapping\n    n_items = len(weight_lst)\n    subset_size = min(n_items, max(1, int(np.sqrt(n_items))))\n    subset_indices = random.sample(range(n_items), subset_size)\n\n    # Perform a weighted random swap\n    for idx in subset_indices:\n        if random.random() < 0.5:  # 50% chance to flip the bit\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n            else:\n                new_solution[idx] = 1\n\n    # Check feasibility and perform greedy improvement\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items randomly until feasible\n        excess_weight = current_weight - capacity\n        removable_indices = [i for i in range(n_items) if new_solution[i] == 1]\n        random.shuffle(removable_indices)\n        for idx in removable_indices:\n            if excess_weight <= 0:\n                break\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                excess_weight -= weight_lst[idx]\n\n    # Greedy improvement: add items that improve both objectives\n    remaining_weight = capacity - np.sum(weight_lst * new_solution)\n    if remaining_weight > 0:\n        # Calculate marginal gains for each item\n        marginal_gains = []\n        for i in range(n_items):\n            if new_solution[i] == 0 and weight_lst[i] <= remaining_weight:\n                gain1 = value1_lst[i]\n                gain2 = value2_lst[i]\n                marginal_gains.append((gain1 + gain2, i))\n        marginal_gains.sort(reverse=True, key=lambda x: x[0])\n\n        # Add items with highest combined marginal gain\n        for _, idx in marginal_gains:\n            if weight_lst[idx] <= remaining_weight:\n                new_solution[idx] = 1\n                remaining_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.38085421859963875,
            5.850529313087463
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate weights for selection based on objective values\n    weights = [sum(obj) for _, obj in archive]\n    total_weight = sum(weights)\n    if total_weight == 0:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [w / total_weight for w in weights]\n\n    base_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[base_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a random subset of items to consider for swapping\n    n_items = len(weight_lst)\n    subset_size = min(n_items, max(1, int(np.sqrt(n_items))))\n    subset_indices = random.sample(range(n_items), subset_size)\n\n    # Perform a weighted random swap\n    for idx in subset_indices:\n        if random.random() < 0.5:  # 50% chance to flip the bit\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n            else:\n                new_solution[idx] = 1\n\n    # Check feasibility and perform greedy improvement\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items randomly until feasible\n        excess_weight = current_weight - capacity\n        removable_indices = [i for i in range(n_items) if new_solution[i] == 1]\n        random.shuffle(removable_indices)\n        for idx in removable_indices:\n            if excess_weight <= 0:\n                break\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                excess_weight -= weight_lst[idx]\n\n    # Greedy improvement: add items that improve both objectives\n    remaining_weight = capacity - np.sum(weight_lst * new_solution)\n    if remaining_weight > 0:\n        # Calculate marginal gains for each item\n        marginal_gains = []\n        for i in range(n_items):\n            if new_solution[i] == 0 and weight_lst[i] <= remaining_weight:\n                gain1 = value1_lst[i]\n                gain2 = value2_lst[i]\n                marginal_gains.append((gain1 + gain2, i))\n        marginal_gains.sort(reverse=True, key=lambda x: x[0])\n\n        # Add items with highest combined marginal gain\n        for _, idx in marginal_gains:\n            if weight_lst[idx] <= remaining_weight:\n                new_solution[idx] = 1\n                remaining_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 181,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[0]) / len(x[0]))[0].copy()\n\n    # Identify items to flip based on marginal gains in both objectives\n    current_weight = np.sum(weight_lst * selected_solution)\n    current_value1 = np.sum(value1_lst * selected_solution)\n    current_value2 = np.sum(value2_lst * selected_solution)\n\n    # Calculate marginal gains for each item\n    marginal_gain1 = (value1_lst - (value1_lst * selected_solution)) / (weight_lst + 1e-8)\n    marginal_gain2 = (value2_lst - (value2_lst * selected_solution)) / (weight_lst + 1e-8)\n    combined_gain = marginal_gain1 + marginal_gain2\n\n    # Sort items by combined marginal gain\n    sorted_items = np.argsort(combined_gain)[::-1]\n\n    # Try to add items with highest marginal gains\n    for item in sorted_items:\n        if selected_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            selected_solution[item] = 1\n            current_weight += weight_lst[item]\n            current_value1 += value1_lst[item]\n            current_value2 += value2_lst[item]\n\n    # If no additions possible, try removing items with lowest marginal gains\n    if np.sum(selected_solution) == np.sum(selected_solution):\n        sorted_items = np.argsort(combined_gain)\n        for item in sorted_items:\n            if selected_solution[item] == 1:\n                selected_solution[item] = 0\n                current_weight -= weight_lst[item]\n                current_value1 -= value1_lst[item]\n                current_value2 -= value2_lst[item]\n                if current_weight <= capacity:\n                    break\n                else:\n                    selected_solution[item] = 1\n                    current_weight += weight_lst[item]\n                    current_value1 += value1_lst[item]\n                    current_value2 += value2_lst[item]\n\n    return selected_solution\n\n",
        "score": [
            -0.8368347493955671,
            11.06483593583107
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[0]) / len(x[0]))[0].copy()\n\n    # Identify items to flip based on marginal gains in both objectives\n    current_weight = np.sum(weight_lst * selected_solution)\n    current_value1 = np.sum(value1_lst * selected_solution)\n    current_value2 = np.sum(value2_lst * selected_solution)\n\n    # Calculate marginal gains for each item\n    marginal_gain1 = (value1_lst - (value1_lst * selected_solution)) / (weight_lst + 1e-8)\n    marginal_gain2 = (value2_lst - (value2_lst * selected_solution)) / (weight_lst + 1e-8)\n    combined_gain = marginal_gain1 + marginal_gain2\n\n    # Sort items by combined marginal gain\n    sorted_items = np.argsort(combined_gain)[::-1]\n\n    # Try to add items with highest marginal gains\n    for item in sorted_items:\n        if selected_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            selected_solution[item] = 1\n            current_weight += weight_lst[item]\n            current_value1 += value1_lst[item]\n            current_value2 += value2_lst[item]\n\n    # If no additions possible, try removing items with lowest marginal gains\n    if np.sum(selected_solution) == np.sum(selected_solution):\n        sorted_items = np.argsort(combined_gain)\n        for item in sorted_items:\n            if selected_solution[item] == 1:\n                selected_solution[item] = 0\n                current_weight -= weight_lst[item]\n                current_value1 -= value1_lst[item]\n                current_value2 -= value2_lst[item]\n                if current_weight <= capacity:\n                    break\n                else:\n                    selected_solution[item] = 1\n                    current_weight += weight_lst[item]\n                    current_value1 += value1_lst[item]\n                    current_value2 += value2_lst[item]\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 182,
        "algorithm": "{The algorithm intelligently selects a solution from the archive by prioritizing those with higher potential for improvement, then applies a hybrid local search that combines item swaps and value-based perturbations to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., high objective values or diversity)\n    selected_idx = random.choices(range(len(archive)), weights=[(obj[0] + obj[1]) for _, obj in archive], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: combine item swaps and value-based perturbations\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly flip items to explore neighborhood\n    for _ in range(3):  # Number of perturbations\n        if random.random() < 0.5:\n            # Randomly select an item to flip\n            item_idx = random.randint(0, n_items - 1)\n            if base_solution[item_idx] == 1:\n                # Check if removing the item keeps the solution feasible\n                if current_weight - weight_lst[item_idx] <= capacity:\n                    new_solution[item_idx] = 0\n                    current_weight -= weight_lst[item_idx]\n            else:\n                # Check if adding the item keeps the solution feasible\n                if current_weight + weight_lst[item_idx] <= capacity:\n                    new_solution[item_idx] = 1\n                    current_weight += weight_lst[item_idx]\n\n    # Step 2: Value-based perturbation (swap items with high value ratios)\n    if random.random() < 0.7:  # Probability of applying this step\n        value_ratio1 = value1_lst / (weight_lst + 1e-6)\n        value_ratio2 = value2_lst / (weight_lst + 1e-6)\n        combined_ratio = value_ratio1 + value_ratio2\n\n        # Select top-k items based on combined value ratios\n        top_k = min(5, n_items)\n        top_items = np.argsort(combined_ratio)[-top_k:]\n\n        for item_idx in top_items:\n            if base_solution[item_idx] == 0 and current_weight + weight_lst[item_idx] <= capacity:\n                new_solution[item_idx] = 1\n                current_weight += weight_lst[item_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.32654558303906467,
            5.799903512001038
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., high objective values or diversity)\n    selected_idx = random.choices(range(len(archive)), weights=[(obj[0] + obj[1]) for _, obj in archive], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: combine item swaps and value-based perturbations\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly flip items to explore neighborhood\n    for _ in range(3):  # Number of perturbations\n        if random.random() < 0.5:\n            # Randomly select an item to flip\n            item_idx = random.randint(0, n_items - 1)\n            if base_solution[item_idx] == 1:\n                # Check if removing the item keeps the solution feasible\n                if current_weight - weight_lst[item_idx] <= capacity:\n                    new_solution[item_idx] = 0\n                    current_weight -= weight_lst[item_idx]\n            else:\n                # Check if adding the item keeps the solution feasible\n                if current_weight + weight_lst[item_idx] <= capacity:\n                    new_solution[item_idx] = 1\n                    current_weight += weight_lst[item_idx]\n\n    # Step 2: Value-based perturbation (swap items with high value ratios)\n    if random.random() < 0.7:  # Probability of applying this step\n        value_ratio1 = value1_lst / (weight_lst + 1e-6)\n        value_ratio2 = value2_lst / (weight_lst + 1e-6)\n        combined_ratio = value_ratio1 + value_ratio2\n\n        # Select top-k items based on combined value ratios\n        top_k = min(5, n_items)\n        top_items = np.argsort(combined_ratio)[-top_k:]\n\n        for item_idx in top_items:\n            if base_solution[item_idx] == 0 and current_weight + weight_lst[item_idx] <= capacity:\n                new_solution[item_idx] = 1\n                current_weight += weight_lst[item_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 183,
        "algorithm": "{The algorithm selects a promising solution from the archive using a hybrid local search strategy that combines adaptive item swapping and probabilistic item flipping, guided by the marginal contribution of items to both objectives, while ensuring feasibility through weight checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution from the archive\n    base_solution, (current_v1, current_v2) = random.choice(archive)\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Identify items that can be flipped (added or removed)\n    candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Check if removing this item keeps the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                candidates.append((i, -1))  # -1 indicates removal\n        else:\n            # Check if adding this item keeps the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                candidates.append((i, 1))  # 1 indicates addition\n\n    if not candidates:\n        return new_solution  # No feasible moves\n\n    # Calculate marginal contributions for each candidate\n    marginal_contributions = []\n    for i, flip in candidates:\n        if flip == 1:\n            # Adding item i\n            delta_v1 = value1_lst[i]\n            delta_v2 = value2_lst[i]\n        else:\n            # Removing item i\n            delta_v1 = -value1_lst[i]\n            delta_v2 = -value2_lst[i]\n\n        # Combine objectives (weighted sum for diversity)\n        marginal_contribution = 0.5 * delta_v1 + 0.5 * delta_v2\n        marginal_contributions.append((i, flip, marginal_contribution))\n\n    # Select the candidate with the highest marginal contribution\n    if marginal_contributions:\n        best_candidate = max(marginal_contributions, key=lambda x: x[2])\n        i, flip, _ = best_candidate\n        new_solution[i] = flip == 1\n\n    # Apply probabilistic flipping for further exploration\n    for i in range(len(new_solution)):\n        if random.random() < 0.1:  # 10% chance to flip\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8688329081139547,
            3.8719093799591064
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution from the archive\n    base_solution, (current_v1, current_v2) = random.choice(archive)\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Identify items that can be flipped (added or removed)\n    candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Check if removing this item keeps the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                candidates.append((i, -1))  # -1 indicates removal\n        else:\n            # Check if adding this item keeps the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                candidates.append((i, 1))  # 1 indicates addition\n\n    if not candidates:\n        return new_solution  # No feasible moves\n\n    # Calculate marginal contributions for each candidate\n    marginal_contributions = []\n    for i, flip in candidates:\n        if flip == 1:\n            # Adding item i\n            delta_v1 = value1_lst[i]\n            delta_v2 = value2_lst[i]\n        else:\n            # Removing item i\n            delta_v1 = -value1_lst[i]\n            delta_v2 = -value2_lst[i]\n\n        # Combine objectives (weighted sum for diversity)\n        marginal_contribution = 0.5 * delta_v1 + 0.5 * delta_v2\n        marginal_contributions.append((i, flip, marginal_contribution))\n\n    # Select the candidate with the highest marginal contribution\n    if marginal_contributions:\n        best_candidate = max(marginal_contributions, key=lambda x: x[2])\n        i, flip, _ = best_candidate\n        new_solution[i] = flip == 1\n\n    # Apply probabilistic flipping for further exploration\n    for i in range(len(new_solution)):\n        if random.random() < 0.1:  # 10% chance to flip\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 184,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, (obj1, obj2) = max(archive, key=lambda x: np.sum(x[0] * (value1_lst + value2_lst)))\n\n    # Calculate current total weight\n    current_weight = np.sum(base_solution * weight_lst)\n\n    # Identify items that can be flipped (added or removed) without violating capacity\n    feasible_flips = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if removing the item keeps the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                feasible_flips.append((i, -1))  # -1 indicates removal\n        else:\n            # Check if adding the item keeps the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                feasible_flips.append((i, 1))  # 1 indicates addition\n\n    if not feasible_flips:\n        # If no feasible flips, return the base solution\n        return base_solution.copy()\n\n    # Select a random feasible flip\n    item_idx, flip_type = random.choice(feasible_flips)\n\n    # Create the new solution by flipping the selected item\n    new_solution = base_solution.copy()\n    new_solution[item_idx] = flip_type if flip_type == 1 else 0\n\n    return new_solution\n\n",
        "score": [
            -0.856970327678442,
            5.024493932723999
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, (obj1, obj2) = max(archive, key=lambda x: np.sum(x[0] * (value1_lst + value2_lst)))\n\n    # Calculate current total weight\n    current_weight = np.sum(base_solution * weight_lst)\n\n    # Identify items that can be flipped (added or removed) without violating capacity\n    feasible_flips = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if removing the item keeps the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                feasible_flips.append((i, -1))  # -1 indicates removal\n        else:\n            # Check if adding the item keeps the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                feasible_flips.append((i, 1))  # 1 indicates addition\n\n    if not feasible_flips:\n        # If no feasible flips, return the base solution\n        return base_solution.copy()\n\n    # Select a random feasible flip\n    item_idx, flip_type = random.choice(feasible_flips)\n\n    # Create the new solution by flipping the selected item\n    new_solution = base_solution.copy()\n    new_solution[item_idx] = flip_type if flip_type == 1 else 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 185,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: np.sum(x[0]) * np.sum(weight_lst[x[0].astype(bool)]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Identify items to potentially swap or flip\n    candidate_indices = np.where(new_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.arange(len(new_solution))\n\n    # Randomly select a subset of items to consider for flipping\n    np.random.shuffle(candidate_indices)\n    num_to_flip = min(3, len(candidate_indices))\n    flip_indices = candidate_indices[:num_to_flip]\n\n    # Flip selected items and ensure feasibility\n    for idx in flip_indices:\n        temp_solution = new_solution.copy()\n        temp_solution[idx] = 1 - temp_solution[idx]\n        if np.dot(temp_solution, weight_lst) <= capacity:\n            new_solution = temp_solution\n\n    # Consider adding a random item not in the solution\n    if np.sum(new_solution) < len(new_solution):\n        remaining_indices = np.where(new_solution == 0)[0]\n        np.random.shuffle(remaining_indices)\n        for idx in remaining_indices:\n            if weight_lst[idx] <= capacity - np.dot(new_solution, weight_lst):\n                new_solution[idx] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.35392495047212424,
            4.051641285419464
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: np.sum(x[0]) * np.sum(weight_lst[x[0].astype(bool)]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Identify items to potentially swap or flip\n    candidate_indices = np.where(new_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.arange(len(new_solution))\n\n    # Randomly select a subset of items to consider for flipping\n    np.random.shuffle(candidate_indices)\n    num_to_flip = min(3, len(candidate_indices))\n    flip_indices = candidate_indices[:num_to_flip]\n\n    # Flip selected items and ensure feasibility\n    for idx in flip_indices:\n        temp_solution = new_solution.copy()\n        temp_solution[idx] = 1 - temp_solution[idx]\n        if np.dot(temp_solution, weight_lst) <= capacity:\n            new_solution = temp_solution\n\n    # Consider adding a random item not in the solution\n    if np.sum(new_solution) < len(new_solution):\n        remaining_indices = np.where(new_solution == 0)[0]\n        np.random.shuffle(remaining_indices)\n        for idx in remaining_indices:\n            if weight_lst[idx] <= capacity - np.dot(new_solution, weight_lst):\n                new_solution[idx] = 1\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 186,
        "algorithm": "{The algorithm intelligently selects a solution from the archive with high potential for improvement by evaluating its objective values and diversity, then applies a hybrid local search operator combining random item swaps and targeted flips to balance exploration and exploitation while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_solution, selected_objective = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected_solution.copy()\n\n    # Hybrid local search: combine random swaps and targeted flips\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Randomly select items to swap\n    swap_indices = random.sample(range(n_items), min(3, n_items))\n    for i in swap_indices:\n        new_solution[i] = 1 - new_solution[i]\n\n    # Ensure feasibility by removing excess weight\n    total_weight = np.sum(new_solution * weight_lst)\n    if total_weight > capacity:\n        excess_weight = total_weight - capacity\n        # Remove items with highest ratio of weight to value1 (to minimize impact)\n        item_ratios = (weight_lst * value1_lst) / (weight_lst + 1e-6)  # Avoid division by zero\n        sorted_indices = np.argsort(item_ratios)[::-1]  # Descending order\n        for i in sorted_indices:\n            if new_solution[i] == 1 and excess_weight <= 0:\n                break\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                excess_weight -= weight_lst[i]\n\n    # Additional targeted flip: add items with high value2 if not already included\n    if random.random() < 0.3:  # 30% chance to perform targeted flip\n        candidate_items = np.where(new_solution == 0)[0]\n        if len(candidate_items) > 0:\n            # Select item with highest value2 that fits in capacity\n            remaining_capacity = capacity - np.sum(new_solution * weight_lst)\n            feasible_items = [i for i in candidate_items if weight_lst[i] <= remaining_capacity]\n            if feasible_items:\n                best_item = max(feasible_items, key=lambda x: value2_lst[x])\n                new_solution[best_item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.330236329452342,
            2.0544547736644745
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_solution, selected_objective = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected_solution.copy()\n\n    # Hybrid local search: combine random swaps and targeted flips\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Randomly select items to swap\n    swap_indices = random.sample(range(n_items), min(3, n_items))\n    for i in swap_indices:\n        new_solution[i] = 1 - new_solution[i]\n\n    # Ensure feasibility by removing excess weight\n    total_weight = np.sum(new_solution * weight_lst)\n    if total_weight > capacity:\n        excess_weight = total_weight - capacity\n        # Remove items with highest ratio of weight to value1 (to minimize impact)\n        item_ratios = (weight_lst * value1_lst) / (weight_lst + 1e-6)  # Avoid division by zero\n        sorted_indices = np.argsort(item_ratios)[::-1]  # Descending order\n        for i in sorted_indices:\n            if new_solution[i] == 1 and excess_weight <= 0:\n                break\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                excess_weight -= weight_lst[i]\n\n    # Additional targeted flip: add items with high value2 if not already included\n    if random.random() < 0.3:  # 30% chance to perform targeted flip\n        candidate_items = np.where(new_solution == 0)[0]\n        if len(candidate_items) > 0:\n            # Select item with highest value2 that fits in capacity\n            remaining_capacity = capacity - np.sum(new_solution * weight_lst)\n            feasible_items = [i for i in candidate_items if weight_lst[i] <= remaining_capacity]\n            if feasible_items:\n                best_item = max(feasible_items, key=lambda x: value2_lst[x])\n                new_solution[best_item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 187,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution, (base_v1, base_v2) = archive[selected_idx]\n\n    new_solution = base_solution.copy()\n\n    # Identify items that can be flipped (either added or removed) while maintaining feasibility\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    removable_items = np.where(new_solution == 1)[0]\n    addable_items = np.where(new_solution == 0)[0]\n\n    # Filter addable items that do not exceed capacity when added\n    valid_addable = addable_items[np.cumsum(weight_lst[addable_items]) <= (capacity - current_weight)]\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a subset of removable items to flip (remove)\n    if len(removable_items) > 0:\n        flip_remove = np.random.choice(removable_items, size=min(2, len(removable_items)), replace=False)\n        new_solution[flip_remove] = 0\n\n    # 2. Randomly select a subset of addable items to flip (add) if capacity allows\n    if len(valid_addable) > 0:\n        flip_add = np.random.choice(valid_addable, size=min(2, len(valid_addable)), replace=False)\n        new_solution[flip_add] = 1\n\n    # 3. Objective-aware flip: randomly select one item to flip based on objective dominance\n    if np.random.rand() < 0.3:\n        # If the solution is dominated by others in the archive, try to improve it\n        dominated = False\n        for _, (v1, v2) in archive:\n            if (v1 > base_v1 and v2 >= base_v2) or (v1 >= base_v1 and v2 > base_v2):\n                dominated = True\n                break\n        if dominated:\n            # Flip a random item that could improve at least one objective\n            flip_candidates = np.where(new_solution != base_solution)[0]\n            if len(flip_candidates) > 0:\n                flip_idx = np.random.choice(flip_candidates)\n                new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7999653280879153,
            3.6653405129909515
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution, (base_v1, base_v2) = archive[selected_idx]\n\n    new_solution = base_solution.copy()\n\n    # Identify items that can be flipped (either added or removed) while maintaining feasibility\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    removable_items = np.where(new_solution == 1)[0]\n    addable_items = np.where(new_solution == 0)[0]\n\n    # Filter addable items that do not exceed capacity when added\n    valid_addable = addable_items[np.cumsum(weight_lst[addable_items]) <= (capacity - current_weight)]\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a subset of removable items to flip (remove)\n    if len(removable_items) > 0:\n        flip_remove = np.random.choice(removable_items, size=min(2, len(removable_items)), replace=False)\n        new_solution[flip_remove] = 0\n\n    # 2. Randomly select a subset of addable items to flip (add) if capacity allows\n    if len(valid_addable) > 0:\n        flip_add = np.random.choice(valid_addable, size=min(2, len(valid_addable)), replace=False)\n        new_solution[flip_add] = 1\n\n    # 3. Objective-aware flip: randomly select one item to flip based on objective dominance\n    if np.random.rand() < 0.3:\n        # If the solution is dominated by others in the archive, try to improve it\n        dominated = False\n        for _, (v1, v2) in archive:\n            if (v1 > base_v1 and v2 >= base_v2) or (v1 >= base_v1 and v2 > base_v2):\n                dominated = True\n                break\n        if dominated:\n            # Flip a random item that could improve at least one objective\n            flip_candidates = np.where(new_solution != base_solution)[0]\n            if len(flip_candidates) > 0:\n                flip_idx = np.random.choice(flip_candidates)\n                new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 188,
        "algorithm": "{A hybrid local search algorithm that intelligently selects a promising solution from the archive, then applies a dynamic flip-and-replace strategy to generate neighbors by flipping multiple items and replacing them with a subset of excluded items that improve both objectives, ensuring feasibility and maximizing objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def potential_score(obj):\n        return obj[0] + obj[1]  # Sum of objectives as a simple proxy for potential\n\n    selected = max(archive, key=lambda x: potential_score(x[1]))\n    base_solution = selected[0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n\n    # Dynamic flip-and-replace strategy\n    excluded_items = np.where(new_solution == 0)[0]\n    included_items = np.where(new_solution == 1)[0]\n\n    # Randomly select a subset of included items to flip\n    num_flips = min(3, len(included_items))  # Limit to 3 flips for diversity\n    flip_indices = np.random.choice(included_items, size=num_flips, replace=False)\n    new_solution[flip_indices] = 0\n    current_weight -= np.sum(weight_lst[flip_indices])\n    current_value1 -= np.sum(value1_lst[flip_indices])\n    current_value2 -= np.sum(value2_lst[flip_indices])\n\n    # Randomly select a subset of excluded items to include, ensuring capacity\n    available_weight = capacity - current_weight\n    candidate_items = [i for i in excluded_items if weight_lst[i] <= available_weight]\n\n    if candidate_items:\n        num_add = min(2, len(candidate_items))  # Limit to 2 additions for diversity\n        add_indices = np.random.choice(candidate_items, size=num_add, replace=False)\n        new_solution[add_indices] = 1\n        current_weight += np.sum(weight_lst[add_indices])\n        current_value1 += np.sum(value1_lst[add_indices])\n        current_value2 += np.sum(value2_lst[add_indices])\n\n    # Ensure feasibility (should not be needed due to checks, but safe)\n    if current_weight > capacity:\n        # Remove randomly until feasible\n        excess_weight = current_weight - capacity\n        included_items = np.where(new_solution == 1)[0]\n        while excess_weight > 0 and len(included_items) > 0:\n            remove_idx = np.random.choice(included_items)\n            new_solution[remove_idx] = 0\n            excess_weight -= weight_lst[remove_idx]\n            included_items = np.where(new_solution == 1)[0]\n\n    return new_solution\n\n",
        "score": [
            -0.49290133894621047,
            4.531202167272568
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def potential_score(obj):\n        return obj[0] + obj[1]  # Sum of objectives as a simple proxy for potential\n\n    selected = max(archive, key=lambda x: potential_score(x[1]))\n    base_solution = selected[0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n\n    # Dynamic flip-and-replace strategy\n    excluded_items = np.where(new_solution == 0)[0]\n    included_items = np.where(new_solution == 1)[0]\n\n    # Randomly select a subset of included items to flip\n    num_flips = min(3, len(included_items))  # Limit to 3 flips for diversity\n    flip_indices = np.random.choice(included_items, size=num_flips, replace=False)\n    new_solution[flip_indices] = 0\n    current_weight -= np.sum(weight_lst[flip_indices])\n    current_value1 -= np.sum(value1_lst[flip_indices])\n    current_value2 -= np.sum(value2_lst[flip_indices])\n\n    # Randomly select a subset of excluded items to include, ensuring capacity\n    available_weight = capacity - current_weight\n    candidate_items = [i for i in excluded_items if weight_lst[i] <= available_weight]\n\n    if candidate_items:\n        num_add = min(2, len(candidate_items))  # Limit to 2 additions for diversity\n        add_indices = np.random.choice(candidate_items, size=num_add, replace=False)\n        new_solution[add_indices] = 1\n        current_weight += np.sum(weight_lst[add_indices])\n        current_value1 += np.sum(value1_lst[add_indices])\n        current_value2 += np.sum(value2_lst[add_indices])\n\n    # Ensure feasibility (should not be needed due to checks, but safe)\n    if current_weight > capacity:\n        # Remove randomly until feasible\n        excess_weight = current_weight - capacity\n        included_items = np.where(new_solution == 1)[0]\n        while excess_weight > 0 and len(included_items) > 0:\n            remove_idx = np.random.choice(included_items)\n            new_solution[remove_idx] = 0\n            excess_weight -= weight_lst[remove_idx]\n            included_items = np.where(new_solution == 1)[0]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 189,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive based on its potential for local improvement, then applies a hybrid local search strategy combining random item swaps, targeted value maximization, and capacity-aware adjustments to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def get_promising_solution():\n        # Sort solutions by their objective values (lexicographical order)\n        sorted_archive = sorted(archive, key=lambda x: (-x[1][0], -x[1][1]))\n        # Select top 30% solutions for potential improvement\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from top solutions\n        return random.choice(top_solutions)[0].copy()\n\n    base_solution = get_promising_solution()\n    new_solution = base_solution.copy()\n\n    # Step 2: Hybrid local search strategy\n    def apply_hybrid_search():\n        nonlocal new_solution\n\n        # Randomly select a subset of items to consider for modification\n        candidate_indices = np.where(new_solution == 1)[0]\n        if len(candidate_indices) == 0:\n            candidate_indices = np.arange(len(weight_lst))\n\n        # Randomly select a small portion of items to flip\n        num_flips = min(3, len(candidate_indices))\n        flip_indices = np.random.choice(candidate_indices, size=num_flips, replace=False)\n\n        # Flip selected items and check feasibility\n        for idx in flip_indices:\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            if new_solution[idx] == 1:\n                # If item is in, try removing it\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n            else:\n                # If item is out, try adding it\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n\n        # Additional targeted improvement for both objectives\n        for _ in range(2):  # Do this a few times\n            # Find items not in solution that could improve both objectives\n            candidate_add = np.where(new_solution == 0)[0]\n            current_weight = np.sum(weight_lst[new_solution == 1])\n\n            for idx in candidate_add:\n                if current_weight + weight_lst[idx] <= capacity:\n                    # Calculate potential improvement\n                    delta1 = value1_lst[idx]\n                    delta2 = value2_lst[idx]\n                    # If both values are positive, consider adding\n                    if delta1 > 0 and delta2 > 0:\n                        new_solution[idx] = 1\n                        current_weight += weight_lst[idx]\n                        break\n\n    apply_hybrid_search()\n\n    return new_solution\n\n",
        "score": [
            -0.5074308646636896,
            4.7779147028923035
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def get_promising_solution():\n        # Sort solutions by their objective values (lexicographical order)\n        sorted_archive = sorted(archive, key=lambda x: (-x[1][0], -x[1][1]))\n        # Select top 30% solutions for potential improvement\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from top solutions\n        return random.choice(top_solutions)[0].copy()\n\n    base_solution = get_promising_solution()\n    new_solution = base_solution.copy()\n\n    # Step 2: Hybrid local search strategy\n    def apply_hybrid_search():\n        nonlocal new_solution\n\n        # Randomly select a subset of items to consider for modification\n        candidate_indices = np.where(new_solution == 1)[0]\n        if len(candidate_indices) == 0:\n            candidate_indices = np.arange(len(weight_lst))\n\n        # Randomly select a small portion of items to flip\n        num_flips = min(3, len(candidate_indices))\n        flip_indices = np.random.choice(candidate_indices, size=num_flips, replace=False)\n\n        # Flip selected items and check feasibility\n        for idx in flip_indices:\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            if new_solution[idx] == 1:\n                # If item is in, try removing it\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n            else:\n                # If item is out, try adding it\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n\n        # Additional targeted improvement for both objectives\n        for _ in range(2):  # Do this a few times\n            # Find items not in solution that could improve both objectives\n            candidate_add = np.where(new_solution == 0)[0]\n            current_weight = np.sum(weight_lst[new_solution == 1])\n\n            for idx in candidate_add:\n                if current_weight + weight_lst[idx] <= capacity:\n                    # Calculate potential improvement\n                    delta1 = value1_lst[idx]\n                    delta2 = value2_lst[idx]\n                    # If both values are positive, consider adding\n                    if delta1 > 0 and delta2 > 0:\n                        new_solution[idx] = 1\n                        current_weight += weight_lst[idx]\n                        break\n\n    apply_hybrid_search()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 190,
        "algorithm": "{The heuristic function intelligently selects a solution from the archive with high potential for improvement by evaluating the diversity and objective values, then applies a hybrid local search combining randomized swaps and targeted flips to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Select the solution with the highest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    n_items = len(weight_lst)\n\n    # Randomly select a subset of items to flip (1-3 items)\n    flip_indices = random.sample(range(n_items), min(3, n_items))\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Try to remove the item if it's in the solution\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add the item if it's not in the solution\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Additional targeted flip: add the highest-value item if possible\n    if current_weight < capacity:\n        # Calculate value-to-weight ratio for objective 1 and 2\n        value_ratio1 = value1_lst / weight_lst\n        value_ratio2 = value2_lst / weight_lst\n\n        # Select the item with the highest combined ratio\n        combined_ratio = value_ratio1 + value_ratio2\n        candidate_idx = np.argmax(combined_ratio)\n\n        if new_solution[candidate_idx] == 0 and current_weight + weight_lst[candidate_idx] <= capacity:\n            new_solution[candidate_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.30430510092488505,
            3.9793746769428253
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Select the solution with the highest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    n_items = len(weight_lst)\n\n    # Randomly select a subset of items to flip (1-3 items)\n    flip_indices = random.sample(range(n_items), min(3, n_items))\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Try to remove the item if it's in the solution\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add the item if it's not in the solution\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Additional targeted flip: add the highest-value item if possible\n    if current_weight < capacity:\n        # Calculate value-to-weight ratio for objective 1 and 2\n        value_ratio1 = value1_lst / weight_lst\n        value_ratio2 = value2_lst / weight_lst\n\n        # Select the item with the highest combined ratio\n        combined_ratio = value_ratio1 + value_ratio2\n        candidate_idx = np.argmax(combined_ratio)\n\n        if new_solution[candidate_idx] == 0 and current_weight + weight_lst[candidate_idx] <= capacity:\n            new_solution[candidate_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 191,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive by prioritizing those with high objective values and low dominance counts, then applies a hybrid local search combining item swaps and probabilistic flips to explore the neighborhood while ensuring feasibility through dynamic capacity checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the most promising solution (highest sum of objectives)\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items or flip based on a heuristic\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Randomly select a subset of items to consider for flipping\n    candidate_indices = np.where(base_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.arange(n_items)\n\n    # Probabilistic flip: flip items with high value-to-weight ratio\n    value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n    flip_prob = value_ratios / np.max(value_ratios + 1e-6)\n\n    for idx in candidate_indices:\n        if np.random.rand() < flip_prob[idx]:\n            if base_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    # Ensure at least one change is made\n    if np.array_equal(new_solution, base_solution):\n        # If no flip occurred, perform a random swap\n        swap_indices = np.random.choice(np.arange(n_items), size=2, replace=False)\n        new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n        # Check feasibility\n        if np.sum(weight_lst[new_solution == 1]) > capacity:\n            # Revert if infeasible\n            new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.8525753872150169,
            3.3653404116630554
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the most promising solution (highest sum of objectives)\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items or flip based on a heuristic\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Randomly select a subset of items to consider for flipping\n    candidate_indices = np.where(base_solution == 1)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.arange(n_items)\n\n    # Probabilistic flip: flip items with high value-to-weight ratio\n    value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n    flip_prob = value_ratios / np.max(value_ratios + 1e-6)\n\n    for idx in candidate_indices:\n        if np.random.rand() < flip_prob[idx]:\n            if base_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    # Ensure at least one change is made\n    if np.array_equal(new_solution, base_solution):\n        # If no flip occurred, perform a random swap\n        swap_indices = np.random.choice(np.arange(n_items), size=2, replace=False)\n        new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n        # Check feasibility\n        if np.sum(weight_lst[new_solution == 1]) > capacity:\n            # Revert if infeasible\n            new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 192,
        "algorithm": "{A novel hybrid local search strategy combines adaptive item swapping with probabilistic objective-biased flipping, where items are selected based on their marginal contribution and a temperature-controlled randomness to escape local optima, ensuring feasibility by always validating weight constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: adaptive swapping + probabilistic flipping\n    new_solution = base_solution.copy()\n\n    # Step 1: Adaptive item swapping based on marginal contribution\n    for _ in range(2):  # Perform 2 swaps\n        # Select two random items\n        items = np.where(base_solution == 1)[0]\n        if len(items) < 2:\n            break\n        i, j = random.sample(list(items), 2)\n\n        # Calculate potential weight and objective changes\n        delta_weight = weight_lst[j] - weight_lst[i]\n        new_weight = current_weight + delta_weight\n\n        if new_weight <= capacity:\n            # Swap items\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight = new_weight\n\n    # Step 2: Probabilistic flipping based on objective bias\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 0:\n            if current_weight + weight_lst[i] <= capacity:\n                # Flip with probability based on normalized marginal contribution\n                marginal1 = value1_lst[i] / (weight_lst[i] + 1e-6)\n                marginal2 = value2_lst[i] / (weight_lst[i] + 1e-6)\n                prob = 0.5 * (marginal1 / (marginal1 + marginal2 + 1e-6)) + 0.5 * random.random()\n                if prob > 0.7:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n        else:\n            # Flip with probability to escape local optima\n            if random.random() < 0.2:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5748417307541824,
            5.532417148351669
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: adaptive swapping + probabilistic flipping\n    new_solution = base_solution.copy()\n\n    # Step 1: Adaptive item swapping based on marginal contribution\n    for _ in range(2):  # Perform 2 swaps\n        # Select two random items\n        items = np.where(base_solution == 1)[0]\n        if len(items) < 2:\n            break\n        i, j = random.sample(list(items), 2)\n\n        # Calculate potential weight and objective changes\n        delta_weight = weight_lst[j] - weight_lst[i]\n        new_weight = current_weight + delta_weight\n\n        if new_weight <= capacity:\n            # Swap items\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight = new_weight\n\n    # Step 2: Probabilistic flipping based on objective bias\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 0:\n            if current_weight + weight_lst[i] <= capacity:\n                # Flip with probability based on normalized marginal contribution\n                marginal1 = value1_lst[i] / (weight_lst[i] + 1e-6)\n                marginal2 = value2_lst[i] / (weight_lst[i] + 1e-6)\n                prob = 0.5 * (marginal1 / (marginal1 + marginal2 + 1e-6)) + 0.5 * random.random()\n                if prob > 0.7:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n        else:\n            # Flip with probability to escape local optima\n            if random.random() < 0.2:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 193,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high diversity in objective values and applies a hybrid local search that combines item swapping and weight-balanced flipping to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high diversity in objectives\n    diversity_scores = []\n    for sol, obj in archive:\n        diversity = (obj[0] - obj[1]) ** 2  # Simple diversity measure\n        diversity_scores.append(diversity)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: swap items or flip based on weight balance\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        # Try swapping two items\n        items = np.where(new_solution == 1)[0]\n        if len(items) >= 2:\n            i, j = np.random.choice(items, 2, replace=False)\n            if weight_lst[j] - weight_lst[i] <= capacity - current_weight:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight = np.sum(weight_lst * new_solution)\n                break\n\n        # Try flipping an item if possible\n        else:\n            candidates = np.where(new_solution == 0)[0]\n            if len(candidates) > 0:\n                for idx in candidates:\n                    if weight_lst[idx] <= capacity - current_weight:\n                        new_solution[idx] = 1\n                        current_weight += weight_lst[idx]\n                        break\n\n    # If no improvement, try random flip with weight check\n    if np.array_equal(base_solution, new_solution):\n        candidates = np.where(new_solution == 1)[0]\n        if len(candidates) > 0:\n            idx = np.random.choice(candidates)\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7806967180030021,
            2.607153058052063
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high diversity in objectives\n    diversity_scores = []\n    for sol, obj in archive:\n        diversity = (obj[0] - obj[1]) ** 2  # Simple diversity measure\n        diversity_scores.append(diversity)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: swap items or flip based on weight balance\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        # Try swapping two items\n        items = np.where(new_solution == 1)[0]\n        if len(items) >= 2:\n            i, j = np.random.choice(items, 2, replace=False)\n            if weight_lst[j] - weight_lst[i] <= capacity - current_weight:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight = np.sum(weight_lst * new_solution)\n                break\n\n        # Try flipping an item if possible\n        else:\n            candidates = np.where(new_solution == 0)[0]\n            if len(candidates) > 0:\n                for idx in candidates:\n                    if weight_lst[idx] <= capacity - current_weight:\n                        new_solution[idx] = 1\n                        current_weight += weight_lst[idx]\n                        break\n\n    # If no improvement, try random flip with weight check\n    if np.array_equal(base_solution, new_solution):\n        candidates = np.where(new_solution == 1)[0]\n        if len(candidates) > 0:\n            idx = np.random.choice(candidates)\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 194,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive by prioritizing those with high objective values and low weights, then applies a hybrid local search operator that combines item swaps with targeted flips based on value-to-weight ratios, ensuring feasibility and maximizing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    selected_idx = random.choices(range(len(archive)), weights=[obj[1][0] * obj[1][1] for obj in archive], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate a neighbor solution using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: Identify items to potentially swap or flip\n    included_items = np.where(new_solution == 1)[0]\n    excluded_items = np.where(new_solution == 0)[0]\n\n    # Step 2: Calculate value-to-weight ratios for excluded items\n    excluded_ratios = (value1_lst[excluded_items] + value2_lst[excluded_items]) / weight_lst[excluded_items]\n\n    if len(excluded_items) > 0 and len(included_items) > 0:\n        # Step 3: Select an item to potentially swap\n        best_excluded = excluded_items[np.argmax(excluded_ratios)]\n        best_included = included_items[np.argmin((value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items])]\n\n        # Step 4: Check if swapping improves both objectives\n        new_weight = current_weight - weight_lst[best_included] + weight_lst[best_excluded]\n        if new_weight <= capacity:\n            new_solution[best_included] = 0\n            new_solution[best_excluded] = 1\n            return new_solution\n\n    # Step 5: If no swap is possible, try flipping a single item\n    if len(excluded_items) > 0:\n        best_excluded = excluded_items[np.argmax(excluded_ratios)]\n        if current_weight + weight_lst[best_excluded] <= capacity:\n            new_solution[best_excluded] = 1\n            return new_solution\n\n    if len(included_items) > 0:\n        best_included = included_items[np.argmin((value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items])]\n        new_weight = current_weight - weight_lst[best_included]\n        if new_weight <= capacity:\n            new_solution[best_included] = 0\n            return new_solution\n\n    # If no improvement is possible, return the base solution\n    return base_solution\n\n",
        "score": [
            -0.3899993456801826,
            2.329034686088562
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    selected_idx = random.choices(range(len(archive)), weights=[obj[1][0] * obj[1][1] for obj in archive], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate a neighbor solution using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: Identify items to potentially swap or flip\n    included_items = np.where(new_solution == 1)[0]\n    excluded_items = np.where(new_solution == 0)[0]\n\n    # Step 2: Calculate value-to-weight ratios for excluded items\n    excluded_ratios = (value1_lst[excluded_items] + value2_lst[excluded_items]) / weight_lst[excluded_items]\n\n    if len(excluded_items) > 0 and len(included_items) > 0:\n        # Step 3: Select an item to potentially swap\n        best_excluded = excluded_items[np.argmax(excluded_ratios)]\n        best_included = included_items[np.argmin((value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items])]\n\n        # Step 4: Check if swapping improves both objectives\n        new_weight = current_weight - weight_lst[best_included] + weight_lst[best_excluded]\n        if new_weight <= capacity:\n            new_solution[best_included] = 0\n            new_solution[best_excluded] = 1\n            return new_solution\n\n    # Step 5: If no swap is possible, try flipping a single item\n    if len(excluded_items) > 0:\n        best_excluded = excluded_items[np.argmax(excluded_ratios)]\n        if current_weight + weight_lst[best_excluded] <= capacity:\n            new_solution[best_excluded] = 1\n            return new_solution\n\n    if len(included_items) > 0:\n        best_included = included_items[np.argmin((value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items])]\n        new_weight = current_weight - weight_lst[best_included]\n        if new_weight <= capacity:\n            new_solution[best_included] = 0\n            return new_solution\n\n    # If no improvement is possible, return the base solution\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 195,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a solution from the archive, then applies a combination of random swaps, guided by objective improvements and feasibility checks, to generate a promising neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Intelligently select a solution with potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (base_v1, base_v2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Generate neighbor using hybrid local search\n    n_items = len(weight_lst)\n    max_attempts = 10\n    best_improvement = 0\n    best_solution = new_solution.copy()\n\n    for _ in range(max_attempts):\n        # Randomly select two items to swap\n        i, j = random.sample(range(n_items), 2)\n\n        # Check feasibility of swap\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        delta_weight = weight_lst[j] - weight_lst[i] if new_solution[i] == 1 and new_solution[j] == 0 else \\\n                       weight_lst[i] - weight_lst[j] if new_solution[i] == 0 and new_solution[j] == 1 else 0\n\n        if current_weight + delta_weight > capacity:\n            continue\n\n        # Calculate potential improvement\n        delta_v1 = value1_lst[j] - value1_lst[i] if new_solution[i] == 1 and new_solution[j] == 0 else \\\n                   value1_lst[i] - value1_lst[j] if new_solution[i] == 0 and new_solution[j] == 1 else 0\n        delta_v2 = value2_lst[j] - value2_lst[i] if new_solution[i] == 1 and new_solution[j] == 0 else \\\n                   value2_lst[i] - value2_lst[j] if new_solution[i] == 0 and new_solution[j] == 1 else 0\n\n        # If swap improves at least one objective, perform it\n        if delta_v1 > 0 or delta_v2 > 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            improvement = delta_v1 + delta_v2\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_solution = new_solution.copy()\n\n    # If no improvement found, perform a random feasible swap\n    if best_improvement == 0:\n        for _ in range(max_attempts):\n            i, j = random.sample(range(n_items), 2)\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            delta_weight = weight_lst[j] - weight_lst[i] if new_solution[i] == 1 and new_solution[j] == 0 else \\\n                           weight_lst[i] - weight_lst[j] if new_solution[i] == 0 and new_solution[j] == 1 else 0\n\n            if current_weight + delta_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n\n    return best_solution if best_improvement > 0 else new_solution\n\n",
        "score": [
            -0.5535374171731098,
            4.483648657798767
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Intelligently select a solution with potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (base_v1, base_v2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Generate neighbor using hybrid local search\n    n_items = len(weight_lst)\n    max_attempts = 10\n    best_improvement = 0\n    best_solution = new_solution.copy()\n\n    for _ in range(max_attempts):\n        # Randomly select two items to swap\n        i, j = random.sample(range(n_items), 2)\n\n        # Check feasibility of swap\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        delta_weight = weight_lst[j] - weight_lst[i] if new_solution[i] == 1 and new_solution[j] == 0 else \\\n                       weight_lst[i] - weight_lst[j] if new_solution[i] == 0 and new_solution[j] == 1 else 0\n\n        if current_weight + delta_weight > capacity:\n            continue\n\n        # Calculate potential improvement\n        delta_v1 = value1_lst[j] - value1_lst[i] if new_solution[i] == 1 and new_solution[j] == 0 else \\\n                   value1_lst[i] - value1_lst[j] if new_solution[i] == 0 and new_solution[j] == 1 else 0\n        delta_v2 = value2_lst[j] - value2_lst[i] if new_solution[i] == 1 and new_solution[j] == 0 else \\\n                   value2_lst[i] - value2_lst[j] if new_solution[i] == 0 and new_solution[j] == 1 else 0\n\n        # If swap improves at least one objective, perform it\n        if delta_v1 > 0 or delta_v2 > 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            improvement = delta_v1 + delta_v2\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_solution = new_solution.copy()\n\n    # If no improvement found, perform a random feasible swap\n    if best_improvement == 0:\n        for _ in range(max_attempts):\n            i, j = random.sample(range(n_items), 2)\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            delta_weight = weight_lst[j] - weight_lst[i] if new_solution[i] == 1 and new_solution[j] == 0 else \\\n                           weight_lst[i] - weight_lst[j] if new_solution[i] == 0 and new_solution[j] == 1 else 0\n\n            if current_weight + delta_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n\n    return best_solution if best_improvement > 0 else new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 196,
        "algorithm": "{The heuristic function selects a promising solution from the archive by prioritizing those with the highest combined objective values, then applies a hybrid local search operator that combines random flips with a greedy improvement step to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random flip + greedy improvement\n    # Step 1: Randomly flip a subset of items (with probability 0.3)\n    for i in range(len(new_solution)):\n        if random.random() < 0.3:\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n            else:\n                # Check if adding the item is feasible\n                if np.sum(new_solution * weight_lst) + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    # Step 2: Greedy improvement - try to add items that improve both objectives\n    current_weight = np.sum(new_solution * weight_lst)\n    for i in range(len(new_solution)):\n        if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            # Calculate potential improvement in both objectives\n            delta1 = value1_lst[i]\n            delta2 = value2_lst[i]\n            if delta1 > 0 and delta2 > 0:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Step 3: Randomly remove items to free up space if needed\n    while np.sum(new_solution * weight_lst) > capacity:\n        # Select a random item to remove\n        candidates = np.where(new_solution == 1)[0]\n        if len(candidates) > 0:\n            idx = random.choice(candidates)\n            new_solution[idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.328978796681768,
            5.2808089554309845
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random flip + greedy improvement\n    # Step 1: Randomly flip a subset of items (with probability 0.3)\n    for i in range(len(new_solution)):\n        if random.random() < 0.3:\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n            else:\n                # Check if adding the item is feasible\n                if np.sum(new_solution * weight_lst) + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    # Step 2: Greedy improvement - try to add items that improve both objectives\n    current_weight = np.sum(new_solution * weight_lst)\n    for i in range(len(new_solution)):\n        if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            # Calculate potential improvement in both objectives\n            delta1 = value1_lst[i]\n            delta2 = value2_lst[i]\n            if delta1 > 0 and delta2 > 0:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Step 3: Randomly remove items to free up space if needed\n    while np.sum(new_solution * weight_lst) > capacity:\n        # Select a random item to remove\n        candidates = np.where(new_solution == 1)[0]\n        if len(candidates) > 0:\n            idx = random.choice(candidates)\n            new_solution[idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 197,
        "algorithm": "{This algorithm selects a promising solution from the archive by evaluating the potential for local improvement based on the diversity of objective values and then applies a hybrid local search strategy combining item swaps and probabilistic flips to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items and flip with probability\n    for _ in range(5):  # Number of local search steps\n        # Randomly select two items to swap\n        if len(np.where(new_solution == 1)[0]) >= 2:\n            swap_indices = np.random.choice(np.where(new_solution == 1)[0], 2, replace=False)\n            new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n        # Probabilistic flip: flip a random item with probability based on its value\n        flip_prob = np.random.random()\n        if flip_prob < 0.3:\n            flip_idx = np.random.choice(len(new_solution))\n            if new_solution[flip_idx] == 1:\n                # Check if removing the item keeps the solution feasible\n                if np.sum(new_solution * weight_lst) - weight_lst[flip_idx] <= capacity:\n                    new_solution[flip_idx] = 0\n            else:\n                # Check if adding the item keeps the solution feasible\n                if np.sum(new_solution * weight_lst) + weight_lst[flip_idx] <= capacity:\n                    new_solution[flip_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.5239152595781975,
            8.065014958381653
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items and flip with probability\n    for _ in range(5):  # Number of local search steps\n        # Randomly select two items to swap\n        if len(np.where(new_solution == 1)[0]) >= 2:\n            swap_indices = np.random.choice(np.where(new_solution == 1)[0], 2, replace=False)\n            new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n        # Probabilistic flip: flip a random item with probability based on its value\n        flip_prob = np.random.random()\n        if flip_prob < 0.3:\n            flip_idx = np.random.choice(len(new_solution))\n            if new_solution[flip_idx] == 1:\n                # Check if removing the item keeps the solution feasible\n                if np.sum(new_solution * weight_lst) - weight_lst[flip_idx] <= capacity:\n                    new_solution[flip_idx] = 0\n            else:\n                # Check if adding the item keeps the solution feasible\n                if np.sum(new_solution * weight_lst) + weight_lst[flip_idx] <= capacity:\n                    new_solution[flip_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 198,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a novel hybrid local search that combines item swaps, flips, and adaptive neighborhood exploration to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal)\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1.0 / (1 + obj[0] + obj[1]) for _, obj in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive item swaps, flips, and neighborhood exploration\n    for _ in range(10):  # Limit iterations for efficiency\n        # Randomly select a subset of items to modify\n        n_items = len(weight_lst)\n        subset_size = max(1, min(5, n_items // 5))\n        items_to_modify = random.sample(range(n_items), subset_size)\n\n        # Apply adaptive flips or swaps based on current solution\n        for item in items_to_modify:\n            if new_solution[item] == 1:\n                # Try removing the item\n                temp_solution = new_solution.copy()\n                temp_solution[item] = 0\n                if np.dot(temp_solution, weight_lst) <= capacity:\n                    new_solution = temp_solution\n            else:\n                # Try adding the item\n                temp_solution = new_solution.copy()\n                temp_solution[item] = 1\n                if np.dot(temp_solution, weight_lst) <= capacity:\n                    new_solution = temp_solution\n\n        # Apply a swap if possible\n        if len(items_to_modify) >= 2:\n            i, j = random.sample(items_to_modify, 2)\n            if new_solution[i] != new_solution[j]:\n                temp_solution = new_solution.copy()\n                temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n                if np.dot(temp_solution, weight_lst) <= capacity:\n                    new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.4146207897386519,
            8.231414496898651
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal)\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1.0 / (1 + obj[0] + obj[1]) for _, obj in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive item swaps, flips, and neighborhood exploration\n    for _ in range(10):  # Limit iterations for efficiency\n        # Randomly select a subset of items to modify\n        n_items = len(weight_lst)\n        subset_size = max(1, min(5, n_items // 5))\n        items_to_modify = random.sample(range(n_items), subset_size)\n\n        # Apply adaptive flips or swaps based on current solution\n        for item in items_to_modify:\n            if new_solution[item] == 1:\n                # Try removing the item\n                temp_solution = new_solution.copy()\n                temp_solution[item] = 0\n                if np.dot(temp_solution, weight_lst) <= capacity:\n                    new_solution = temp_solution\n            else:\n                # Try adding the item\n                temp_solution = new_solution.copy()\n                temp_solution[item] = 1\n                if np.dot(temp_solution, weight_lst) <= capacity:\n                    new_solution = temp_solution\n\n        # Apply a swap if possible\n        if len(items_to_modify) >= 2:\n            i, j = random.sample(items_to_modify, 2)\n            if new_solution[i] != new_solution[j]:\n                temp_solution = new_solution.copy()\n                temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n                if np.dot(temp_solution, weight_lst) <= capacity:\n                    new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 199,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high potential for local improvement, then applies a hybrid local search strategy combining greedy value-based swaps and random perturbations to explore high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution: prioritize those with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine greedy value-based swaps and random perturbations\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Greedy swap: consider swapping items with high value-to-weight ratio\n    for _ in range(5):  # Limit number of swaps to avoid excessive computation\n        # Calculate value-to-weight ratios for items not in the solution\n        outside_items = np.where(new_solution == 0)[0]\n        if len(outside_items) == 0:\n            break\n\n        ratios1 = value1_lst[outside_items] / weight_lst[outside_items]\n        ratios2 = value2_lst[outside_items] / weight_lst[outside_items]\n\n        # Select best candidate based on combined ratio\n        combined_ratios = ratios1 + ratios2\n        best_candidate = outside_items[np.argmax(combined_ratios)]\n\n        # Check if adding the best candidate is feasible\n        if current_weight + weight_lst[best_candidate] <= capacity:\n            new_solution[best_candidate] = 1\n            current_weight += weight_lst[best_candidate]\n            current_value1 += value1_lst[best_candidate]\n            current_value2 += value2_lst[best_candidate]\n\n    # Random perturbation: flip a few random bits to escape local optima\n    flip_indices = random.sample(range(len(new_solution)), min(3, len(new_solution)))\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Check if removing this item keeps the solution feasible\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            # Check if adding this item is feasible\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3205673237872876,
            5.170581877231598
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution: prioritize those with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine greedy value-based swaps and random perturbations\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Greedy swap: consider swapping items with high value-to-weight ratio\n    for _ in range(5):  # Limit number of swaps to avoid excessive computation\n        # Calculate value-to-weight ratios for items not in the solution\n        outside_items = np.where(new_solution == 0)[0]\n        if len(outside_items) == 0:\n            break\n\n        ratios1 = value1_lst[outside_items] / weight_lst[outside_items]\n        ratios2 = value2_lst[outside_items] / weight_lst[outside_items]\n\n        # Select best candidate based on combined ratio\n        combined_ratios = ratios1 + ratios2\n        best_candidate = outside_items[np.argmax(combined_ratios)]\n\n        # Check if adding the best candidate is feasible\n        if current_weight + weight_lst[best_candidate] <= capacity:\n            new_solution[best_candidate] = 1\n            current_weight += weight_lst[best_candidate]\n            current_value1 += value1_lst[best_candidate]\n            current_value2 += value2_lst[best_candidate]\n\n    # Random perturbation: flip a few random bits to escape local optima\n    flip_indices = random.sample(range(len(new_solution)), min(3, len(new_solution)))\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Check if removing this item keeps the solution feasible\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            # Check if adding this item is feasible\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 200,
        "algorithm": "{A novel hybrid local search strategy combines adaptive item flipping with a dynamic neighborhood exploration, prioritizing items with high marginal gains in either objective while ensuring feasibility through a constrained random walk to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a bias towards those with high potential for improvement\n    base_solution, (current_val1, current_val2) = max(archive, key=lambda x: sum(x[0]) / len(x[0]))\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify candidate items for flipping (either 0->1 or 1->0)\n    candidate_indices = np.where(base_solution == 1)[0]\n    if len(candidate_indices) > 0:\n        flip_index = random.choice(candidate_indices)\n        new_solution = base_solution.copy()\n        new_solution[flip_index] = 0  # Try removing an item first\n        new_weight = current_weight - weight_lst[flip_index]\n    else:\n        # If no items are selected, try adding items\n        candidate_indices = np.where(base_solution == 0)[0]\n        if len(candidate_indices) > 0:\n            flip_index = random.choice(candidate_indices)\n            new_solution = base_solution.copy()\n            new_solution[flip_index] = 1\n            new_weight = current_weight + weight_lst[flip_index]\n        else:\n            return base_solution.copy()  # No changes possible\n\n    # Check feasibility\n    if new_weight > capacity:\n        # If infeasible, try a different flip\n        candidate_indices = np.where(base_solution != new_solution[flip_index])[0]\n        for idx in candidate_indices:\n            temp_weight = current_weight - weight_lst[flip_index] + weight_lst[idx]\n            if temp_weight <= capacity:\n                new_solution = base_solution.copy()\n                new_solution[flip_index] = 0\n                new_solution[idx] = 1\n                break\n        else:\n            # If no feasible flip found, try a constrained random walk\n            for _ in range(10):  # Limit iterations to avoid long loops\n                idx1, idx2 = random.sample(range(len(base_solution)), 2)\n                if base_solution[idx1] != base_solution[idx2]:\n                    temp_weight = current_weight - weight_lst[idx1] + weight_lst[idx2]\n                    if temp_weight <= capacity:\n                        new_solution = base_solution.copy()\n                        new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.8007834587639178,
            6.457062155008316
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a bias towards those with high potential for improvement\n    base_solution, (current_val1, current_val2) = max(archive, key=lambda x: sum(x[0]) / len(x[0]))\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify candidate items for flipping (either 0->1 or 1->0)\n    candidate_indices = np.where(base_solution == 1)[0]\n    if len(candidate_indices) > 0:\n        flip_index = random.choice(candidate_indices)\n        new_solution = base_solution.copy()\n        new_solution[flip_index] = 0  # Try removing an item first\n        new_weight = current_weight - weight_lst[flip_index]\n    else:\n        # If no items are selected, try adding items\n        candidate_indices = np.where(base_solution == 0)[0]\n        if len(candidate_indices) > 0:\n            flip_index = random.choice(candidate_indices)\n            new_solution = base_solution.copy()\n            new_solution[flip_index] = 1\n            new_weight = current_weight + weight_lst[flip_index]\n        else:\n            return base_solution.copy()  # No changes possible\n\n    # Check feasibility\n    if new_weight > capacity:\n        # If infeasible, try a different flip\n        candidate_indices = np.where(base_solution != new_solution[flip_index])[0]\n        for idx in candidate_indices:\n            temp_weight = current_weight - weight_lst[flip_index] + weight_lst[idx]\n            if temp_weight <= capacity:\n                new_solution = base_solution.copy()\n                new_solution[flip_index] = 0\n                new_solution[idx] = 1\n                break\n        else:\n            # If no feasible flip found, try a constrained random walk\n            for _ in range(10):  # Limit iterations to avoid long loops\n                idx1, idx2 = random.sample(range(len(base_solution)), 2)\n                if base_solution[idx1] != base_solution[idx2]:\n                    temp_weight = current_weight - weight_lst[idx1] + weight_lst[idx2]\n                    if temp_weight <= capacity:\n                        new_solution = base_solution.copy()\n                        new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 201,
        "algorithm": "{The heuristic function selects a promising solution from the archive by prioritizing those with high marginal improvement potential, then applies a hybrid local search operator that combines adaptive bit-flipping and guided item swapping to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with high marginal improvement potential\n    selected_idx = random.choices(range(len(archive)), weights=[(v1 + v2) / (1 + np.sum(s[0])) for s, (v1, v2) in archive], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search operator: adaptive bit-flipping and guided item swapping\n    new_solution = base_solution.copy()\n\n    # Step 1: Adaptive bit-flipping (flip items with high marginal value/weight ratio)\n    value_ratios = (value1_lst + value2_lst) / weight_lst\n    sorted_indices = np.argsort(-value_ratios)  # Sort by descending ratio\n\n    for idx in sorted_indices:\n        if base_solution[idx] == 1:\n            # Try removing item\n            temp_weight = current_weight - weight_lst[idx]\n            if temp_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = temp_weight\n        else:\n            # Try adding item\n            temp_weight = current_weight + weight_lst[idx]\n            if temp_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = temp_weight\n\n    # Step 2: Guided item swapping (swap items with complementary value profiles)\n    if np.sum(new_solution) > 1:\n        # Find items with high positive correlation in values\n        corr_matrix = np.corrcoef(np.vstack((value1_lst, value2_lst)))\n        corr_values = corr_matrix[0, 1:]  # Correlation with first objective\n\n        # Sort items by correlation and swap pairs\n        sorted_corr_indices = np.argsort(-corr_values)\n        for i in range(0, len(sorted_corr_indices) - 1, 2):\n            if i + 1 < len(sorted_corr_indices):\n                idx1, idx2 = sorted_corr_indices[i], sorted_corr_indices[i+1]\n                if new_solution[idx1] != new_solution[idx2]:\n                    # Try swapping\n                    temp_weight = current_weight - weight_lst[idx1] + weight_lst[idx2]\n                    if temp_weight <= capacity:\n                        new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n                        current_weight = temp_weight\n\n    return new_solution\n\n",
        "score": [
            -0.8790384776402588,
            6.802375227212906
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with high marginal improvement potential\n    selected_idx = random.choices(range(len(archive)), weights=[(v1 + v2) / (1 + np.sum(s[0])) for s, (v1, v2) in archive], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search operator: adaptive bit-flipping and guided item swapping\n    new_solution = base_solution.copy()\n\n    # Step 1: Adaptive bit-flipping (flip items with high marginal value/weight ratio)\n    value_ratios = (value1_lst + value2_lst) / weight_lst\n    sorted_indices = np.argsort(-value_ratios)  # Sort by descending ratio\n\n    for idx in sorted_indices:\n        if base_solution[idx] == 1:\n            # Try removing item\n            temp_weight = current_weight - weight_lst[idx]\n            if temp_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = temp_weight\n        else:\n            # Try adding item\n            temp_weight = current_weight + weight_lst[idx]\n            if temp_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = temp_weight\n\n    # Step 2: Guided item swapping (swap items with complementary value profiles)\n    if np.sum(new_solution) > 1:\n        # Find items with high positive correlation in values\n        corr_matrix = np.corrcoef(np.vstack((value1_lst, value2_lst)))\n        corr_values = corr_matrix[0, 1:]  # Correlation with first objective\n\n        # Sort items by correlation and swap pairs\n        sorted_corr_indices = np.argsort(-corr_values)\n        for i in range(0, len(sorted_corr_indices) - 1, 2):\n            if i + 1 < len(sorted_corr_indices):\n                idx1, idx2 = sorted_corr_indices[i], sorted_corr_indices[i+1]\n                if new_solution[idx1] != new_solution[idx2]:\n                    # Try swapping\n                    temp_weight = current_weight - weight_lst[idx1] + weight_lst[idx2]\n                    if temp_weight <= capacity:\n                        new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n                        current_weight = temp_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 202,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its potential for local improvement, then applies a hybrid local search strategy combining item swaps and adaptive neighborhood exploration to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly select a subset of items to potentially swap or flip\n    num_items = len(weight_lst)\n    subset_size = min(5, num_items)  # Small subset for efficiency\n    subset_indices = random.sample(range(num_items), subset_size)\n\n    # Step 2: Adaptive neighborhood exploration\n    for i in subset_indices:\n        if base_solution[i] == 1:\n            # Try removing the item if it doesn't violate capacity\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                new_solution[i] = 0\n                current_weight = new_weight\n        else:\n            # Try adding the item if it doesn't violate capacity\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                new_solution[i] = 1\n                current_weight = new_weight\n\n    # Step 3: If no change, perform a random swap to ensure progress\n    if np.array_equal(new_solution, base_solution):\n        swap_candidates = [i for i in range(num_items) if base_solution[i] != new_solution[i]]\n        if len(swap_candidates) >= 2:\n            i, j = random.sample(swap_candidates, 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.31566948585598864,
            1.7596897184848785
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly select a subset of items to potentially swap or flip\n    num_items = len(weight_lst)\n    subset_size = min(5, num_items)  # Small subset for efficiency\n    subset_indices = random.sample(range(num_items), subset_size)\n\n    # Step 2: Adaptive neighborhood exploration\n    for i in subset_indices:\n        if base_solution[i] == 1:\n            # Try removing the item if it doesn't violate capacity\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                new_solution[i] = 0\n                current_weight = new_weight\n        else:\n            # Try adding the item if it doesn't violate capacity\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                new_solution[i] = 1\n                current_weight = new_weight\n\n    # Step 3: If no change, perform a random swap to ensure progress\n    if np.array_equal(new_solution, base_solution):\n        swap_candidates = [i for i in range(num_items) if base_solution[i] != new_solution[i]]\n        if len(swap_candidates) >= 2:\n            i, j = random.sample(swap_candidates, 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 203,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a hybrid local search strategy that combines cluster-based exploration and objective-specific perturbations, then generates a neighbor by intelligently flipping a subset of items while ensuring feasibility and diversity, balancing the trade-off between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (here, randomly for simplicity, but can be enhanced)\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution, (base_val1, base_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Step 2: Identify candidate items for flipping (those with high marginal contribution)\n    included_items = np.where(new_solution == 1)[0]\n    excluded_items = np.where(new_solution == 0)[0]\n\n    # Step 3: Calculate marginal contributions for both objectives\n    marginal_val1 = value1_lst[excluded_items] / weight_lst[excluded_items]\n    marginal_val2 = value2_lst[excluded_items] / weight_lst[excluded_items]\n\n    # Step 4: Combine marginal contributions (simple sum for simplicity, can be weighted)\n    combined_marginal = marginal_val1 + marginal_val2\n    sorted_indices = np.argsort(combined_marginal)[::-1]  # Descending order\n\n    # Step 5: Select top k items to consider flipping (k can be adaptive)\n    k = min(5, len(excluded_items))\n    top_candidates = excluded_items[sorted_indices[:k]]\n\n    # Step 6: Flip one of the top candidates if feasible\n    for item in top_candidates:\n        if weight_lst[item] <= capacity - np.sum(weight_lst * new_solution):\n            new_solution[item] = 1 - new_solution[item]  # Flip\n            break\n\n    # Step 7: If no flip was made, try flipping a random item from included items\n    if np.array_equal(new_solution, base_solution):\n        if len(included_items) > 0:\n            random_item = np.random.choice(included_items)\n            new_solution[random_item] = 1 - new_solution[random_item]\n\n    return new_solution\n\n",
        "score": [
            -0.8826397724164488,
            2.623246669769287
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (here, randomly for simplicity, but can be enhanced)\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution, (base_val1, base_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Step 2: Identify candidate items for flipping (those with high marginal contribution)\n    included_items = np.where(new_solution == 1)[0]\n    excluded_items = np.where(new_solution == 0)[0]\n\n    # Step 3: Calculate marginal contributions for both objectives\n    marginal_val1 = value1_lst[excluded_items] / weight_lst[excluded_items]\n    marginal_val2 = value2_lst[excluded_items] / weight_lst[excluded_items]\n\n    # Step 4: Combine marginal contributions (simple sum for simplicity, can be weighted)\n    combined_marginal = marginal_val1 + marginal_val2\n    sorted_indices = np.argsort(combined_marginal)[::-1]  # Descending order\n\n    # Step 5: Select top k items to consider flipping (k can be adaptive)\n    k = min(5, len(excluded_items))\n    top_candidates = excluded_items[sorted_indices[:k]]\n\n    # Step 6: Flip one of the top candidates if feasible\n    for item in top_candidates:\n        if weight_lst[item] <= capacity - np.sum(weight_lst * new_solution):\n            new_solution[item] = 1 - new_solution[item]  # Flip\n            break\n\n    # Step 7: If no flip was made, try flipping a random item from included items\n    if np.array_equal(new_solution, base_solution):\n        if len(included_items) > 0:\n            random_item = np.random.choice(included_items)\n            new_solution[random_item] = 1 - new_solution[random_item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 204,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its potential for local improvement, then applies a hybrid local search operator that combines item swaps, flips, and adaptive neighborhood exploration to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Step 1: Random item flip with feasibility check\n    flip_pos = random.randint(0, len(new_solution) - 1)\n    if new_solution[flip_pos] == 1:\n        if current_weight - weight_lst[flip_pos] <= capacity:\n            new_solution[flip_pos] = 0\n    else:\n        if current_weight + weight_lst[flip_pos] <= capacity:\n            new_solution[flip_pos] = 1\n\n    # Step 2: Adaptive neighborhood exploration\n    if random.random() < 0.5:  # 50% chance for swap operation\n        swap_pos1, swap_pos2 = random.sample(range(len(new_solution)), 2)\n        if new_solution[swap_pos1] != new_solution[swap_pos2]:\n            # Check feasibility after swap\n            if (new_solution[swap_pos1] == 1 and new_solution[swap_pos2] == 0 and\n                current_weight - weight_lst[swap_pos1] + weight_lst[swap_pos2] <= capacity):\n                new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n            elif (new_solution[swap_pos1] == 0 and new_solution[swap_pos2] == 1 and\n                  current_weight + weight_lst[swap_pos1] - weight_lst[swap_pos2] <= capacity):\n                new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n\n    # Step 3: Local improvement based on objective values\n    if random.random() < 0.3:  # 30% chance for local improvement\n        for i in range(len(new_solution)):\n            if new_solution[i] == 0:\n                if current_weight + weight_lst[i] <= capacity:\n                    # Evaluate potential improvement\n                    potential_improvement = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n                    if potential_improvement > 0.5 * (value1_lst.mean() + value2_lst.mean()) / weight_lst.mean():\n                        new_solution[i] = 1\n                        current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.31722852714311733,
            5.186464250087738
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Step 1: Random item flip with feasibility check\n    flip_pos = random.randint(0, len(new_solution) - 1)\n    if new_solution[flip_pos] == 1:\n        if current_weight - weight_lst[flip_pos] <= capacity:\n            new_solution[flip_pos] = 0\n    else:\n        if current_weight + weight_lst[flip_pos] <= capacity:\n            new_solution[flip_pos] = 1\n\n    # Step 2: Adaptive neighborhood exploration\n    if random.random() < 0.5:  # 50% chance for swap operation\n        swap_pos1, swap_pos2 = random.sample(range(len(new_solution)), 2)\n        if new_solution[swap_pos1] != new_solution[swap_pos2]:\n            # Check feasibility after swap\n            if (new_solution[swap_pos1] == 1 and new_solution[swap_pos2] == 0 and\n                current_weight - weight_lst[swap_pos1] + weight_lst[swap_pos2] <= capacity):\n                new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n            elif (new_solution[swap_pos1] == 0 and new_solution[swap_pos2] == 1 and\n                  current_weight + weight_lst[swap_pos1] - weight_lst[swap_pos2] <= capacity):\n                new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n\n    # Step 3: Local improvement based on objective values\n    if random.random() < 0.3:  # 30% chance for local improvement\n        for i in range(len(new_solution)):\n            if new_solution[i] == 0:\n                if current_weight + weight_lst[i] <= capacity:\n                    # Evaluate potential improvement\n                    potential_improvement = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n                    if potential_improvement > 0.5 * (value1_lst.mean() + value2_lst.mean()) / weight_lst.mean():\n                        new_solution[i] = 1\n                        current_weight += weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 205,
        "algorithm": "{A novel local search strategy that intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid of item swapping and perturbation to generate a neighbor solution while ensuring feasibility through adaptive weight adjustment.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: choose a solution with high potential for improvement\n    # Here, we select the solution with the highest sum of normalized values (potential for improvement)\n    max_potential = -1\n    selected_idx = 0\n    for i, (sol, obj) in enumerate(archive):\n        potential = (obj[0] / np.sum(value1_lst)) + (obj[1] / np.sum(value2_lst))\n        if potential > max_potential:\n            max_potential = potential\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: item swapping and perturbation\n    # Step 1: Identify items that can be swapped (one in, one out)\n    included = np.where(new_solution == 1)[0]\n    excluded = np.where(new_solution == 0)[0]\n\n    if len(included) > 0 and len(excluded) > 0:\n        # Randomly select one included and one excluded item\n        in_item = np.random.choice(included)\n        out_item = np.random.choice(excluded)\n\n        # Swap them\n        new_solution[in_item] = 0\n        new_solution[out_item] = 1\n\n        # Check feasibility\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        if current_weight > capacity:\n            # If infeasible, remove the heaviest item in the swap\n            if weight_lst[in_item] > weight_lst[out_item]:\n                new_solution[in_item] = 1\n                new_solution[out_item] = 0\n            else:\n                # Remove the out_item if it makes the solution infeasible\n                new_solution[out_item] = 0\n\n    # Step 2: Random perturbation (flip a random bit if feasible)\n    if np.random.rand() < 0.3:  # 30% chance to perturb\n        perturb_idx = np.random.randint(len(new_solution))\n        if new_solution[perturb_idx] == 1:\n            new_solution[perturb_idx] = 0\n            # Ensure feasibility\n            if np.sum(weight_lst[new_solution == 1]) > capacity:\n                new_solution[perturb_idx] = 1\n        else:\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[perturb_idx] <= capacity:\n                new_solution[perturb_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.3525672554879694,
            8.053470343351364
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: choose a solution with high potential for improvement\n    # Here, we select the solution with the highest sum of normalized values (potential for improvement)\n    max_potential = -1\n    selected_idx = 0\n    for i, (sol, obj) in enumerate(archive):\n        potential = (obj[0] / np.sum(value1_lst)) + (obj[1] / np.sum(value2_lst))\n        if potential > max_potential:\n            max_potential = potential\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: item swapping and perturbation\n    # Step 1: Identify items that can be swapped (one in, one out)\n    included = np.where(new_solution == 1)[0]\n    excluded = np.where(new_solution == 0)[0]\n\n    if len(included) > 0 and len(excluded) > 0:\n        # Randomly select one included and one excluded item\n        in_item = np.random.choice(included)\n        out_item = np.random.choice(excluded)\n\n        # Swap them\n        new_solution[in_item] = 0\n        new_solution[out_item] = 1\n\n        # Check feasibility\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        if current_weight > capacity:\n            # If infeasible, remove the heaviest item in the swap\n            if weight_lst[in_item] > weight_lst[out_item]:\n                new_solution[in_item] = 1\n                new_solution[out_item] = 0\n            else:\n                # Remove the out_item if it makes the solution infeasible\n                new_solution[out_item] = 0\n\n    # Step 2: Random perturbation (flip a random bit if feasible)\n    if np.random.rand() < 0.3:  # 30% chance to perturb\n        perturb_idx = np.random.randint(len(new_solution))\n        if new_solution[perturb_idx] == 1:\n            new_solution[perturb_idx] = 0\n            # Ensure feasibility\n            if np.sum(weight_lst[new_solution == 1]) > capacity:\n                new_solution[perturb_idx] = 1\n        else:\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[perturb_idx] <= capacity:\n                new_solution[perturb_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 206,
        "algorithm": "{This heuristic function selects a solution from the archive based on the highest combined objective value, then applies a hybrid local search that combines item swaps and adaptive perturbation to explore the neighborhood while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective value\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: item swaps and adaptive perturbation\n    for _ in range(10):  # Number of perturbation attempts\n        # Randomly select two items to swap\n        item1, item2 = random.sample(range(len(weight_lst)), 2)\n\n        # Calculate new weights and values\n        new_weight = current_weight - weight_lst[item1] * base_solution[item1] + weight_lst[item1] * (1 - base_solution[item1]) - weight_lst[item2] * base_solution[item2] + weight_lst[item2] * (1 - base_solution[item2])\n        new_value1 = current_value1 - value1_lst[item1] * base_solution[item1] + value1_lst[item1] * (1 - base_solution[item1]) - value1_lst[item2] * base_solution[item2] + value1_lst[item2] * (1 - base_solution[item2])\n        new_value2 = current_value2 - value2_lst[item1] * base_solution[item1] + value2_lst[item1] * (1 - base_solution[item1]) - value2_lst[item2] * base_solution[item2] + value2_lst[item2] * (1 - base_solution[item2])\n\n        if new_weight <= capacity:\n            # Accept the swap\n            new_solution[item1] = 1 - new_solution[item1]\n            new_solution[item2] = 1 - new_solution[item2]\n            current_weight = new_weight\n            current_value1 = new_value1\n            current_value2 = new_value2\n\n    # Adaptive perturbation: flip a random item if feasible\n    for _ in range(5):  # Number of flips\n        item = random.randint(0, len(weight_lst) - 1)\n        if base_solution[item] == 1:\n            new_weight = current_weight - weight_lst[item]\n            if new_weight <= capacity:\n                new_solution[item] = 0\n                current_weight = new_weight\n        else:\n            new_weight = current_weight + weight_lst[item]\n            if new_weight <= capacity:\n                new_solution[item] = 1\n                current_weight = new_weight\n\n    return new_solution\n\n",
        "score": [
            -0.3280406898435517,
            8.345239609479904
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective value\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: item swaps and adaptive perturbation\n    for _ in range(10):  # Number of perturbation attempts\n        # Randomly select two items to swap\n        item1, item2 = random.sample(range(len(weight_lst)), 2)\n\n        # Calculate new weights and values\n        new_weight = current_weight - weight_lst[item1] * base_solution[item1] + weight_lst[item1] * (1 - base_solution[item1]) - weight_lst[item2] * base_solution[item2] + weight_lst[item2] * (1 - base_solution[item2])\n        new_value1 = current_value1 - value1_lst[item1] * base_solution[item1] + value1_lst[item1] * (1 - base_solution[item1]) - value1_lst[item2] * base_solution[item2] + value1_lst[item2] * (1 - base_solution[item2])\n        new_value2 = current_value2 - value2_lst[item1] * base_solution[item1] + value2_lst[item1] * (1 - base_solution[item1]) - value2_lst[item2] * base_solution[item2] + value2_lst[item2] * (1 - base_solution[item2])\n\n        if new_weight <= capacity:\n            # Accept the swap\n            new_solution[item1] = 1 - new_solution[item1]\n            new_solution[item2] = 1 - new_solution[item2]\n            current_weight = new_weight\n            current_value1 = new_value1\n            current_value2 = new_value2\n\n    # Adaptive perturbation: flip a random item if feasible\n    for _ in range(5):  # Number of flips\n        item = random.randint(0, len(weight_lst) - 1)\n        if base_solution[item] == 1:\n            new_weight = current_weight - weight_lst[item]\n            if new_weight <= capacity:\n                new_solution[item] = 0\n                current_weight = new_weight\n        else:\n            new_weight = current_weight + weight_lst[item]\n            if new_weight <= capacity:\n                new_solution[item] = 1\n                current_weight = new_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 207,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: combine random flips with value-based flips\n    new_solution = base_solution.copy()\n\n    # Randomly select a subset of items to flip\n    num_flips = min(3, len(base_solution))\n    flip_indices = random.sample(range(len(base_solution)), num_flips)\n\n    # Flip items based on a combination of randomness and value improvement\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = new_weight\n        else:\n            # Try adding the item if it improves both objectives\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                # Check if adding this item improves both objectives\n                if (value1_lst[idx] > 0 and value2_lst[idx] > 0):\n                    new_solution[idx] = 1\n                    current_weight = new_weight\n\n    # Additional random flip to ensure diversity\n    if random.random() < 0.5:\n        idx = random.randint(0, len(base_solution) - 1)\n        if base_solution[idx] == 1:\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n        else:\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.3286343549443828,
            3.8107306957244873
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: combine random flips with value-based flips\n    new_solution = base_solution.copy()\n\n    # Randomly select a subset of items to flip\n    num_flips = min(3, len(base_solution))\n    flip_indices = random.sample(range(len(base_solution)), num_flips)\n\n    # Flip items based on a combination of randomness and value improvement\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = new_weight\n        else:\n            # Try adding the item if it improves both objectives\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                # Check if adding this item improves both objectives\n                if (value1_lst[idx] > 0 and value2_lst[idx] > 0):\n                    new_solution[idx] = 1\n                    current_weight = new_weight\n\n    # Additional random flip to ensure diversity\n    if random.random() < 0.5:\n        idx = random.randint(0, len(base_solution) - 1)\n        if base_solution[idx] == 1:\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n        else:\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 208,
        "algorithm": "{A novel hybrid local search operator combines adaptive item swapping with a probabilistic exploration of high-margin items, prioritizing solutions with the highest potential for multi-objective improvement while ensuring feasibility through a dynamic capacity-aware adjustment mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values (prioritize high value solutions)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_idx = min(int(len(archive_sorted) * 0.3), len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Calculate current total weight and margins\n    current_weight = np.sum(base_solution * weight_lst)\n    remaining_capacity = capacity - current_weight\n\n    # Identify items that can be added without exceeding capacity\n    feasible_add = (weight_lst <= remaining_capacity) & (base_solution == 0)\n    feasible_remove = (base_solution == 1)\n\n    # Hybrid local search: adaptive swapping and probabilistic exploration\n    new_solution = base_solution.copy()\n\n    # Step 1: Adaptive item swapping (swap high-margin items)\n    if np.any(feasible_add) and np.any(feasible_remove):\n        # Calculate marginal gains for potential swaps\n        add_gains1 = value1_lst[feasible_add] / weight_lst[feasible_add]\n        add_gains2 = value2_lst[feasible_add] / weight_lst[feasible_add]\n\n        remove_gains1 = value1_lst[feasible_remove] / weight_lst[feasible_remove]\n        remove_gains2 = value2_lst[feasible_remove] / weight_lst[feasible_remove]\n\n        # Select top candidates for swap\n        if len(add_gains1) > 0 and len(remove_gains1) > 0:\n            top_add_idx = np.argmax(add_gains1 + add_gains2)\n            top_remove_idx = np.argmin(remove_gains1 + remove_gains2)\n\n            # Perform swap if it maintains feasibility\n            add_item = np.where(feasible_add)[0][top_add_idx]\n            remove_item = np.where(feasible_remove)[0][top_remove_idx]\n\n            if (current_weight - weight_lst[remove_item] + weight_lst[add_item]) <= capacity:\n                new_solution[remove_item] = 0\n                new_solution[add_item] = 1\n\n    # Step 2: Probabilistic exploration of high-margin items\n    if np.any(feasible_add):\n        # Calculate normalized marginal gains\n        add_gains = (value1_lst[feasible_add] + value2_lst[feasible_add]) / weight_lst[feasible_add]\n        if len(add_gains) > 0:\n            add_probs = add_gains / np.sum(add_gains)\n            selected_item = np.random.choice(np.where(feasible_add)[0], p=add_probs)\n\n            # Add item if it doesn't exceed capacity\n            if (current_weight + weight_lst[selected_item]) <= capacity:\n                new_solution[selected_item] = 1\n\n    # Step 3: Random removal to escape local optima\n    if np.any(feasible_remove) and random.random() < 0.3:\n        selected_item = random.choice(np.where(feasible_remove)[0])\n        new_solution[selected_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.9471441049451546,
            1.9875133633613586
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values (prioritize high value solutions)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_idx = min(int(len(archive_sorted) * 0.3), len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Calculate current total weight and margins\n    current_weight = np.sum(base_solution * weight_lst)\n    remaining_capacity = capacity - current_weight\n\n    # Identify items that can be added without exceeding capacity\n    feasible_add = (weight_lst <= remaining_capacity) & (base_solution == 0)\n    feasible_remove = (base_solution == 1)\n\n    # Hybrid local search: adaptive swapping and probabilistic exploration\n    new_solution = base_solution.copy()\n\n    # Step 1: Adaptive item swapping (swap high-margin items)\n    if np.any(feasible_add) and np.any(feasible_remove):\n        # Calculate marginal gains for potential swaps\n        add_gains1 = value1_lst[feasible_add] / weight_lst[feasible_add]\n        add_gains2 = value2_lst[feasible_add] / weight_lst[feasible_add]\n\n        remove_gains1 = value1_lst[feasible_remove] / weight_lst[feasible_remove]\n        remove_gains2 = value2_lst[feasible_remove] / weight_lst[feasible_remove]\n\n        # Select top candidates for swap\n        if len(add_gains1) > 0 and len(remove_gains1) > 0:\n            top_add_idx = np.argmax(add_gains1 + add_gains2)\n            top_remove_idx = np.argmin(remove_gains1 + remove_gains2)\n\n            # Perform swap if it maintains feasibility\n            add_item = np.where(feasible_add)[0][top_add_idx]\n            remove_item = np.where(feasible_remove)[0][top_remove_idx]\n\n            if (current_weight - weight_lst[remove_item] + weight_lst[add_item]) <= capacity:\n                new_solution[remove_item] = 0\n                new_solution[add_item] = 1\n\n    # Step 2: Probabilistic exploration of high-margin items\n    if np.any(feasible_add):\n        # Calculate normalized marginal gains\n        add_gains = (value1_lst[feasible_add] + value2_lst[feasible_add]) / weight_lst[feasible_add]\n        if len(add_gains) > 0:\n            add_probs = add_gains / np.sum(add_gains)\n            selected_item = np.random.choice(np.where(feasible_add)[0], p=add_probs)\n\n            # Add item if it doesn't exceed capacity\n            if (current_weight + weight_lst[selected_item]) <= capacity:\n                new_solution[selected_item] = 1\n\n    # Step 3: Random removal to escape local optima\n    if np.any(feasible_remove) and random.random() < 0.3:\n        selected_item = random.choice(np.where(feasible_remove)[0])\n        new_solution[selected_item] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 209,
        "algorithm": "{A novel adaptive local search strategy that intelligently selects a solution from the archive, applies a hybrid of item swapping and dynamic subset replacement to generate a neighbor solution while ensuring feasibility, and prioritizes solutions with high potential for multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [s[0] for s in archive]\n    archive_objectives = [s[1] for s in archive]\n\n    # Calculate potential for improvement (sum of ratios of values to weights)\n    potential = []\n    for sol, obj in zip(archive_solutions, archive_objectives):\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight > 0:\n            potential.append((obj[0] / total_weight + obj[1] / total_weight) / 2)\n        else:\n            potential.append(0)\n\n    # Select top 20% solutions with highest potential\n    top_indices = np.argsort(potential)[-max(1, len(potential) // 5):]\n    selected_idx = random.choice(top_indices)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n\n    # Step 1: Random item swap (if feasible)\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 1:\n        i, j = random.sample(list(swap_candidates), 2)\n        if (np.sum(weight_lst * new_solution) - weight_lst[i] + weight_lst[j] <= capacity and\n            np.sum(weight_lst * new_solution) - weight_lst[j] + weight_lst[i] <= capacity):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Dynamic subset replacement (add/remove items based on value ratios)\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Calculate value-to-weight ratios for all items\n    ratios1 = value1_lst / weight_lst\n    ratios2 = value2_lst / weight_lst\n\n    # Add promising items\n    for i in np.argsort(ratios1 + ratios2)[::-1]:\n        if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n            new_solution[i] = 1\n            remaining_capacity -= weight_lst[i]\n\n    # Remove low-value items\n    for i in np.argsort(ratios1 + ratios2):\n        if new_solution[i] == 1 and (current_weight - weight_lst[i] + remaining_capacity >= 0):\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7841577502328596,
            9.34622049331665
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [s[0] for s in archive]\n    archive_objectives = [s[1] for s in archive]\n\n    # Calculate potential for improvement (sum of ratios of values to weights)\n    potential = []\n    for sol, obj in zip(archive_solutions, archive_objectives):\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight > 0:\n            potential.append((obj[0] / total_weight + obj[1] / total_weight) / 2)\n        else:\n            potential.append(0)\n\n    # Select top 20% solutions with highest potential\n    top_indices = np.argsort(potential)[-max(1, len(potential) // 5):]\n    selected_idx = random.choice(top_indices)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n\n    # Step 1: Random item swap (if feasible)\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 1:\n        i, j = random.sample(list(swap_candidates), 2)\n        if (np.sum(weight_lst * new_solution) - weight_lst[i] + weight_lst[j] <= capacity and\n            np.sum(weight_lst * new_solution) - weight_lst[j] + weight_lst[i] <= capacity):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Dynamic subset replacement (add/remove items based on value ratios)\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Calculate value-to-weight ratios for all items\n    ratios1 = value1_lst / weight_lst\n    ratios2 = value2_lst / weight_lst\n\n    # Add promising items\n    for i in np.argsort(ratios1 + ratios2)[::-1]:\n        if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n            new_solution[i] = 1\n            remaining_capacity -= weight_lst[i]\n\n    # Remove low-value items\n    for i in np.argsort(ratios1 + ratios2):\n        if new_solution[i] == 1 and (current_weight - weight_lst[i] + remaining_capacity >= 0):\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 210,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: adaptive flip and swap\n    new_solution = base_solution.copy()\n    num_items = len(base_solution)\n\n    # Step 1: Adaptive flip (flip items with high marginal contribution)\n    for i in range(num_items):\n        if np.random.rand() < 0.5:  # Randomly decide to flip\n            if base_solution[i] == 1:\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Step 2: Swap with promising items (items with high value ratios)\n    value_ratio1 = value1_lst / weight_lst\n    value_ratio2 = value2_lst / weight_lst\n    combined_ratio = value_ratio1 + value_ratio2\n\n    # Find items not in solution with highest combined ratio\n    candidate_indices = np.where(base_solution == 0)[0]\n    if len(candidate_indices) > 0:\n        best_candidate = candidate_indices[np.argmax(combined_ratio[candidate_indices])]\n        # Find items in solution with lowest combined ratio\n        in_indices = np.where(base_solution == 1)[0]\n        if len(in_indices) > 0:\n            worst_in = in_indices[np.argmin(combined_ratio[in_indices])]\n            # Check if swap is feasible\n            if (current_weight - weight_lst[worst_in] + weight_lst[best_candidate]) <= capacity:\n                new_solution[worst_in] = 0\n                new_solution[best_candidate] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.4446132902514446,
            4.309234529733658
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: adaptive flip and swap\n    new_solution = base_solution.copy()\n    num_items = len(base_solution)\n\n    # Step 1: Adaptive flip (flip items with high marginal contribution)\n    for i in range(num_items):\n        if np.random.rand() < 0.5:  # Randomly decide to flip\n            if base_solution[i] == 1:\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Step 2: Swap with promising items (items with high value ratios)\n    value_ratio1 = value1_lst / weight_lst\n    value_ratio2 = value2_lst / weight_lst\n    combined_ratio = value_ratio1 + value_ratio2\n\n    # Find items not in solution with highest combined ratio\n    candidate_indices = np.where(base_solution == 0)[0]\n    if len(candidate_indices) > 0:\n        best_candidate = candidate_indices[np.argmax(combined_ratio[candidate_indices])]\n        # Find items in solution with lowest combined ratio\n        in_indices = np.where(base_solution == 1)[0]\n        if len(in_indices) > 0:\n            worst_in = in_indices[np.argmin(combined_ratio[in_indices])]\n            # Check if swap is feasible\n            if (current_weight - weight_lst[worst_in] + weight_lst[best_candidate]) <= capacity:\n                new_solution[worst_in] = 0\n                new_solution[best_candidate] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 211,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = [v1 + v2 for (sol, (v1, v2)) in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor by flipping items with the highest marginal gain\n    marginal_gain = (value1_lst + value2_lst) / weight_lst\n    sorted_indices = np.argsort(marginal_gain)[::-1]\n\n    new_solution = base_solution.copy()\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            temp_solution = new_solution.copy()\n            temp_solution[idx] = 0\n            if np.dot(temp_solution, weight_lst) <= capacity:\n                new_solution = temp_solution\n        else:\n            # Try adding the item\n            temp_solution = new_solution.copy()\n            temp_solution[idx] = 1\n            if np.dot(temp_solution, weight_lst) <= capacity:\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.9393917027852501,
            9.892672836780548
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = [v1 + v2 for (sol, (v1, v2)) in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor by flipping items with the highest marginal gain\n    marginal_gain = (value1_lst + value2_lst) / weight_lst\n    sorted_indices = np.argsort(marginal_gain)[::-1]\n\n    new_solution = base_solution.copy()\n    for idx in sorted_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            temp_solution = new_solution.copy()\n            temp_solution[idx] = 0\n            if np.dot(temp_solution, weight_lst) <= capacity:\n                new_solution = temp_solution\n        else:\n            # Try adding the item\n            temp_solution = new_solution.copy()\n            temp_solution[idx] = 1\n            if np.dot(temp_solution, weight_lst) <= capacity:\n                new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 212,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (base_value1, base_value2) = archive[selected_idx]\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Identify items not in the current solution that can be added without exceeding capacity\n    candidate_items = np.where(base_solution == 0)[0]\n    feasible_items = [i for i in candidate_items if current_weight + weight_lst[i] <= capacity]\n\n    if not feasible_items:\n        # If no items can be added, try removing items to create space\n        # Select items to remove based on their marginal contribution to both objectives\n        marginal_contributions = []\n        for i in np.where(base_solution == 1)[0]:\n            new_weight = current_weight - weight_lst[i]\n            new_value1 = base_value1 - value1_lst[i]\n            new_value2 = base_value2 - value2_lst[i]\n            marginal_contributions.append((i, (base_value1 - new_value1) / (current_weight - new_weight) if (current_weight - new_weight) != 0 else float('inf'),\n                                         (base_value2 - new_value2) / (current_weight - new_weight) if (current_weight - new_weight) != 0 else float('inf')))\n        if marginal_contributions:\n            # Remove items with the highest marginal contribution (product of both objectives)\n            marginal_contributions.sort(key=lambda x: (x[1] * x[2]), reverse=True)\n            item_to_remove = marginal_contributions[0][0]\n            new_solution = base_solution.copy()\n            new_solution[item_to_remove] = 0\n            return new_solution\n\n    # Step 3: Hybrid local search strategy - combine addition and removal\n    new_solution = base_solution.copy()\n    if feasible_items:\n        # Add the item with the highest combined marginal value\n        marginal_values = []\n        for i in feasible_items:\n            marginal_value1 = value1_lst[i] / weight_lst[i]\n            marginal_value2 = value2_lst[i] / weight_lst[i]\n            marginal_values.append((i, marginal_value1 + marginal_value2))\n        marginal_values.sort(key=lambda x: x[1], reverse=True)\n        best_item = marginal_values[0][0]\n        new_solution[best_item] = 1\n\n    # Step 4: Optionally remove an item to make space for potentially better items\n    if np.random.rand() < 0.3:  # 30% chance to perform removal\n        current_weight = np.sum(weight_lst * new_solution)\n        items_in_solution = np.where(new_solution == 1)[0]\n        if len(items_in_solution) > 0:\n            # Select the item to remove based on the least contribution to both objectives\n            least_contribution = None\n            least_contribution_value = float('inf')\n            for i in items_in_solution:\n                contribution = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n                if contribution < least_contribution_value:\n                    least_contribution_value = contribution\n                    least_contribution = i\n            if least_contribution is not None:\n                new_solution[least_contribution] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.852539075998231,
            3.3371738493442535
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (base_value1, base_value2) = archive[selected_idx]\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Identify items not in the current solution that can be added without exceeding capacity\n    candidate_items = np.where(base_solution == 0)[0]\n    feasible_items = [i for i in candidate_items if current_weight + weight_lst[i] <= capacity]\n\n    if not feasible_items:\n        # If no items can be added, try removing items to create space\n        # Select items to remove based on their marginal contribution to both objectives\n        marginal_contributions = []\n        for i in np.where(base_solution == 1)[0]:\n            new_weight = current_weight - weight_lst[i]\n            new_value1 = base_value1 - value1_lst[i]\n            new_value2 = base_value2 - value2_lst[i]\n            marginal_contributions.append((i, (base_value1 - new_value1) / (current_weight - new_weight) if (current_weight - new_weight) != 0 else float('inf'),\n                                         (base_value2 - new_value2) / (current_weight - new_weight) if (current_weight - new_weight) != 0 else float('inf')))\n        if marginal_contributions:\n            # Remove items with the highest marginal contribution (product of both objectives)\n            marginal_contributions.sort(key=lambda x: (x[1] * x[2]), reverse=True)\n            item_to_remove = marginal_contributions[0][0]\n            new_solution = base_solution.copy()\n            new_solution[item_to_remove] = 0\n            return new_solution\n\n    # Step 3: Hybrid local search strategy - combine addition and removal\n    new_solution = base_solution.copy()\n    if feasible_items:\n        # Add the item with the highest combined marginal value\n        marginal_values = []\n        for i in feasible_items:\n            marginal_value1 = value1_lst[i] / weight_lst[i]\n            marginal_value2 = value2_lst[i] / weight_lst[i]\n            marginal_values.append((i, marginal_value1 + marginal_value2))\n        marginal_values.sort(key=lambda x: x[1], reverse=True)\n        best_item = marginal_values[0][0]\n        new_solution[best_item] = 1\n\n    # Step 4: Optionally remove an item to make space for potentially better items\n    if np.random.rand() < 0.3:  # 30% chance to perform removal\n        current_weight = np.sum(weight_lst * new_solution)\n        items_in_solution = np.where(new_solution == 1)[0]\n        if len(items_in_solution) > 0:\n            # Select the item to remove based on the least contribution to both objectives\n            least_contribution = None\n            least_contribution_value = float('inf')\n            for i in items_in_solution:\n                contribution = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n                if contribution < least_contribution_value:\n                    least_contribution_value = contribution\n                    least_contribution = i\n            if least_contribution is not None:\n                new_solution[least_contribution] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 213,
        "algorithm": "{The algorithm selects a promising solution from the archive using a hybrid local search strategy that combines random walk with adaptive neighborhood exploration, focusing on items with high marginal gains in either objective, while ensuring feasibility through weight-constrained swaps.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Identify items that can be swapped (either in or out) while maintaining feasibility\n    candidate_items = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if removing this item keeps the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                candidate_items.append((i, -1))  # -1 indicates removal\n        else:\n            # Check if adding this item keeps the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                candidate_items.append((i, 1))  # 1 indicates addition\n\n    if not candidate_items:\n        return base_solution  # No feasible moves, return original\n\n    # Randomly select a candidate item to modify\n    item_idx, action = candidate_items[np.random.randint(len(candidate_items))]\n\n    if action == 1:\n        # Add the item\n        new_solution[item_idx] = 1\n    else:\n        # Remove the item\n        new_solution[item_idx] = 0\n\n    # Ensure the solution is feasible (should already be, but verify)\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Revert to base solution if infeasible (should not happen due to checks)\n        new_solution = base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7615576303319295,
            3.080580085515976
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Identify items that can be swapped (either in or out) while maintaining feasibility\n    candidate_items = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if removing this item keeps the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                candidate_items.append((i, -1))  # -1 indicates removal\n        else:\n            # Check if adding this item keeps the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                candidate_items.append((i, 1))  # 1 indicates addition\n\n    if not candidate_items:\n        return base_solution  # No feasible moves, return original\n\n    # Randomly select a candidate item to modify\n    item_idx, action = candidate_items[np.random.randint(len(candidate_items))]\n\n    if action == 1:\n        # Add the item\n        new_solution[item_idx] = 1\n    else:\n        # Remove the item\n        new_solution[item_idx] = 0\n\n    # Ensure the solution is feasible (should already be, but verify)\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Revert to base solution if infeasible (should not happen due to checks)\n        new_solution = base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 214,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a hybrid of objective diversity and local improvement potential, then applies a novel local search operator that combines item swapping and weighted random flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high combined objective diversity and local potential\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (base_val1, base_val2) = archive[selected_idx]\n    base_weight = np.sum(weight_lst * base_solution)\n\n    # Create a copy of the base solution\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: weighted random flipping with item swapping\n    for _ in range(2):  # Perform 2 flips/swaps\n        # Calculate flip scores for each item\n        flip_scores = []\n        for i in range(len(base_solution)):\n            if base_solution[i] == 1:\n                # Score for removing item i\n                new_weight = base_weight - weight_lst[i]\n                if new_weight <= capacity:\n                    score = (value1_lst[i] + value2_lst[i]) * 0.5  # Combined objective score\n                    flip_scores.append((score, i, 0))\n            else:\n                # Score for adding item i\n                new_weight = base_weight + weight_lst[i]\n                if new_weight <= capacity:\n                    score = (value1_lst[i] + value2_lst[i]) * 1.2  # Higher score for addition\n                    flip_scores.append((score, i, 1))\n\n        if flip_scores:\n            # Select the best flip/swap with probability based on score\n            scores, items, actions = zip(*flip_scores)\n            probs = np.array(scores) / np.sum(scores)\n            chosen_idx = np.random.choice(len(scores), p=probs)\n            item, action = items[chosen_idx], actions[chosen_idx]\n\n            # Perform the flip/swap\n            if action == 1:  # Add item\n                new_solution[item] = 1\n                base_weight += weight_lst[item]\n            else:  # Remove item\n                new_solution[item] = 0\n                base_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.3988076862480737,
            7.703116536140442
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high combined objective diversity and local potential\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (base_val1, base_val2) = archive[selected_idx]\n    base_weight = np.sum(weight_lst * base_solution)\n\n    # Create a copy of the base solution\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: weighted random flipping with item swapping\n    for _ in range(2):  # Perform 2 flips/swaps\n        # Calculate flip scores for each item\n        flip_scores = []\n        for i in range(len(base_solution)):\n            if base_solution[i] == 1:\n                # Score for removing item i\n                new_weight = base_weight - weight_lst[i]\n                if new_weight <= capacity:\n                    score = (value1_lst[i] + value2_lst[i]) * 0.5  # Combined objective score\n                    flip_scores.append((score, i, 0))\n            else:\n                # Score for adding item i\n                new_weight = base_weight + weight_lst[i]\n                if new_weight <= capacity:\n                    score = (value1_lst[i] + value2_lst[i]) * 1.2  # Higher score for addition\n                    flip_scores.append((score, i, 1))\n\n        if flip_scores:\n            # Select the best flip/swap with probability based on score\n            scores, items, actions = zip(*flip_scores)\n            probs = np.array(scores) / np.sum(scores)\n            chosen_idx = np.random.choice(len(scores), p=probs)\n            item, action = items[chosen_idx], actions[chosen_idx]\n\n            # Perform the flip/swap\n            if action == 1:  # Add item\n                new_solution[item] = 1\n                base_weight += weight_lst[item]\n            else:  # Remove item\n                new_solution[item] = 0\n                base_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 215,
        "algorithm": "{This algorithm intelligently selects a diverse solution from the archive by prioritizing those with high objective values and low crowding distance, then applies a hybrid local search combining item swapping and random perturbation to explore the neighborhood while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items and random perturbation\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select items to swap or perturb\n    for _ in range(min(3, n_items // 2)):\n        # Choose a random item to flip\n        idx = random.randint(0, n_items - 1)\n        if new_solution[idx] == 1:\n            # Try to remove it if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add it if feasible\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Additional perturbation: randomly flip a few items\n    for _ in range(min(2, n_items // 3)):\n        idx = random.randint(0, n_items - 1)\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.37613598171478313,
            2.189596563577652
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items and random perturbation\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select items to swap or perturb\n    for _ in range(min(3, n_items // 2)):\n        # Choose a random item to flip\n        idx = random.randint(0, n_items - 1)\n        if new_solution[idx] == 1:\n            # Try to remove it if feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add it if feasible\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Additional perturbation: randomly flip a few items\n    for _ in range(min(2, n_items // 3)):\n        idx = random.randint(0, n_items - 1)\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 216,
        "algorithm": "{The heuristic function first selects a promising solution from the archive by evaluating the crowding distance and dominance rank, then applies a hybrid local search combining item swaps and adaptive flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution from the archive\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n\n    # Step 1: Adaptive flip - flip items with high marginal gains\n    marginal_gains1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal_gains2 = value2_lst / (weight_lst + 1e-6)\n    combined_gains = marginal_gains1 + marginal_gains2\n\n    # Sort items by combined marginal gains\n    sorted_items = np.argsort(-combined_gains)\n\n    # Flip top-k items (adaptive k based on solution diversity)\n    k = max(1, int(0.1 * len(sorted_items)))  # Flip 10% of items\n    for item in sorted_items[:k]:\n        if new_solution[item] == 1:\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Step 2: Item swaps - swap items between included and excluded\n    included_items = np.where(base_solution == 1)[0]\n    excluded_items = np.where(base_solution == 0)[0]\n\n    if len(included_items) > 0 and len(excluded_items) > 0:\n        # Randomly select an item to remove and an item to add\n        remove_item = np.random.choice(included_items)\n        add_item = np.random.choice(excluded_items)\n\n        # Check feasibility before swap\n        if (current_weight - weight_lst[remove_item] + weight_lst[add_item]) <= capacity:\n            new_solution[remove_item] = 0\n            new_solution[add_item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8360681230783333,
            3.135969191789627
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution from the archive\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n\n    # Step 1: Adaptive flip - flip items with high marginal gains\n    marginal_gains1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal_gains2 = value2_lst / (weight_lst + 1e-6)\n    combined_gains = marginal_gains1 + marginal_gains2\n\n    # Sort items by combined marginal gains\n    sorted_items = np.argsort(-combined_gains)\n\n    # Flip top-k items (adaptive k based on solution diversity)\n    k = max(1, int(0.1 * len(sorted_items)))  # Flip 10% of items\n    for item in sorted_items[:k]:\n        if new_solution[item] == 1:\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Step 2: Item swaps - swap items between included and excluded\n    included_items = np.where(base_solution == 1)[0]\n    excluded_items = np.where(base_solution == 0)[0]\n\n    if len(included_items) > 0 and len(excluded_items) > 0:\n        # Randomly select an item to remove and an item to add\n        remove_item = np.random.choice(included_items)\n        add_item = np.random.choice(excluded_items)\n\n        # Check feasibility before swap\n        if (current_weight - weight_lst[remove_item] + weight_lst[add_item]) <= capacity:\n            new_solution[remove_item] = 0\n            new_solution[add_item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 217,
        "algorithm": "{This algorithm selects a promising solution from the archive by prioritizing those with high objective values and low weight, then applies a novel hybrid local search that combines item swaps and probabilistic flips to explore the neighborhood while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by normalized score (combination of objective values and weight)\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        score = (obj[0] + obj[1]) / (total_weight + 1e-6)  # Avoid division by zero\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap two items or flip one item probabilistically\n    items = np.where(new_solution == 1)[0]\n    if len(items) >= 2:\n        # Swap two items\n        a, b = np.random.choice(items, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        # Check feasibility\n        if np.sum(weight_lst * new_solution) > capacity:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]  # Revert if infeasible\n    else:\n        # Flip one item\n        candidates = np.where(new_solution == 0)[0]\n        if len(candidates) > 0:\n            idx = np.random.choice(candidates)\n            new_solution[idx] = 1\n            # Check feasibility\n            if np.sum(weight_lst * new_solution) > capacity:\n                new_solution[idx] = 0  # Revert if infeasible\n\n    # If no change due to feasibility, try flipping a random item\n    if np.array_equal(new_solution, base_solution):\n        items = np.where(new_solution == 1)[0]\n        if len(items) > 0:\n            idx = np.random.choice(items)\n            new_solution[idx] = 0\n            # Check feasibility (always feasible since we're removing an item)\n\n    return new_solution\n\n",
        "score": [
            -0.8487265912550499,
            7.669589996337891
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by normalized score (combination of objective values and weight)\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        score = (obj[0] + obj[1]) / (total_weight + 1e-6)  # Avoid division by zero\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap two items or flip one item probabilistically\n    items = np.where(new_solution == 1)[0]\n    if len(items) >= 2:\n        # Swap two items\n        a, b = np.random.choice(items, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        # Check feasibility\n        if np.sum(weight_lst * new_solution) > capacity:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]  # Revert if infeasible\n    else:\n        # Flip one item\n        candidates = np.where(new_solution == 0)[0]\n        if len(candidates) > 0:\n            idx = np.random.choice(candidates)\n            new_solution[idx] = 1\n            # Check feasibility\n            if np.sum(weight_lst * new_solution) > capacity:\n                new_solution[idx] = 0  # Revert if infeasible\n\n    # If no change due to feasibility, try flipping a random item\n    if np.array_equal(new_solution, base_solution):\n        items = np.where(new_solution == 1)[0]\n        if len(items) > 0:\n            idx = np.random.choice(items)\n            new_solution[idx] = 0\n            # Check feasibility (always feasible since we're removing an item)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 218,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for local improvement by prioritizing solutions with high objective values and low weight utilization, then applies a hybrid local search strategy combining random item swaps with a greedy value-to-weight ratio-based perturbation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[(obj[0] + obj[1]) / (np.sum(archive[i][0] * weight_lst) + 1e-6) for i, (_, obj) in enumerate(archive)],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and values\n    current_weight = np.sum(base_solution * weight_lst)\n    current_value1 = np.sum(base_solution * value1_lst)\n    current_value2 = np.sum(base_solution * value2_lst)\n\n    # Hybrid local search strategy\n    # Step 1: Randomly swap items (with probability based on their value-to-weight ratio)\n    for i in range(len(base_solution)):\n        if random.random() < 0.3:  # 30% chance to consider swapping\n            if base_solution[i] == 1:\n                # Consider removing this item\n                new_weight = current_weight - weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 0\n                    current_weight = new_weight\n            else:\n                # Consider adding this item\n                new_weight = current_weight + weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 1\n                    current_weight = new_weight\n\n    # Step 2: Greedy perturbation based on value-to-weight ratio\n    # Calculate value-to-weight ratios for all items\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    combined_ratio = v1_ratio + v2_ratio\n\n    # Sort items by combined ratio\n    sorted_indices = np.argsort(combined_ratio)[::-1]\n\n    for i in sorted_indices:\n        if random.random() < 0.5:  # 50% chance to consider this item\n            if new_solution[i] == 0:\n                # Try to add this item\n                new_weight = current_weight + weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 1\n                    current_weight = new_weight\n            else:\n                # Try to remove this item\n                new_weight = current_weight - weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 0\n                    current_weight = new_weight\n\n    return new_solution\n\n",
        "score": [
            -0.4423768430900309,
            8.722380429506302
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[(obj[0] + obj[1]) / (np.sum(archive[i][0] * weight_lst) + 1e-6) for i, (_, obj) in enumerate(archive)],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and values\n    current_weight = np.sum(base_solution * weight_lst)\n    current_value1 = np.sum(base_solution * value1_lst)\n    current_value2 = np.sum(base_solution * value2_lst)\n\n    # Hybrid local search strategy\n    # Step 1: Randomly swap items (with probability based on their value-to-weight ratio)\n    for i in range(len(base_solution)):\n        if random.random() < 0.3:  # 30% chance to consider swapping\n            if base_solution[i] == 1:\n                # Consider removing this item\n                new_weight = current_weight - weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 0\n                    current_weight = new_weight\n            else:\n                # Consider adding this item\n                new_weight = current_weight + weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 1\n                    current_weight = new_weight\n\n    # Step 2: Greedy perturbation based on value-to-weight ratio\n    # Calculate value-to-weight ratios for all items\n    v1_ratio = value1_lst / (weight_lst + 1e-6)\n    v2_ratio = value2_lst / (weight_lst + 1e-6)\n    combined_ratio = v1_ratio + v2_ratio\n\n    # Sort items by combined ratio\n    sorted_indices = np.argsort(combined_ratio)[::-1]\n\n    for i in sorted_indices:\n        if random.random() < 0.5:  # 50% chance to consider this item\n            if new_solution[i] == 0:\n                # Try to add this item\n                new_weight = current_weight + weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 1\n                    current_weight = new_weight\n            else:\n                # Try to remove this item\n                new_weight = current_weight - weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 0\n                    current_weight = new_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 219,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive by prioritizing those with high objective values and low total weight, then applies a hybrid local search that combines item swaps, random flips, and adaptive neighborhood exploration to generate a feasible neighbor solution while balancing exploration and exploitation of the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution, base_obj = archive[selected_idx]\n\n    # Hybrid local search: combine swap, flip, and adaptive neighborhood\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 1: Random flip with adaptive probability\n    flip_prob = 0.3 + 0.4 * (1 - current_weight / capacity)  # Higher probability when underutilized\n    for i in range(len(new_solution)):\n        if random.random() < flip_prob:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Step 2: Item swap for better balance\n    if len(new_solution) >= 2:\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and len(items_out) > 0:\n            # Select two items to swap (one in, one out)\n            i_in = random.choice(items_in)\n            i_out = random.choice(items_out)\n\n            # Check feasibility\n            if (current_weight - weight_lst[i_in] + weight_lst[i_out]) <= capacity:\n                new_solution[i_in] = 0\n                new_solution[i_out] = 1\n\n    # Step 3: Adaptive neighborhood exploration\n    if random.random() < 0.5:  # 50% chance to explore further\n        # Add or remove a random item that improves both objectives\n        candidate_items = np.where(new_solution == 0)[0]\n        if len(candidate_items) > 0:\n            # Evaluate candidates based on normalized improvement\n            improvements = []\n            for i in candidate_items:\n                if current_weight + weight_lst[i] <= capacity:\n                    imp1 = value1_lst[i] / (weight_lst[i] + 1e-8)\n                    imp2 = value2_lst[i] / (weight_lst[i] + 1e-8)\n                    improvements.append((imp1 + imp2, i))\n\n            if improvements:\n                _, best_i = max(improvements)\n                new_solution[best_i] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.4208080766154285,
            4.943958878517151
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution, base_obj = archive[selected_idx]\n\n    # Hybrid local search: combine swap, flip, and adaptive neighborhood\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 1: Random flip with adaptive probability\n    flip_prob = 0.3 + 0.4 * (1 - current_weight / capacity)  # Higher probability when underutilized\n    for i in range(len(new_solution)):\n        if random.random() < flip_prob:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Step 2: Item swap for better balance\n    if len(new_solution) >= 2:\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and len(items_out) > 0:\n            # Select two items to swap (one in, one out)\n            i_in = random.choice(items_in)\n            i_out = random.choice(items_out)\n\n            # Check feasibility\n            if (current_weight - weight_lst[i_in] + weight_lst[i_out]) <= capacity:\n                new_solution[i_in] = 0\n                new_solution[i_out] = 1\n\n    # Step 3: Adaptive neighborhood exploration\n    if random.random() < 0.5:  # 50% chance to explore further\n        # Add or remove a random item that improves both objectives\n        candidate_items = np.where(new_solution == 0)[0]\n        if len(candidate_items) > 0:\n            # Evaluate candidates based on normalized improvement\n            improvements = []\n            for i in candidate_items:\n                if current_weight + weight_lst[i] <= capacity:\n                    imp1 = value1_lst[i] / (weight_lst[i] + 1e-8)\n                    imp2 = value2_lst[i] / (weight_lst[i] + 1e-8)\n                    improvements.append((imp1 + imp2, i))\n\n            if improvements:\n                _, best_i = max(improvements)\n                new_solution[best_i] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 220,
        "algorithm": "{A novel hybrid local search operator combines probabilistic item swaps with a greedy objective-balanced exploration, prioritizing items with high marginal ratios of both objectives while ensuring feasibility through adaptive capacity checks and a restart mechanism for local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Generate a neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: Probabilistic swap based on marginal ratios\n    for _ in range(5):  # Limit the number of swaps to avoid excessive computation\n        # Calculate marginal ratios for both objectives\n        marginal_ratio1 = value1_lst / weight_lst\n        marginal_ratio2 = value2_lst / weight_lst\n\n        # Combine ratios with a balance factor (adjustable)\n        combined_ratio = 0.5 * marginal_ratio1 + 0.5 * marginal_ratio2\n\n        # Select items to swap probabilistically\n        if random.random() < 0.7:  # Higher chance to swap based on ratio\n            candidate_items = np.argsort(combined_ratio)[::-1]  # Sort by descending ratio\n        else:\n            candidate_items = np.arange(len(weight_lst))\n            random.shuffle(candidate_items)\n\n        for item in candidate_items:\n            if new_solution[item] == 1:\n                # Try removing the item\n                if current_weight - weight_lst[item] >= 0:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n                    break\n            else:\n                # Try adding the item\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n                    break\n\n    # Step 2: Greedy local improvement for one objective\n    if random.random() < 0.5:  # 50% chance to improve one objective\n        obj_to_improve = random.choice([0, 1])  # 0 for value1, 1 for value2\n        for _ in range(3):  # Limit the number of improvements\n            if obj_to_improve == 0:\n                # Improve value1\n                for item in np.argsort(value1_lst / weight_lst)[::-1]:\n                    if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        current_weight += weight_lst[item]\n                        break\n            else:\n                # Improve value2\n                for item in np.argsort(value2_lst / weight_lst)[::-1]:\n                    if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        current_weight += weight_lst[item]\n                        break\n\n    # Step 3: Restart if stuck in local optima\n    if np.array_equal(new_solution, base_solution):\n        # Randomly flip a small number of items\n        flip_indices = random.sample(range(len(weight_lst)), min(3, len(weight_lst)))\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.3761266994704354,
            10.576960504055023
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Generate a neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: Probabilistic swap based on marginal ratios\n    for _ in range(5):  # Limit the number of swaps to avoid excessive computation\n        # Calculate marginal ratios for both objectives\n        marginal_ratio1 = value1_lst / weight_lst\n        marginal_ratio2 = value2_lst / weight_lst\n\n        # Combine ratios with a balance factor (adjustable)\n        combined_ratio = 0.5 * marginal_ratio1 + 0.5 * marginal_ratio2\n\n        # Select items to swap probabilistically\n        if random.random() < 0.7:  # Higher chance to swap based on ratio\n            candidate_items = np.argsort(combined_ratio)[::-1]  # Sort by descending ratio\n        else:\n            candidate_items = np.arange(len(weight_lst))\n            random.shuffle(candidate_items)\n\n        for item in candidate_items:\n            if new_solution[item] == 1:\n                # Try removing the item\n                if current_weight - weight_lst[item] >= 0:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n                    break\n            else:\n                # Try adding the item\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n                    break\n\n    # Step 2: Greedy local improvement for one objective\n    if random.random() < 0.5:  # 50% chance to improve one objective\n        obj_to_improve = random.choice([0, 1])  # 0 for value1, 1 for value2\n        for _ in range(3):  # Limit the number of improvements\n            if obj_to_improve == 0:\n                # Improve value1\n                for item in np.argsort(value1_lst / weight_lst)[::-1]:\n                    if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        current_weight += weight_lst[item]\n                        break\n            else:\n                # Improve value2\n                for item in np.argsort(value2_lst / weight_lst)[::-1]:\n                    if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        current_weight += weight_lst[item]\n                        break\n\n    # Step 3: Restart if stuck in local optima\n    if np.array_equal(new_solution, base_solution):\n        # Randomly flip a small number of items\n        flip_indices = random.sample(range(len(weight_lst)), min(3, len(weight_lst)))\n        for i in flip_indices:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 221,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomly flip items with high marginal value-to-weight ratio\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Select top-k items with highest marginal value for exploration\n    k = max(1, len(weight_lst) // 10)\n    top_indices = np.argsort(-combined_marginal)[:k]\n\n    for idx in top_indices:\n        if np.random.rand() < 0.7:  # 70% chance to flip\n            new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        excess = total_weight - capacity\n        removable_indices = np.where(new_solution == 1)[0]\n        removable_weights = weight_lst[removable_indices]\n        sorted_indices = removable_indices[np.argsort(-removable_weights)]\n        for idx in sorted_indices:\n            if excess <= 0:\n                break\n            new_solution[idx] = 0\n            excess -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3936586503422404,
            2.2710197269916534
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomly flip items with high marginal value-to-weight ratio\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Select top-k items with highest marginal value for exploration\n    k = max(1, len(weight_lst) // 10)\n    top_indices = np.argsort(-combined_marginal)[:k]\n\n    for idx in top_indices:\n        if np.random.rand() < 0.7:  # 70% chance to flip\n            new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        excess = total_weight - capacity\n        removable_indices = np.where(new_solution == 1)[0]\n        removable_weights = weight_lst[removable_indices]\n        sorted_indices = removable_indices[np.argsort(-removable_weights)]\n        for idx in sorted_indices:\n            if excess <= 0:\n                break\n            new_solution[idx] = 0\n            excess -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 222,
        "algorithm": "{This algorithm intelligently selects a promising solution from the archive based on its current objective values and applies a hybrid local search operator that combines item swaps with probabilistic perturbations to explore high-potential regions of the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with probability proportional to its normalized objective value\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized = objectives / (objectives.sum(axis=0) + 1e-10)\n    weights = normalized.sum(axis=1)\n    weights = weights / weights.sum() if weights.sum() > 0 else np.ones(len(archive)) / len(archive)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Randomly select items to swap (with higher probability for items with high marginal value)\n    marginal_value1 = value1_lst * (1 - base_solution) + value1_lst * base_solution * 0.5\n    marginal_value2 = value2_lst * (1 - base_solution) + value2_lst * base_solution * 0.5\n    combined_marginal = marginal_value1 + marginal_value2\n    swap_probs = combined_marginal / (combined_marginal.sum() + 1e-10)\n\n    # Step 2: Perform swaps while maintaining feasibility\n    num_swaps = min(3, len(new_solution) // 2)\n    for _ in range(num_swaps):\n        if np.random.random() < 0.7:  # 70% chance to swap\n            # Select items to swap based on marginal value\n            swap_indices = np.random.choice(len(new_solution), size=2, p=swap_probs, replace=False)\n            i, j = swap_indices\n\n            # Check if swapping makes the solution feasible\n            if new_solution[i] == new_solution[j]:\n                continue  # No change\n\n            if new_solution[i] == 1 and new_solution[j] == 0:\n                if total_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = 0, 1\n                    total_weight = total_weight - weight_lst[i] + weight_lst[j]\n            elif new_solution[i] == 0 and new_solution[j] == 1:\n                if total_weight - weight_lst[j] + weight_lst[i] <= capacity:\n                    new_solution[i], new_solution[j] = 1, 0\n                    total_weight = total_weight - weight_lst[j] + weight_lst[i]\n\n    # Step 3: Apply probabilistic perturbations to escape local optima\n    for i in range(len(new_solution)):\n        if np.random.random() < 0.1:  # 10% chance to flip each bit\n            if new_solution[i] == 0:\n                if total_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    total_weight += weight_lst[i]\n            else:\n                new_solution[i] = 0\n                total_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.36075948689500176,
            8.877737164497375
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with probability proportional to its normalized objective value\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized = objectives / (objectives.sum(axis=0) + 1e-10)\n    weights = normalized.sum(axis=1)\n    weights = weights / weights.sum() if weights.sum() > 0 else np.ones(len(archive)) / len(archive)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Randomly select items to swap (with higher probability for items with high marginal value)\n    marginal_value1 = value1_lst * (1 - base_solution) + value1_lst * base_solution * 0.5\n    marginal_value2 = value2_lst * (1 - base_solution) + value2_lst * base_solution * 0.5\n    combined_marginal = marginal_value1 + marginal_value2\n    swap_probs = combined_marginal / (combined_marginal.sum() + 1e-10)\n\n    # Step 2: Perform swaps while maintaining feasibility\n    num_swaps = min(3, len(new_solution) // 2)\n    for _ in range(num_swaps):\n        if np.random.random() < 0.7:  # 70% chance to swap\n            # Select items to swap based on marginal value\n            swap_indices = np.random.choice(len(new_solution), size=2, p=swap_probs, replace=False)\n            i, j = swap_indices\n\n            # Check if swapping makes the solution feasible\n            if new_solution[i] == new_solution[j]:\n                continue  # No change\n\n            if new_solution[i] == 1 and new_solution[j] == 0:\n                if total_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = 0, 1\n                    total_weight = total_weight - weight_lst[i] + weight_lst[j]\n            elif new_solution[i] == 0 and new_solution[j] == 1:\n                if total_weight - weight_lst[j] + weight_lst[i] <= capacity:\n                    new_solution[i], new_solution[j] = 1, 0\n                    total_weight = total_weight - weight_lst[j] + weight_lst[i]\n\n    # Step 3: Apply probabilistic perturbations to escape local optima\n    for i in range(len(new_solution)):\n        if np.random.random() < 0.1:  # 10% chance to flip each bit\n            if new_solution[i] == 0:\n                if total_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    total_weight += weight_lst[i]\n            else:\n                new_solution[i] = 0\n                total_weight -= weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 223,
        "algorithm": "{This algorithm selects a promising solution from the archive by prioritizing those with high crowding distance or low dominance count, then applies a hybrid local search combining random item flips with a greedy improvement step to generate a feasible neighbor solution while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (high crowding distance or low dominance count)\n    selected_idx = np.random.choice(len(archive))\n    selected_solution, _ = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Random flip with greedy improvement\n    n_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly flip a subset of items\n    flip_mask = np.random.rand(n_items) < 0.2  # 20% chance to flip each item\n    new_solution[flip_mask] = 1 - new_solution[flip_mask]\n\n    # Ensure feasibility by removing excess weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        # Remove items with lowest value per weight ratio\n        item_ratios = (value1_lst + value2_lst) / weight_lst\n        sorted_indices = np.argsort(item_ratios)\n        for idx in sorted_indices:\n            if new_solution[idx] == 1 and excess <= 0:\n                break\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                excess -= weight_lst[idx]\n\n    # Greedy improvement: Add highest value items that fit\n    remaining_capacity = capacity - np.sum(weight_lst[new_solution == 1])\n    remaining_items = np.where(new_solution == 0)[0]\n    # Sort by combined value per weight\n    item_ratios = (value1_lst + value2_lst) / weight_lst\n    sorted_indices = np.argsort(item_ratios[remaining_items])[::-1]\n\n    for idx in sorted_indices:\n        if weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.41697182410947375,
            3.8746546506881714
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (high crowding distance or low dominance count)\n    selected_idx = np.random.choice(len(archive))\n    selected_solution, _ = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Random flip with greedy improvement\n    n_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly flip a subset of items\n    flip_mask = np.random.rand(n_items) < 0.2  # 20% chance to flip each item\n    new_solution[flip_mask] = 1 - new_solution[flip_mask]\n\n    # Ensure feasibility by removing excess weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        # Remove items with lowest value per weight ratio\n        item_ratios = (value1_lst + value2_lst) / weight_lst\n        sorted_indices = np.argsort(item_ratios)\n        for idx in sorted_indices:\n            if new_solution[idx] == 1 and excess <= 0:\n                break\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                excess -= weight_lst[idx]\n\n    # Greedy improvement: Add highest value items that fit\n    remaining_capacity = capacity - np.sum(weight_lst[new_solution == 1])\n    remaining_items = np.where(new_solution == 0)[0]\n    # Sort by combined value per weight\n    item_ratios = (value1_lst + value2_lst) / weight_lst\n    sorted_indices = np.argsort(item_ratios[remaining_items])[::-1]\n\n    for idx in sorted_indices:\n        if weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 224,
        "algorithm": "{A novel hybrid local search strategy that intelligently selects a promising solution from the archive, then applies a combination of item swapping, removal, and insertion operations while ensuring feasibility, to generate a high-quality neighbor solution by balancing exploration and exploitation of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: swap, remove, or insert items\n    operation = random.choice(['swap', 'remove', 'insert'])\n\n    if operation == 'swap':\n        # Swap two items (one in the knapsack, one out)\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            i, j = random.choice(in_items), random.choice(out_items)\n            if total_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif operation == 'remove':\n        # Remove a random item from the knapsack\n        in_items = np.where(new_solution == 1)[0]\n        if len(in_items) > 0:\n            i = random.choice(in_items)\n            if total_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n\n    elif operation == 'insert':\n        # Insert a random item into the knapsack\n        out_items = np.where(new_solution == 0)[0]\n        if len(out_items) > 0:\n            j = random.choice(out_items)\n            if total_weight + weight_lst[j] <= capacity:\n                new_solution[j] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.29202045585982145,
            4.889940589666367
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: swap, remove, or insert items\n    operation = random.choice(['swap', 'remove', 'insert'])\n\n    if operation == 'swap':\n        # Swap two items (one in the knapsack, one out)\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            i, j = random.choice(in_items), random.choice(out_items)\n            if total_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif operation == 'remove':\n        # Remove a random item from the knapsack\n        in_items = np.where(new_solution == 1)[0]\n        if len(in_items) > 0:\n            i = random.choice(in_items)\n            if total_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n\n    elif operation == 'insert':\n        # Insert a random item into the knapsack\n        out_items = np.where(new_solution == 0)[0]\n        if len(out_items) > 0:\n            j = random.choice(out_items)\n            if total_weight + weight_lst[j] <= capacity:\n                new_solution[j] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 225,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search that combines item swaps and probabilistic flips to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + i) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Hybrid local search: swap items or flip based on potential improvement\n    for _ in range(10):  # Limit the number of attempts to avoid excessive computation\n        # Randomly select two items to swap (if both are in the solution)\n        item1, item2 = random.sample(range(len(weight_lst)), 2)\n        if new_solution[item1] == 1 and new_solution[item2] == 1:\n            # Swap the items\n            new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n            new_weight = current_weight\n            new_value1 = current_value1\n            new_value2 = current_value2\n        else:\n            # Flip one item (add if not in, remove if in)\n            item = random.choice([item1, item2])\n            if new_solution[item] == 1:\n                new_weight = current_weight - weight_lst[item]\n                new_value1 = current_value1 - value1_lst[item]\n                new_value2 = current_value2 - value2_lst[item]\n            else:\n                new_weight = current_weight + weight_lst[item]\n                new_value1 = current_value1 + value1_lst[item]\n                new_value2 = current_value2 + value2_lst[item]\n\n            if new_weight <= capacity:\n                new_solution[item] = 1 - new_solution[item]\n                current_weight = new_weight\n                current_value1 = new_value1\n                current_value2 = new_value2\n            else:\n                # Revert if infeasible\n                if new_solution[item] == 1:\n                    new_solution[item] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.35432382661677464,
            2.918520152568817
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + i) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Hybrid local search: swap items or flip based on potential improvement\n    for _ in range(10):  # Limit the number of attempts to avoid excessive computation\n        # Randomly select two items to swap (if both are in the solution)\n        item1, item2 = random.sample(range(len(weight_lst)), 2)\n        if new_solution[item1] == 1 and new_solution[item2] == 1:\n            # Swap the items\n            new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n            new_weight = current_weight\n            new_value1 = current_value1\n            new_value2 = current_value2\n        else:\n            # Flip one item (add if not in, remove if in)\n            item = random.choice([item1, item2])\n            if new_solution[item] == 1:\n                new_weight = current_weight - weight_lst[item]\n                new_value1 = current_value1 - value1_lst[item]\n                new_value2 = current_value2 - value2_lst[item]\n            else:\n                new_weight = current_weight + weight_lst[item]\n                new_value1 = current_value1 + value1_lst[item]\n                new_value2 = current_value2 + value2_lst[item]\n\n            if new_weight <= capacity:\n                new_solution[item] = 1 - new_solution[item]\n                current_weight = new_weight\n                current_value1 = new_value1\n                current_value2 = new_value2\n            else:\n                # Revert if infeasible\n                if new_solution[item] == 1:\n                    new_solution[item] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 226,
        "algorithm": "{This algorithm intelligently selects a promising solution from the archive using a hybrid local search strategy that combines random perturbation, adaptive neighborhood exploration, and objective-aware mutation to generate high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution from the archive (prioritize solutions with high potential for improvement)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Generate a neighbor solution using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly perturb some items (with probability based on remaining capacity)\n    for i in range(len(new_solution)):\n        if random.random() < 0.3:  # 30% chance to flip each item\n            if new_solution[i] == 1:\n                # Remove item if it doesn't violate capacity\n                new_solution[i] = 0\n            else:\n                # Add item if it doesn't exceed capacity\n                if weight_lst[i] <= remaining_capacity:\n                    new_solution[i] = 1\n                    remaining_capacity -= weight_lst[i]\n\n    # Step 2: Adaptive neighborhood exploration (focus on high-value items)\n    sorted_items = np.argsort(-value1_lst - value2_lst)  # Prioritize items with high combined value\n    for i in sorted_items:\n        if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n            new_solution[i] = 1\n            remaining_capacity -= weight_lst[i]\n        elif new_solution[i] == 1 and random.random() < 0.2:  # 20% chance to remove low-value items\n            if np.sum(weight_lst * new_solution) - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                remaining_capacity += weight_lst[i]\n\n    # Step 3: Objective-aware mutation (flip items that improve both objectives)\n    for i in range(len(new_solution)):\n        if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 1\n            temp_weight = np.sum(weight_lst * temp_solution)\n            if temp_weight <= capacity:\n                new_value1 = np.sum(value1_lst * temp_solution)\n                new_value2 = np.sum(value2_lst * temp_solution)\n                if new_value1 > archive[selected_idx][1][0] and new_value2 > archive[selected_idx][1][1]:\n                    new_solution[i] = 1\n                    remaining_capacity -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.3561606363685358,
            10.791144907474518
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution from the archive (prioritize solutions with high potential for improvement)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Generate a neighbor solution using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly perturb some items (with probability based on remaining capacity)\n    for i in range(len(new_solution)):\n        if random.random() < 0.3:  # 30% chance to flip each item\n            if new_solution[i] == 1:\n                # Remove item if it doesn't violate capacity\n                new_solution[i] = 0\n            else:\n                # Add item if it doesn't exceed capacity\n                if weight_lst[i] <= remaining_capacity:\n                    new_solution[i] = 1\n                    remaining_capacity -= weight_lst[i]\n\n    # Step 2: Adaptive neighborhood exploration (focus on high-value items)\n    sorted_items = np.argsort(-value1_lst - value2_lst)  # Prioritize items with high combined value\n    for i in sorted_items:\n        if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n            new_solution[i] = 1\n            remaining_capacity -= weight_lst[i]\n        elif new_solution[i] == 1 and random.random() < 0.2:  # 20% chance to remove low-value items\n            if np.sum(weight_lst * new_solution) - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                remaining_capacity += weight_lst[i]\n\n    # Step 3: Objective-aware mutation (flip items that improve both objectives)\n    for i in range(len(new_solution)):\n        if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 1\n            temp_weight = np.sum(weight_lst * temp_solution)\n            if temp_weight <= capacity:\n                new_value1 = np.sum(value1_lst * temp_solution)\n                new_value2 = np.sum(value2_lst * temp_solution)\n                if new_value1 > archive[selected_idx][1][0] and new_value2 > archive[selected_idx][1][1]:\n                    new_solution[i] = 1\n                    remaining_capacity -= weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 227,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a promising solution from the archive, then applies a combination of item swaps and value-driven perturbations to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their combined objective values (ascending)\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        # Select the top 30% of solutions and pick one randomly\n        candidate_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        selected_idx = random.randint(0, len(candidate_solutions) - 1)\n        base_solution = candidate_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search\n    # Hybrid approach: 1. Randomly flip a subset of items, 2. Add high-value items if capacity allows\n    # Step 2.1: Randomly flip a subset of items (10-30% of items)\n    flip_ratio = random.uniform(0.1, 0.3)\n    num_flips = max(1, int(flip_ratio * len(new_solution)))\n    flip_indices = random.sample(range(len(new_solution)), num_flips)\n\n    # Temporarily flip the selected items to check feasibility\n    temp_solution = new_solution.copy()\n    for idx in flip_indices:\n        temp_solution[idx] = 1 - temp_solution[idx]\n\n    # Step 2.2: If flipping makes the solution infeasible, undo the flips\n    if np.sum(weight_lst[temp_solution.astype(bool)]) > capacity:\n        for idx in flip_indices:\n            new_solution[idx] = 1 - new_solution[idx]\n\n    # Step 2.3: Add high-value items if capacity allows\n    current_weight = np.sum(weight_lst[new_solution.astype(bool)])\n    remaining_capacity = capacity - current_weight\n\n    # Sort items by their combined value-to-weight ratio\n    value_ratio = (value1_lst + value2_lst) / weight_lst\n    sorted_indices = np.argsort(value_ratio)[::-1]  # Descending order\n\n    for idx in sorted_indices:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8191393873036651,
            8.901203006505966
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their combined objective values (ascending)\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        # Select the top 30% of solutions and pick one randomly\n        candidate_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        selected_idx = random.randint(0, len(candidate_solutions) - 1)\n        base_solution = candidate_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search\n    # Hybrid approach: 1. Randomly flip a subset of items, 2. Add high-value items if capacity allows\n    # Step 2.1: Randomly flip a subset of items (10-30% of items)\n    flip_ratio = random.uniform(0.1, 0.3)\n    num_flips = max(1, int(flip_ratio * len(new_solution)))\n    flip_indices = random.sample(range(len(new_solution)), num_flips)\n\n    # Temporarily flip the selected items to check feasibility\n    temp_solution = new_solution.copy()\n    for idx in flip_indices:\n        temp_solution[idx] = 1 - temp_solution[idx]\n\n    # Step 2.2: If flipping makes the solution infeasible, undo the flips\n    if np.sum(weight_lst[temp_solution.astype(bool)]) > capacity:\n        for idx in flip_indices:\n            new_solution[idx] = 1 - new_solution[idx]\n\n    # Step 2.3: Add high-value items if capacity allows\n    current_weight = np.sum(weight_lst[new_solution.astype(bool)])\n    remaining_capacity = capacity - current_weight\n\n    # Sort items by their combined value-to-weight ratio\n    value_ratio = (value1_lst + value2_lst) / weight_lst\n    sorted_indices = np.argsort(value_ratio)[::-1]  # Descending order\n\n    for idx in sorted_indices:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 228,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive by prioritizing those with high objective values and low weight, then applies a hybrid local search operator that combines item swaps and adaptive perturbation to explore high-potential neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[(v1 + v2) / (np.sum(archive[i][0] * weight_lst) + 1e-6) for i, (_, (v1, v2)) in enumerate(archive)],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(base_solution * weight_lst)\n\n    # Hybrid local search: adaptive swaps and perturbations\n    new_solution = base_solution.copy()\n    items = np.where(new_solution == 1)[0]\n\n    # Adaptive swap (swap two items if beneficial)\n    if len(items) >= 2:\n        i, j = random.sample(list(items), 2)\n        if (weight_lst[j] - weight_lst[i]) <= (capacity - current_weight):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Perturbation: add or remove a random item if possible\n    all_items = np.arange(len(weight_lst))\n    excluded_items = np.setdiff1d(all_items, items)\n    if len(excluded_items) > 0:\n        # Try adding a new item\n        candidate = random.choice(excluded_items)\n        if weight_lst[candidate] <= (capacity - current_weight):\n            new_solution[candidate] = 1\n        else:\n            # If adding fails, try removing a low-value item\n            if len(items) > 0:\n                item_to_remove = random.choice(items)\n                new_solution[item_to_remove] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.8910244280507857,
            7.218295454978943
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[(v1 + v2) / (np.sum(archive[i][0] * weight_lst) + 1e-6) for i, (_, (v1, v2)) in enumerate(archive)],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(base_solution * weight_lst)\n\n    # Hybrid local search: adaptive swaps and perturbations\n    new_solution = base_solution.copy()\n    items = np.where(new_solution == 1)[0]\n\n    # Adaptive swap (swap two items if beneficial)\n    if len(items) >= 2:\n        i, j = random.sample(list(items), 2)\n        if (weight_lst[j] - weight_lst[i]) <= (capacity - current_weight):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Perturbation: add or remove a random item if possible\n    all_items = np.arange(len(weight_lst))\n    excluded_items = np.setdiff1d(all_items, items)\n    if len(excluded_items) > 0:\n        # Try adding a new item\n        candidate = random.choice(excluded_items)\n        if weight_lst[candidate] <= (capacity - current_weight):\n            new_solution[candidate] = 1\n        else:\n            # If adding fails, try removing a low-value item\n            if len(items) > 0:\n                item_to_remove = random.choice(items)\n                new_solution[item_to_remove] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 229,
        "algorithm": "{The algorithm intelligently selects a solution from the archive with high potential for improvement by prioritizing solutions with low dominance counts or high marginal gains, then applies a hybrid local search that combines item swaps with value-based perturbations to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution (here, we prioritize solutions with higher total value)\n    selected_idx = np.argmax([obj[0] + obj[1] for (sol, obj) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items with high value ratios\n    value_ratios = (value1_lst + value2_lst) / weight_lst\n    sorted_indices = np.argsort(-value_ratios)  # descending order\n\n    # Try to add items with high value-to-weight ratios\n    for idx in sorted_indices:\n        if new_solution[idx] == 0:\n            if np.dot(new_solution, weight_lst) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n            else:\n                break\n\n    # Try to remove items with low value-to-weight ratios if still over capacity\n    if np.dot(new_solution, weight_lst) > capacity:\n        for idx in reversed(sorted_indices):\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                if np.dot(new_solution, weight_lst) <= capacity:\n                    break\n\n    # Randomly flip a small number of items for diversity\n    flip_indices = random.sample(range(len(weight_lst)), min(2, len(weight_lst)))\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if np.dot(new_solution, weight_lst) - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if np.dot(new_solution, weight_lst) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.2662280664251162,
            8.133909076452255
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution (here, we prioritize solutions with higher total value)\n    selected_idx = np.argmax([obj[0] + obj[1] for (sol, obj) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap items with high value ratios\n    value_ratios = (value1_lst + value2_lst) / weight_lst\n    sorted_indices = np.argsort(-value_ratios)  # descending order\n\n    # Try to add items with high value-to-weight ratios\n    for idx in sorted_indices:\n        if new_solution[idx] == 0:\n            if np.dot(new_solution, weight_lst) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n            else:\n                break\n\n    # Try to remove items with low value-to-weight ratios if still over capacity\n    if np.dot(new_solution, weight_lst) > capacity:\n        for idx in reversed(sorted_indices):\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                if np.dot(new_solution, weight_lst) <= capacity:\n                    break\n\n    # Randomly flip a small number of items for diversity\n    flip_indices = random.sample(range(len(weight_lst)), min(2, len(weight_lst)))\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if np.dot(new_solution, weight_lst) - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if np.dot(new_solution, weight_lst) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 230,
        "algorithm": "{The algorithm selects a promising solution from the archive based on its potential for improvement, then applies a hybrid local search operator combining item swapping and adaptive perturbation to generate a feasible neighbor solution while maximizing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, randomly for simplicity, but can be enhanced)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: item swapping and adaptive perturbation\n    new_solution = base_solution.copy()\n\n    # Step 1: Item swapping (swap items to improve both objectives)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Find items to swap (one in, one out)\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) == 0 or len(out_items) == 0:\n            break\n\n        # Randomly select items to swap\n        in_item = random.choice(in_items)\n        out_item = random.choice(out_items)\n\n        # Check feasibility\n        new_weight = current_weight - weight_lst[out_item] + weight_lst[in_item]\n        if new_weight <= capacity:\n            # Check if swapping improves both objectives\n            if (value1_lst[in_item] > value1_lst[out_item] and value2_lst[in_item] > value2_lst[out_item]):\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                current_weight = new_weight\n\n    # Step 2: Adaptive perturbation (flip a small number of items to escape local optima)\n    perturbation_size = max(1, len(weight_lst) // 20)  # Small perturbation\n    for _ in range(perturbation_size):\n        item = random.randint(0, len(weight_lst) - 1)\n        if new_solution[item] == 1:\n            if current_weight - weight_lst[item] >= 0:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.4201879399139845,
            2.7799289524555206
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, randomly for simplicity, but can be enhanced)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: item swapping and adaptive perturbation\n    new_solution = base_solution.copy()\n\n    # Step 1: Item swapping (swap items to improve both objectives)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Find items to swap (one in, one out)\n        in_items = np.where(new_solution == 0)[0]\n        out_items = np.where(new_solution == 1)[0]\n\n        if len(in_items) == 0 or len(out_items) == 0:\n            break\n\n        # Randomly select items to swap\n        in_item = random.choice(in_items)\n        out_item = random.choice(out_items)\n\n        # Check feasibility\n        new_weight = current_weight - weight_lst[out_item] + weight_lst[in_item]\n        if new_weight <= capacity:\n            # Check if swapping improves both objectives\n            if (value1_lst[in_item] > value1_lst[out_item] and value2_lst[in_item] > value2_lst[out_item]):\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n                current_weight = new_weight\n\n    # Step 2: Adaptive perturbation (flip a small number of items to escape local optima)\n    perturbation_size = max(1, len(weight_lst) // 20)  # Small perturbation\n    for _ in range(perturbation_size):\n        item = random.randint(0, len(weight_lst) - 1)\n        if new_solution[item] == 1:\n            if current_weight - weight_lst[item] >= 0:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 231,
        "algorithm": "{The heuristic function selects a solution from the archive with high potential for improvement by prioritizing those with high objective values and low weight utilization, then applies a hybrid local search combining item swaps and strategic flips to generate a feasible neighbor solution while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (high value, low weight utilization)\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[(archive[i][1][0] + archive[i][1][1]) / (np.sum(weight_lst * archive[i][0]) + 1e-6) for i in range(len(archive))],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: strategic item swaps and flips\n    current_weight = np.sum(weight_lst * new_solution)\n    candidates = np.where(new_solution == 0)[0]\n    np.random.shuffle(candidates)\n\n    for item in candidates:\n        if current_weight + weight_lst[item] <= capacity:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n            break\n\n    # Strategic flip: remove low-value items that don't significantly affect other objectives\n    for item in np.where(new_solution == 1)[0]:\n        if random.random() < 0.3:  # 30% chance to flip\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = np.sum(weight_lst * temp_solution)\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n    # Ensure at least one item is swapped for diversity\n    if np.array_equal(new_solution, base_solution):\n        if len(np.where(new_solution == 1)[0]) > 0:\n            item_to_swap = random.choice(np.where(new_solution == 1)[0])\n            new_solution[item_to_swap] = 0\n            current_weight -= weight_lst[item_to_swap]\n            for item in np.where(new_solution == 0)[0]:\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8471493770119078,
            5.985552996397018
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (high value, low weight utilization)\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[(archive[i][1][0] + archive[i][1][1]) / (np.sum(weight_lst * archive[i][0]) + 1e-6) for i in range(len(archive))],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: strategic item swaps and flips\n    current_weight = np.sum(weight_lst * new_solution)\n    candidates = np.where(new_solution == 0)[0]\n    np.random.shuffle(candidates)\n\n    for item in candidates:\n        if current_weight + weight_lst[item] <= capacity:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n            break\n\n    # Strategic flip: remove low-value items that don't significantly affect other objectives\n    for item in np.where(new_solution == 1)[0]:\n        if random.random() < 0.3:  # 30% chance to flip\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = np.sum(weight_lst * temp_solution)\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n    # Ensure at least one item is swapped for diversity\n    if np.array_equal(new_solution, base_solution):\n        if len(np.where(new_solution == 1)[0]) > 0:\n            item_to_swap = random.choice(np.where(new_solution == 1)[0])\n            new_solution[item_to_swap] = 0\n            current_weight -= weight_lst[item_to_swap]\n            for item in np.where(new_solution == 0)[0]:\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 232,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_solution, _ = archive_sorted[0]\n\n    # Step 2: Generate a neighbor solution using a hybrid local search strategy\n    # Strategy: Randomly flip a subset of items, then apply a greedy improvement step\n    new_solution = selected_solution.copy()\n    n_items = len(new_solution)\n\n    # Randomly flip a subset of items (up to 10% of items)\n    flip_indices = np.random.choice(n_items, size=min(5, n_items), replace=False)\n    new_solution[flip_indices] = 1 - new_solution[flip_indices]\n\n    # Ensure feasibility: if total weight exceeds capacity, remove items until feasible\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Sort items by (value1 + value2) / weight ratio in descending order\n        item_ratios = (value1_lst + value2_lst) / weight_lst\n        sorted_indices = np.argsort(-item_ratios * new_solution)\n        for idx in sorted_indices:\n            if total_weight <= capacity:\n                break\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n\n    # Greedy improvement step: add the most valuable item (based on combined value) that fits\n    remaining_weight = capacity - np.sum(weight_lst * new_solution)\n    if remaining_weight > 0:\n        # Sort items by (value1 + value2) / weight ratio in descending order\n        item_ratios = (value1_lst + value2_lst) / weight_lst\n        sorted_indices = np.argsort(-item_ratios)\n        for idx in sorted_indices:\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_weight:\n                new_solution[idx] = 1\n                remaining_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3374886944549642,
            6.365420073270798
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_solution, _ = archive_sorted[0]\n\n    # Step 2: Generate a neighbor solution using a hybrid local search strategy\n    # Strategy: Randomly flip a subset of items, then apply a greedy improvement step\n    new_solution = selected_solution.copy()\n    n_items = len(new_solution)\n\n    # Randomly flip a subset of items (up to 10% of items)\n    flip_indices = np.random.choice(n_items, size=min(5, n_items), replace=False)\n    new_solution[flip_indices] = 1 - new_solution[flip_indices]\n\n    # Ensure feasibility: if total weight exceeds capacity, remove items until feasible\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Sort items by (value1 + value2) / weight ratio in descending order\n        item_ratios = (value1_lst + value2_lst) / weight_lst\n        sorted_indices = np.argsort(-item_ratios * new_solution)\n        for idx in sorted_indices:\n            if total_weight <= capacity:\n                break\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n\n    # Greedy improvement step: add the most valuable item (based on combined value) that fits\n    remaining_weight = capacity - np.sum(weight_lst * new_solution)\n    if remaining_weight > 0:\n        # Sort items by (value1 + value2) / weight ratio in descending order\n        item_ratios = (value1_lst + value2_lst) / weight_lst\n        sorted_indices = np.argsort(-item_ratios)\n        for idx in sorted_indices:\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_weight:\n                new_solution[idx] = 1\n                remaining_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 233,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and potential improvement, then applies a hybrid local search operator that combines random item swaps with a greedy selection of high-value items to ensure feasibility and diversity in the neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1, len(archive)) / np.sum(np.linspace(0.1, 1, len(archive))))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps + greedy additions\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Random swaps (20% of items)\n    swap_indices = np.random.choice(n_items, size=max(1, int(0.2 * n_items)), replace=False)\n    for idx in swap_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Greedy additions of high-value items not in the solution\n    remaining_items = np.where(new_solution == 0)[0]\n    if len(remaining_items) > 0:\n        # Sort by combined normalized value\n        combined_value = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        sorted_items = remaining_items[np.argsort(-combined_value[remaining_items])]\n\n        for idx in sorted_items:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3470675189124338,
            7.9059790670871735
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1, len(archive)) / np.sum(np.linspace(0.1, 1, len(archive))))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps + greedy additions\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Random swaps (20% of items)\n    swap_indices = np.random.choice(n_items, size=max(1, int(0.2 * n_items)), replace=False)\n    for idx in swap_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Greedy additions of high-value items not in the solution\n    remaining_items = np.where(new_solution == 0)[0]\n    if len(remaining_items) > 0:\n        # Sort by combined normalized value\n        combined_value = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        sorted_items = remaining_items[np.argsort(-combined_value[remaining_items])]\n\n        for idx in sorted_items:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 234,
        "algorithm": "{A novel local search heuristic that intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid strategy combining item swaps, random flips, and adaptive neighborhood exploration to generate a high-quality neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest combined potential for improvement\n    selected_idx = np.argmax([np.sum(sol) + np.sum(sol * weight_lst) / capacity for sol, _ in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    # Step 1: Randomly flip items with high value-to-weight ratio\n    vw1_ratio = value1_lst / (weight_lst + 1e-6)\n    vw2_ratio = value2_lst / (weight_lst + 1e-6)\n    combined_ratio = vw1_ratio + vw2_ratio\n    sorted_indices = np.argsort(combined_ratio)[::-1]\n\n    for idx in sorted_indices[:max(1, len(sorted_indices) // 4)]:\n        if np.random.rand() < 0.3:  # 30% chance to flip\n            new_solution[idx] = 1 - new_solution[idx]\n            if np.sum(new_solution * weight_lst) > capacity:\n                new_solution[idx] = 1 - new_solution[idx]\n\n    # Step 2: Swap items between high and low value items\n    if len(new_solution) > 1:\n        high_value_items = np.where(new_solution == 1)[0]\n        low_value_items = np.where(new_solution == 0)[0]\n\n        if len(high_value_items) > 0 and len(low_value_items) > 0:\n            # Select a high value item to potentially remove\n            high_idx = np.random.choice(high_value_items)\n            # Select a low value item to potentially add\n            low_idx = np.random.choice(low_value_items)\n\n            # Calculate new weight\n            new_weight = np.sum(new_solution * weight_lst) - weight_lst[high_idx] + weight_lst[low_idx]\n\n            if new_weight <= capacity:\n                new_solution[high_idx] = 0\n                new_solution[low_idx] = 1\n\n    # Step 3: Adaptive neighborhood exploration\n    current_weight = np.sum(new_solution * weight_lst)\n    if np.random.rand() < 0.5 and current_weight < capacity:\n        # Try to add more items if possible\n        available_items = np.where(new_solution == 0)[0]\n        np.random.shuffle(available_items)\n\n        for idx in available_items:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n            else:\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.5291981215849403,
            10.249739408493042
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest combined potential for improvement\n    selected_idx = np.argmax([np.sum(sol) + np.sum(sol * weight_lst) / capacity for sol, _ in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    # Step 1: Randomly flip items with high value-to-weight ratio\n    vw1_ratio = value1_lst / (weight_lst + 1e-6)\n    vw2_ratio = value2_lst / (weight_lst + 1e-6)\n    combined_ratio = vw1_ratio + vw2_ratio\n    sorted_indices = np.argsort(combined_ratio)[::-1]\n\n    for idx in sorted_indices[:max(1, len(sorted_indices) // 4)]:\n        if np.random.rand() < 0.3:  # 30% chance to flip\n            new_solution[idx] = 1 - new_solution[idx]\n            if np.sum(new_solution * weight_lst) > capacity:\n                new_solution[idx] = 1 - new_solution[idx]\n\n    # Step 2: Swap items between high and low value items\n    if len(new_solution) > 1:\n        high_value_items = np.where(new_solution == 1)[0]\n        low_value_items = np.where(new_solution == 0)[0]\n\n        if len(high_value_items) > 0 and len(low_value_items) > 0:\n            # Select a high value item to potentially remove\n            high_idx = np.random.choice(high_value_items)\n            # Select a low value item to potentially add\n            low_idx = np.random.choice(low_value_items)\n\n            # Calculate new weight\n            new_weight = np.sum(new_solution * weight_lst) - weight_lst[high_idx] + weight_lst[low_idx]\n\n            if new_weight <= capacity:\n                new_solution[high_idx] = 0\n                new_solution[low_idx] = 1\n\n    # Step 3: Adaptive neighborhood exploration\n    current_weight = np.sum(new_solution * weight_lst)\n    if np.random.rand() < 0.5 and current_weight < capacity:\n        # Try to add more items if possible\n        available_items = np.where(new_solution == 0)[0]\n        np.random.shuffle(available_items)\n\n        for idx in available_items:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n            else:\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 235,
        "algorithm": "{A novel heuristic local search operator that intelligently selects a solution from the archive, identifies critical items using a multi-objective utility function, and performs a hybrid flip-and-shift operation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Select a solution with high potential for improvement (e.g., not too crowded in objective space)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (obj1, obj2) = archive[selected_idx]\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Compute utility scores for each item to identify critical items\n    utility = (value1_lst + value2_lst) / weight_lst  # Multi-objective utility\n    utility[base_solution == 0] = 0  # Only consider items in the solution\n\n    # Step 3: Perform hybrid flip-and-shift operation\n    new_solution = base_solution.copy()\n\n    # Flip a random item (with higher chance for low-utility items)\n    flip_candidates = np.where(utility > 0)[0]\n    if len(flip_candidates) > 0:\n        flip_item = random.choice(flip_candidates)\n        new_solution[flip_item] = 1 - new_solution[flip_item]\n\n    # Shift: Add a random item not in the solution (if capacity allows)\n    zero_weight = np.sum(weight_lst * (1 - new_solution))\n    add_candidates = np.where((weight_lst <= zero_weight) & (base_solution == 0))[0]\n    if len(add_candidates) > 0:\n        add_item = random.choice(add_candidates)\n        new_solution[add_item] = 1\n\n    # Ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Remove a random item from the solution\n        remove_candidates = np.where(new_solution == 1)[0]\n        if len(remove_candidates) == 0:\n            break  # No items left to remove\n        remove_item = random.choice(remove_candidates)\n        new_solution[remove_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.5509737189243201,
            2.8133144676685333
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Select a solution with high potential for improvement (e.g., not too crowded in objective space)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (obj1, obj2) = archive[selected_idx]\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Step 2: Compute utility scores for each item to identify critical items\n    utility = (value1_lst + value2_lst) / weight_lst  # Multi-objective utility\n    utility[base_solution == 0] = 0  # Only consider items in the solution\n\n    # Step 3: Perform hybrid flip-and-shift operation\n    new_solution = base_solution.copy()\n\n    # Flip a random item (with higher chance for low-utility items)\n    flip_candidates = np.where(utility > 0)[0]\n    if len(flip_candidates) > 0:\n        flip_item = random.choice(flip_candidates)\n        new_solution[flip_item] = 1 - new_solution[flip_item]\n\n    # Shift: Add a random item not in the solution (if capacity allows)\n    zero_weight = np.sum(weight_lst * (1 - new_solution))\n    add_candidates = np.where((weight_lst <= zero_weight) & (base_solution == 0))[0]\n    if len(add_candidates) > 0:\n        add_item = random.choice(add_candidates)\n        new_solution[add_item] = 1\n\n    # Ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Remove a random item from the solution\n        remove_candidates = np.where(new_solution == 1)[0]\n        if len(remove_candidates) == 0:\n            break  # No items left to remove\n        remove_item = random.choice(remove_candidates)\n        new_solution[remove_item] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 236,
        "algorithm": "{The heuristic function selects a promising solution from the archive based on a weighted randomness favoring solutions with high potential for improvement, then applies a hybrid local search operator combining item swaps and random flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with weighted randomness based on potential for improvement\n    weights = [1.0 / (1 + sum(archive[i][1])) for i in range(len(archive))]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Step 1: Random flip with feasibility check\n    if random.random() < 0.5:\n        flip_idx = random.randint(0, n_items - 1)\n        if base_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    # Step 2: Swap two items with feasibility check\n    else:\n        swap_indices = random.sample(range(n_items), 2)\n        i, j = swap_indices[0], swap_indices[1]\n        if new_solution[i] != new_solution[j]:\n            delta_weight = (weight_lst[j] - weight_lst[i]) if new_solution[i] == 1 else (weight_lst[i] - weight_lst[j])\n            if current_weight + delta_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Random flip of a subset of items (diversification)\n    if random.random() < 0.3:\n        subset_size = min(3, n_items)\n        subset = random.sample(range(n_items), subset_size)\n        for idx in subset:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.26408368130448856,
            5.334557831287384
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with weighted randomness based on potential for improvement\n    weights = [1.0 / (1 + sum(archive[i][1])) for i in range(len(archive))]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Step 1: Random flip with feasibility check\n    if random.random() < 0.5:\n        flip_idx = random.randint(0, n_items - 1)\n        if base_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    # Step 2: Swap two items with feasibility check\n    else:\n        swap_indices = random.sample(range(n_items), 2)\n        i, j = swap_indices[0], swap_indices[1]\n        if new_solution[i] != new_solution[j]:\n            delta_weight = (weight_lst[j] - weight_lst[i]) if new_solution[i] == 1 else (weight_lst[i] - weight_lst[j])\n            if current_weight + delta_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Random flip of a subset of items (diversification)\n    if random.random() < 0.3:\n        subset_size = min(3, n_items)\n        subset = random.sample(range(n_items), subset_size)\n        for idx in subset:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 237,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines item swaps and probabilistic flips to generate a neighbor solution while ensuring feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their objective values (ascending for both objectives)\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n        # Select a solution from the middle to avoid extreme solutions\n        base_solution = sorted_archive[len(sorted_archive) // 2][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Hybrid local search: probabilistic flips and item swaps\n    for _ in range(2):  # Perform a few iterations\n        # Randomly select a subset of items to flip\n        flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n        for idx in flip_indices:\n            if random.random() < 0.5:  # Probabilistic flip\n                new_solution[idx] = 1 - new_solution[idx]\n\n        # Ensure feasibility by removing items if capacity is exceeded\n        total_weight = np.sum(weight_lst[new_solution == 1])\n        if total_weight > capacity:\n            # Remove items with the lowest value-to-weight ratio\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) > 0:\n                value_to_weight = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n                sorted_indices = np.argsort(value_to_weight)\n                for idx in sorted_indices:\n                    new_solution[included_items[idx]] = 0\n                    total_weight = np.sum(weight_lst[new_solution == 1])\n                    if total_weight <= capacity:\n                        break\n\n        # Randomly swap items between included and excluded\n        included = np.where(new_solution == 1)[0]\n        excluded = np.where(new_solution == 0)[0]\n        if len(included) > 0 and len(excluded) > 0:\n            swap_in = random.choice(included)\n            swap_out = random.choice(excluded)\n            new_solution[swap_in], new_solution[swap_out] = new_solution[swap_out], new_solution[swap_in]\n\n            # Re-check feasibility\n            total_weight = np.sum(weight_lst[new_solution == 1])\n            if total_weight > capacity:\n                new_solution[swap_out] = 1  # Undo the swap if infeasible\n\n    return new_solution\n\n",
        "score": [
            -0.4821235527883513,
            3.9773355424404144
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their objective values (ascending for both objectives)\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n        # Select a solution from the middle to avoid extreme solutions\n        base_solution = sorted_archive[len(sorted_archive) // 2][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Hybrid local search: probabilistic flips and item swaps\n    for _ in range(2):  # Perform a few iterations\n        # Randomly select a subset of items to flip\n        flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n        for idx in flip_indices:\n            if random.random() < 0.5:  # Probabilistic flip\n                new_solution[idx] = 1 - new_solution[idx]\n\n        # Ensure feasibility by removing items if capacity is exceeded\n        total_weight = np.sum(weight_lst[new_solution == 1])\n        if total_weight > capacity:\n            # Remove items with the lowest value-to-weight ratio\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) > 0:\n                value_to_weight = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n                sorted_indices = np.argsort(value_to_weight)\n                for idx in sorted_indices:\n                    new_solution[included_items[idx]] = 0\n                    total_weight = np.sum(weight_lst[new_solution == 1])\n                    if total_weight <= capacity:\n                        break\n\n        # Randomly swap items between included and excluded\n        included = np.where(new_solution == 1)[0]\n        excluded = np.where(new_solution == 0)[0]\n        if len(included) > 0 and len(excluded) > 0:\n            swap_in = random.choice(included)\n            swap_out = random.choice(excluded)\n            new_solution[swap_in], new_solution[swap_out] = new_solution[swap_out], new_solution[swap_in]\n\n            # Re-check feasibility\n            total_weight = np.sum(weight_lst[new_solution == 1])\n            if total_weight > capacity:\n                new_solution[swap_out] = 1  # Undo the swap if infeasible\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 238,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n\n    # Identify items that are not in the solution (0) and could potentially be added\n    zero_indices = np.where(base_solution == 0)[0]\n    if len(zero_indices) > 0:\n        # Randomly select an item to add\n        add_idx = random.choice(zero_indices)\n        if weight_lst[add_idx] <= capacity - np.sum(weight_lst[base_solution == 1]):\n            new_solution[add_idx] = 1\n\n    # Identify items that are in the solution (1) and could potentially be removed\n    one_indices = np.where(base_solution == 1)[0]\n    if len(one_indices) > 0:\n        # Randomly select an item to remove\n        remove_idx = random.choice(one_indices)\n        new_solution[remove_idx] = 0\n\n    # Ensure the solution is feasible (weight <= capacity)\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        # If not feasible, remove a random item from the new solution\n        one_indices = np.where(new_solution == 1)[0]\n        if len(one_indices) == 0:\n            break  # No items to remove, return original solution\n        remove_idx = random.choice(one_indices)\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.8695887155569264,
            1.3405407667160034
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n\n    # Identify items that are not in the solution (0) and could potentially be added\n    zero_indices = np.where(base_solution == 0)[0]\n    if len(zero_indices) > 0:\n        # Randomly select an item to add\n        add_idx = random.choice(zero_indices)\n        if weight_lst[add_idx] <= capacity - np.sum(weight_lst[base_solution == 1]):\n            new_solution[add_idx] = 1\n\n    # Identify items that are in the solution (1) and could potentially be removed\n    one_indices = np.where(base_solution == 1)[0]\n    if len(one_indices) > 0:\n        # Randomly select an item to remove\n        remove_idx = random.choice(one_indices)\n        new_solution[remove_idx] = 0\n\n    # Ensure the solution is feasible (weight <= capacity)\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        # If not feasible, remove a random item from the new solution\n        one_indices = np.where(new_solution == 1)[0]\n        if len(one_indices) == 0:\n            break  # No items to remove, return original solution\n        remove_idx = random.choice(one_indices)\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 239,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search combining item swapping and random perturbation to explore the neighborhood while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected = random.choice(archive_sorted[:max(1, len(archive_sorted) // 3)])\n    base_solution = selected[0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: swap items or perturb randomly\n    new_solution = base_solution.copy()\n\n    # First, try to swap items to improve both objectives\n    for _ in range(10):  # Limit attempts to avoid excessive computation\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) == 0 or len(out_items) == 0:\n            break\n\n        # Select random items to swap\n        i_in = random.choice(in_items)\n        i_out = random.choice(out_items)\n\n        # Check feasibility of swap\n        delta_weight = weight_lst[i_out] - weight_lst[i_in]\n        if current_weight + delta_weight <= capacity:\n            new_solution[i_in], new_solution[i_out] = new_solution[i_out], new_solution[i_in]\n            current_weight += delta_weight\n            break\n\n    # If no improvement via swap, perform random perturbation\n    if np.array_equal(new_solution, base_solution):\n        # Randomly flip some items while maintaining feasibility\n        for _ in range(5):\n            flip_idx = random.randint(0, len(new_solution) - 1)\n            if new_solution[flip_idx] == 1:\n                if current_weight - weight_lst[flip_idx] <= capacity:\n                    new_solution[flip_idx] = 0\n                    current_weight -= weight_lst[flip_idx]\n            else:\n                if current_weight + weight_lst[flip_idx] <= capacity:\n                    new_solution[flip_idx] = 1\n                    current_weight += weight_lst[flip_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.48394654583474916,
            1.8701262176036835
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected = random.choice(archive_sorted[:max(1, len(archive_sorted) // 3)])\n    base_solution = selected[0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: swap items or perturb randomly\n    new_solution = base_solution.copy()\n\n    # First, try to swap items to improve both objectives\n    for _ in range(10):  # Limit attempts to avoid excessive computation\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) == 0 or len(out_items) == 0:\n            break\n\n        # Select random items to swap\n        i_in = random.choice(in_items)\n        i_out = random.choice(out_items)\n\n        # Check feasibility of swap\n        delta_weight = weight_lst[i_out] - weight_lst[i_in]\n        if current_weight + delta_weight <= capacity:\n            new_solution[i_in], new_solution[i_out] = new_solution[i_out], new_solution[i_in]\n            current_weight += delta_weight\n            break\n\n    # If no improvement via swap, perform random perturbation\n    if np.array_equal(new_solution, base_solution):\n        # Randomly flip some items while maintaining feasibility\n        for _ in range(5):\n            flip_idx = random.randint(0, len(new_solution) - 1)\n            if new_solution[flip_idx] == 1:\n                if current_weight - weight_lst[flip_idx] <= capacity:\n                    new_solution[flip_idx] = 0\n                    current_weight -= weight_lst[flip_idx]\n            else:\n                if current_weight + weight_lst[flip_idx] <= capacity:\n                    new_solution[flip_idx] = 1\n                    current_weight += weight_lst[flip_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 240,
        "algorithm": "{The algorithm intelligently selects a solution from the archive with high potential for improvement by evaluating the trade-off between the two objectives, then applies a hybrid local search operator that combines item swaps and weight-balanced flips to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    def potential_score(solution, objective):\n        # Higher score for solutions with high potential trade-off\n        return objective[0] * objective[1]  # Product of objectives as a proxy for trade-off\n\n    scored_solutions = [(potential_score(sol, obj), sol, obj) for sol, obj in archive]\n    scored_solutions.sort(reverse=True, key=lambda x: x[0])\n    selected = scored_solutions[0][1].copy()\n\n    # Hybrid local search operator\n    new_solution = selected.copy()\n    n_items = len(new_solution)\n\n    # Step 1: Randomly flip items with high marginal contribution\n    for _ in range(random.randint(1, 3)):\n        # Select items with high value-to-weight ratio\n        v1_ratio = value1_lst / weight_lst\n        v2_ratio = value2_lst / weight_lst\n        combined_ratio = v1_ratio + v2_ratio\n\n        # Prioritize items not in the solution\n        candidates = np.where(new_solution == 0)[0]\n        if len(candidates) > 0:\n            candidate_scores = combined_ratio[candidates]\n            best_candidate = candidates[np.argmax(candidate_scores)]\n            if weight_lst[best_candidate] <= capacity - np.sum(weight_lst[new_solution == 1]):\n                new_solution[best_candidate] = 1\n\n    # Step 2: Perform item swaps between included and excluded items\n    included = np.where(new_solution == 1)[0]\n    excluded = np.where(new_solution == 0)[0]\n\n    if len(included) > 0 and len(excluded) > 0:\n        # Select a swap pair that maintains feasibility\n        for _ in range(random.randint(1, 2)):\n            out_item = random.choice(included)\n            in_item = random.choice(excluded)\n\n            # Check if swap is feasible\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            delta = weight_lst[in_item] - weight_lst[out_item]\n\n            if current_weight + delta <= capacity:\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n\n    # Step 3: Randomly flip a small number of items to escape local optima\n    flip_indices = random.sample(range(n_items), min(2, n_items))\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if np.sum(weight_lst[new_solution == 1]) - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.3067245222761843,
            5.40446138381958
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    def potential_score(solution, objective):\n        # Higher score for solutions with high potential trade-off\n        return objective[0] * objective[1]  # Product of objectives as a proxy for trade-off\n\n    scored_solutions = [(potential_score(sol, obj), sol, obj) for sol, obj in archive]\n    scored_solutions.sort(reverse=True, key=lambda x: x[0])\n    selected = scored_solutions[0][1].copy()\n\n    # Hybrid local search operator\n    new_solution = selected.copy()\n    n_items = len(new_solution)\n\n    # Step 1: Randomly flip items with high marginal contribution\n    for _ in range(random.randint(1, 3)):\n        # Select items with high value-to-weight ratio\n        v1_ratio = value1_lst / weight_lst\n        v2_ratio = value2_lst / weight_lst\n        combined_ratio = v1_ratio + v2_ratio\n\n        # Prioritize items not in the solution\n        candidates = np.where(new_solution == 0)[0]\n        if len(candidates) > 0:\n            candidate_scores = combined_ratio[candidates]\n            best_candidate = candidates[np.argmax(candidate_scores)]\n            if weight_lst[best_candidate] <= capacity - np.sum(weight_lst[new_solution == 1]):\n                new_solution[best_candidate] = 1\n\n    # Step 2: Perform item swaps between included and excluded items\n    included = np.where(new_solution == 1)[0]\n    excluded = np.where(new_solution == 0)[0]\n\n    if len(included) > 0 and len(excluded) > 0:\n        # Select a swap pair that maintains feasibility\n        for _ in range(random.randint(1, 2)):\n            out_item = random.choice(included)\n            in_item = random.choice(excluded)\n\n            # Check if swap is feasible\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            delta = weight_lst[in_item] - weight_lst[out_item]\n\n            if current_weight + delta <= capacity:\n                new_solution[out_item] = 0\n                new_solution[in_item] = 1\n\n    # Step 3: Randomly flip a small number of items to escape local optima\n    flip_indices = random.sample(range(n_items), min(2, n_items))\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if np.sum(weight_lst[new_solution == 1]) - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 241,
        "algorithm": "{The heuristic function selects a solution from the archive with high potential for improvement by evaluating the trade-off between the two objectives, then applies a novel local search strategy that combines item swapping and probabilistic reinsertion to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.choices(range(len(archive)), weights=[1 / (1 + i) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: item swapping and probabilistic reinsertion\n    new_solution = base_solution.copy()\n    num_items = len(weight_lst)\n\n    # Step 1: Randomly swap items between included and excluded\n    for _ in range(min(3, num_items)):\n        included = np.where(new_solution == 1)[0]\n        excluded = np.where(new_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            i = random.choice(included)\n            j = random.choice(excluded)\n            new_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n            if new_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight = new_weight\n\n    # Step 2: Probabilistic reinsertion of high-value items\n    for _ in range(min(2, num_items)):\n        excluded = np.where(new_solution == 0)[0]\n        if len(excluded) == 0:\n            break\n\n        # Calculate normalized value scores\n        value_scores = (value1_lst[excluded] + value2_lst[excluded]) / (weight_lst[excluded] + 1e-6)\n        probs = value_scores / np.sum(value_scores)\n        j = random.choices(excluded, weights=probs)[0]\n\n        if current_weight + weight_lst[j] <= capacity:\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    return new_solution\n\n",
        "score": [
            -0.37172839223473386,
            8.739397436380386
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.choices(range(len(archive)), weights=[1 / (1 + i) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: item swapping and probabilistic reinsertion\n    new_solution = base_solution.copy()\n    num_items = len(weight_lst)\n\n    # Step 1: Randomly swap items between included and excluded\n    for _ in range(min(3, num_items)):\n        included = np.where(new_solution == 1)[0]\n        excluded = np.where(new_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            i = random.choice(included)\n            j = random.choice(excluded)\n            new_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n            if new_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight = new_weight\n\n    # Step 2: Probabilistic reinsertion of high-value items\n    for _ in range(min(2, num_items)):\n        excluded = np.where(new_solution == 0)[0]\n        if len(excluded) == 0:\n            break\n\n        # Calculate normalized value scores\n        value_scores = (value1_lst[excluded] + value2_lst[excluded]) / (weight_lst[excluded] + 1e-6)\n        probs = value_scores / np.sum(value_scores)\n        j = random.choices(excluded, weights=probs)[0]\n\n        if current_weight + weight_lst[j] <= capacity:\n            new_solution[j] = 1\n            current_weight += weight_lst[j]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 242,
        "algorithm": "{This algorithm selects a promising solution from the archive based on its potential for local improvement, then applies a hybrid local search operator that combines item swapping and random perturbation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: swap items with high potential and random perturbation\n    # Step 1: Identify items to swap (e.g., items with high value-to-weight ratio)\n    value_to_weight1 = value1_lst / weight_lst\n    value_to_weight2 = value2_lst / weight_lst\n\n    # Step 2: Randomly select a subset of items to consider for swapping\n    candidate_indices = np.where(new_solution == 1)[0]\n    if len(candidate_indices) > 0:\n        np.random.shuffle(candidate_indices)\n        swap_indices = candidate_indices[:min(3, len(candidate_indices))]  # Swap up to 3 items\n\n        for idx in swap_indices:\n            # Try to swap with an item not in the solution\n            not_in_solution = np.where(new_solution == 0)[0]\n            if len(not_in_solution) > 0:\n                swap_candidate = np.random.choice(not_in_solution)\n                new_weight = current_weight - weight_lst[idx] + weight_lst[swap_candidate]\n\n                if new_weight <= capacity:\n                    # Perform the swap\n                    new_solution[idx] = 0\n                    new_solution[swap_candidate] = 1\n                    current_weight = new_weight\n\n    # Step 3: Random perturbation to escape local optima\n    if np.random.rand() < 0.3:  # 30% chance of perturbation\n        perturbation_indices = np.random.choice(len(new_solution), size=min(2, len(new_solution)), replace=False)\n        for idx in perturbation_indices:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3851146482397462,
            4.136387974023819
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: swap items with high potential and random perturbation\n    # Step 1: Identify items to swap (e.g., items with high value-to-weight ratio)\n    value_to_weight1 = value1_lst / weight_lst\n    value_to_weight2 = value2_lst / weight_lst\n\n    # Step 2: Randomly select a subset of items to consider for swapping\n    candidate_indices = np.where(new_solution == 1)[0]\n    if len(candidate_indices) > 0:\n        np.random.shuffle(candidate_indices)\n        swap_indices = candidate_indices[:min(3, len(candidate_indices))]  # Swap up to 3 items\n\n        for idx in swap_indices:\n            # Try to swap with an item not in the solution\n            not_in_solution = np.where(new_solution == 0)[0]\n            if len(not_in_solution) > 0:\n                swap_candidate = np.random.choice(not_in_solution)\n                new_weight = current_weight - weight_lst[idx] + weight_lst[swap_candidate]\n\n                if new_weight <= capacity:\n                    # Perform the swap\n                    new_solution[idx] = 0\n                    new_solution[swap_candidate] = 1\n                    current_weight = new_weight\n\n    # Step 3: Random perturbation to escape local optima\n    if np.random.rand() < 0.3:  # 30% chance of perturbation\n        perturbation_indices = np.random.choice(len(new_solution), size=min(2, len(new_solution)), replace=False)\n        for idx in perturbation_indices:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 243,
        "algorithm": "{A novel hybrid local search algorithm that combines random item swaps with a guided diversification strategy to intelligently explore the solution space, prioritizing solutions with high potential for further improvement while ensuring feasibility through adaptive weight adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n\n    # Generate a neighbor solution using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly select a subset of items to flip (swap 0 and 1)\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Step 2: Check feasibility and adjust if necessary\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        while total_weight > capacity:\n            remove_idx = np.random.choice(np.where(new_solution == 1)[0])\n            new_solution[remove_idx] = 0\n            total_weight = np.sum(weight_lst * new_solution)\n\n    # Step 3: Guided diversification: add a random item if possible\n    if np.random.random() < 0.3:  # 30% chance to diversify\n        zero_indices = np.where(new_solution == 0)[0]\n        if len(zero_indices) > 0:\n            add_idx = np.random.choice(zero_indices)\n            if total_weight + weight_lst[add_idx] <= capacity:\n                new_solution[add_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.3524610850685774,
            3.961041748523712
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n\n    # Generate a neighbor solution using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly select a subset of items to flip (swap 0 and 1)\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Step 2: Check feasibility and adjust if necessary\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        while total_weight > capacity:\n            remove_idx = np.random.choice(np.where(new_solution == 1)[0])\n            new_solution[remove_idx] = 0\n            total_weight = np.sum(weight_lst * new_solution)\n\n    # Step 3: Guided diversification: add a random item if possible\n    if np.random.random() < 0.3:  # 30% chance to diversify\n        zero_indices = np.where(new_solution == 0)[0]\n        if len(zero_indices) > 0:\n            add_idx = np.random.choice(zero_indices)\n            if total_weight + weight_lst[add_idx] <= capacity:\n                new_solution[add_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 244,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive, identifies critical items via a hybrid local search strategy combining swap and reinsertion moves, and generates a neighbor solution by dynamically adjusting item selections while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the crowding distance for each solution in the archive\n    crowding_distances = []\n    objectives = [obj for (sol, obj) in archive]\n\n    # Sort objectives by each objective value\n    sorted_obj1 = sorted(objectives, key=lambda x: x[0])\n    sorted_obj2 = sorted(objectives, key=lambda x: x[1])\n\n    # Calculate crowding distance for each objective\n    for i in range(len(archive)):\n        obj1_dist = (sorted_obj1[(i+1)%len(archive)][0] - sorted_obj1[(i-1)%len(archive)][0]) / (max(sorted_obj1, key=lambda x: x[0])[0] - min(sorted_obj1, key=lambda x: x[0])[0] + 1e-10)\n        obj2_dist = (sorted_obj2[(i+1)%len(archive)][1] - sorted_obj2[(i-1)%len(archive)][1]) / (max(sorted_obj2, key=lambda x: x[1])[1] - min(sorted_obj2, key=lambda x: x[1])[1] + 1e-10)\n        crowding_distances.append(obj1_dist + obj2_dist)\n\n    # Select the solution with the highest crowding distance (promising for improvement)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Identify critical items (those that contribute significantly to both objectives)\n    included_items = np.where(new_solution == 1)[0]\n    excluded_items = np.where(new_solution == 0)[0]\n\n    if len(included_items) == 0 or len(excluded_items) == 0:\n        return new_solution\n\n    # Hybrid move: swap a critical included item with a promising excluded item\n    # Critical item: highest ratio of (value1 + value2) / weight\n    critical_included = included_items[np.argmax((value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items])]\n\n    # Promising excluded item: highest ratio of (value1 + value2) / weight within capacity constraint\n    feasible_excluded = [i for i in excluded_items if current_weight - weight_lst[critical_included] + weight_lst[i] <= capacity]\n    if feasible_excluded:\n        promising_excluded = feasible_excluded[np.argmax((value1_lst[feasible_excluded] + value2_lst[feasible_excluded]) / weight_lst[feasible_excluded])]\n        new_solution[critical_included] = 0\n        new_solution[promising_excluded] = 1\n\n    # If no feasible swap, try reinsertion of a random excluded item\n    else:\n        feasible_reinsert = [i for i in excluded_items if weight_lst[i] <= capacity - current_weight]\n        if feasible_reinsert:\n            reinsert_item = random.choice(feasible_reinsert)\n            new_solution[reinsert_item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.9466045574262304,
            6.848877668380737
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the crowding distance for each solution in the archive\n    crowding_distances = []\n    objectives = [obj for (sol, obj) in archive]\n\n    # Sort objectives by each objective value\n    sorted_obj1 = sorted(objectives, key=lambda x: x[0])\n    sorted_obj2 = sorted(objectives, key=lambda x: x[1])\n\n    # Calculate crowding distance for each objective\n    for i in range(len(archive)):\n        obj1_dist = (sorted_obj1[(i+1)%len(archive)][0] - sorted_obj1[(i-1)%len(archive)][0]) / (max(sorted_obj1, key=lambda x: x[0])[0] - min(sorted_obj1, key=lambda x: x[0])[0] + 1e-10)\n        obj2_dist = (sorted_obj2[(i+1)%len(archive)][1] - sorted_obj2[(i-1)%len(archive)][1]) / (max(sorted_obj2, key=lambda x: x[1])[1] - min(sorted_obj2, key=lambda x: x[1])[1] + 1e-10)\n        crowding_distances.append(obj1_dist + obj2_dist)\n\n    # Select the solution with the highest crowding distance (promising for improvement)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Identify critical items (those that contribute significantly to both objectives)\n    included_items = np.where(new_solution == 1)[0]\n    excluded_items = np.where(new_solution == 0)[0]\n\n    if len(included_items) == 0 or len(excluded_items) == 0:\n        return new_solution\n\n    # Hybrid move: swap a critical included item with a promising excluded item\n    # Critical item: highest ratio of (value1 + value2) / weight\n    critical_included = included_items[np.argmax((value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items])]\n\n    # Promising excluded item: highest ratio of (value1 + value2) / weight within capacity constraint\n    feasible_excluded = [i for i in excluded_items if current_weight - weight_lst[critical_included] + weight_lst[i] <= capacity]\n    if feasible_excluded:\n        promising_excluded = feasible_excluded[np.argmax((value1_lst[feasible_excluded] + value2_lst[feasible_excluded]) / weight_lst[feasible_excluded])]\n        new_solution[critical_included] = 0\n        new_solution[promising_excluded] = 1\n\n    # If no feasible swap, try reinsertion of a random excluded item\n    else:\n        feasible_reinsert = [i for i in excluded_items if weight_lst[i] <= capacity - current_weight]\n        if feasible_reinsert:\n            reinsert_item = random.choice(feasible_reinsert)\n            new_solution[reinsert_item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 245,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Identify items that could be flipped (added or removed) to improve both objectives\n    candidate_items = []\n    current_weight = np.sum(weight_lst * base_solution)\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if removing this item improves both objectives\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                candidate_items.append(i)\n        else:\n            # Check if adding this item improves both objectives\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                candidate_items.append(i)\n\n    if not candidate_items:\n        # Fallback to random selection if no candidates found\n        candidate_items = np.where(base_solution == 1)[0].tolist() + np.where(base_solution == 0)[0].tolist()\n\n    # Randomly select an item to flip\n    item_to_flip = np.random.choice(candidate_items)\n    new_solution = base_solution.copy()\n    new_solution[item_to_flip] = 1 - new_solution[item_to_flip]\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # If not feasible, try to remove items randomly until feasible\n        while total_weight > capacity:\n            remove_items = np.where(new_solution == 1)[0]\n            if len(remove_items) == 0:\n                break\n            item_to_remove = np.random.choice(remove_items)\n            new_solution[item_to_remove] = 0\n            total_weight = np.sum(weight_lst * new_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.9118909655866985,
            3.808208078145981
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Identify items that could be flipped (added or removed) to improve both objectives\n    candidate_items = []\n    current_weight = np.sum(weight_lst * base_solution)\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if removing this item improves both objectives\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                candidate_items.append(i)\n        else:\n            # Check if adding this item improves both objectives\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                candidate_items.append(i)\n\n    if not candidate_items:\n        # Fallback to random selection if no candidates found\n        candidate_items = np.where(base_solution == 1)[0].tolist() + np.where(base_solution == 0)[0].tolist()\n\n    # Randomly select an item to flip\n    item_to_flip = np.random.choice(candidate_items)\n    new_solution = base_solution.copy()\n    new_solution[item_to_flip] = 1 - new_solution[item_to_flip]\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # If not feasible, try to remove items randomly until feasible\n        while total_weight > capacity:\n            remove_items = np.where(new_solution == 1)[0]\n            if len(remove_items) == 0:\n                break\n            item_to_remove = np.random.choice(remove_items)\n            new_solution[item_to_remove] = 0\n            total_weight = np.sum(weight_lst * new_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 246,
        "algorithm": "{The heuristic function selects a promising solution from the archive by prioritizing those with high objective values and applies a novel hybrid local search operator that combines bit-flipping with a probabilistic greedy insertion step to generate feasible neighbor solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 3:\n        selected_indices = sorted(range(len(archive)), key=lambda i: (archive[i][1][0] + archive[i][1][1]), reverse=True)[:max(1, len(archive) // 3)]\n        selected_idx = random.choice(selected_indices)\n    else:\n        selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: bit-flipping with probabilistic greedy insertion\n    # Step 1: Randomly flip a few bits (1-3) to introduce diversity\n    num_flips = random.randint(1, min(3, len(new_solution)))\n    flip_indices = random.sample(range(len(new_solution)), num_flips)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Step 2: Check feasibility and repair if necessary\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items until feasible\n        excess_weight = current_weight - capacity\n        candidate_indices = np.where(new_solution == 1)[0]\n        np.random.shuffle(candidate_indices)\n        for idx in candidate_indices:\n            if excess_weight <= 0:\n                break\n            if weight_lst[idx] <= excess_weight:\n                new_solution[idx] = 0\n                excess_weight -= weight_lst[idx]\n\n    # Step 3: Probabilistic greedy insertion of items not in current solution\n    remaining_indices = np.where(new_solution == 0)[0]\n    if len(remaining_indices) > 0:\n        np.random.shuffle(remaining_indices)\n        for idx in remaining_indices:\n            if current_weight + weight_lst[idx] <= capacity:\n                # Probabilistic insertion based on normalized value\n                norm_value1 = value1_lst[idx] / np.max(value1_lst)\n                norm_value2 = value2_lst[idx] / np.max(value2_lst)\n                prob = 0.5 * (norm_value1 + norm_value2)\n                if random.random() < prob:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.30711958744657997,
            3.8989949226379395
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 3:\n        selected_indices = sorted(range(len(archive)), key=lambda i: (archive[i][1][0] + archive[i][1][1]), reverse=True)[:max(1, len(archive) // 3)]\n        selected_idx = random.choice(selected_indices)\n    else:\n        selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: bit-flipping with probabilistic greedy insertion\n    # Step 1: Randomly flip a few bits (1-3) to introduce diversity\n    num_flips = random.randint(1, min(3, len(new_solution)))\n    flip_indices = random.sample(range(len(new_solution)), num_flips)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Step 2: Check feasibility and repair if necessary\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items until feasible\n        excess_weight = current_weight - capacity\n        candidate_indices = np.where(new_solution == 1)[0]\n        np.random.shuffle(candidate_indices)\n        for idx in candidate_indices:\n            if excess_weight <= 0:\n                break\n            if weight_lst[idx] <= excess_weight:\n                new_solution[idx] = 0\n                excess_weight -= weight_lst[idx]\n\n    # Step 3: Probabilistic greedy insertion of items not in current solution\n    remaining_indices = np.where(new_solution == 0)[0]\n    if len(remaining_indices) > 0:\n        np.random.shuffle(remaining_indices)\n        for idx in remaining_indices:\n            if current_weight + weight_lst[idx] <= capacity:\n                # Probabilistic insertion based on normalized value\n                norm_value1 = value1_lst[idx] / np.max(value1_lst)\n                norm_value2 = value2_lst[idx] / np.max(value2_lst)\n                prob = 0.5 * (norm_value1 + norm_value2)\n                if random.random() < prob:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 247,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def score(solution, objective):\n        return objective[0] + objective[1]  # Simple sum as a proxy for combined potential\n\n    # Sort solutions by score in descending order\n    sorted_archive = sorted(archive, key=lambda x: score(x[0], x[1]), reverse=True)\n\n    # Select the top 10% of solutions for further consideration\n    top_k = max(1, len(sorted_archive) // 10)\n    candidates = sorted_archive[:top_k]\n\n    # Randomly select one candidate\n    selected_solution, _ = random.choice(candidates)\n    base_solution = selected_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contribution = (value1_lst + value2_lst) / weight_lst\n    sorted_indices = np.argsort(marginal_contribution)[::-1]  # Highest to lowest\n\n    # Flip top 10% of items with highest marginal contribution\n    k = max(1, len(sorted_indices) // 10)\n    flip_indices = sorted_indices[:k]\n\n    new_solution = base_solution.copy()\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]  # Flip the bit\n\n    # Ensure feasibility by removing items if weight exceeds capacity\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items with lowest marginal contribution until feasible\n        while total_weight > capacity:\n            for idx in sorted_indices:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    total_weight -= weight_lst[idx]\n                    if total_weight <= capacity:\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.8185597509067637,
            2.336212635040283
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def score(solution, objective):\n        return objective[0] + objective[1]  # Simple sum as a proxy for combined potential\n\n    # Sort solutions by score in descending order\n    sorted_archive = sorted(archive, key=lambda x: score(x[0], x[1]), reverse=True)\n\n    # Select the top 10% of solutions for further consideration\n    top_k = max(1, len(sorted_archive) // 10)\n    candidates = sorted_archive[:top_k]\n\n    # Randomly select one candidate\n    selected_solution, _ = random.choice(candidates)\n    base_solution = selected_solution.copy()\n\n    # Generate a neighbor by flipping a subset of items with high marginal contribution\n    marginal_contribution = (value1_lst + value2_lst) / weight_lst\n    sorted_indices = np.argsort(marginal_contribution)[::-1]  # Highest to lowest\n\n    # Flip top 10% of items with highest marginal contribution\n    k = max(1, len(sorted_indices) // 10)\n    flip_indices = sorted_indices[:k]\n\n    new_solution = base_solution.copy()\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]  # Flip the bit\n\n    # Ensure feasibility by removing items if weight exceeds capacity\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items with lowest marginal contribution until feasible\n        while total_weight > capacity:\n            for idx in sorted_indices:\n                if new_solution[idx] == 1:\n                    new_solution[idx] = 0\n                    total_weight -= weight_lst[idx]\n                    if total_weight <= capacity:\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 248,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_values = np.array([(obj[0] + obj[1]) / (np.sum(value1_lst) + np.sum(value2_lst)) for _, obj in archive])\n    selected_idx = np.argmax(normalized_values)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search strategy\n    # Strategy: Randomly flip a subset of items, then apply a greedy improvement step\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)  # Flip up to 3 items randomly\n    new_solution[flip_indices] = 1 - new_solution[flip_indices]\n\n    # Ensure feasibility by removing items if capacity is exceeded\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        excess_items = np.where(new_solution == 1)[0]\n        if len(excess_items) == 0:\n            break  # No items to remove, but solution is still infeasible (edge case)\n        remove_idx = np.random.choice(excess_items)\n        new_solution[remove_idx] = 0\n\n    # Greedy improvement: Add items that improve the most in either objective\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - current_weight\n    remaining_items = np.where(new_solution == 0)[0]\n\n    for item in remaining_items:\n        if weight_lst[item] <= remaining_capacity:\n            # Calculate potential improvement in both objectives\n            improvement1 = value1_lst[item]\n            improvement2 = value2_lst[item]\n            # Add item if it improves either objective\n            if improvement1 > 0 or improvement2 > 0:\n                new_solution[item] = 1\n                remaining_capacity -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.33642067461241365,
            6.366248279809952
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_values = np.array([(obj[0] + obj[1]) / (np.sum(value1_lst) + np.sum(value2_lst)) for _, obj in archive])\n    selected_idx = np.argmax(normalized_values)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search strategy\n    # Strategy: Randomly flip a subset of items, then apply a greedy improvement step\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)  # Flip up to 3 items randomly\n    new_solution[flip_indices] = 1 - new_solution[flip_indices]\n\n    # Ensure feasibility by removing items if capacity is exceeded\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        excess_items = np.where(new_solution == 1)[0]\n        if len(excess_items) == 0:\n            break  # No items to remove, but solution is still infeasible (edge case)\n        remove_idx = np.random.choice(excess_items)\n        new_solution[remove_idx] = 0\n\n    # Greedy improvement: Add items that improve the most in either objective\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - current_weight\n    remaining_items = np.where(new_solution == 0)[0]\n\n    for item in remaining_items:\n        if weight_lst[item] <= remaining_capacity:\n            # Calculate potential improvement in both objectives\n            improvement1 = value1_lst[item]\n            improvement2 = value2_lst[item]\n            # Add item if it improves either objective\n            if improvement1 > 0 or improvement2 > 0:\n                new_solution[item] = 1\n                remaining_capacity -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 249,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a promising solution from the archive, then applies a dynamic swap-and-replace strategy with adaptive neighborhood exploration to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution, base_obj = archive[selected_idx]\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = base_obj[0]\n    current_value2 = base_obj[1]\n\n    # Dynamic swap-and-replace strategy\n    for _ in range(10):  # Number of perturbation attempts\n        # Identify items to consider for swap/replace\n        zero_indices = np.where(new_solution == 0)[0]\n        one_indices = np.where(new_solution == 1)[0]\n\n        if len(zero_indices) == 0 or len(one_indices) == 0:\n            break\n\n        # Randomly select items for potential swap or replace\n        swap_candidate = np.random.choice(one_indices)\n        replace_candidate = np.random.choice(zero_indices)\n\n        # Calculate potential changes\n        swap_weight = weight_lst[swap_candidate]\n        replace_weight = weight_lst[replace_candidate]\n\n        # Check feasibility for swap\n        if current_weight - swap_weight + replace_weight <= capacity:\n            # Perform swap\n            new_solution[swap_candidate] = 0\n            new_solution[replace_candidate] = 1\n            current_weight = current_weight - swap_weight + replace_weight\n            current_value1 = current_value1 - value1_lst[swap_candidate] + value1_lst[replace_candidate]\n            current_value2 = current_value2 - value2_lst[swap_candidate] + value2_lst[replace_candidate]\n\n        # Adaptive neighborhood exploration\n        if np.random.random() < 0.3:  # 30% chance to try additional swaps\n            second_swap = np.random.choice(one_indices)\n            if second_swap != swap_candidate and current_weight - weight_lst[second_swap] <= capacity:\n                new_solution[second_swap] = 0\n                current_weight -= weight_lst[second_swap]\n                current_value1 -= value1_lst[second_swap]\n                current_value2 -= value2_lst[second_swap]\n\n    return new_solution\n\n",
        "score": [
            -0.4184707893785513,
            11.144274413585663
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution, base_obj = archive[selected_idx]\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = base_obj[0]\n    current_value2 = base_obj[1]\n\n    # Dynamic swap-and-replace strategy\n    for _ in range(10):  # Number of perturbation attempts\n        # Identify items to consider for swap/replace\n        zero_indices = np.where(new_solution == 0)[0]\n        one_indices = np.where(new_solution == 1)[0]\n\n        if len(zero_indices) == 0 or len(one_indices) == 0:\n            break\n\n        # Randomly select items for potential swap or replace\n        swap_candidate = np.random.choice(one_indices)\n        replace_candidate = np.random.choice(zero_indices)\n\n        # Calculate potential changes\n        swap_weight = weight_lst[swap_candidate]\n        replace_weight = weight_lst[replace_candidate]\n\n        # Check feasibility for swap\n        if current_weight - swap_weight + replace_weight <= capacity:\n            # Perform swap\n            new_solution[swap_candidate] = 0\n            new_solution[replace_candidate] = 1\n            current_weight = current_weight - swap_weight + replace_weight\n            current_value1 = current_value1 - value1_lst[swap_candidate] + value1_lst[replace_candidate]\n            current_value2 = current_value2 - value2_lst[swap_candidate] + value2_lst[replace_candidate]\n\n        # Adaptive neighborhood exploration\n        if np.random.random() < 0.3:  # 30% chance to try additional swaps\n            second_swap = np.random.choice(one_indices)\n            if second_swap != swap_candidate and current_weight - weight_lst[second_swap] <= capacity:\n                new_solution[second_swap] = 0\n                current_weight -= weight_lst[second_swap]\n                current_value1 -= value1_lst[second_swap]\n                current_value2 -= value2_lst[second_swap]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 250,
        "algorithm": "{This heuristic selects a promising solution from the archive by prioritizing those with high diversity and marginal improvement potential, then applies a hybrid local search combining random swaps and targeted flips to explore high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Step 1: Select a promising solution (prioritize high diversity and marginal improvement potential)\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution, selected_obj = archive[selected_idx]\n    current_weight = np.sum(weight_lst[selected_solution == 1])\n\n    # Step 2: Hybrid local search (random swaps + targeted flips)\n    new_solution = selected_solution.copy()\n\n    # Random swaps (exploration)\n    for _ in range(min(3, len(weight_lst) // 2)):\n        i, j = random.sample(range(len(weight_lst)), 2)\n        if new_solution[i] != new_solution[j]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Targeted flips (exploitation)\n    for _ in range(min(5, len(weight_lst))):\n        # Identify items with high marginal value-to-weight ratio\n        marginal1 = value1_lst / (weight_lst + 1e-6)\n        marginal2 = value2_lst / (weight_lst + 1e-6)\n        marginal = marginal1 + marginal2\n\n        # Prioritize flipping items based on marginal value\n        candidate_items = np.where(new_solution == 0)[0]\n        if len(candidate_items) > 0:\n            item = candidate_items[np.argmax(marginal[candidate_items])]\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        # Remove items with lowest marginal value\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) == 0:\n            break\n        item_to_remove = included_items[np.argmin(value1_lst[included_items] + value2_lst[included_items])]\n        new_solution[item_to_remove] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.3746053285620128,
            9.865058362483978
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Step 1: Select a promising solution (prioritize high diversity and marginal improvement potential)\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution, selected_obj = archive[selected_idx]\n    current_weight = np.sum(weight_lst[selected_solution == 1])\n\n    # Step 2: Hybrid local search (random swaps + targeted flips)\n    new_solution = selected_solution.copy()\n\n    # Random swaps (exploration)\n    for _ in range(min(3, len(weight_lst) // 2)):\n        i, j = random.sample(range(len(weight_lst)), 2)\n        if new_solution[i] != new_solution[j]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Targeted flips (exploitation)\n    for _ in range(min(5, len(weight_lst))):\n        # Identify items with high marginal value-to-weight ratio\n        marginal1 = value1_lst / (weight_lst + 1e-6)\n        marginal2 = value2_lst / (weight_lst + 1e-6)\n        marginal = marginal1 + marginal2\n\n        # Prioritize flipping items based on marginal value\n        candidate_items = np.where(new_solution == 0)[0]\n        if len(candidate_items) > 0:\n            item = candidate_items[np.argmax(marginal[candidate_items])]\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        # Remove items with lowest marginal value\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) == 0:\n            break\n        item_to_remove = included_items[np.argmin(value1_lst[included_items] + value2_lst[included_items])]\n        new_solution[item_to_remove] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 251,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines dynamic item swapping and probabilistic flipping to explore the neighborhood while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = [sol for sol, _ in archive if np.sum(weight_lst * sol) < capacity * 0.95]\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: dynamic item swapping and probabilistic flipping\n    current_weight = np.sum(weight_lst * base_solution)\n    available_weight = capacity - current_weight\n\n    # Step 1: Dynamic item swapping (swap items with high marginal contribution)\n    swap_candidates = np.where(base_solution == 1)[0]\n    for i in swap_candidates:\n        if random.random() < 0.3:  # 30% chance to consider swapping\n            # Find items not in solution with weight <= available_weight + weight_lst[i]\n            possible_swaps = np.where((base_solution == 0) & (weight_lst <= available_weight + weight_lst[i]))[0]\n            if len(possible_swaps) > 0:\n                j = random.choice(possible_swaps)\n                if (value1_lst[i] + value2_lst[i] < value1_lst[j] + value2_lst[j]) and \\\n                   (current_weight - weight_lst[i] + weight_lst[j] <= capacity):\n                    new_solution[i], new_solution[j] = 0, 1\n                    current_weight = current_weight - weight_lst[i] + weight_lst[j]\n                    available_weight = capacity - current_weight\n\n    # Step 2: Probabilistic flipping (add/remove items with high marginal contribution)\n    for i in range(len(base_solution)):\n        if base_solution[i] == 0 and random.random() < 0.1:  # 10% chance to add\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n        elif base_solution[i] == 1 and random.random() < 0.05:  # 5% chance to remove\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.3727094162438895,
            8.54955467581749
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = [sol for sol, _ in archive if np.sum(weight_lst * sol) < capacity * 0.95]\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: dynamic item swapping and probabilistic flipping\n    current_weight = np.sum(weight_lst * base_solution)\n    available_weight = capacity - current_weight\n\n    # Step 1: Dynamic item swapping (swap items with high marginal contribution)\n    swap_candidates = np.where(base_solution == 1)[0]\n    for i in swap_candidates:\n        if random.random() < 0.3:  # 30% chance to consider swapping\n            # Find items not in solution with weight <= available_weight + weight_lst[i]\n            possible_swaps = np.where((base_solution == 0) & (weight_lst <= available_weight + weight_lst[i]))[0]\n            if len(possible_swaps) > 0:\n                j = random.choice(possible_swaps)\n                if (value1_lst[i] + value2_lst[i] < value1_lst[j] + value2_lst[j]) and \\\n                   (current_weight - weight_lst[i] + weight_lst[j] <= capacity):\n                    new_solution[i], new_solution[j] = 0, 1\n                    current_weight = current_weight - weight_lst[i] + weight_lst[j]\n                    available_weight = capacity - current_weight\n\n    # Step 2: Probabilistic flipping (add/remove items with high marginal contribution)\n    for i in range(len(base_solution)):\n        if base_solution[i] == 0 and random.random() < 0.1:  # 10% chance to add\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n        elif base_solution[i] == 1 and random.random() < 0.05:  # 5% chance to remove\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 252,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high potential for local improvement, then applies a hybrid local search that combines item swaps and probabilistic flips to explore non-dominated regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Prioritize solutions with high potential for improvement\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution = archive[0][0].copy()\n    current_weight = np.sum(weight_lst[selected_solution == 1])\n\n    # Generate a neighbor using hybrid local search\n    new_solution = selected_solution.copy()\n    items = np.where(new_solution == 1)[0]\n    non_items = np.where(new_solution == 0)[0]\n\n    # Step 1: Randomly flip items with high marginal benefit\n    if len(items) > 0:\n        for _ in range(min(2, len(items))):\n            idx = random.choice(items)\n            if current_weight - weight_lst[idx] + weight_lst[random.choice(non_items)] <= capacity:\n                new_solution[idx] = 0\n                new_solution[random.choice(non_items)] = 1\n\n    # Step 2: Add items with high marginal benefit if capacity allows\n    for idx in non_items:\n        if current_weight + weight_lst[idx] <= capacity:\n            if random.random() < 0.3:  # Probabilistic addition\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.5902360950160263,
            2.966909348964691
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Prioritize solutions with high potential for improvement\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution = archive[0][0].copy()\n    current_weight = np.sum(weight_lst[selected_solution == 1])\n\n    # Generate a neighbor using hybrid local search\n    new_solution = selected_solution.copy()\n    items = np.where(new_solution == 1)[0]\n    non_items = np.where(new_solution == 0)[0]\n\n    # Step 1: Randomly flip items with high marginal benefit\n    if len(items) > 0:\n        for _ in range(min(2, len(items))):\n            idx = random.choice(items)\n            if current_weight - weight_lst[idx] + weight_lst[random.choice(non_items)] <= capacity:\n                new_solution[idx] = 0\n                new_solution[random.choice(non_items)] = 1\n\n    # Step 2: Add items with high marginal benefit if capacity allows\n    for idx in non_items:\n        if current_weight + weight_lst[idx] <= capacity:\n            if random.random() < 0.3:  # Probabilistic addition\n                new_solution[idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 253,
        "algorithm": "{The heuristic selects a promising solution from the archive based on a combination of objective values and solution diversity, then applies a hybrid local search operator that combines item swaps and random flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate selection probabilities based on normalized objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.sum(normalized_obj, axis=1)\n    weights = weights / np.sum(weights) if np.sum(weights) > 0 else np.ones(len(weights)) / len(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    items = np.where(new_solution == 1)[0]\n    non_items = np.where(new_solution == 0)[0]\n\n    # Apply swap-based local search\n    if len(items) > 0 and len(non_items) > 0:\n        # Randomly select items to swap\n        swap_item = random.choice(items)\n        swap_candidate = random.choice(non_items)\n\n        # Check feasibility of swap\n        current_weight = np.sum(weight_lst[items])\n        swap_weight_diff = weight_lst[swap_candidate] - weight_lst[swap_item]\n        if current_weight + swap_weight_diff <= capacity:\n            new_solution[swap_item] = 0\n            new_solution[swap_candidate] = 1\n\n    # Apply random flip-based local search\n    if random.random() < 0.3:  # 30% chance to flip\n        flip_item = random.choice(np.arange(len(new_solution)))\n        if new_solution[flip_item] == 1:\n            if np.sum(weight_lst[new_solution == 1]) - weight_lst[flip_item] <= capacity:\n                new_solution[flip_item] = 0\n        else:\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[flip_item] <= capacity:\n                new_solution[flip_item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.3563763639514588,
            5.122778087854385
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate selection probabilities based on normalized objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.sum(normalized_obj, axis=1)\n    weights = weights / np.sum(weights) if np.sum(weights) > 0 else np.ones(len(weights)) / len(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    items = np.where(new_solution == 1)[0]\n    non_items = np.where(new_solution == 0)[0]\n\n    # Apply swap-based local search\n    if len(items) > 0 and len(non_items) > 0:\n        # Randomly select items to swap\n        swap_item = random.choice(items)\n        swap_candidate = random.choice(non_items)\n\n        # Check feasibility of swap\n        current_weight = np.sum(weight_lst[items])\n        swap_weight_diff = weight_lst[swap_candidate] - weight_lst[swap_item]\n        if current_weight + swap_weight_diff <= capacity:\n            new_solution[swap_item] = 0\n            new_solution[swap_candidate] = 1\n\n    # Apply random flip-based local search\n    if random.random() < 0.3:  # 30% chance to flip\n        flip_item = random.choice(np.arange(len(new_solution)))\n        if new_solution[flip_item] == 1:\n            if np.sum(weight_lst[new_solution == 1]) - weight_lst[flip_item] <= capacity:\n                new_solution[flip_item] = 0\n        else:\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[flip_item] <= capacity:\n                new_solution[flip_item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 254,
        "algorithm": "{This algorithm intelligently selects a promising solution from the archive by prioritizing those with high objective values and low weight ratios, then applies a hybrid local search combining item swapping and probabilistic flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate a score for each solution in the archive (combination of objective values and weight ratio)\n    scores = []\n    for sol, (v1, v2) in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight > capacity:\n            continue  # Skip infeasible solutions\n        score = (v1 + v2) / (1 + total_weight / capacity)  # Higher score is better\n        scores.append(score)\n\n    if not scores:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: item swapping and probabilistic flipping\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Randomly select a subset of items to consider for swapping\n    indices = np.where(new_solution == 1)[0]\n    if len(indices) > 0:\n        # Swap one item in the solution with one item out\n        swap_in = np.where(new_solution == 0)[0]\n        if len(swap_in) > 0:\n            i = random.choice(indices)\n            j = random.choice(swap_in)\n            if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Probabilistic flipping: flip items with a probability based on their value-to-weight ratio\n    for i in range(n_items):\n        if new_solution[i] == 1:\n            if random.random() < 0.3:  # 30% chance to remove\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n        else:\n            # Calculate value-to-weight ratio for the item\n            v1_ratio = value1_lst[i] / weight_lst[i] if weight_lst[i] > 0 else 0\n            v2_ratio = value2_lst[i] / weight_lst[i] if weight_lst[i] > 0 else 0\n            flip_prob = 0.1 * (v1_ratio + v2_ratio)  # Higher ratio increases chance of inclusion\n            if random.random() < flip_prob and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.9039715874937024,
            6.780169874429703
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate a score for each solution in the archive (combination of objective values and weight ratio)\n    scores = []\n    for sol, (v1, v2) in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight > capacity:\n            continue  # Skip infeasible solutions\n        score = (v1 + v2) / (1 + total_weight / capacity)  # Higher score is better\n        scores.append(score)\n\n    if not scores:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: item swapping and probabilistic flipping\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Randomly select a subset of items to consider for swapping\n    indices = np.where(new_solution == 1)[0]\n    if len(indices) > 0:\n        # Swap one item in the solution with one item out\n        swap_in = np.where(new_solution == 0)[0]\n        if len(swap_in) > 0:\n            i = random.choice(indices)\n            j = random.choice(swap_in)\n            if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Probabilistic flipping: flip items with a probability based on their value-to-weight ratio\n    for i in range(n_items):\n        if new_solution[i] == 1:\n            if random.random() < 0.3:  # 30% chance to remove\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n        else:\n            # Calculate value-to-weight ratio for the item\n            v1_ratio = value1_lst[i] / weight_lst[i] if weight_lst[i] > 0 else 0\n            v2_ratio = value2_lst[i] / weight_lst[i] if weight_lst[i] > 0 else 0\n            flip_prob = 0.1 * (v1_ratio + v2_ratio)  # Higher ratio increases chance of inclusion\n            if random.random() < flip_prob and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 255,
        "algorithm": "{This algorithm selects a promising solution from the archive by prioritizing those with the highest combined objective values, then applies a hybrid local search combining item swapping and probabilistic bit flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: item swapping and probabilistic bit flipping\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Item swapping (swap two items if feasible)\n    for _ in range(5):  # Try 5 random swaps\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] != new_solution[j]:\n            if new_solution[i] == 1 and new_solution[j] == 0:\n                if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    current_weight = current_weight - weight_lst[i] + weight_lst[j]\n            elif new_solution[i] == 0 and new_solution[j] == 1:\n                if current_weight + weight_lst[i] - weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    current_weight = current_weight + weight_lst[i] - weight_lst[j]\n\n    # Step 2: Probabilistic bit flipping (flip bits based on value-to-weight ratio)\n    for i in range(n_items):\n        if random.random() < 0.3:  # 30% chance to consider flipping\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:  # Ensure feasibility\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    # Select the item with highest combined value-to-weight ratio\n                    if (value1_lst[i] / weight_lst[i] + value2_lst[i] / weight_lst[i]) > 0.5:\n                        new_solution[i] = 1\n                        current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.35212779203656874,
            2.8983799815177917
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: item swapping and probabilistic bit flipping\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Item swapping (swap two items if feasible)\n    for _ in range(5):  # Try 5 random swaps\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] != new_solution[j]:\n            if new_solution[i] == 1 and new_solution[j] == 0:\n                if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    current_weight = current_weight - weight_lst[i] + weight_lst[j]\n            elif new_solution[i] == 0 and new_solution[j] == 1:\n                if current_weight + weight_lst[i] - weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    current_weight = current_weight + weight_lst[i] - weight_lst[j]\n\n    # Step 2: Probabilistic bit flipping (flip bits based on value-to-weight ratio)\n    for i in range(n_items):\n        if random.random() < 0.3:  # 30% chance to consider flipping\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:  # Ensure feasibility\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    # Select the item with highest combined value-to-weight ratio\n                    if (value1_lst[i] / weight_lst[i] + value2_lst[i] / weight_lst[i]) > 0.5:\n                        new_solution[i] = 1\n                        current_weight += weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 256,
        "algorithm": "{A novel hybrid local search algorithm that intelligently combines random swaps, guided by objective diversity and weight constraints, to explore high-quality neighbors by flipping items with high marginal utility and feasibility checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution from the archive (intelligent random selection)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Compute marginal utilities for each item\n    marginal_value1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal_value2 = value2_lst / (weight_lst + 1e-6)\n\n    # Combine marginal utilities to prioritize items that improve both objectives\n    combined_utility = marginal_value1 + marginal_value2\n\n    # Sort items by combined utility in descending order\n    sorted_items = np.argsort(-combined_utility)\n\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Perform a hybrid local search: flip top-k items with highest marginal utility\n    k = min(5, len(sorted_items))  # Number of items to consider flipping\n    for item in sorted_items[:k]:\n        if base_solution[item] == 1:\n            # Try removing the item\n            new_weight = total_weight - weight_lst[item]\n            if new_weight <= capacity:\n                new_solution[item] = 0\n                total_weight = new_weight\n        else:\n            # Try adding the item\n            new_weight = total_weight + weight_lst[item]\n            if new_weight <= capacity:\n                new_solution[item] = 1\n                total_weight = new_weight\n\n    # If no changes, perform a random flip to escape local optima\n    if np.array_equal(new_solution, base_solution):\n        feasible_items = []\n        for i in range(len(base_solution)):\n            if base_solution[i] == 1:\n                if total_weight - weight_lst[i] <= capacity:\n                    feasible_items.append(i)\n            else:\n                if total_weight + weight_lst[i] <= capacity:\n                    feasible_items.append(i)\n        if feasible_items:\n            flip_item = random.choice(feasible_items)\n            new_solution[flip_item] = 1 - new_solution[flip_item]\n\n    return new_solution\n\n",
        "score": [
            -0.9233340930314784,
            1.7819720804691315
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution from the archive (intelligent random selection)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Compute marginal utilities for each item\n    marginal_value1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal_value2 = value2_lst / (weight_lst + 1e-6)\n\n    # Combine marginal utilities to prioritize items that improve both objectives\n    combined_utility = marginal_value1 + marginal_value2\n\n    # Sort items by combined utility in descending order\n    sorted_items = np.argsort(-combined_utility)\n\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Perform a hybrid local search: flip top-k items with highest marginal utility\n    k = min(5, len(sorted_items))  # Number of items to consider flipping\n    for item in sorted_items[:k]:\n        if base_solution[item] == 1:\n            # Try removing the item\n            new_weight = total_weight - weight_lst[item]\n            if new_weight <= capacity:\n                new_solution[item] = 0\n                total_weight = new_weight\n        else:\n            # Try adding the item\n            new_weight = total_weight + weight_lst[item]\n            if new_weight <= capacity:\n                new_solution[item] = 1\n                total_weight = new_weight\n\n    # If no changes, perform a random flip to escape local optima\n    if np.array_equal(new_solution, base_solution):\n        feasible_items = []\n        for i in range(len(base_solution)):\n            if base_solution[i] == 1:\n                if total_weight - weight_lst[i] <= capacity:\n                    feasible_items.append(i)\n            else:\n                if total_weight + weight_lst[i] <= capacity:\n                    feasible_items.append(i)\n        if feasible_items:\n            flip_item = random.choice(feasible_items)\n            new_solution[flip_item] = 1 - new_solution[flip_item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 257,
        "algorithm": "{The heuristic function selects a promising solution from the archive by prioritizing those with high objective values and low crowding distance, then applies a novel hybrid local search that combines item swapping with value-based neighborhood exploration to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution based on high objective values and low crowding distance\n    def crowding_distance(obj1, obj2):\n        return abs(obj1[0] - obj2[0]) + abs(obj1[1] - obj2[1])\n\n    best_solution = None\n    max_score = -float('inf')\n\n    for sol, obj in archive:\n        score = obj[0] + obj[1]  # Simple score based on sum of objectives\n        for other_sol, other_obj in archive:\n            if sol is not other_sol:\n                score -= crowding_distance(obj, other_obj)\n        if score > max_score:\n            max_score = score\n            best_solution = sol\n\n    if best_solution is None:\n        best_solution = archive[0][0]\n\n    # Hybrid local search: swap items with high value ratios\n    new_solution = best_solution.copy()\n    n_items = len(weight_lst)\n    value_ratio = (value1_lst + value2_lst) / weight_lst\n\n    # Step 1: Randomly select a subset of items to consider for swapping\n    swap_candidates = random.sample(range(n_items), min(5, n_items))\n\n    for i in swap_candidates:\n        if new_solution[i] == 1:\n            # Try removing item i\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            if np.dot(temp_solution, weight_lst) <= capacity:\n                new_solution = temp_solution\n                break\n        else:\n            # Try adding item i\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 1\n            if np.dot(temp_solution, weight_lst) <= capacity:\n                new_solution = temp_solution\n                break\n\n    # Step 2: Value-based neighborhood exploration\n    # Sort items by value ratio in descending order\n    sorted_items = np.argsort(-value_ratio)\n\n    for i in sorted_items:\n        if new_solution[i] == 0:\n            # Try adding item i if it fits\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 1\n            if np.dot(temp_solution, weight_lst) <= capacity:\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.8238601390071871,
            7.791850566864014
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution based on high objective values and low crowding distance\n    def crowding_distance(obj1, obj2):\n        return abs(obj1[0] - obj2[0]) + abs(obj1[1] - obj2[1])\n\n    best_solution = None\n    max_score = -float('inf')\n\n    for sol, obj in archive:\n        score = obj[0] + obj[1]  # Simple score based on sum of objectives\n        for other_sol, other_obj in archive:\n            if sol is not other_sol:\n                score -= crowding_distance(obj, other_obj)\n        if score > max_score:\n            max_score = score\n            best_solution = sol\n\n    if best_solution is None:\n        best_solution = archive[0][0]\n\n    # Hybrid local search: swap items with high value ratios\n    new_solution = best_solution.copy()\n    n_items = len(weight_lst)\n    value_ratio = (value1_lst + value2_lst) / weight_lst\n\n    # Step 1: Randomly select a subset of items to consider for swapping\n    swap_candidates = random.sample(range(n_items), min(5, n_items))\n\n    for i in swap_candidates:\n        if new_solution[i] == 1:\n            # Try removing item i\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            if np.dot(temp_solution, weight_lst) <= capacity:\n                new_solution = temp_solution\n                break\n        else:\n            # Try adding item i\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 1\n            if np.dot(temp_solution, weight_lst) <= capacity:\n                new_solution = temp_solution\n                break\n\n    # Step 2: Value-based neighborhood exploration\n    # Sort items by value ratio in descending order\n    sorted_items = np.argsort(-value_ratio)\n\n    for i in sorted_items:\n        if new_solution[i] == 0:\n            # Try adding item i if it fits\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 1\n            if np.dot(temp_solution, weight_lst) <= capacity:\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 258,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search combining random item swaps and value-based flips to generate a feasible neighbor solution while maximizing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[obj[0] + obj[1] for _, obj in archive], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps + value-based flips\n    n_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Random swap of two items (if feasible)\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if base_solution[i] != base_solution[j]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            new_weight = np.sum(weight_lst[new_solution == 1])\n            if new_weight > capacity:\n                # Revert if infeasible\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                return new_solution\n\n    # Value-based flip: flip items with high value-to-weight ratio\n    value_ratio1 = value1_lst / weight_lst\n    value_ratio2 = value2_lst / weight_lst\n    combined_ratio = value_ratio1 + value_ratio2\n\n    # Sort items by combined value ratio (descending)\n    sorted_indices = np.argsort(-combined_ratio)\n\n    for idx in sorted_indices:\n        if base_solution[idx] == 1:\n            # Try removing the item\n            temp_solution = new_solution.copy()\n            temp_solution[idx] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                return new_solution\n        else:\n            # Try adding the item\n            temp_solution = new_solution.copy()\n            temp_solution[idx] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                return new_solution\n\n    return new_solution\n\n",
        "score": [
            -0.4395369995845131,
            3.7943505346775055
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[obj[0] + obj[1] for _, obj in archive], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps + value-based flips\n    n_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Random swap of two items (if feasible)\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        if base_solution[i] != base_solution[j]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            new_weight = np.sum(weight_lst[new_solution == 1])\n            if new_weight > capacity:\n                # Revert if infeasible\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                return new_solution\n\n    # Value-based flip: flip items with high value-to-weight ratio\n    value_ratio1 = value1_lst / weight_lst\n    value_ratio2 = value2_lst / weight_lst\n    combined_ratio = value_ratio1 + value_ratio2\n\n    # Sort items by combined value ratio (descending)\n    sorted_indices = np.argsort(-combined_ratio)\n\n    for idx in sorted_indices:\n        if base_solution[idx] == 1:\n            # Try removing the item\n            temp_solution = new_solution.copy()\n            temp_solution[idx] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                return new_solution\n        else:\n            # Try adding the item\n            temp_solution = new_solution.copy()\n            temp_solution[idx] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                return new_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 259,
        "algorithm": "{A novel hybrid local search strategy combines a guided item swap with a probabilistic neighborhood exploration, leveraging objective-specific dominance criteria to intelligently select and perturb solutions while ensuring feasibility through adaptive weight adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, base_obj = max(archive, key=lambda x: sum(x[0]) / len(x[0]))  # Prefer more diverse solutions\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    total_weight = np.sum(new_solution * weight_lst)\n\n    # Identify items that can be toggled without violating capacity\n    candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            if total_weight - weight_lst[i] + weight_lst[(i+1) % len(new_solution)] <= capacity:\n                candidates.append(i)\n        else:\n            if total_weight + weight_lst[i] <= capacity:\n                candidates.append(i)\n\n    if not candidates:\n        return new_solution  # No feasible moves\n\n    # Select a random candidate with preference for objective improvement\n    selected = random.choice(candidates)\n\n    # Hybrid local search: flip the selected item and consider swapping with another\n    new_solution[selected] = 1 - new_solution[selected]\n\n    # Additional probabilistic swap to explore neighborhood\n    if random.random() < 0.3:  # 30% chance to perform swap\n        swap_candidate = random.choice([i for i in range(len(new_solution)) if i != selected])\n        if new_solution[swap_candidate] == 1 - new_solution[selected]:\n            new_solution[selected], new_solution[swap_candidate] = new_solution[swap_candidate], new_solution[selected]\n\n    # Ensure feasibility\n    total_weight = np.sum(new_solution * weight_lst)\n    if total_weight > capacity:\n        # Remove random items until feasible\n        excess = total_weight - capacity\n        while excess > 0:\n            items_in = np.where(new_solution == 1)[0]\n            if len(items_in) == 0:\n                break\n            remove_idx = random.choice(items_in)\n            new_solution[remove_idx] = 0\n            excess -= weight_lst[remove_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.860909603415279,
            10.754533767700195
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, base_obj = max(archive, key=lambda x: sum(x[0]) / len(x[0]))  # Prefer more diverse solutions\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    total_weight = np.sum(new_solution * weight_lst)\n\n    # Identify items that can be toggled without violating capacity\n    candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            if total_weight - weight_lst[i] + weight_lst[(i+1) % len(new_solution)] <= capacity:\n                candidates.append(i)\n        else:\n            if total_weight + weight_lst[i] <= capacity:\n                candidates.append(i)\n\n    if not candidates:\n        return new_solution  # No feasible moves\n\n    # Select a random candidate with preference for objective improvement\n    selected = random.choice(candidates)\n\n    # Hybrid local search: flip the selected item and consider swapping with another\n    new_solution[selected] = 1 - new_solution[selected]\n\n    # Additional probabilistic swap to explore neighborhood\n    if random.random() < 0.3:  # 30% chance to perform swap\n        swap_candidate = random.choice([i for i in range(len(new_solution)) if i != selected])\n        if new_solution[swap_candidate] == 1 - new_solution[selected]:\n            new_solution[selected], new_solution[swap_candidate] = new_solution[swap_candidate], new_solution[selected]\n\n    # Ensure feasibility\n    total_weight = np.sum(new_solution * weight_lst)\n    if total_weight > capacity:\n        # Remove random items until feasible\n        excess = total_weight - capacity\n        while excess > 0:\n            items_in = np.where(new_solution == 1)[0]\n            if len(items_in) == 0:\n                break\n            remove_idx = random.choice(items_in)\n            new_solution[remove_idx] = 0\n            excess -= weight_lst[remove_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 260,
        "algorithm": "{This algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a hybrid local search that combines item swaps and probabilistic flips to generate a feasible neighbor solution while balancing exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (e.g., based on dominance and diversity)\n    improvement_scores = []\n    for i, (sol, obj) in enumerate(archive):\n        # Score based on dominance and how close it is to the Pareto front\n        score = obj[0] + obj[1]  # Simple combined score for selection\n        improvement_scores.append(score)\n\n    # Select top 20% of solutions\n    top_indices = np.argsort(improvement_scores)[-max(1, len(archive) // 5):]\n    selected_idx = random.choice(top_indices)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Step 1: Try to swap items between included and excluded\n    included_items = np.where(base_solution == 1)[0]\n    excluded_items = np.where(base_solution == 0)[0]\n\n    if len(included_items) > 0 and len(excluded_items) > 0:\n        # Randomly select items to swap\n        swap_in = random.choice(included_items)\n        swap_out = random.choice(excluded_items)\n\n        # Check if swapping is feasible\n        delta_weight = weight_lst[swap_out] - weight_lst[swap_in]\n        if current_weight + delta_weight <= capacity:\n            new_solution[swap_in] = 0\n            new_solution[swap_out] = 1\n            current_weight += delta_weight\n\n    # Step 2: Probabilistic flip of items to explore more\n    for i in range(len(new_solution)):\n        if random.random() < 0.1:  # 10% chance to flip\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.4397273139766057,
            3.5707362592220306
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (e.g., based on dominance and diversity)\n    improvement_scores = []\n    for i, (sol, obj) in enumerate(archive):\n        # Score based on dominance and how close it is to the Pareto front\n        score = obj[0] + obj[1]  # Simple combined score for selection\n        improvement_scores.append(score)\n\n    # Select top 20% of solutions\n    top_indices = np.argsort(improvement_scores)[-max(1, len(archive) // 5):]\n    selected_idx = random.choice(top_indices)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Step 1: Try to swap items between included and excluded\n    included_items = np.where(base_solution == 1)[0]\n    excluded_items = np.where(base_solution == 0)[0]\n\n    if len(included_items) > 0 and len(excluded_items) > 0:\n        # Randomly select items to swap\n        swap_in = random.choice(included_items)\n        swap_out = random.choice(excluded_items)\n\n        # Check if swapping is feasible\n        delta_weight = weight_lst[swap_out] - weight_lst[swap_in]\n        if current_weight + delta_weight <= capacity:\n            new_solution[swap_in] = 0\n            new_solution[swap_out] = 1\n            current_weight += delta_weight\n\n    # Step 2: Probabilistic flip of items to explore more\n    for i in range(len(new_solution)):\n        if random.random() < 0.1:  # 10% chance to flip\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 261,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a solution from the archive, performs a weighted random swap of items based on their marginal contribution to both objectives, and ensures feasibility by dynamically adjusting the swap to respect the capacity constraint.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a bias towards higher marginal potential\n    base_solution, (current_value1, current_value2) = random.choice(archive)\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Calculate marginal contributions for each item\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n\n    # Identify promising items to consider for swap\n    included = np.where(base_solution == 1)[0]\n    excluded = np.where(base_solution == 0)[0]\n\n    # Hybrid local search: weighted random swap with marginal consideration\n    new_solution = base_solution.copy()\n    if len(included) > 0 and len(excluded) > 0:\n        # Select an item to remove based on marginal contribution\n        remove_idx = random.choices(included, weights=combined_marginal[included], k=1)[0]\n\n        # Select an item to add based on marginal contribution and weight feasibility\n        feasible_add = []\n        feasible_weights = []\n        for idx in excluded:\n            if current_weight - weight_lst[remove_idx] + weight_lst[idx] <= capacity:\n                feasible_add.append(idx)\n                feasible_weights.append(combined_marginal[idx])\n\n        if feasible_add:\n            add_idx = random.choices(feasible_add, weights=feasible_weights, k=1)[0]\n            new_solution[remove_idx] = 0\n            new_solution[add_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.48758880817141276,
            2.976039230823517
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a bias towards higher marginal potential\n    base_solution, (current_value1, current_value2) = random.choice(archive)\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Calculate marginal contributions for each item\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n\n    # Identify promising items to consider for swap\n    included = np.where(base_solution == 1)[0]\n    excluded = np.where(base_solution == 0)[0]\n\n    # Hybrid local search: weighted random swap with marginal consideration\n    new_solution = base_solution.copy()\n    if len(included) > 0 and len(excluded) > 0:\n        # Select an item to remove based on marginal contribution\n        remove_idx = random.choices(included, weights=combined_marginal[included], k=1)[0]\n\n        # Select an item to add based on marginal contribution and weight feasibility\n        feasible_add = []\n        feasible_weights = []\n        for idx in excluded:\n            if current_weight - weight_lst[remove_idx] + weight_lst[idx] <= capacity:\n                feasible_add.append(idx)\n                feasible_weights.append(combined_marginal[idx])\n\n        if feasible_add:\n            add_idx = random.choices(feasible_add, weights=feasible_weights, k=1)[0]\n            new_solution[remove_idx] = 0\n            new_solution[add_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 262,
        "algorithm": "{A novel hybrid local search strategy that intelligently selects a promising solution from the archive and applies a multi-stage perturbation and improvement process, combining adaptive item swaps, marginal gain evaluation, and feasibility-aware adjustments to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with high marginal potential\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        marginal_weight = capacity - total_weight\n        marginal_value1 = np.sum(value1_lst * (1 - sol))\n        marginal_value2 = np.sum(value2_lst * (1 - sol))\n        # Score based on potential improvement and feasibility\n        score = (marginal_value1 + marginal_value2) * (marginal_weight if marginal_weight > 0 else 0.1)\n        candidates.append((score, sol))\n\n    candidates.sort(key=lambda x: -x[0])\n    base_solution = candidates[0][1].copy()\n\n    # Step 2: Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(new_solution)\n\n    # Stage 1: Adaptive item swaps based on marginal gains\n    for _ in range(min(5, n_items)):\n        if random.random() < 0.7:  # Higher probability for swaps\n            # Select items to potentially swap\n            items = random.sample(range(n_items), min(3, n_items))\n            for i in items:\n                if new_solution[i] == 1:\n                    # Try removing item i\n                    temp_sol = new_solution.copy()\n                    temp_sol[i] = 0\n                    temp_weight = np.sum(weight_lst * temp_sol)\n                    if temp_weight <= capacity:\n                        new_solution = temp_sol\n                        break\n                else:\n                    # Try adding item i\n                    temp_sol = new_solution.copy()\n                    temp_sol[i] = 1\n                    temp_weight = np.sum(weight_lst * temp_sol)\n                    if temp_weight <= capacity:\n                        new_solution = temp_sol\n                        break\n\n    # Stage 2: Multi-objective marginal improvement\n    for _ in range(3):\n        # Evaluate marginal gains for both objectives\n        marginal_gains1 = value1_lst * (1 - new_solution) - value1_lst * new_solution\n        marginal_gains2 = value2_lst * (1 - new_solution) - value2_lst * new_solution\n\n        # Combine gains with weights to balance objectives\n        combined_gains = 0.6 * marginal_gains1 + 0.4 * marginal_gains2\n\n        # Select items with positive combined gains\n        candidates = np.where(combined_gains > 0)[0]\n        if len(candidates) > 0:\n            best_item = candidates[np.argmax(combined_gains[candidates])]\n            # Try to add the best item\n            temp_sol = new_solution.copy()\n            temp_sol[best_item] = 1\n            temp_weight = np.sum(weight_lst * temp_sol)\n            if temp_weight <= capacity:\n                new_solution = temp_sol\n\n    # Stage 3: Feasibility-aware adjustments\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items until feasible\n        excess = current_weight - capacity\n        removable_items = np.where(new_solution == 1)[0]\n        removable_weights = weight_lst[removable_items]\n        # Sort by weight (remove smallest items first)\n        sorted_indices = np.argsort(removable_weights)\n        for i in sorted_indices:\n            if excess <= 0:\n                break\n            item_idx = removable_items[i]\n            new_solution[item_idx] = 0\n            excess -= weight_lst[item_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5138933042110334,
            7.882039397954941
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with high marginal potential\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        marginal_weight = capacity - total_weight\n        marginal_value1 = np.sum(value1_lst * (1 - sol))\n        marginal_value2 = np.sum(value2_lst * (1 - sol))\n        # Score based on potential improvement and feasibility\n        score = (marginal_value1 + marginal_value2) * (marginal_weight if marginal_weight > 0 else 0.1)\n        candidates.append((score, sol))\n\n    candidates.sort(key=lambda x: -x[0])\n    base_solution = candidates[0][1].copy()\n\n    # Step 2: Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(new_solution)\n\n    # Stage 1: Adaptive item swaps based on marginal gains\n    for _ in range(min(5, n_items)):\n        if random.random() < 0.7:  # Higher probability for swaps\n            # Select items to potentially swap\n            items = random.sample(range(n_items), min(3, n_items))\n            for i in items:\n                if new_solution[i] == 1:\n                    # Try removing item i\n                    temp_sol = new_solution.copy()\n                    temp_sol[i] = 0\n                    temp_weight = np.sum(weight_lst * temp_sol)\n                    if temp_weight <= capacity:\n                        new_solution = temp_sol\n                        break\n                else:\n                    # Try adding item i\n                    temp_sol = new_solution.copy()\n                    temp_sol[i] = 1\n                    temp_weight = np.sum(weight_lst * temp_sol)\n                    if temp_weight <= capacity:\n                        new_solution = temp_sol\n                        break\n\n    # Stage 2: Multi-objective marginal improvement\n    for _ in range(3):\n        # Evaluate marginal gains for both objectives\n        marginal_gains1 = value1_lst * (1 - new_solution) - value1_lst * new_solution\n        marginal_gains2 = value2_lst * (1 - new_solution) - value2_lst * new_solution\n\n        # Combine gains with weights to balance objectives\n        combined_gains = 0.6 * marginal_gains1 + 0.4 * marginal_gains2\n\n        # Select items with positive combined gains\n        candidates = np.where(combined_gains > 0)[0]\n        if len(candidates) > 0:\n            best_item = candidates[np.argmax(combined_gains[candidates])]\n            # Try to add the best item\n            temp_sol = new_solution.copy()\n            temp_sol[best_item] = 1\n            temp_weight = np.sum(weight_lst * temp_sol)\n            if temp_weight <= capacity:\n                new_solution = temp_sol\n\n    # Stage 3: Feasibility-aware adjustments\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items until feasible\n        excess = current_weight - capacity\n        removable_items = np.where(new_solution == 1)[0]\n        removable_weights = weight_lst[removable_items]\n        # Sort by weight (remove smallest items first)\n        sorted_indices = np.argsort(removable_weights)\n        for i in sorted_indices:\n            if excess <= 0:\n                break\n            item_idx = removable_items[i]\n            new_solution[item_idx] = 0\n            excess -= weight_lst[item_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 263,
        "algorithm": "{This heuristic function selects a promising solution from the archive by prioritizing those with high objective values, then applies a hybrid local search combining item swapping and adaptive perturbation to generate a feasible neighbor solution while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most promising solution (highest sum of objectives)\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Generate a neighbor using hybrid local search\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly select a subset of items to consider for swapping\n    num_items = len(new_solution)\n    swap_indices = np.random.choice(num_items, size=min(10, num_items), replace=False)\n\n    # Step 2: Try to swap items within the subset\n    for i in swap_indices:\n        if new_solution[i] == 1:\n            # Try removing this item\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                # After removing, try adding a new item\n                for j in swap_indices:\n                    if temp_solution[j] == 0:\n                        temp_solution2 = temp_solution.copy()\n                        temp_solution2[j] = 1\n                        temp_weight2 = np.sum(weight_lst[temp_solution2 == 1])\n                        if temp_weight2 <= capacity:\n                            # Accept if it improves both objectives\n                            val1_diff = value1_lst[j] - value1_lst[i]\n                            val2_diff = value2_lst[j] - value2_lst[i]\n                            if val1_diff > 0 and val2_diff > 0:\n                                new_solution = temp_solution2\n        elif new_solution[i] == 0:\n            # Try adding this item if it fits\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                # Accept if it improves both objectives\n                val1_diff = value1_lst[i]\n                val2_diff = value2_lst[i]\n                if val1_diff > 0 and val2_diff > 0:\n                    new_solution = temp_solution\n\n    # Step 3: Adaptive perturbation - flip a random bit if no improvement\n    if np.array_equal(new_solution, base_solution):\n        # Randomly select a bit to flip\n        flip_index = np.random.choice(num_items)\n        new_solution[flip_index] = 1 - new_solution[flip_index]\n        # Ensure feasibility\n        if np.sum(weight_lst[new_solution == 1]) > capacity:\n            new_solution[flip_index] = 1 - new_solution[flip_index]\n\n    return new_solution\n\n",
        "score": [
            -0.34730279943649367,
            6.2134703397750854
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most promising solution (highest sum of objectives)\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Generate a neighbor using hybrid local search\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly select a subset of items to consider for swapping\n    num_items = len(new_solution)\n    swap_indices = np.random.choice(num_items, size=min(10, num_items), replace=False)\n\n    # Step 2: Try to swap items within the subset\n    for i in swap_indices:\n        if new_solution[i] == 1:\n            # Try removing this item\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                # After removing, try adding a new item\n                for j in swap_indices:\n                    if temp_solution[j] == 0:\n                        temp_solution2 = temp_solution.copy()\n                        temp_solution2[j] = 1\n                        temp_weight2 = np.sum(weight_lst[temp_solution2 == 1])\n                        if temp_weight2 <= capacity:\n                            # Accept if it improves both objectives\n                            val1_diff = value1_lst[j] - value1_lst[i]\n                            val2_diff = value2_lst[j] - value2_lst[i]\n                            if val1_diff > 0 and val2_diff > 0:\n                                new_solution = temp_solution2\n        elif new_solution[i] == 0:\n            # Try adding this item if it fits\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 1\n            temp_weight = np.sum(weight_lst[temp_solution == 1])\n            if temp_weight <= capacity:\n                # Accept if it improves both objectives\n                val1_diff = value1_lst[i]\n                val2_diff = value2_lst[i]\n                if val1_diff > 0 and val2_diff > 0:\n                    new_solution = temp_solution\n\n    # Step 3: Adaptive perturbation - flip a random bit if no improvement\n    if np.array_equal(new_solution, base_solution):\n        # Randomly select a bit to flip\n        flip_index = np.random.choice(num_items)\n        new_solution[flip_index] = 1 - new_solution[flip_index]\n        # Ensure feasibility\n        if np.sum(weight_lst[new_solution == 1]) > capacity:\n            new_solution[flip_index] = 1 - new_solution[flip_index]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 264,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: np.sum(x[0]) * 0.7 + np.random.random() * 0.3)  # Bias toward denser solutions with randomness\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: Swap items with high marginal gains and perturbate\n    candidates = np.where(new_solution == 1)[0]\n    for _ in range(min(5, len(candidates))):  # Limit to 5 swaps\n        # Select a candidate to remove\n        i = np.random.choice(candidates)\n        temp_solution = new_solution.copy()\n        temp_solution[i] = 0\n        temp_weight = current_weight - weight_lst[i]\n\n        # Find best item to add (not in solution) that fits capacity\n        available_items = np.where(new_solution == 0)[0]\n        feasible_items = available_items[weight_lst[available_items] + temp_weight <= capacity]\n\n        if len(feasible_items) > 0:\n            # Select item with highest combined marginal gain\n            gains1 = value1_lst[feasible_items]\n            gains2 = value2_lst[feasible_items]\n            combined_gain = gains1 + gains2  # Simple combination for diversification\n            j = feasible_items[np.argmax(combined_gain)]\n\n            # Perform the swap\n            new_solution[i] = 0\n            new_solution[j] = 1\n            current_weight = temp_weight + weight_lst[j]\n\n    # Add perturbation for diversification\n    if np.random.random() < 0.3:  # 30% chance to perturbate\n        perturb_items = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n        for i in perturb_items:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:  # Ensure feasibility\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.3415819005907993,
            8.062194615602493
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: np.sum(x[0]) * 0.7 + np.random.random() * 0.3)  # Bias toward denser solutions with randomness\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: Swap items with high marginal gains and perturbate\n    candidates = np.where(new_solution == 1)[0]\n    for _ in range(min(5, len(candidates))):  # Limit to 5 swaps\n        # Select a candidate to remove\n        i = np.random.choice(candidates)\n        temp_solution = new_solution.copy()\n        temp_solution[i] = 0\n        temp_weight = current_weight - weight_lst[i]\n\n        # Find best item to add (not in solution) that fits capacity\n        available_items = np.where(new_solution == 0)[0]\n        feasible_items = available_items[weight_lst[available_items] + temp_weight <= capacity]\n\n        if len(feasible_items) > 0:\n            # Select item with highest combined marginal gain\n            gains1 = value1_lst[feasible_items]\n            gains2 = value2_lst[feasible_items]\n            combined_gain = gains1 + gains2  # Simple combination for diversification\n            j = feasible_items[np.argmax(combined_gain)]\n\n            # Perform the swap\n            new_solution[i] = 0\n            new_solution[j] = 1\n            current_weight = temp_weight + weight_lst[j]\n\n    # Add perturbation for diversification\n    if np.random.random() < 0.3:  # 30% chance to perturbate\n        perturb_items = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n        for i in perturb_items:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:  # Ensure feasibility\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 265,
        "algorithm": "{The heuristic function selects a promising solution from the archive based on a combination of objective diversity and potential for local improvement, then applies a hybrid local search operator that intelligently flips items to improve both objectives while ensuring feasibility, using a novel combination of value-to-weight ratio and objective-space exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution based on objective diversity and potential improvement\n    selected_idx = np.argmax([np.sum(sol[0]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate neighbor by hybrid local search\n    new_solution = base_solution.copy()\n    candidates = np.where(new_solution == 0)[0]\n    candidates = candidates[np.argsort((value1_lst + value2_lst)[candidates] / weight_lst[candidates])[::-1]]\n\n    for item in candidates:\n        if current_weight + weight_lst[item] <= capacity:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Apply additional local improvement\n    for _ in range(2):\n        for item in np.where(new_solution == 1)[0]:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            if temp_weight + np.sum(weight_lst[new_solution == 0]) >= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.8590910291448901,
            5.831676781177521
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution based on objective diversity and potential improvement\n    selected_idx = np.argmax([np.sum(sol[0]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate neighbor by hybrid local search\n    new_solution = base_solution.copy()\n    candidates = np.where(new_solution == 0)[0]\n    candidates = candidates[np.argsort((value1_lst + value2_lst)[candidates] / weight_lst[candidates])[::-1]]\n\n    for item in candidates:\n        if current_weight + weight_lst[item] <= capacity:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Apply additional local improvement\n    for _ in range(2):\n        for item in np.where(new_solution == 1)[0]:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            if temp_weight + np.sum(weight_lst[new_solution == 0]) >= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 266,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high objective values and low weight utilization, then applies a hybrid local search combining random item swaps and objective-aware flips to generate a feasible neighbor solution with improved potential.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine random swaps and objective-aware flips\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select a subset of items to consider for flipping\n    candidate_items = np.where(new_solution == 1)[0]\n    if len(candidate_items) > 0:\n        # Flip items with low marginal contribution in either objective\n        for item in candidate_items:\n            if random.random() < 0.3:  # 30% chance to consider flipping\n                new_solution[item] = 0\n                new_weight = current_weight - weight_lst[item]\n                if new_weight <= capacity:\n                    current_weight = new_weight\n                else:\n                    new_solution[item] = 1\n\n    # Add items that could improve either objective\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        # Evaluate potential items to add\n        potential_items = []\n        for item in candidate_items:\n            if current_weight + weight_lst[item] <= capacity:\n                potential_items.append(item)\n\n        if potential_items:\n            # Select items that improve either objective\n            for item in potential_items:\n                if random.random() < 0.5:  # 50% chance to consider adding\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.869282287309616,
            3.999189019203186
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine random swaps and objective-aware flips\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select a subset of items to consider for flipping\n    candidate_items = np.where(new_solution == 1)[0]\n    if len(candidate_items) > 0:\n        # Flip items with low marginal contribution in either objective\n        for item in candidate_items:\n            if random.random() < 0.3:  # 30% chance to consider flipping\n                new_solution[item] = 0\n                new_weight = current_weight - weight_lst[item]\n                if new_weight <= capacity:\n                    current_weight = new_weight\n                else:\n                    new_solution[item] = 1\n\n    # Add items that could improve either objective\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        # Evaluate potential items to add\n        potential_items = []\n        for item in candidate_items:\n            if current_weight + weight_lst[item] <= capacity:\n                potential_items.append(item)\n\n        if potential_items:\n            # Select items that improve either objective\n            for item in potential_items:\n                if random.random() < 0.5:  # 50% chance to consider adding\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 267,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high objective values and low dominance counts, then applies a hybrid local search operator that combines item swapping with a biased random walk to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions with high objective values and low dominance counts\n    dominance_counts = [0] * len(archive)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                obj_i = archive[i][1]\n                obj_j = archive[j][1]\n                if obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1] and (obj_i[0] < obj_j[0] or obj_i[1] < obj_j[1]):\n                    dominance_counts[i] += 1\n\n    # Select the solution with the lowest dominance count (most promising)\n    selected_idx = np.argmin(dominance_counts)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search operator\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: combine item swapping with a biased random walk\n    for _ in range(10):  # Number of local search iterations\n        # Randomly select two items: one in the knapsack, one not in it\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) == 0 or len(out_items) == 0:\n            break\n\n        # Biased selection: prefer items with high value-to-weight ratio\n        in_item = random.choices(in_items, weights=value1_lst[in_items] + value2_lst[in_items])[0]\n        out_item = random.choices(out_items, weights=value1_lst[out_items] + value2_lst[out_items])[0]\n\n        # Calculate potential weight change\n        delta_weight = weight_lst[out_item] - weight_lst[in_item]\n\n        # Apply the swap if it maintains feasibility\n        if current_weight + delta_weight <= capacity:\n            new_solution[in_item] = 0\n            new_solution[out_item] = 1\n            current_weight += delta_weight\n\n    return new_solution\n\n",
        "score": [
            -0.4429503675625551,
            7.72153103351593
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions with high objective values and low dominance counts\n    dominance_counts = [0] * len(archive)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                obj_i = archive[i][1]\n                obj_j = archive[j][1]\n                if obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1] and (obj_i[0] < obj_j[0] or obj_i[1] < obj_j[1]):\n                    dominance_counts[i] += 1\n\n    # Select the solution with the lowest dominance count (most promising)\n    selected_idx = np.argmin(dominance_counts)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search operator\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: combine item swapping with a biased random walk\n    for _ in range(10):  # Number of local search iterations\n        # Randomly select two items: one in the knapsack, one not in it\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) == 0 or len(out_items) == 0:\n            break\n\n        # Biased selection: prefer items with high value-to-weight ratio\n        in_item = random.choices(in_items, weights=value1_lst[in_items] + value2_lst[in_items])[0]\n        out_item = random.choices(out_items, weights=value1_lst[out_items] + value2_lst[out_items])[0]\n\n        # Calculate potential weight change\n        delta_weight = weight_lst[out_item] - weight_lst[in_item]\n\n        # Apply the swap if it maintains feasibility\n        if current_weight + delta_weight <= capacity:\n            new_solution[in_item] = 0\n            new_solution[out_item] = 1\n            current_weight += delta_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 268,
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive item swapping with probabilistic objective-driven perturbations to intelligently explore the solution space while ensuring feasibility, balancing exploration of both objectives through dynamic trade-off analysis and randomness to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        current_weight = np.sum(weight_lst * sol)\n        potential = np.sum((value1_lst + value2_lst) * (1 - sol))  # Potential improvement\n        candidates.append((sol, obj, potential))\n\n    # Sort by potential improvement and select top 20%\n    candidates.sort(key=lambda x: -x[2])\n    top_candidates = candidates[:max(1, len(candidates) // 5)]\n    selected = random.choice(top_candidates)[0]\n    base_solution = selected.copy()\n\n    # Hybrid local search: adaptive swapping with probabilistic perturbations\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Objective-driven swaps\n    for _ in range(5):  # Number of attempts\n        # Find items to swap out (low value density) and swap in (high value density)\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) == 0 or len(out_items) == 0:\n            break\n\n        # Calculate value densities\n        in_density = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n        out_density = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n\n        # Select items to swap\n        if random.random() < 0.7:  # Prefer high density swaps\n            if len(in_items) > 0 and len(out_items) > 0:\n                out_idx = np.argmin(in_density)\n                in_idx = np.argmax(out_density)\n\n                out_item = in_items[out_idx]\n                in_item = out_items[in_idx]\n\n                # Check feasibility\n                if weight_lst[in_item] <= remaining_capacity + weight_lst[out_item]:\n                    new_solution[out_item] = 0\n                    new_solution[in_item] = 1\n                    remaining_capacity += weight_lst[out_item] - weight_lst[in_item]\n        else:  # Random perturbation\n            if len(in_items) > 0:\n                out_item = random.choice(in_items)\n                new_solution[out_item] = 0\n                remaining_capacity += weight_lst[out_item]\n\n                # Try to add a new item\n                possible_add = [i for i in out_items if weight_lst[i] <= remaining_capacity]\n                if possible_add:\n                    in_item = random.choice(possible_add)\n                    new_solution[in_item] = 1\n                    remaining_capacity -= weight_lst[in_item]\n\n    return new_solution\n\n",
        "score": [
            -0.8283388200858681,
            7.109702527523041
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        current_weight = np.sum(weight_lst * sol)\n        potential = np.sum((value1_lst + value2_lst) * (1 - sol))  # Potential improvement\n        candidates.append((sol, obj, potential))\n\n    # Sort by potential improvement and select top 20%\n    candidates.sort(key=lambda x: -x[2])\n    top_candidates = candidates[:max(1, len(candidates) // 5)]\n    selected = random.choice(top_candidates)[0]\n    base_solution = selected.copy()\n\n    # Hybrid local search: adaptive swapping with probabilistic perturbations\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Objective-driven swaps\n    for _ in range(5):  # Number of attempts\n        # Find items to swap out (low value density) and swap in (high value density)\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) == 0 or len(out_items) == 0:\n            break\n\n        # Calculate value densities\n        in_density = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n        out_density = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n\n        # Select items to swap\n        if random.random() < 0.7:  # Prefer high density swaps\n            if len(in_items) > 0 and len(out_items) > 0:\n                out_idx = np.argmin(in_density)\n                in_idx = np.argmax(out_density)\n\n                out_item = in_items[out_idx]\n                in_item = out_items[in_idx]\n\n                # Check feasibility\n                if weight_lst[in_item] <= remaining_capacity + weight_lst[out_item]:\n                    new_solution[out_item] = 0\n                    new_solution[in_item] = 1\n                    remaining_capacity += weight_lst[out_item] - weight_lst[in_item]\n        else:  # Random perturbation\n            if len(in_items) > 0:\n                out_item = random.choice(in_items)\n                new_solution[out_item] = 0\n                remaining_capacity += weight_lst[out_item]\n\n                # Try to add a new item\n                possible_add = [i for i in out_items if weight_lst[i] <= remaining_capacity]\n                if possible_add:\n                    in_item = random.choice(possible_add)\n                    new_solution[in_item] = 1\n                    remaining_capacity -= weight_lst[in_item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 269,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive swap-and-replace with objective-aware perturbation\n    for _ in range(3):  # Multiple perturbation attempts\n        # Objective-aware selection of items to swap\n        if np.random.rand() < 0.7:  # Higher chance for value1 improvement\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                item_to_add = np.random.choice(candidate_items)\n                if np.dot(weight_lst, new_solution) + weight_lst[item_to_add] <= capacity:\n                    new_solution[item_to_add] = 1\n        else:  # Chance for value2 improvement\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                item_to_remove = np.random.choice(candidate_items)\n                new_solution[item_to_remove] = 0\n\n    # Ensure feasibility\n    while np.dot(weight_lst, new_solution) > capacity:\n        excess_items = np.where(new_solution == 1)[0]\n        if len(excess_items) > 0:\n            item_to_remove = np.random.choice(excess_items)\n            new_solution[item_to_remove] = 0\n        else:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.2772043936830799,
            4.359162747859955
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive swap-and-replace with objective-aware perturbation\n    for _ in range(3):  # Multiple perturbation attempts\n        # Objective-aware selection of items to swap\n        if np.random.rand() < 0.7:  # Higher chance for value1 improvement\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                item_to_add = np.random.choice(candidate_items)\n                if np.dot(weight_lst, new_solution) + weight_lst[item_to_add] <= capacity:\n                    new_solution[item_to_add] = 1\n        else:  # Chance for value2 improvement\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                item_to_remove = np.random.choice(candidate_items)\n                new_solution[item_to_remove] = 0\n\n    # Ensure feasibility\n    while np.dot(weight_lst, new_solution) > capacity:\n        excess_items = np.where(new_solution == 1)[0]\n        if len(excess_items) > 0:\n            item_to_remove = np.random.choice(excess_items)\n            new_solution[item_to_remove] = 0\n        else:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 270,
        "algorithm": "{A novel hybrid local search algorithm combines adaptive item swapping with probabilistic item replacement, guided by a dynamic trade-off factor to balance the two objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = None\n    max_potential = -1\n\n    for sol, obj in archive:\n        # Calculate potential improvement (difference from current objectives)\n        total_weight = np.sum(weight_lst * sol)\n        potential = np.sum(value1_lst * (1 - sol)) + np.sum(value2_lst * (1 - sol)) - (np.sum(value1_lst * sol) + np.sum(value2_lst * sol))\n        if potential > max_potential and total_weight <= capacity:\n            max_potential = potential\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: adaptive swapping and probabilistic replacement\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Adaptive swapping: swap items based on value ratios\n    value_ratio = value1_lst / (value2_lst + 1e-10)\n    sorted_indices = np.argsort(value_ratio)[::-1]\n\n    for i in sorted_indices:\n        if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            new_solution[i] = 1\n            current_weight += weight_lst[i]\n        elif new_solution[i] == 1 and np.random.rand() < 0.3:  # Probabilistic removal\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.4797129787072412,
            5.387972354888916
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = None\n    max_potential = -1\n\n    for sol, obj in archive:\n        # Calculate potential improvement (difference from current objectives)\n        total_weight = np.sum(weight_lst * sol)\n        potential = np.sum(value1_lst * (1 - sol)) + np.sum(value2_lst * (1 - sol)) - (np.sum(value1_lst * sol) + np.sum(value2_lst * sol))\n        if potential > max_potential and total_weight <= capacity:\n            max_potential = potential\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: adaptive swapping and probabilistic replacement\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Adaptive swapping: swap items based on value ratios\n    value_ratio = value1_lst / (value2_lst + 1e-10)\n    sorted_indices = np.argsort(value_ratio)[::-1]\n\n    for i in sorted_indices:\n        if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            new_solution[i] = 1\n            current_weight += weight_lst[i]\n        elif new_solution[i] == 1 and np.random.rand() < 0.3:  # Probabilistic removal\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 271,
        "algorithm": "{A novel hybrid local search operator combines adaptive item swapping with dynamic objective-weighted perturbations to intelligently explore the solution space, balancing exploration and exploitation by prioritizing items with high marginal gains in both objectives while ensuring feasibility through capacity-aware adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, randomly but could be enhanced with selection criteria)\n    base_solution, _ = archive[np.random.randint(len(archive))]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and values\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Identify candidate items for swap (those not in solution)\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) == 0:\n        return new_solution\n\n    # Randomly select a candidate item and a item in solution to swap\n    item_to_add = np.random.choice(candidate_items)\n    items_in_solution = np.where(new_solution == 1)[0]\n\n    if len(items_in_solution) == 0:\n        # If no items in solution, just add the candidate\n        if current_weight + weight_lst[item_to_add] <= capacity:\n            new_solution[item_to_add] = 1\n        return new_solution\n\n    item_to_remove = np.random.choice(items_in_solution)\n\n    # Calculate potential new weight\n    potential_weight = current_weight - weight_lst[item_to_remove] + weight_lst[item_to_add]\n\n    # Ensure feasibility\n    if potential_weight <= capacity:\n        new_solution[item_to_remove] = 0\n        new_solution[item_to_add] = 1\n    else:\n        # If swap is not feasible, try adding only if possible\n        if current_weight + weight_lst[item_to_add] <= capacity:\n            new_solution[item_to_add] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.5466704877985474,
            3.3400782346725464
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, randomly but could be enhanced with selection criteria)\n    base_solution, _ = archive[np.random.randint(len(archive))]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and values\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Identify candidate items for swap (those not in solution)\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) == 0:\n        return new_solution\n\n    # Randomly select a candidate item and a item in solution to swap\n    item_to_add = np.random.choice(candidate_items)\n    items_in_solution = np.where(new_solution == 1)[0]\n\n    if len(items_in_solution) == 0:\n        # If no items in solution, just add the candidate\n        if current_weight + weight_lst[item_to_add] <= capacity:\n            new_solution[item_to_add] = 1\n        return new_solution\n\n    item_to_remove = np.random.choice(items_in_solution)\n\n    # Calculate potential new weight\n    potential_weight = current_weight - weight_lst[item_to_remove] + weight_lst[item_to_add]\n\n    # Ensure feasibility\n    if potential_weight <= capacity:\n        new_solution[item_to_remove] = 0\n        new_solution[item_to_add] = 1\n    else:\n        # If swap is not feasible, try adding only if possible\n        if current_weight + weight_lst[item_to_add] <= capacity:\n            new_solution[item_to_add] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 272,
        "algorithm": "{The heuristic function selects a promising solution from the archive by prioritizing those with high potential for local improvement, then applies a hybrid local search operator that combines item swaps and biased random flips to explore the solution space efficiently while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = archive[0][0].copy()\n    selected_value1, selected_value2 = archive[0][1]\n\n    # Calculate the total weight of the selected solution\n    total_weight = np.sum(weight_lst[selected_solution == 1])\n\n    # Generate a neighbor solution using a hybrid local search operator\n    new_solution = selected_solution.copy()\n\n    # Step 1: Perform biased random flips (higher probability for items with high marginal value)\n    for i in range(len(new_solution)):\n        if random.random() < 0.3:  # 30% chance to flip each item\n            if new_solution[i] == 0:\n                if total_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    total_weight += weight_lst[i]\n            else:\n                new_solution[i] = 0\n                total_weight -= weight_lst[i]\n\n    # Step 2: Perform item swaps (swap an item in the knapsack with one outside)\n    if np.sum(new_solution) > 0 and np.sum(new_solution) < len(new_solution):\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        # Select a random item to remove and a random item to add\n        item_to_remove = random.choice(in_items)\n        item_to_add = random.choice(out_items)\n\n        if (total_weight - weight_lst[item_to_remove] + weight_lst[item_to_add]) <= capacity:\n            new_solution[item_to_remove] = 0\n            new_solution[item_to_add] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.4165702412076016,
            2.1957102715969086
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = archive[0][0].copy()\n    selected_value1, selected_value2 = archive[0][1]\n\n    # Calculate the total weight of the selected solution\n    total_weight = np.sum(weight_lst[selected_solution == 1])\n\n    # Generate a neighbor solution using a hybrid local search operator\n    new_solution = selected_solution.copy()\n\n    # Step 1: Perform biased random flips (higher probability for items with high marginal value)\n    for i in range(len(new_solution)):\n        if random.random() < 0.3:  # 30% chance to flip each item\n            if new_solution[i] == 0:\n                if total_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    total_weight += weight_lst[i]\n            else:\n                new_solution[i] = 0\n                total_weight -= weight_lst[i]\n\n    # Step 2: Perform item swaps (swap an item in the knapsack with one outside)\n    if np.sum(new_solution) > 0 and np.sum(new_solution) < len(new_solution):\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        # Select a random item to remove and a random item to add\n        item_to_remove = random.choice(in_items)\n        item_to_add = random.choice(out_items)\n\n        if (total_weight - weight_lst[item_to_remove] + weight_lst[item_to_add]) <= capacity:\n            new_solution[item_to_remove] = 0\n            new_solution[item_to_add] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 273,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor by flipping a subset of items based on marginal gains\n    new_solution = selected_solution.copy()\n    n_items = len(new_solution)\n\n    # Calculate marginal gains for each item (value/weight ratio for both objectives)\n    marginal1 = value1_lst / weight_lst\n    marginal2 = value2_lst / weight_lst\n\n    # Identify items with high marginal gains in either objective\n    high_marginal_indices = np.where((marginal1 > np.percentile(marginal1, 75)) |\n                                     (marginal2 > np.percentile(marginal2, 75)))[0]\n\n    # Randomly select a subset of high-marginal items to flip\n    if len(high_marginal_indices) > 0:\n        flip_indices = np.random.choice(high_marginal_indices, size=min(3, len(high_marginal_indices)), replace=False)\n        new_solution[flip_indices] = 1 - new_solution[flip_indices]\n\n    # Ensure feasibility: if total weight exceeds capacity, remove items until feasible\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Sort items by marginal gain (prioritize removing low-margin items)\n        sorted_indices = np.argsort(marginal1 + marginal2)\n        for idx in sorted_indices:\n            if new_solution[idx] == 1 and total_weight > capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.28383355079469663,
            5.317220687866211
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor by flipping a subset of items based on marginal gains\n    new_solution = selected_solution.copy()\n    n_items = len(new_solution)\n\n    # Calculate marginal gains for each item (value/weight ratio for both objectives)\n    marginal1 = value1_lst / weight_lst\n    marginal2 = value2_lst / weight_lst\n\n    # Identify items with high marginal gains in either objective\n    high_marginal_indices = np.where((marginal1 > np.percentile(marginal1, 75)) |\n                                     (marginal2 > np.percentile(marginal2, 75)))[0]\n\n    # Randomly select a subset of high-marginal items to flip\n    if len(high_marginal_indices) > 0:\n        flip_indices = np.random.choice(high_marginal_indices, size=min(3, len(high_marginal_indices)), replace=False)\n        new_solution[flip_indices] = 1 - new_solution[flip_indices]\n\n    # Ensure feasibility: if total weight exceeds capacity, remove items until feasible\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Sort items by marginal gain (prioritize removing low-margin items)\n        sorted_indices = np.argsort(marginal1 + marginal2)\n        for idx in sorted_indices:\n            if new_solution[idx] == 1 and total_weight > capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 274,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high objective values and low weight, then applies a hybrid local search strategy combining item swapping and probabilistic flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def selection_criteria(sol_obj):\n        sol, (v1, v2) = sol_obj\n        total_weight = np.sum(weight_lst[sol == 1])\n        return (v1 + v2) / (1 + total_weight)  # Balance between value and weight\n\n    archive.sort(key=selection_criteria, reverse=True)\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: swap items + probabilistic flip\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Swap two items (if feasible)\n    if n_items >= 2:\n        idx1, idx2 = random.sample(range(n_items), 2)\n        if new_solution[idx1] != new_solution[idx2]:\n            new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    # Step 2: Probabilistic flip (tend to flip out low-value items)\n    for i in range(n_items):\n        if random.random() < 0.1:  # 10% chance to flip\n            if new_solution[i] == 1:\n                # Check if removing this item keeps the solution feasible\n                if np.sum(weight_lst[new_solution == 1]) - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n            else:\n                # Check if adding this item keeps the solution feasible\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    # Ensure feasibility (fallback)\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    while total_weight > capacity:\n        # Randomly remove items until feasible\n        items_in = np.where(new_solution == 1)[0]\n        if len(items_in) == 0:\n            break\n        remove_idx = random.choice(items_in)\n        new_solution[remove_idx] = 0\n        total_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3808830801842684,
            4.033686101436615
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def selection_criteria(sol_obj):\n        sol, (v1, v2) = sol_obj\n        total_weight = np.sum(weight_lst[sol == 1])\n        return (v1 + v2) / (1 + total_weight)  # Balance between value and weight\n\n    archive.sort(key=selection_criteria, reverse=True)\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: swap items + probabilistic flip\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Swap two items (if feasible)\n    if n_items >= 2:\n        idx1, idx2 = random.sample(range(n_items), 2)\n        if new_solution[idx1] != new_solution[idx2]:\n            new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    # Step 2: Probabilistic flip (tend to flip out low-value items)\n    for i in range(n_items):\n        if random.random() < 0.1:  # 10% chance to flip\n            if new_solution[i] == 1:\n                # Check if removing this item keeps the solution feasible\n                if np.sum(weight_lst[new_solution == 1]) - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n            else:\n                # Check if adding this item keeps the solution feasible\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    # Ensure feasibility (fallback)\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    while total_weight > capacity:\n        # Randomly remove items until feasible\n        items_in = np.where(new_solution == 1)[0]\n        if len(items_in) == 0:\n            break\n        remove_idx = random.choice(items_in)\n        new_solution[remove_idx] = 0\n        total_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 275,
        "algorithm": "{A hybrid local search strategy that combines adaptive item swapping with probabilistic exploration of high-value regions to generate neighbors while ensuring feasibility and multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and objectives\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Identify items to consider for swapping\n    zero_indices = np.where(base_solution == 0)[0]\n    one_indices = np.where(base_solution == 1)[0]\n\n    # Hybrid local search: adaptive swapping with probabilistic exploration\n    if len(zero_indices) > 0 and len(one_indices) > 0:\n        # Probabilistically select an item to remove (from 1s)\n        remove_item = random.choice(one_indices)\n        new_weight = current_weight - weight_lst[remove_item]\n\n        # Select an item to add (from 0s) that improves both objectives\n        candidate_items = []\n        for item in zero_indices:\n            if new_weight + weight_lst[item] <= capacity:\n                candidate_items.append(item)\n\n        if candidate_items:\n            # Select the item with the highest combined normalized value improvement\n            improvements = []\n            for item in candidate_items:\n                delta_value1 = value1_lst[item] - value1_lst[remove_item]\n                delta_value2 = value2_lst[item] - value2_lst[remove_item]\n                # Normalize improvements to balance objectives\n                norm_improvement = (delta_value1 / (np.max(value1_lst) + 1e-6)) + (delta_value2 / (np.max(value2_lst) + 1e-6))\n                improvements.append((norm_improvement, item))\n\n            if improvements:\n                _, best_item = max(improvements, key=lambda x: x[0])\n                new_solution[remove_item] = 0\n                new_solution[best_item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.42833080736450524,
            10.601253777742386
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and objectives\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Identify items to consider for swapping\n    zero_indices = np.where(base_solution == 0)[0]\n    one_indices = np.where(base_solution == 1)[0]\n\n    # Hybrid local search: adaptive swapping with probabilistic exploration\n    if len(zero_indices) > 0 and len(one_indices) > 0:\n        # Probabilistically select an item to remove (from 1s)\n        remove_item = random.choice(one_indices)\n        new_weight = current_weight - weight_lst[remove_item]\n\n        # Select an item to add (from 0s) that improves both objectives\n        candidate_items = []\n        for item in zero_indices:\n            if new_weight + weight_lst[item] <= capacity:\n                candidate_items.append(item)\n\n        if candidate_items:\n            # Select the item with the highest combined normalized value improvement\n            improvements = []\n            for item in candidate_items:\n                delta_value1 = value1_lst[item] - value1_lst[remove_item]\n                delta_value2 = value2_lst[item] - value2_lst[remove_item]\n                # Normalize improvements to balance objectives\n                norm_improvement = (delta_value1 / (np.max(value1_lst) + 1e-6)) + (delta_value2 / (np.max(value2_lst) + 1e-6))\n                improvements.append((norm_improvement, item))\n\n            if improvements:\n                _, best_item = max(improvements, key=lambda x: x[0])\n                new_solution[remove_item] = 0\n                new_solution[best_item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 276,
        "algorithm": "{This heuristic selects a promising solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search operator that intelligently flips item selections while ensuring feasibility, using a novel combination of value-based and weight-aware flipping strategies to explore the solution space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Use a combination of objective values and diversity to select a solution\n    scores = []\n    for sol, obj in archive:\n        total_value1, total_value2 = obj\n        # Compute a score based on normalized objectives and diversity\n        norm_value1 = total_value1 / np.max(value1_lst) if np.max(value1_lst) != 0 else 0\n        norm_value2 = total_value2 / np.max(value2_lst) if np.max(value2_lst) != 0 else 0\n        diversity = np.sum(sol) / len(sol)  # Fraction of items selected\n        score = 0.6 * (norm_value1 + norm_value2) + 0.4 * diversity\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search operator\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Strategy 1: Flip items with high value-to-weight ratio in one objective\n    # Strategy 2: Flip items that are currently in the knapsack but have low marginal contribution\n    # Strategy 3: Randomly flip items to escape local optima\n\n    # Strategy 1: Value-to-weight ratio for objective 1\n    value_weight_ratio1 = value1_lst / weight_lst\n    sorted_indices1 = np.argsort(-value_weight_ratio1)\n\n    # Strategy 2: Marginal contribution in objective 1\n    marginal_contribution1 = value1_lst * new_solution\n    sorted_indices2 = np.argsort(marginal_contribution1)\n\n    # Strategy 3: Random selection\n    random_indices = np.random.permutation(len(weight_lst))\n\n    # Combine strategies with probabilities\n    strategy = np.random.choice(['value_weight', 'marginal', 'random'], p=[0.4, 0.3, 0.3])\n\n    if strategy == 'value_weight':\n        for idx in sorted_indices1:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                break\n            elif new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                break\n    elif strategy == 'marginal':\n        for idx in sorted_indices2:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                break\n    else:  # random\n        for idx in random_indices:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                break\n            elif new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.8885522582331538,
            8.09379032254219
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Use a combination of objective values and diversity to select a solution\n    scores = []\n    for sol, obj in archive:\n        total_value1, total_value2 = obj\n        # Compute a score based on normalized objectives and diversity\n        norm_value1 = total_value1 / np.max(value1_lst) if np.max(value1_lst) != 0 else 0\n        norm_value2 = total_value2 / np.max(value2_lst) if np.max(value2_lst) != 0 else 0\n        diversity = np.sum(sol) / len(sol)  # Fraction of items selected\n        score = 0.6 * (norm_value1 + norm_value2) + 0.4 * diversity\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search operator\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Strategy 1: Flip items with high value-to-weight ratio in one objective\n    # Strategy 2: Flip items that are currently in the knapsack but have low marginal contribution\n    # Strategy 3: Randomly flip items to escape local optima\n\n    # Strategy 1: Value-to-weight ratio for objective 1\n    value_weight_ratio1 = value1_lst / weight_lst\n    sorted_indices1 = np.argsort(-value_weight_ratio1)\n\n    # Strategy 2: Marginal contribution in objective 1\n    marginal_contribution1 = value1_lst * new_solution\n    sorted_indices2 = np.argsort(marginal_contribution1)\n\n    # Strategy 3: Random selection\n    random_indices = np.random.permutation(len(weight_lst))\n\n    # Combine strategies with probabilities\n    strategy = np.random.choice(['value_weight', 'marginal', 'random'], p=[0.4, 0.3, 0.3])\n\n    if strategy == 'value_weight':\n        for idx in sorted_indices1:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                break\n            elif new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                break\n    elif strategy == 'marginal':\n        for idx in sorted_indices2:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                break\n    else:  # random\n        for idx in random_indices:\n            if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                break\n            elif new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 277,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_objectives = np.array([(v1 / np.sum(value1_lst), v2 / np.sum(value2_lst)) for _, (v1, v2) in archive])\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Identify items to potentially flip (items with high marginal contribution)\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    marginal_contributions = (value1_lst + value2_lst) / weight_lst\n    sorted_indices = np.argsort(marginal_contributions)[::-1]\n\n    # Apply a hybrid local search: first try to add high-marginal items, then remove low-marginal items if needed\n    new_solution = base_solution.copy()\n    for i in sorted_indices:\n        if base_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity:\n            new_solution[i] = 1\n            current_weight += weight_lst[i]\n            break\n\n    if np.all(new_solution == base_solution):\n        for i in sorted_indices:\n            if base_solution[i] == 1:\n                temp_solution = new_solution.copy()\n                temp_solution[i] = 0\n                temp_weight = current_weight - weight_lst[i]\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.825753868021594,
            4.766593843698502
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_objectives = np.array([(v1 / np.sum(value1_lst), v2 / np.sum(value2_lst)) for _, (v1, v2) in archive])\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Identify items to potentially flip (items with high marginal contribution)\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    marginal_contributions = (value1_lst + value2_lst) / weight_lst\n    sorted_indices = np.argsort(marginal_contributions)[::-1]\n\n    # Apply a hybrid local search: first try to add high-marginal items, then remove low-marginal items if needed\n    new_solution = base_solution.copy()\n    for i in sorted_indices:\n        if base_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity:\n            new_solution[i] = 1\n            current_weight += weight_lst[i]\n            break\n\n    if np.all(new_solution == base_solution):\n        for i in sorted_indices:\n            if base_solution[i] == 1:\n                temp_solution = new_solution.copy()\n                temp_solution[i] = 0\n                temp_weight = current_weight - weight_lst[i]\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 278,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on its potential for improvement in both objectives, then applies a hybrid local search operator that combines item swaps and diversified flips to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + i) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: combine item swaps and diversified flips\n    new_solution = base_solution.copy()\n\n    # Step 1: Perform item swaps between included and excluded items\n    included = np.where(new_solution == 1)[0]\n    excluded = np.where(new_solution == 0)[0]\n\n    if len(included) > 0 and len(excluded) > 0:\n        swap_candidate = random.choice(included)\n        flip_candidate = random.choice(excluded)\n\n        swap_weight = weight_lst[swap_candidate]\n        flip_weight = weight_lst[flip_candidate]\n\n        if current_weight - swap_weight + flip_weight <= capacity:\n            new_solution[swap_candidate] = 0\n            new_solution[flip_candidate] = 1\n\n    # Step 2: Perform diversified flips (randomly select items to flip)\n    flip_indices = random.sample(range(len(new_solution)), min(3, len(new_solution)))\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.35155061667177506,
            2.0829457342624664
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + i) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: combine item swaps and diversified flips\n    new_solution = base_solution.copy()\n\n    # Step 1: Perform item swaps between included and excluded items\n    included = np.where(new_solution == 1)[0]\n    excluded = np.where(new_solution == 0)[0]\n\n    if len(included) > 0 and len(excluded) > 0:\n        swap_candidate = random.choice(included)\n        flip_candidate = random.choice(excluded)\n\n        swap_weight = weight_lst[swap_candidate]\n        flip_weight = weight_lst[flip_candidate]\n\n        if current_weight - swap_weight + flip_weight <= capacity:\n            new_solution[swap_candidate] = 0\n            new_solution[flip_candidate] = 1\n\n    # Step 2: Perform diversified flips (randomly select items to flip)\n    flip_indices = random.sample(range(len(new_solution)), min(3, len(new_solution)))\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 279,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: flip items based on marginal utility and diversity\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Identify items with high marginal utility for either objective\n    marginal_utility1 = value1_lst / (weight_lst + 1e-6)\n    marginal_utility2 = value2_lst / (weight_lst + 1e-6)\n\n    # Step 2: Flip items with high marginal utility if feasible\n    for i in np.argsort(marginal_utility1 + marginal_utility2)[::-1]:\n        if new_solution[i] == 0:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n        else:\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    # Step 3: Randomly flip items to explore diversity\n    for i in np.random.permutation(n_items):\n        if np.random.rand() < 0.1:  # 10% chance to flip\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n            elif new_solution[i] == 1:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.35808589892604575,
            5.472942769527435
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: flip items based on marginal utility and diversity\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Identify items with high marginal utility for either objective\n    marginal_utility1 = value1_lst / (weight_lst + 1e-6)\n    marginal_utility2 = value2_lst / (weight_lst + 1e-6)\n\n    # Step 2: Flip items with high marginal utility if feasible\n    for i in np.argsort(marginal_utility1 + marginal_utility2)[::-1]:\n        if new_solution[i] == 0:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n        else:\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    # Step 3: Randomly flip items to explore diversity\n    for i in np.random.permutation(n_items):\n        if np.random.rand() < 0.1:  # 10% chance to flip\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n            elif new_solution[i] == 1:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 280,
        "algorithm": "{The algorithm intelligently selects a solution from the archive with high potential for further improvement by evaluating the diversity and dominance of solutions, then applies a hybrid local search that combines item swapping and adaptive perturbation to explore the solution space while ensuring feasibility through weight-constrained operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros(len(weight_lst), dtype=int)\n\n    # Evaluate potential solutions based on dominance and diversity\n    candidates = []\n    for sol, _ in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight <= capacity:\n            candidates.append(sol)\n\n    if not candidates:\n        return np.zeros(len(weight_lst), dtype=int)\n\n    # Select a solution with high potential for improvement\n    base_solution = random.choice(candidates)\n\n    # Hybrid local search: item swapping and adaptive perturbation\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Item swapping (swap items between included and excluded)\n    included = np.where(new_solution == 1)[0]\n    excluded = np.where(new_solution == 0)[0]\n\n    if len(included) > 0 and len(excluded) > 0:\n        swap_idx = random.choice(included)\n        add_idx = random.choice(excluded)\n\n        # Check feasibility of swap\n        if (np.sum(weight_lst * new_solution) - weight_lst[swap_idx] + weight_lst[add_idx]) <= capacity:\n            new_solution[swap_idx] = 0\n            new_solution[add_idx] = 1\n\n    # Step 2: Adaptive perturbation (flip a small number of items)\n    flip_count = max(1, int(0.1 * n_items))  # Flip 10% of items or at least 1\n    flip_indices = np.random.choice(n_items, flip_count, replace=False)\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Check if removing the item keeps the solution feasible\n            if (np.sum(weight_lst * new_solution) - weight_lst[idx]) <= capacity:\n                new_solution[idx] = 0\n        else:\n            # Check if adding the item keeps the solution feasible\n            if (np.sum(weight_lst * new_solution) + weight_lst[idx]) <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.39642064090373585,
            4.070865213871002
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros(len(weight_lst), dtype=int)\n\n    # Evaluate potential solutions based on dominance and diversity\n    candidates = []\n    for sol, _ in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight <= capacity:\n            candidates.append(sol)\n\n    if not candidates:\n        return np.zeros(len(weight_lst), dtype=int)\n\n    # Select a solution with high potential for improvement\n    base_solution = random.choice(candidates)\n\n    # Hybrid local search: item swapping and adaptive perturbation\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Item swapping (swap items between included and excluded)\n    included = np.where(new_solution == 1)[0]\n    excluded = np.where(new_solution == 0)[0]\n\n    if len(included) > 0 and len(excluded) > 0:\n        swap_idx = random.choice(included)\n        add_idx = random.choice(excluded)\n\n        # Check feasibility of swap\n        if (np.sum(weight_lst * new_solution) - weight_lst[swap_idx] + weight_lst[add_idx]) <= capacity:\n            new_solution[swap_idx] = 0\n            new_solution[add_idx] = 1\n\n    # Step 2: Adaptive perturbation (flip a small number of items)\n    flip_count = max(1, int(0.1 * n_items))  # Flip 10% of items or at least 1\n    flip_indices = np.random.choice(n_items, flip_count, replace=False)\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Check if removing the item keeps the solution feasible\n            if (np.sum(weight_lst * new_solution) - weight_lst[idx]) <= capacity:\n                new_solution[idx] = 0\n        else:\n            # Check if adding the item keeps the solution feasible\n            if (np.sum(weight_lst * new_solution) + weight_lst[idx]) <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 281,
        "algorithm": "{A novel hybrid local search strategy that intelligently selects a promising solution from the archive, then applies a combination of item swapping and probabilistic flip-based moves to explore both objective spaces while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution with higher potential for improvement\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (i + 1) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of item swapping and probabilistic flips\n    # Step 1: Item swapping (for diversification)\n    if np.sum(base_solution) >= 2:\n        items = np.where(base_solution == 1)[0]\n        i, j = random.sample(list(items), 2)\n        if (current_weight - weight_lst[i] + weight_lst[j] <= capacity and\n            current_weight - weight_lst[j] + weight_lst[i] <= capacity):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Probabilistic flip (for intensification)\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 1:\n            if random.random() < 0.2 and (current_weight - weight_lst[i] <= capacity):\n                new_solution[i] = 0\n        else:\n            if random.random() < 0.1 and (current_weight + weight_lst[i] <= capacity):\n                new_solution[i] = 1\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        while total_weight > capacity:\n            items_in = np.where(new_solution == 1)[0]\n            if len(items_in) == 0:\n                break\n            item_to_remove = random.choice(items_in)\n            new_solution[item_to_remove] = 0\n            total_weight -= weight_lst[item_to_remove]\n\n    return new_solution\n\n",
        "score": [
            -0.816132032377585,
            2.1756932735443115
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution with higher potential for improvement\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (i + 1) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of item swapping and probabilistic flips\n    # Step 1: Item swapping (for diversification)\n    if np.sum(base_solution) >= 2:\n        items = np.where(base_solution == 1)[0]\n        i, j = random.sample(list(items), 2)\n        if (current_weight - weight_lst[i] + weight_lst[j] <= capacity and\n            current_weight - weight_lst[j] + weight_lst[i] <= capacity):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Probabilistic flip (for intensification)\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 1:\n            if random.random() < 0.2 and (current_weight - weight_lst[i] <= capacity):\n                new_solution[i] = 0\n        else:\n            if random.random() < 0.1 and (current_weight + weight_lst[i] <= capacity):\n                new_solution[i] = 1\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        while total_weight > capacity:\n            items_in = np.where(new_solution == 1)[0]\n            if len(items_in) == 0:\n                break\n            item_to_remove = random.choice(items_in)\n            new_solution[item_to_remove] = 0\n            total_weight -= weight_lst[item_to_remove]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 282,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: np.sum(x[0]) * (np.sum(value1_lst) + np.sum(value2_lst)))\n\n    # Generate a neighbor by flipping items with high marginal contribution\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Calculate marginal contributions\n    marginal1 = value1_lst / weight_lst\n    marginal2 = value2_lst / weight_lst\n    combined_marginal = marginal1 + marginal2\n\n    # Sort items by combined marginal contribution\n    item_indices = np.argsort(combined_marginal)[::-1]\n\n    # Flip top items that can be added without exceeding capacity\n    for idx in item_indices:\n        if base_solution[idx] == 0 and total_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            total_weight += weight_lst[idx]\n        elif base_solution[idx] == 1:\n            new_solution[idx] = 0\n            total_weight -= weight_lst[idx]\n            if total_weight < 0:  # Ensure non-negative weight\n                total_weight = 0\n\n    return new_solution\n\n",
        "score": [
            -0.8194807884543565,
            6.180204063653946
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: np.sum(x[0]) * (np.sum(value1_lst) + np.sum(value2_lst)))\n\n    # Generate a neighbor by flipping items with high marginal contribution\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Calculate marginal contributions\n    marginal1 = value1_lst / weight_lst\n    marginal2 = value2_lst / weight_lst\n    combined_marginal = marginal1 + marginal2\n\n    # Sort items by combined marginal contribution\n    item_indices = np.argsort(combined_marginal)[::-1]\n\n    # Flip top items that can be added without exceeding capacity\n    for idx in item_indices:\n        if base_solution[idx] == 0 and total_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            total_weight += weight_lst[idx]\n        elif base_solution[idx] == 1:\n            new_solution[idx] = 0\n            total_weight -= weight_lst[idx]\n            if total_weight < 0:  # Ensure non-negative weight\n                total_weight = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 283,
        "algorithm": "{This algorithm selects a promising solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines adaptive item swaps and probabilistic flips to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we prioritize solutions with high total value)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_idx = min(len(archive_sorted) - 1, int(len(archive_sorted) * 0.2))  # Top 20% of solutions\n    selected = archive_sorted[selected_idx]\n    base_solution = selected[0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 1: Adaptive item swaps (swap items with high marginal value)\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 1:\n        i, j = random.sample(list(swap_candidates), 2)\n        if (current_weight - weight_lst[i] + weight_lst[j] <= capacity and\n            current_weight - weight_lst[j] + weight_lst[i] <= capacity):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Probabilistic flips (flip items with high marginal value)\n    for i in range(len(new_solution)):\n        if random.random() < 0.3:  # 30% chance to flip\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.45438011003636136,
            2.06324565410614
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we prioritize solutions with high total value)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_idx = min(len(archive_sorted) - 1, int(len(archive_sorted) * 0.2))  # Top 20% of solutions\n    selected = archive_sorted[selected_idx]\n    base_solution = selected[0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 1: Adaptive item swaps (swap items with high marginal value)\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) > 1:\n        i, j = random.sample(list(swap_candidates), 2)\n        if (current_weight - weight_lst[i] + weight_lst[j] <= capacity and\n            current_weight - weight_lst[j] + weight_lst[i] <= capacity):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Probabilistic flips (flip items with high marginal value)\n    for i in range(len(new_solution)):\n        if random.random() < 0.3:  # 30% chance to flip\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 284,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a solution from the archive, applies a randomized perturbation to explore high-potential regions, and uses a dynamic swap strategy to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol[0] for sol in archive]\n    archive_values = np.array([sol[1] for sol in archive])\n\n    # Calculate potential for improvement (difference from max values)\n    max_value1 = np.max(archive_values[:, 0])\n    max_value2 = np.max(archive_values[:, 1])\n    potential = (max_value1 - archive_values[:, 0]) + (max_value2 - archive_values[:, 1])\n    selected_idx = np.argmax(potential)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select a subset of items to perturb\n    perturb_indices = np.random.choice(len(new_solution), size=min(5, len(new_solution)), replace=False)\n    for i in perturb_indices:\n        if new_solution[i] == 1:\n            # Try to remove the item if it doesn't violate capacity\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            # Try to add the item if it doesn't violate capacity\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Apply a dynamic swap strategy to improve both objectives\n    for _ in range(3):  # Limit the number of swaps\n        # Identify items not in the solution with high value ratios\n        candidates = np.where(new_solution == 0)[0]\n        if len(candidates) == 0:\n            break\n        value_ratio1 = value1_lst[candidates] / (weight_lst[candidates] + 1e-6)\n        value_ratio2 = value2_lst[candidates] / (weight_lst[candidates] + 1e-6)\n        combined_ratio = value_ratio1 + value_ratio2\n        best_candidate = candidates[np.argmax(combined_ratio)]\n\n        # If adding the best candidate doesn't violate capacity, swap it in\n        if current_weight + weight_lst[best_candidate] <= capacity:\n            new_solution[best_candidate] = 1\n            current_weight += weight_lst[best_candidate]\n\n    return new_solution\n\n",
        "score": [
            -0.8840985443619238,
            2.5634419322013855
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol[0] for sol in archive]\n    archive_values = np.array([sol[1] for sol in archive])\n\n    # Calculate potential for improvement (difference from max values)\n    max_value1 = np.max(archive_values[:, 0])\n    max_value2 = np.max(archive_values[:, 1])\n    potential = (max_value1 - archive_values[:, 0]) + (max_value2 - archive_values[:, 1])\n    selected_idx = np.argmax(potential)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select a subset of items to perturb\n    perturb_indices = np.random.choice(len(new_solution), size=min(5, len(new_solution)), replace=False)\n    for i in perturb_indices:\n        if new_solution[i] == 1:\n            # Try to remove the item if it doesn't violate capacity\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            # Try to add the item if it doesn't violate capacity\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Apply a dynamic swap strategy to improve both objectives\n    for _ in range(3):  # Limit the number of swaps\n        # Identify items not in the solution with high value ratios\n        candidates = np.where(new_solution == 0)[0]\n        if len(candidates) == 0:\n            break\n        value_ratio1 = value1_lst[candidates] / (weight_lst[candidates] + 1e-6)\n        value_ratio2 = value2_lst[candidates] / (weight_lst[candidates] + 1e-6)\n        combined_ratio = value_ratio1 + value_ratio2\n        best_candidate = candidates[np.argmax(combined_ratio)]\n\n        # If adding the best candidate doesn't violate capacity, swap it in\n        if current_weight + weight_lst[best_candidate] <= capacity:\n            new_solution[best_candidate] = 1\n            current_weight += weight_lst[best_candidate]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 285,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive by prioritizing those with high objective values and low crowding distance, then applies a hybrid local search that combines item swaps with a probabilistic neighborhood exploration to generate a feasible neighbor solution with improved or diverse objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Step 1: Intelligently select a promising solution\n    # Sort solutions by objective values (prioritize high values)\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][0], -x[1][1]))\n\n    # Select top 20% solutions to consider for selection\n    top_k = max(1, len(archive_sorted) // 5)\n    candidates = archive_sorted[:top_k]\n\n    # Randomly select one solution with probability proportional to its rank\n    weights = [1.0 / (i + 1) for i in range(len(candidates))]\n    selected_idx = random.choices(range(len(candidates)), weights=weights, k=1)[0]\n    base_solution = candidates[selected_idx][0].copy()\n    current_value1, current_value2 = candidates[selected_idx][1]\n\n    # Step 2: Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Strategy 1: Probabilistic item swaps (exploration)\n    for _ in range(5):  # Limit the number of attempts\n        # Randomly select two items to swap\n        item1, item2 = random.sample(range(len(weight_lst)), 2)\n\n        # Calculate new weight if we swap the items\n        new_weight = current_weight - weight_lst[item1] * new_solution[item1] + weight_lst[item2] * (1 - new_solution[item2])\n\n        if new_weight <= capacity:\n            # Perform the swap\n            new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n            current_weight = new_weight\n\n    # Strategy 2: Add or remove items with high marginal gain\n    # Calculate marginal gains for each item\n    marginal_gains = []\n    for i in range(len(weight_lst)):\n        if new_solution[i] == 1:\n            # Marginal gain for removal\n            marginal_gain = (-value1_lst[i], -value2_lst[i])\n        else:\n            # Marginal gain for addition\n            if current_weight + weight_lst[i] <= capacity:\n                marginal_gain = (value1_lst[i], value2_lst[i])\n            else:\n                marginal_gain = (0, 0)\n        marginal_gains.append(marginal_gain)\n\n    # Select top 3 items with highest marginal gains (considering both objectives)\n    top_items = sorted(range(len(marginal_gains)),\n                      key=lambda x: (-marginal_gains[x][0], -marginal_gains[x][1]))[:3]\n\n    for item in top_items:\n        if new_solution[item] == 1:\n            # Remove item if it's in the solution\n            new_solution[item] = 0\n        else:\n            # Add item if it's not in the solution and feasible\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.3153586490920387,
            5.179766207933426
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Step 1: Intelligently select a promising solution\n    # Sort solutions by objective values (prioritize high values)\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][0], -x[1][1]))\n\n    # Select top 20% solutions to consider for selection\n    top_k = max(1, len(archive_sorted) // 5)\n    candidates = archive_sorted[:top_k]\n\n    # Randomly select one solution with probability proportional to its rank\n    weights = [1.0 / (i + 1) for i in range(len(candidates))]\n    selected_idx = random.choices(range(len(candidates)), weights=weights, k=1)[0]\n    base_solution = candidates[selected_idx][0].copy()\n    current_value1, current_value2 = candidates[selected_idx][1]\n\n    # Step 2: Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Strategy 1: Probabilistic item swaps (exploration)\n    for _ in range(5):  # Limit the number of attempts\n        # Randomly select two items to swap\n        item1, item2 = random.sample(range(len(weight_lst)), 2)\n\n        # Calculate new weight if we swap the items\n        new_weight = current_weight - weight_lst[item1] * new_solution[item1] + weight_lst[item2] * (1 - new_solution[item2])\n\n        if new_weight <= capacity:\n            # Perform the swap\n            new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n            current_weight = new_weight\n\n    # Strategy 2: Add or remove items with high marginal gain\n    # Calculate marginal gains for each item\n    marginal_gains = []\n    for i in range(len(weight_lst)):\n        if new_solution[i] == 1:\n            # Marginal gain for removal\n            marginal_gain = (-value1_lst[i], -value2_lst[i])\n        else:\n            # Marginal gain for addition\n            if current_weight + weight_lst[i] <= capacity:\n                marginal_gain = (value1_lst[i], value2_lst[i])\n            else:\n                marginal_gain = (0, 0)\n        marginal_gains.append(marginal_gain)\n\n    # Select top 3 items with highest marginal gains (considering both objectives)\n    top_items = sorted(range(len(marginal_gains)),\n                      key=lambda x: (-marginal_gains[x][0], -marginal_gains[x][1]))[:3]\n\n    for item in top_items:\n        if new_solution[item] == 1:\n            # Remove item if it's in the solution\n            new_solution[item] = 0\n        else:\n            # Add item if it's not in the solution and feasible\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 286,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify items that can be flipped (added or removed) without violating capacity\n    feasible_indices = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1 and (current_weight - weight_lst[i]) <= capacity:\n            feasible_indices.append(i)\n        elif base_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity:\n            feasible_indices.append(i)\n\n    if not feasible_indices:\n        return base_solution.copy()  # No feasible moves, return original\n\n    # Select a random item to flip\n    flip_idx = np.random.choice(feasible_indices)\n    new_solution = base_solution.copy()\n    new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    # Apply a hybrid local search: flip multiple items based on value density\n    if np.random.random() < 0.3:  # 30% chance for hybrid move\n        # Calculate value densities for each objective\n        density1 = value1_lst / weight_lst\n        density2 = value2_lst / weight_lst\n\n        # Sort items by combined density (weighted sum)\n        combined_density = 0.5 * density1 + 0.5 * density2\n        sorted_indices = np.argsort(-combined_density)\n\n        # Try to add top items not already in the solution\n        for i in sorted_indices:\n            if new_solution[i] == 0 and (np.sum(weight_lst * new_solution) + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n\n        # Try to remove bottom items in the solution\n        for i in reversed(sorted_indices):\n            if new_solution[i] == 1 and (np.sum(weight_lst * new_solution) - weight_lst[i]) <= capacity:\n                new_solution[i] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.805435234975332,
            8.417586833238602
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify items that can be flipped (added or removed) without violating capacity\n    feasible_indices = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1 and (current_weight - weight_lst[i]) <= capacity:\n            feasible_indices.append(i)\n        elif base_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity:\n            feasible_indices.append(i)\n\n    if not feasible_indices:\n        return base_solution.copy()  # No feasible moves, return original\n\n    # Select a random item to flip\n    flip_idx = np.random.choice(feasible_indices)\n    new_solution = base_solution.copy()\n    new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    # Apply a hybrid local search: flip multiple items based on value density\n    if np.random.random() < 0.3:  # 30% chance for hybrid move\n        # Calculate value densities for each objective\n        density1 = value1_lst / weight_lst\n        density2 = value2_lst / weight_lst\n\n        # Sort items by combined density (weighted sum)\n        combined_density = 0.5 * density1 + 0.5 * density2\n        sorted_indices = np.argsort(-combined_density)\n\n        # Try to add top items not already in the solution\n        for i in sorted_indices:\n            if new_solution[i] == 0 and (np.sum(weight_lst * new_solution) + weight_lst[i]) <= capacity:\n                new_solution[i] = 1\n\n        # Try to remove bottom items in the solution\n        for i in reversed(sorted_indices):\n            if new_solution[i] == 1 and (np.sum(weight_lst * new_solution) - weight_lst[i]) <= capacity:\n                new_solution[i] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 287,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Select solutions with the highest combined objective values\n        combined_scores = [sum(obj) for (sol, obj) in archive]\n        selected_idx = np.argmax(combined_scores)\n        base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: flip a subset of items based on value-to-weight ratio\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate value-to-weight ratios for all items\n    v1_ratio = value1_lst / weight_lst\n    v2_ratio = value2_lst / weight_lst\n\n    # Select items to flip based on the highest combined ratio\n    combined_ratio = v1_ratio + v2_ratio\n    sorted_indices = np.argsort(-combined_ratio)  # Descending order\n\n    # Flip top k items (k is randomly chosen between 1 and min(5, number of items))\n    k = np.random.randint(1, min(5, len(weight_lst)) + 1)\n    for idx in sorted_indices[:k]:\n        if new_solution[idx] == 1:\n            # Remove item if it exists\n            if total_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            # Add item if it fits\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8627832986012645,
            2.0611961483955383
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Select solutions with the highest combined objective values\n        combined_scores = [sum(obj) for (sol, obj) in archive]\n        selected_idx = np.argmax(combined_scores)\n        base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: flip a subset of items based on value-to-weight ratio\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate value-to-weight ratios for all items\n    v1_ratio = value1_lst / weight_lst\n    v2_ratio = value2_lst / weight_lst\n\n    # Select items to flip based on the highest combined ratio\n    combined_ratio = v1_ratio + v2_ratio\n    sorted_indices = np.argsort(-combined_ratio)  # Descending order\n\n    # Flip top k items (k is randomly chosen between 1 and min(5, number of items))\n    k = np.random.randint(1, min(5, len(weight_lst)) + 1)\n    for idx in sorted_indices[:k]:\n        if new_solution[idx] == 1:\n            # Remove item if it exists\n            if total_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            # Add item if it fits\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 288,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0))\n    scores = normalized.sum(axis=1)\n    base_idx = np.argmax(scores)\n    base_solution = archive[base_idx][0].copy()\n\n    # Calculate current weight and potential items to flip\n    current_weight = np.sum(weight_lst * base_solution)\n    potential_items = np.where(base_solution == 0)[0]\n\n    if len(potential_items) == 0:\n        return base_solution  # No items to add\n\n    # Select a random item to add, ensuring feasibility\n    np.random.shuffle(potential_items)\n    for item in potential_items:\n        if current_weight + weight_lst[item] <= capacity:\n            new_solution = base_solution.copy()\n            new_solution[item] = 1\n            return new_solution\n\n    # If no addition possible, try removing items to make space\n    current_items = np.where(base_solution == 1)[0]\n    if len(current_items) == 0:\n        return base_solution  # No items to remove\n\n    np.random.shuffle(current_items)\n    for item in current_items:\n        new_solution = base_solution.copy()\n        new_solution[item] = 0\n        remaining_weight = current_weight - weight_lst[item]\n        # Try adding any previously excluded item\n        for add_item in potential_items:\n            if remaining_weight + weight_lst[add_item] <= capacity:\n                new_solution[add_item] = 1\n                return new_solution\n\n    return base_solution  # No improvement possible\n\n",
        "score": [
            -0.33501151380688177,
            2.930110603570938
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0))\n    scores = normalized.sum(axis=1)\n    base_idx = np.argmax(scores)\n    base_solution = archive[base_idx][0].copy()\n\n    # Calculate current weight and potential items to flip\n    current_weight = np.sum(weight_lst * base_solution)\n    potential_items = np.where(base_solution == 0)[0]\n\n    if len(potential_items) == 0:\n        return base_solution  # No items to add\n\n    # Select a random item to add, ensuring feasibility\n    np.random.shuffle(potential_items)\n    for item in potential_items:\n        if current_weight + weight_lst[item] <= capacity:\n            new_solution = base_solution.copy()\n            new_solution[item] = 1\n            return new_solution\n\n    # If no addition possible, try removing items to make space\n    current_items = np.where(base_solution == 1)[0]\n    if len(current_items) == 0:\n        return base_solution  # No items to remove\n\n    np.random.shuffle(current_items)\n    for item in current_items:\n        new_solution = base_solution.copy()\n        new_solution[item] = 0\n        remaining_weight = current_weight - weight_lst[item]\n        # Try adding any previously excluded item\n        for add_item in potential_items:\n            if remaining_weight + weight_lst[add_item] <= capacity:\n                new_solution[add_item] = 1\n                return new_solution\n\n    return base_solution  # No improvement possible\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 289,
        "algorithm": "{This heuristic function selects a promising solution from the archive by prioritizing those with the highest average objective values, then applies a novel hybrid local search operator that combines item swaps with probabilistic exploration of neighboring solutions to escape local optima while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (highest average objective value)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2, reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: probabilistic item swaps with feasibility check\n    num_items = len(base_solution)\n    for _ in range(min(5, num_items)):  # Limit the number of attempts\n        # Randomly select two distinct items\n        i, j = random.sample(range(num_items), 2)\n\n        # Calculate the effect of swapping\n        old_weight = np.sum(weight_lst[base_solution == 1])\n        new_weight = old_weight - weight_lst[i] + weight_lst[j] if base_solution[i] else old_weight + weight_lst[j] - weight_lst[i]\n\n        if new_weight <= capacity:\n            # Accept the swap with probability based on value improvement\n            old_value1 = np.sum(value1_lst[base_solution == 1])\n            old_value2 = np.sum(value2_lst[base_solution == 1])\n\n            new_value1 = old_value1 - value1_lst[i] + value1_lst[j] if base_solution[i] else old_value1 + value1_lst[j] - value1_lst[i]\n            new_value2 = old_value2 - value2_lst[i] + value2_lst[j] if base_solution[i] else old_value2 + value2_lst[j] - value2_lst[i]\n\n            # Probability of accepting the swap is higher if it improves both objectives\n            improvement = (new_value1 - old_value1) + (new_value2 - old_value2)\n            if improvement > 0 or random.random() < 0.3:  # 30% chance to accept even if no improvement\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Apply probabilistic exploration (flip a random bit if feasible)\n    if random.random() < 0.2:  # 20% chance to explore\n        i = random.randint(0, num_items - 1)\n        if base_solution[i] == 1:\n            if np.sum(weight_lst[base_solution == 1]) - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n        else:\n            if np.sum(weight_lst[base_solution == 1]) + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.29181378182313733,
            4.636238008737564
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (highest average objective value)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2, reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: probabilistic item swaps with feasibility check\n    num_items = len(base_solution)\n    for _ in range(min(5, num_items)):  # Limit the number of attempts\n        # Randomly select two distinct items\n        i, j = random.sample(range(num_items), 2)\n\n        # Calculate the effect of swapping\n        old_weight = np.sum(weight_lst[base_solution == 1])\n        new_weight = old_weight - weight_lst[i] + weight_lst[j] if base_solution[i] else old_weight + weight_lst[j] - weight_lst[i]\n\n        if new_weight <= capacity:\n            # Accept the swap with probability based on value improvement\n            old_value1 = np.sum(value1_lst[base_solution == 1])\n            old_value2 = np.sum(value2_lst[base_solution == 1])\n\n            new_value1 = old_value1 - value1_lst[i] + value1_lst[j] if base_solution[i] else old_value1 + value1_lst[j] - value1_lst[i]\n            new_value2 = old_value2 - value2_lst[i] + value2_lst[j] if base_solution[i] else old_value2 + value2_lst[j] - value2_lst[i]\n\n            # Probability of accepting the swap is higher if it improves both objectives\n            improvement = (new_value1 - old_value1) + (new_value2 - old_value2)\n            if improvement > 0 or random.random() < 0.3:  # 30% chance to accept even if no improvement\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Apply probabilistic exploration (flip a random bit if feasible)\n    if random.random() < 0.2:  # 20% chance to explore\n        i = random.randint(0, num_items - 1)\n        if base_solution[i] == 1:\n            if np.sum(weight_lst[base_solution == 1]) - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n        else:\n            if np.sum(weight_lst[base_solution == 1]) + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 290,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive by prioritizing those with high objective values and high diversity, then applies a hybrid local search combining random item swaps and value-based perturbations to generate a feasible neighbor solution while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution from the archive\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[(obj[0] + obj[1]) * (1 + np.sum(sol)) for (sol, obj) in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine random swaps and value-based perturbations\n    for _ in range(3):  # Number of perturbation steps\n        # Random swap with probability based on value\n        if random.random() < 0.7:\n            # Select items with high value1 and low weight\n            candidates = np.where((value1_lst > np.median(value1_lst)) & (weight_lst < capacity/2))[0]\n            if len(candidates) > 0:\n                item = random.choice(candidates)\n                new_solution[item] = 1 - new_solution[item]\n                if np.dot(new_solution, weight_lst) > capacity:\n                    new_solution[item] = 1 - new_solution[item]\n\n        # Value-based perturbation for objective 2\n        if random.random() < 0.5:\n            # Select items with high value2 and low weight\n            candidates = np.where((value2_lst > np.median(value2_lst)) & (weight_lst < capacity/2))[0]\n            if len(candidates) > 0:\n                item = random.choice(candidates)\n                new_solution[item] = 1 - new_solution[item]\n                if np.dot(new_solution, weight_lst) > capacity:\n                    new_solution[item] = 1 - new_solution[item]\n\n    # Ensure feasibility\n    while np.dot(new_solution, weight_lst) > capacity:\n        # Remove items with lowest value1/value2 ratio until feasible\n        ratios = (value1_lst + value2_lst) / weight_lst\n        ratios[new_solution == 0] = np.inf\n        item_to_remove = np.argmin(ratios)\n        new_solution[item_to_remove] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.47231871179747065,
            6.272249132394791
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution from the archive\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[(obj[0] + obj[1]) * (1 + np.sum(sol)) for (sol, obj) in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine random swaps and value-based perturbations\n    for _ in range(3):  # Number of perturbation steps\n        # Random swap with probability based on value\n        if random.random() < 0.7:\n            # Select items with high value1 and low weight\n            candidates = np.where((value1_lst > np.median(value1_lst)) & (weight_lst < capacity/2))[0]\n            if len(candidates) > 0:\n                item = random.choice(candidates)\n                new_solution[item] = 1 - new_solution[item]\n                if np.dot(new_solution, weight_lst) > capacity:\n                    new_solution[item] = 1 - new_solution[item]\n\n        # Value-based perturbation for objective 2\n        if random.random() < 0.5:\n            # Select items with high value2 and low weight\n            candidates = np.where((value2_lst > np.median(value2_lst)) & (weight_lst < capacity/2))[0]\n            if len(candidates) > 0:\n                item = random.choice(candidates)\n                new_solution[item] = 1 - new_solution[item]\n                if np.dot(new_solution, weight_lst) > capacity:\n                    new_solution[item] = 1 - new_solution[item]\n\n    # Ensure feasibility\n    while np.dot(new_solution, weight_lst) > capacity:\n        # Remove items with lowest value1/value2 ratio until feasible\n        ratios = (value1_lst + value2_lst) / weight_lst\n        ratios[new_solution == 0] = np.inf\n        item_to_remove = np.argmin(ratios)\n        new_solution[item_to_remove] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 291,
        "algorithm": "{This algorithm intelligently selects a non-dominated solution from the archive based on its diversity and potential for improvement, then applies a hybrid local search strategy combining item swapping and strategic flipping to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (low crowding distance or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: swap items with high potential and flip strategically\n    for _ in range(10):  # Perform multiple swaps/flips\n        # Identify candidate items to swap or flip\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Potential swap: replace one included item with one excluded item\n            swap_in = random.choice(excluded)\n            swap_out = random.choice(included)\n\n            # Check if swap is feasible\n            new_weight = current_weight - weight_lst[swap_out] + weight_lst[swap_in]\n            if new_weight <= capacity:\n                new_solution[swap_out] = 0\n                new_solution[swap_in] = 1\n                current_weight = new_weight\n                continue\n\n        # If swap not possible, try flipping a single item\n        if len(included) > 0:\n            flip_item = random.choice(included)\n            if current_weight - weight_lst[flip_item] <= capacity:\n                new_solution[flip_item] = 0\n                current_weight -= weight_lst[flip_item]\n\n    return new_solution\n\n",
        "score": [
            -0.48463627385473046,
            2.5456468164920807
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (low crowding distance or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: swap items with high potential and flip strategically\n    for _ in range(10):  # Perform multiple swaps/flips\n        # Identify candidate items to swap or flip\n        included = np.where(base_solution == 1)[0]\n        excluded = np.where(base_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Potential swap: replace one included item with one excluded item\n            swap_in = random.choice(excluded)\n            swap_out = random.choice(included)\n\n            # Check if swap is feasible\n            new_weight = current_weight - weight_lst[swap_out] + weight_lst[swap_in]\n            if new_weight <= capacity:\n                new_solution[swap_out] = 0\n                new_solution[swap_in] = 1\n                current_weight = new_weight\n                continue\n\n        # If swap not possible, try flipping a single item\n        if len(included) > 0:\n            flip_item = random.choice(included)\n            if current_weight - weight_lst[flip_item] <= capacity:\n                new_solution[flip_item] = 0\n                current_weight -= weight_lst[flip_item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 292,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * selected_solution)\n\n    # Identify items that can be swapped (either in or out) while maintaining feasibility\n    candidate_items = []\n    for i in range(len(selected_solution)):\n        if selected_solution[i] == 1:\n            # Check if removing this item keeps the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                candidate_items.append((i, -1))  # -1 indicates removal\n        else:\n            # Check if adding this item keeps the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                candidate_items.append((i, 1))  # 1 indicates addition\n\n    if not candidate_items:\n        return selected_solution  # No feasible changes possible\n\n    # Select a random candidate item to modify\n    item_idx, change = random.choice(candidate_items)\n\n    # Create the new solution\n    new_solution = selected_solution.copy()\n    new_solution[item_idx] = 1 if change == 1 else 0\n\n    # Apply a secondary heuristic: if adding an item, try to add more items with high value ratios\n    if change == 1:\n        remaining_capacity = capacity - np.sum(weight_lst * new_solution)\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)  # Avoid division by zero\n        sorted_items = np.argsort(-value_ratios)  # Sort by descending value ratio\n\n        for i in sorted_items:\n            if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8069401661337428,
            2.0490737855434418
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * selected_solution)\n\n    # Identify items that can be swapped (either in or out) while maintaining feasibility\n    candidate_items = []\n    for i in range(len(selected_solution)):\n        if selected_solution[i] == 1:\n            # Check if removing this item keeps the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                candidate_items.append((i, -1))  # -1 indicates removal\n        else:\n            # Check if adding this item keeps the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                candidate_items.append((i, 1))  # 1 indicates addition\n\n    if not candidate_items:\n        return selected_solution  # No feasible changes possible\n\n    # Select a random candidate item to modify\n    item_idx, change = random.choice(candidate_items)\n\n    # Create the new solution\n    new_solution = selected_solution.copy()\n    new_solution[item_idx] = 1 if change == 1 else 0\n\n    # Apply a secondary heuristic: if adding an item, try to add more items with high value ratios\n    if change == 1:\n        remaining_capacity = capacity - np.sum(weight_lst * new_solution)\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)  # Avoid division by zero\n        sorted_items = np.argsort(-value_ratios)  # Sort by descending value ratio\n\n        for i in sorted_items:\n            if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 293,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects promising solutions from the archive, applies a weighted random swap of items based on their marginal contributions to both objectives, and ensures feasibility by dynamically adjusting the selection to respect the capacity constraint.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    base_value1, base_value2 = archive[selected_idx][1]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Identify items to consider for swap (those not in the solution)\n    candidate_items = np.where(base_solution == 0)[0]\n\n    # If no items to add, try removing some\n    if len(candidate_items) == 0:\n        candidate_items = np.where(base_solution == 1)[0]\n\n    # Calculate marginal contributions for each candidate item\n    marginal_weights = weight_lst[candidate_items]\n    marginal_value1 = value1_lst[candidate_items]\n    marginal_value2 = value2_lst[candidate_items]\n\n    # Normalize marginal contributions\n    norm_marginal = np.sqrt(marginal_value1**2 + marginal_value2**2)\n\n    # Weighted random selection based on marginal contributions\n    if len(norm_marginal) > 0:\n        probabilities = norm_marginal / np.sum(norm_marginal)\n        selected_item = np.random.choice(candidate_items, p=probabilities)\n    else:\n        selected_item = random.choice(candidate_items)\n\n    # Determine if we're adding or removing the item\n    if base_solution[selected_item] == 0:\n        # Adding an item\n        if current_weight + weight_lst[selected_item] <= capacity:\n            new_solution[selected_item] = 1\n        else:\n            # If adding would exceed capacity, try removing an item instead\n            remove_candidates = np.where(base_solution == 1)[0]\n            if len(remove_candidates) > 0:\n                remove_item = random.choice(remove_candidates)\n                new_solution[remove_item] = 0\n    else:\n        # Removing an item\n        new_solution[selected_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.9245075728729961,
            1.7841967344284058
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    base_value1, base_value2 = archive[selected_idx][1]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Identify items to consider for swap (those not in the solution)\n    candidate_items = np.where(base_solution == 0)[0]\n\n    # If no items to add, try removing some\n    if len(candidate_items) == 0:\n        candidate_items = np.where(base_solution == 1)[0]\n\n    # Calculate marginal contributions for each candidate item\n    marginal_weights = weight_lst[candidate_items]\n    marginal_value1 = value1_lst[candidate_items]\n    marginal_value2 = value2_lst[candidate_items]\n\n    # Normalize marginal contributions\n    norm_marginal = np.sqrt(marginal_value1**2 + marginal_value2**2)\n\n    # Weighted random selection based on marginal contributions\n    if len(norm_marginal) > 0:\n        probabilities = norm_marginal / np.sum(norm_marginal)\n        selected_item = np.random.choice(candidate_items, p=probabilities)\n    else:\n        selected_item = random.choice(candidate_items)\n\n    # Determine if we're adding or removing the item\n    if base_solution[selected_item] == 0:\n        # Adding an item\n        if current_weight + weight_lst[selected_item] <= capacity:\n            new_solution[selected_item] = 1\n        else:\n            # If adding would exceed capacity, try removing an item instead\n            remove_candidates = np.where(base_solution == 1)[0]\n            if len(remove_candidates) > 0:\n                remove_item = random.choice(remove_candidates)\n                new_solution[remove_item] = 0\n    else:\n        # Removing an item\n        new_solution[selected_item] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 294,
        "algorithm": "{The algorithm first selects a promising solution from the archive by prioritizing those with high objective values and low weights, then applies a hybrid local search combining random flips and objective-driven swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its objective values\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_obj = objectives / objectives.sum(axis=0, keepdims=True)\n    probs = normalized_obj.mean(axis=1)\n    probs = probs / probs.sum()\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Calculate current total weight\n    total_weight = np.sum(weight_lst * base_solution)\n\n    # Generate neighbor by hybrid local search\n    new_solution = base_solution.copy()\n\n    # Random flip with feasibility check\n    for _ in range(3):  # Try 3 random flips\n        item = random.randint(0, len(weight_lst) - 1)\n        if new_solution[item] == 1:\n            if total_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                total_weight -= weight_lst[item]\n        else:\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Objective-driven swap\n    for _ in range(2):  # Try 2 swaps\n        # Find items not in solution with high potential\n        candidate_items = np.where(new_solution == 0)[0]\n        if len(candidate_items) == 0:\n            break\n        # Sort by value1 + value2\n        scores = value1_lst[candidate_items] + value2_lst[candidate_items]\n        sorted_items = candidate_items[np.argsort(scores)[::-1]]\n\n        for item in sorted_items[:3]:  # Consider top 3 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.37380485219137655,
            4.398363947868347
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its objective values\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_obj = objectives / objectives.sum(axis=0, keepdims=True)\n    probs = normalized_obj.mean(axis=1)\n    probs = probs / probs.sum()\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Calculate current total weight\n    total_weight = np.sum(weight_lst * base_solution)\n\n    # Generate neighbor by hybrid local search\n    new_solution = base_solution.copy()\n\n    # Random flip with feasibility check\n    for _ in range(3):  # Try 3 random flips\n        item = random.randint(0, len(weight_lst) - 1)\n        if new_solution[item] == 1:\n            if total_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                total_weight -= weight_lst[item]\n        else:\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n\n    # Objective-driven swap\n    for _ in range(2):  # Try 2 swaps\n        # Find items not in solution with high potential\n        candidate_items = np.where(new_solution == 0)[0]\n        if len(candidate_items) == 0:\n            break\n        # Sort by value1 + value2\n        scores = value1_lst[candidate_items] + value2_lst[candidate_items]\n        sorted_items = candidate_items[np.argsort(scores)[::-1]]\n\n        for item in sorted_items[:3]:  # Consider top 3 items\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 295,
        "algorithm": "{The algorithm intelligently selects a solution from the archive by prioritizing those with high objective values and low weight utilization, then applies a hybrid local search combining randomized item swaps and adaptive neighborhood exploration to generate a feasible neighbor solution with improved multi-objective trade-offs.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate potential scores for each solution (weighted sum of objectives and weight utilization)\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        utilization = total_weight / capacity\n        score = (obj[0] + obj[1]) * (1 - utilization)  # Prefer high value and low weight utilization\n        scores.append(score)\n\n    # Select top 3 solutions based on scores\n    top_indices = np.argsort(scores)[-3:][::-1]\n    selected_idx = random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Randomly select a subset of items to consider for swap\n    k = min(5, n_items)  # Number of items to consider for swap\n    candidate_indices = random.sample(range(n_items), k)\n\n    # Try to swap items in the candidate set\n    for i in candidate_indices:\n        if new_solution[i] == 1:\n            # Try removing item i\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            temp_weight = np.sum(weight_lst * temp_solution)\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n        else:\n            # Try adding item i\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 1\n            temp_weight = np.sum(weight_lst * temp_solution)\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n    # If no improvement, try a more aggressive move: flip a random subset\n    if np.array_equal(new_solution, base_solution):\n        # Randomly flip a small subset of items\n        flip_indices = random.sample(range(n_items), min(3, n_items))\n        for i in flip_indices:\n            new_solution[i] = 1 - new_solution[i]\n        # Ensure feasibility\n        total_weight = np.sum(weight_lst * new_solution)\n        if total_weight > capacity:\n            # Remove items until feasible\n            items_in_solution = np.where(new_solution == 1)[0]\n            np.random.shuffle(items_in_solution)\n            for i in items_in_solution:\n                new_solution[i] = 0\n                total_weight = np.sum(weight_lst * new_solution)\n                if total_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.613259778554409,
            2.5740902423858643
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate potential scores for each solution (weighted sum of objectives and weight utilization)\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        utilization = total_weight / capacity\n        score = (obj[0] + obj[1]) * (1 - utilization)  # Prefer high value and low weight utilization\n        scores.append(score)\n\n    # Select top 3 solutions based on scores\n    top_indices = np.argsort(scores)[-3:][::-1]\n    selected_idx = random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Randomly select a subset of items to consider for swap\n    k = min(5, n_items)  # Number of items to consider for swap\n    candidate_indices = random.sample(range(n_items), k)\n\n    # Try to swap items in the candidate set\n    for i in candidate_indices:\n        if new_solution[i] == 1:\n            # Try removing item i\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            temp_weight = np.sum(weight_lst * temp_solution)\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n        else:\n            # Try adding item i\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 1\n            temp_weight = np.sum(weight_lst * temp_solution)\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                break\n\n    # If no improvement, try a more aggressive move: flip a random subset\n    if np.array_equal(new_solution, base_solution):\n        # Randomly flip a small subset of items\n        flip_indices = random.sample(range(n_items), min(3, n_items))\n        for i in flip_indices:\n            new_solution[i] = 1 - new_solution[i]\n        # Ensure feasibility\n        total_weight = np.sum(weight_lst * new_solution)\n        if total_weight > capacity:\n            # Remove items until feasible\n            items_in_solution = np.where(new_solution == 1)[0]\n            np.random.shuffle(items_in_solution)\n            for i in items_in_solution:\n                new_solution[i] = 0\n                total_weight = np.sum(weight_lst * new_solution)\n                if total_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 296,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate a score for each solution based on its objective values and diversity\n    scores = []\n    for sol, (v1, v2) in archive:\n        # Score is a weighted sum of normalized objectives and a diversity term\n        norm_v1 = v1 / (np.sum(value1_lst) + 1e-6)\n        norm_v2 = v2 / (np.sum(value2_lst) + 1e-6)\n        diversity = np.sum(sol) / len(sol)  # Fraction of items selected\n        score = 0.6 * (norm_v1 + norm_v2) + 0.4 * diversity\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search: flip a subset of items based on marginal gains\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    current_v1 = np.sum(value1_lst * base_solution)\n    current_v2 = np.sum(value2_lst * base_solution)\n\n    # Identify items to flip: those with high marginal gain in either objective\n    marginal_gains_v1 = (value1_lst - np.mean(value1_lst)) / (weight_lst + 1e-6)\n    marginal_gains_v2 = (value2_lst - np.mean(value2_lst)) / (weight_lst + 1e-6)\n    combined_gains = marginal_gains_v1 + marginal_gains_v2\n\n    # Sort items by combined marginal gains and select top candidates\n    candidate_indices = np.argsort(-combined_gains)[:max(1, len(combined_gains) // 5)]\n    np.random.shuffle(candidate_indices)  # Add randomness\n\n    for idx in candidate_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                current_v1 -= value1_lst[idx]\n                current_v2 -= value2_lst[idx]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                current_v1 += value1_lst[idx]\n                current_v2 += value2_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.4306664019230787,
            4.516296207904816
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate a score for each solution based on its objective values and diversity\n    scores = []\n    for sol, (v1, v2) in archive:\n        # Score is a weighted sum of normalized objectives and a diversity term\n        norm_v1 = v1 / (np.sum(value1_lst) + 1e-6)\n        norm_v2 = v2 / (np.sum(value2_lst) + 1e-6)\n        diversity = np.sum(sol) / len(sol)  # Fraction of items selected\n        score = 0.6 * (norm_v1 + norm_v2) + 0.4 * diversity\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search: flip a subset of items based on marginal gains\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    current_v1 = np.sum(value1_lst * base_solution)\n    current_v2 = np.sum(value2_lst * base_solution)\n\n    # Identify items to flip: those with high marginal gain in either objective\n    marginal_gains_v1 = (value1_lst - np.mean(value1_lst)) / (weight_lst + 1e-6)\n    marginal_gains_v2 = (value2_lst - np.mean(value2_lst)) / (weight_lst + 1e-6)\n    combined_gains = marginal_gains_v1 + marginal_gains_v2\n\n    # Sort items by combined marginal gains and select top candidates\n    candidate_indices = np.argsort(-combined_gains)[:max(1, len(combined_gains) // 5)]\n    np.random.shuffle(candidate_indices)  # Add randomness\n\n    for idx in candidate_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                current_v1 -= value1_lst[idx]\n                current_v2 -= value2_lst[idx]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                current_v1 += value1_lst[idx]\n                current_v2 += value2_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 297,
        "algorithm": "{The heuristic selects a promising solution from the archive based on a weighted combination of objective values and applies a novel local search operator that combines item swaps and adaptive perturbation to explore high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Intelligent selection: choose a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) == 1:\n        selected_solution = archive[0][0].copy()\n    else:\n        # Use a weighted combination of objectives to identify promising solutions\n        weights = np.random.dirichlet(np.ones(2), size=1)[0]\n        scores = np.dot(objectives, weights)\n        selected_idx = np.argmax(scores)\n        selected_solution = archive[selected_idx][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: adaptive item swaps and perturbations\n    current_weight = np.sum(weight_lst * selected_solution)\n    available_items = np.where(~selected_solution)[0]\n    included_items = np.where(selected_solution)[0]\n\n    # Step 1: Try to swap items between included and available\n    if len(included_items) > 0 and len(available_items) > 0:\n        for _ in range(min(3, len(included_items), len(available_items))):\n            i = random.choice(included_items)\n            j = random.choice(available_items)\n            if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight = current_weight - weight_lst[i] + weight_lst[j]\n                included_items = np.where(new_solution)[0]\n                available_items = np.where(~new_solution)[0]\n                break\n\n    # Step 2: Adaptive perturbation - flip a small number of items\n    if len(included_items) > 0:\n        num_flips = min(2, len(included_items))\n        flip_indices = random.sample(list(included_items), num_flips)\n        for i in flip_indices:\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Step 3: Try to add new items if possible\n    if len(available_items) > 0:\n        for i in available_items:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.46708897923975096,
            2.51566019654274
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Intelligent selection: choose a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) == 1:\n        selected_solution = archive[0][0].copy()\n    else:\n        # Use a weighted combination of objectives to identify promising solutions\n        weights = np.random.dirichlet(np.ones(2), size=1)[0]\n        scores = np.dot(objectives, weights)\n        selected_idx = np.argmax(scores)\n        selected_solution = archive[selected_idx][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: adaptive item swaps and perturbations\n    current_weight = np.sum(weight_lst * selected_solution)\n    available_items = np.where(~selected_solution)[0]\n    included_items = np.where(selected_solution)[0]\n\n    # Step 1: Try to swap items between included and available\n    if len(included_items) > 0 and len(available_items) > 0:\n        for _ in range(min(3, len(included_items), len(available_items))):\n            i = random.choice(included_items)\n            j = random.choice(available_items)\n            if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight = current_weight - weight_lst[i] + weight_lst[j]\n                included_items = np.where(new_solution)[0]\n                available_items = np.where(~new_solution)[0]\n                break\n\n    # Step 2: Adaptive perturbation - flip a small number of items\n    if len(included_items) > 0:\n        num_flips = min(2, len(included_items))\n        flip_indices = random.sample(list(included_items), num_flips)\n        for i in flip_indices:\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Step 3: Try to add new items if possible\n    if len(available_items) > 0:\n        for i in available_items:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 298,
        "algorithm": "{A novel hybrid local search strategy that intelligently selects a solution from the archive based on its potential for improvement by considering both objective values and their trade-offs, then applies a dynamic flip-and-repair operator that flips a subset of items and repairs the solution to maintain feasibility while exploring diverse neighborhoods in the objective space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, (current_val1, current_val2) = random.choice(archive)\n    base_solution = selected_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify items that can be flipped (either add or remove)\n    flip_candidates = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if removing this item would keep the solution feasible\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                flip_candidates.append(i)\n        else:\n            # Check if adding this item would keep the solution feasible\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                flip_candidates.append(i)\n\n    if not flip_candidates:\n        return base_solution  # No feasible flips possible\n\n    # Randomly select a subset of flip candidates (dynamic size)\n    flip_size = min(3, len(flip_candidates))  # Limit to 3 flips for diversity\n    flip_indices = random.sample(flip_candidates, flip_size)\n\n    # Create new solution by flipping selected items\n    new_solution = base_solution.copy()\n    for i in flip_indices:\n        new_solution[i] = 1 - new_solution[i]\n\n    # Repair to ensure feasibility (in case of multiple flips)\n    new_weight = np.sum(weight_lst * new_solution)\n    if new_weight > capacity:\n        # Remove items randomly until feasible\n        excess_items = np.where(new_solution == 1)[0]\n        random.shuffle(excess_items)\n        for i in excess_items:\n            new_solution[i] = 0\n            new_weight -= weight_lst[i]\n            if new_weight <= capacity:\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.8263012184493782,
            2.6113153398036957
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, (current_val1, current_val2) = random.choice(archive)\n    base_solution = selected_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify items that can be flipped (either add or remove)\n    flip_candidates = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if removing this item would keep the solution feasible\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                flip_candidates.append(i)\n        else:\n            # Check if adding this item would keep the solution feasible\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                flip_candidates.append(i)\n\n    if not flip_candidates:\n        return base_solution  # No feasible flips possible\n\n    # Randomly select a subset of flip candidates (dynamic size)\n    flip_size = min(3, len(flip_candidates))  # Limit to 3 flips for diversity\n    flip_indices = random.sample(flip_candidates, flip_size)\n\n    # Create new solution by flipping selected items\n    new_solution = base_solution.copy()\n    for i in flip_indices:\n        new_solution[i] = 1 - new_solution[i]\n\n    # Repair to ensure feasibility (in case of multiple flips)\n    new_weight = np.sum(weight_lst * new_solution)\n    if new_weight > capacity:\n        # Remove items randomly until feasible\n        excess_items = np.where(new_solution == 1)[0]\n        random.shuffle(excess_items)\n        for i in excess_items:\n            new_solution[i] = 0\n            new_weight -= weight_lst[i]\n            if new_weight <= capacity:\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 299,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive by prioritizing those with high objective values and low weights, then applies a hybrid local search operator that combines item swaps and path relinking to explore the neighborhood while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (prioritize high value solutions with low weight)\n    def score(sol, obj):\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight > capacity:\n            return -np.inf\n        return obj[0] + obj[1] - 0.1 * total_weight  # Balance between objectives and weight\n\n    scored_solutions = [(sol, obj, score(sol, obj)) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: -x[2])\n    selected = scored_solutions[0][0]\n    base_solution = selected.copy()\n\n    # Hybrid local search: item swaps + path relinking\n    new_solution = base_solution.copy()\n    N = len(base_solution)\n\n    # Step 1: Random item swaps (exploration)\n    for _ in range(random.randint(1, 3)):\n        i, j = random.sample(range(N), 2)\n        if base_solution[i] != base_solution[j]:\n            new_solution[i], new_solution[j] = base_solution[j], base_solution[i]\n            if np.sum(weight_lst * new_solution) > capacity:\n                new_solution[i], new_solution[j] = base_solution[i], base_solution[j]\n\n    # Step 2: Path relinking (exploitation)\n    if len(archive) > 1:\n        target = random.choice([sol for sol, _, _ in scored_solutions[1:]])\n        for i in range(N):\n            if base_solution[i] != target[i]:\n                temp_solution = new_solution.copy()\n                temp_solution[i] = target[i]\n                if np.sum(weight_lst * temp_solution) <= capacity:\n                    new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.6256189122257727,
            8.01486536860466
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (prioritize high value solutions with low weight)\n    def score(sol, obj):\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight > capacity:\n            return -np.inf\n        return obj[0] + obj[1] - 0.1 * total_weight  # Balance between objectives and weight\n\n    scored_solutions = [(sol, obj, score(sol, obj)) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: -x[2])\n    selected = scored_solutions[0][0]\n    base_solution = selected.copy()\n\n    # Hybrid local search: item swaps + path relinking\n    new_solution = base_solution.copy()\n    N = len(base_solution)\n\n    # Step 1: Random item swaps (exploration)\n    for _ in range(random.randint(1, 3)):\n        i, j = random.sample(range(N), 2)\n        if base_solution[i] != base_solution[j]:\n            new_solution[i], new_solution[j] = base_solution[j], base_solution[i]\n            if np.sum(weight_lst * new_solution) > capacity:\n                new_solution[i], new_solution[j] = base_solution[i], base_solution[j]\n\n    # Step 2: Path relinking (exploitation)\n    if len(archive) > 1:\n        target = random.choice([sol for sol, _, _ in scored_solutions[1:]])\n        for i in range(N):\n            if base_solution[i] != target[i]:\n                temp_solution = new_solution.copy()\n                temp_solution[i] = target[i]\n                if np.sum(weight_lst * temp_solution) <= capacity:\n                    new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 300,
        "algorithm": "{A novel local search strategy combines adaptive item swapping with objective-aware perturbation, prioritizing high-value items while ensuring feasibility through dynamic weight adjustment and multi-objective trade-off analysis.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = random.choice(archive)\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Identify items that can be flipped (0 to 1 or 1 to 0) while maintaining feasibility\n    candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Check if removing this item would keep the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                candidates.append((i, -1))  # -1 indicates removal\n        else:\n            # Check if adding this item would keep the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                candidates.append((i, 1))  # 1 indicates addition\n\n    if not candidates:\n        return new_solution\n\n    # Select a candidate item to flip\n    item_idx, flip = random.choice(candidates)\n    new_solution[item_idx] = 1 - new_solution[item_idx]\n\n    # Additional perturbation: flip another item based on value-to-weight ratio\n    if len(candidates) > 1:\n        # Calculate value-to-weight ratios for all items\n        v1_ratio = value1_lst / weight_lst\n        v2_ratio = value2_lst / weight_lst\n\n        # Combine ratios for both objectives\n        combined_ratio = v1_ratio + v2_ratio\n\n        # Select the item with highest combined ratio that hasn't been selected yet\n        for i in sorted(range(len(combined_ratio)), key=lambda x: -combined_ratio[x]):\n            if i != item_idx and ((new_solution[i] == 1 and current_weight - weight_lst[i] <= capacity) or\n                                 (new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity)):\n                new_solution[i] = 1 - new_solution[i]\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.8746183810082195,
            3.383536159992218
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = random.choice(archive)\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Identify items that can be flipped (0 to 1 or 1 to 0) while maintaining feasibility\n    candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Check if removing this item would keep the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                candidates.append((i, -1))  # -1 indicates removal\n        else:\n            # Check if adding this item would keep the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                candidates.append((i, 1))  # 1 indicates addition\n\n    if not candidates:\n        return new_solution\n\n    # Select a candidate item to flip\n    item_idx, flip = random.choice(candidates)\n    new_solution[item_idx] = 1 - new_solution[item_idx]\n\n    # Additional perturbation: flip another item based on value-to-weight ratio\n    if len(candidates) > 1:\n        # Calculate value-to-weight ratios for all items\n        v1_ratio = value1_lst / weight_lst\n        v2_ratio = value2_lst / weight_lst\n\n        # Combine ratios for both objectives\n        combined_ratio = v1_ratio + v2_ratio\n\n        # Select the item with highest combined ratio that hasn't been selected yet\n        for i in sorted(range(len(combined_ratio)), key=lambda x: -combined_ratio[x]):\n            if i != item_idx and ((new_solution[i] == 1 and current_weight - weight_lst[i] <= capacity) or\n                                 (new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity)):\n                new_solution[i] = 1 - new_solution[i]\n                break\n\n    return new_solution\n\n"
    }
]