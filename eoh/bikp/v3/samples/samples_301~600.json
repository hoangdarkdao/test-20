[
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 301,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidate_indices = [i for i, (sol, _) in enumerate(archive) if sol.sum() > 0]\n    if not candidate_indices:\n        candidate_indices = list(range(len(archive)))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine item swaps and marginal utility-based flips\n    new_solution = base_solution.copy()\n    current_weight = np.dot(new_solution, weight_lst)\n\n    # Step 1: Random item swap (if possible)\n    ones = np.where(new_solution == 1)[0]\n    zeros = np.where(new_solution == 0)[0]\n    if len(ones) > 0 and len(zeros) > 0:\n        i, j = np.random.choice(ones, 1)[0], np.random.choice(zeros, 1)[0]\n        if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n            new_solution[i], new_solution[j] = 0, 1\n\n    # Step 2: Marginal utility-based flip (if swap didn't help)\n    if np.array_equal(new_solution, base_solution):\n        # Calculate marginal utility for each item\n        marginal1 = value1_lst / weight_lst\n        marginal2 = value2_lst / weight_lst\n        marginal = marginal1 + marginal2  # Combined marginal utility\n\n        # Flip items with highest marginal utility first, ensuring feasibility\n        sorted_items = np.argsort(-marginal)\n        for item in sorted_items:\n            if new_solution[item] == 0:\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n            else:\n                if current_weight - weight_lst[item] >= 0:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.5039654286446923,
            3.656356930732727
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidate_indices = [i for i, (sol, _) in enumerate(archive) if sol.sum() > 0]\n    if not candidate_indices:\n        candidate_indices = list(range(len(archive)))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine item swaps and marginal utility-based flips\n    new_solution = base_solution.copy()\n    current_weight = np.dot(new_solution, weight_lst)\n\n    # Step 1: Random item swap (if possible)\n    ones = np.where(new_solution == 1)[0]\n    zeros = np.where(new_solution == 0)[0]\n    if len(ones) > 0 and len(zeros) > 0:\n        i, j = np.random.choice(ones, 1)[0], np.random.choice(zeros, 1)[0]\n        if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n            new_solution[i], new_solution[j] = 0, 1\n\n    # Step 2: Marginal utility-based flip (if swap didn't help)\n    if np.array_equal(new_solution, base_solution):\n        # Calculate marginal utility for each item\n        marginal1 = value1_lst / weight_lst\n        marginal2 = value2_lst / weight_lst\n        marginal = marginal1 + marginal2  # Combined marginal utility\n\n        # Flip items with highest marginal utility first, ensuring feasibility\n        sorted_items = np.argsort(-marginal)\n        for item in sorted_items:\n            if new_solution[item] == 0:\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n            else:\n                if current_weight - weight_lst[item] >= 0:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 302,
        "algorithm": "{The algorithm intelligently selects a non-dominated solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines item swapping and probabilistic flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions with high potential for improvement (e.g., those not fully packed)\n    candidates = []\n    for sol, obj in archive:\n        current_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - current_weight\n        if remaining_capacity > 0:\n            # Prefer solutions with some remaining capacity and high objective values\n            candidates.append((sol, obj, remaining_capacity))\n\n    if not candidates:\n        # If no candidates, randomly select from archive\n        selected_sol, _ = random.choice(archive)\n    else:\n        # Select the solution with the highest remaining capacity and high objectives\n        selected_sol, _, _ = max(candidates, key=lambda x: (x[2], x[1][0], x[1][1]))\n\n    base_solution = selected_sol.copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search operator\n    # Option 1: Swap two items (if feasible)\n    items_in = np.where(new_solution == 1)[0]\n    items_out = np.where(new_solution == 0)[0]\n\n    if len(items_in) > 1 and len(items_out) > 0:\n        # Randomly select two items to swap (one in, one out)\n        item_in = random.choice(items_in)\n        item_out = random.choice(items_out)\n\n        # Check feasibility of swap\n        new_weight = np.sum(weight_lst * new_solution) - weight_lst[item_in] + weight_lst[item_out]\n        if new_weight <= capacity:\n            new_solution[item_in] = 0\n            new_solution[item_out] = 1\n\n    # Option 2: Flip items with high potential (probabilistic)\n    else:\n        # If no swap possible, flip items with high value-to-weight ratio\n        for i in range(len(new_solution)):\n            if new_solution[i] == 0:\n                if random.random() < 0.3:  # 30% chance to flip\n                    new_weight = np.sum(weight_lst * new_solution) + weight_lst[i]\n                    if new_weight <= capacity:\n                        new_solution[i] = 1\n            else:\n                if random.random() < 0.1:  # 10% chance to flip\n                    new_weight = np.sum(weight_lst * new_solution) - weight_lst[i]\n                    new_solution[i] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.5867173365864683,
            3.518651247024536
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions with high potential for improvement (e.g., those not fully packed)\n    candidates = []\n    for sol, obj in archive:\n        current_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - current_weight\n        if remaining_capacity > 0:\n            # Prefer solutions with some remaining capacity and high objective values\n            candidates.append((sol, obj, remaining_capacity))\n\n    if not candidates:\n        # If no candidates, randomly select from archive\n        selected_sol, _ = random.choice(archive)\n    else:\n        # Select the solution with the highest remaining capacity and high objectives\n        selected_sol, _, _ = max(candidates, key=lambda x: (x[2], x[1][0], x[1][1]))\n\n    base_solution = selected_sol.copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search operator\n    # Option 1: Swap two items (if feasible)\n    items_in = np.where(new_solution == 1)[0]\n    items_out = np.where(new_solution == 0)[0]\n\n    if len(items_in) > 1 and len(items_out) > 0:\n        # Randomly select two items to swap (one in, one out)\n        item_in = random.choice(items_in)\n        item_out = random.choice(items_out)\n\n        # Check feasibility of swap\n        new_weight = np.sum(weight_lst * new_solution) - weight_lst[item_in] + weight_lst[item_out]\n        if new_weight <= capacity:\n            new_solution[item_in] = 0\n            new_solution[item_out] = 1\n\n    # Option 2: Flip items with high potential (probabilistic)\n    else:\n        # If no swap possible, flip items with high value-to-weight ratio\n        for i in range(len(new_solution)):\n            if new_solution[i] == 0:\n                if random.random() < 0.3:  # 30% chance to flip\n                    new_weight = np.sum(weight_lst * new_solution) + weight_lst[i]\n                    if new_weight <= capacity:\n                        new_solution[i] = 1\n            else:\n                if random.random() < 0.1:  # 10% chance to flip\n                    new_weight = np.sum(weight_lst * new_solution) - weight_lst[i]\n                    new_solution[i] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 303,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high potential for improvement, then applies a novel hybrid local search operator that combines item swaps and adaptive perturbations to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    current_weights = [np.sum(weight_lst[sol == 1]) for sol in archive_solutions]\n    current_values1 = [np.sum(value1_lst[sol == 1]) for sol in archive_solutions]\n    current_values2 = [np.sum(value2_lst[sol == 1]) for sol in archive_solutions]\n\n    # Prioritize solutions with high potential (e.g., high value, low weight)\n    potential_scores = [\n        (current_values1[i] + current_values2[i]) / (current_weights[i] + 1e-6)\n        for i in range(len(archive))\n    ]\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly swap a subset of items\n    swap_mask = np.random.rand(n_items) < 0.2  # 20% chance to swap\n    new_solution[swap_mask] = 1 - new_solution[swap_mask]\n\n    # Ensure feasibility by removing excess items\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        excess_items = np.where(new_solution == 1)[0]\n        np.random.shuffle(excess_items)\n        for item in excess_items:\n            if excess_weight <= 0:\n                break\n            if weight_lst[item] <= excess_weight:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    # Step 2: Adaptively perturb the solution\n    perturb_mask = np.random.rand(n_items) < 0.1  # 10% chance to perturb\n    for i in np.where(perturb_mask)[0]:\n        if new_solution[i] == 1:\n            # Try to remove the item\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n        else:\n            # Try to add the item\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.6682171190325925,
            7.6142334043979645
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    current_weights = [np.sum(weight_lst[sol == 1]) for sol in archive_solutions]\n    current_values1 = [np.sum(value1_lst[sol == 1]) for sol in archive_solutions]\n    current_values2 = [np.sum(value2_lst[sol == 1]) for sol in archive_solutions]\n\n    # Prioritize solutions with high potential (e.g., high value, low weight)\n    potential_scores = [\n        (current_values1[i] + current_values2[i]) / (current_weights[i] + 1e-6)\n        for i in range(len(archive))\n    ]\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly swap a subset of items\n    swap_mask = np.random.rand(n_items) < 0.2  # 20% chance to swap\n    new_solution[swap_mask] = 1 - new_solution[swap_mask]\n\n    # Ensure feasibility by removing excess items\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        excess_items = np.where(new_solution == 1)[0]\n        np.random.shuffle(excess_items)\n        for item in excess_items:\n            if excess_weight <= 0:\n                break\n            if weight_lst[item] <= excess_weight:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    # Step 2: Adaptively perturb the solution\n    perturb_mask = np.random.rand(n_items) < 0.1  # 10% chance to perturb\n    for i in np.where(perturb_mask)[0]:\n        if new_solution[i] == 1:\n            # Try to remove the item\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n        else:\n            # Try to add the item\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 304,
        "algorithm": "{This algorithm intelligently selects a promising solution from the archive by prioritizing those with high potential for local improvement, then applies a hybrid local search that combines item swaps and probabilistic flips to explore the solution space while ensuring feasibility, aiming to maximize both objectives through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by the sum of objectives to identify promising candidates\n        archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n        # Select top 30% or at least 1 solution\n        top_k = max(1, int(0.3 * len(archive)))\n        candidates = archive_sorted[:top_k]\n        # Randomly select one candidate\n        base_solution, _ = random.choice(candidates)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    # Hybrid of item swaps and probabilistic flips\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2.1: Item swaps (swap two items if feasible)\n    if n_items >= 2:\n        for _ in range(10):  # Try up to 10 swaps\n            i, j = random.sample(range(n_items), 2)\n            if new_solution[i] == new_solution[j]:\n                continue  # No change if both are the same\n            # Calculate new weight if we swap\n            new_weight = current_weight - weight_lst[i] + weight_lst[j] if new_solution[i] else current_weight + weight_lst[i] - weight_lst[j]\n            if new_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight = new_weight\n                break  # Accept first feasible swap\n\n    # Step 2.2: Probabilistic flips (flip items with probability based on their impact)\n    for i in range(n_items):\n        if random.random() < 0.2:  # 20% chance to consider flipping\n            if new_solution[i]:\n                # If item is included, try to remove it\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # If item is excluded, try to add it\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.38320898803397885,
            1.7442240715026855
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by the sum of objectives to identify promising candidates\n        archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n        # Select top 30% or at least 1 solution\n        top_k = max(1, int(0.3 * len(archive)))\n        candidates = archive_sorted[:top_k]\n        # Randomly select one candidate\n        base_solution, _ = random.choice(candidates)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    # Hybrid of item swaps and probabilistic flips\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2.1: Item swaps (swap two items if feasible)\n    if n_items >= 2:\n        for _ in range(10):  # Try up to 10 swaps\n            i, j = random.sample(range(n_items), 2)\n            if new_solution[i] == new_solution[j]:\n                continue  # No change if both are the same\n            # Calculate new weight if we swap\n            new_weight = current_weight - weight_lst[i] + weight_lst[j] if new_solution[i] else current_weight + weight_lst[i] - weight_lst[j]\n            if new_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight = new_weight\n                break  # Accept first feasible swap\n\n    # Step 2.2: Probabilistic flips (flip items with probability based on their impact)\n    for i in range(n_items):\n        if random.random() < 0.2:  # 20% chance to consider flipping\n            if new_solution[i]:\n                # If item is included, try to remove it\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # If item is excluded, try to add it\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 305,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high objective values and low weight, then applies a hybrid local search combining item swaps and probabilistic flips to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (np.max(objectives, axis=0) + 1e-8)\n    scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Initialize neighbor solution\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: swap items or flip bits probabilistically\n    for _ in range(10):  # Perform multiple steps\n        # Randomly choose between swap or flip\n        if random.random() < 0.7:\n            # Swap two items\n            items = np.where(new_solution == 1)[0]\n            if len(items) >= 2:\n                i, j = random.sample(list(items), 2)\n                delta_weight = weight_lst[j] - weight_lst[i]\n                if current_weight + delta_weight <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    current_weight += delta_weight\n        else:\n            # Flip a random item\n            item = random.randint(0, len(new_solution) - 1)\n            if new_solution[item] == 1:\n                if current_weight - weight_lst[item] <= capacity:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n            else:\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.3155309312542238,
            4.373495995998383
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (np.max(objectives, axis=0) + 1e-8)\n    scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Initialize neighbor solution\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: swap items or flip bits probabilistically\n    for _ in range(10):  # Perform multiple steps\n        # Randomly choose between swap or flip\n        if random.random() < 0.7:\n            # Swap two items\n            items = np.where(new_solution == 1)[0]\n            if len(items) >= 2:\n                i, j = random.sample(list(items), 2)\n                delta_weight = weight_lst[j] - weight_lst[i]\n                if current_weight + delta_weight <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    current_weight += delta_weight\n        else:\n            # Flip a random item\n            item = random.randint(0, len(new_solution) - 1)\n            if new_solution[item] == 1:\n                if current_weight - weight_lst[item] <= capacity:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n            else:\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 306,
        "algorithm": "{A hybrid local search strategy that combines adaptive item flipping, objective-biased selection, and capacity-aware perturbation to intelligently explore the solution space while ensuring feasibility and maximizing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective diversity and potential improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    current_solution, current_obj = archive[selected_idx]\n    new_solution = current_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * current_solution)\n\n    # Determine which objective to prioritize for improvement (alternate between them)\n    if random.random() < 0.5:\n        # Prioritize objective 1\n        improvement_items = np.argsort(value1_lst / weight_lst)[::-1]\n    else:\n        # Prioritize objective 2\n        improvement_items = np.argsort(value2_lst / weight_lst)[::-1]\n\n    # Try to flip items to improve both objectives while maintaining feasibility\n    for item in improvement_items:\n        if new_solution[item] == 1:\n            # Try removing the item\n            if new_solution[item] == 1:\n                new_weight = current_weight - weight_lst[item]\n                if new_weight <= capacity:\n                    new_solution[item] = 0\n                    current_weight = new_weight\n        else:\n            # Try adding the item\n            if new_solution[item] == 0:\n                new_weight = current_weight + weight_lst[item]\n                if new_weight <= capacity:\n                    new_solution[item] = 1\n                    current_weight = new_weight\n\n    # Add a small random perturbation to escape local optima\n    if random.random() < 0.3:\n        perturb_item = random.randint(0, len(weight_lst) - 1)\n        if new_solution[perturb_item] == 1:\n            # Try removing\n            if current_weight - weight_lst[perturb_item] <= capacity:\n                new_solution[perturb_item] = 0\n        else:\n            # Try adding\n            if current_weight + weight_lst[perturb_item] <= capacity:\n                new_solution[perturb_item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.28879174879649966,
            3.565266728401184
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective diversity and potential improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    current_solution, current_obj = archive[selected_idx]\n    new_solution = current_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * current_solution)\n\n    # Determine which objective to prioritize for improvement (alternate between them)\n    if random.random() < 0.5:\n        # Prioritize objective 1\n        improvement_items = np.argsort(value1_lst / weight_lst)[::-1]\n    else:\n        # Prioritize objective 2\n        improvement_items = np.argsort(value2_lst / weight_lst)[::-1]\n\n    # Try to flip items to improve both objectives while maintaining feasibility\n    for item in improvement_items:\n        if new_solution[item] == 1:\n            # Try removing the item\n            if new_solution[item] == 1:\n                new_weight = current_weight - weight_lst[item]\n                if new_weight <= capacity:\n                    new_solution[item] = 0\n                    current_weight = new_weight\n        else:\n            # Try adding the item\n            if new_solution[item] == 0:\n                new_weight = current_weight + weight_lst[item]\n                if new_weight <= capacity:\n                    new_solution[item] = 1\n                    current_weight = new_weight\n\n    # Add a small random perturbation to escape local optima\n    if random.random() < 0.3:\n        perturb_item = random.randint(0, len(weight_lst) - 1)\n        if new_solution[perturb_item] == 1:\n            # Try removing\n            if current_weight - weight_lst[perturb_item] <= capacity:\n                new_solution[perturb_item] = 0\n        else:\n            # Try adding\n            if current_weight + weight_lst[perturb_item] <= capacity:\n                new_solution[perturb_item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 307,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive based on objective diversity and applies a hybrid local search operator that combines adaptive bit-flipping and probabilistic item swapping to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution based on objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    if len(archive) > 1:\n        # Calculate crowding distance for each solution\n        sorted_indices = np.argsort(objectives[:, 0])\n        objectives_sorted = objectives[sorted_indices]\n        distances = np.zeros(len(archive))\n        for i in range(1, len(archive)-1):\n            distances[sorted_indices[i]] = (objectives_sorted[i+1, 0] - objectives_sorted[i-1, 0]) / (objectives_sorted[-1, 0] - objectives_sorted[0, 0])\n        # Prefer solutions with high crowding distance (diverse)\n        selected_idx = np.argmax(distances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive bit-flipping and probabilistic swapping\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    available_items = np.where(new_solution == 0)[0]\n    included_items = np.where(new_solution == 1)[0]\n\n    # Adaptive bit-flipping: flip items with high marginal value\n    if len(included_items) > 0:\n        marginal_values1 = value1_lst[included_items] / weight_lst[included_items]\n        marginal_values2 = value2_lst[included_items] / weight_lst[included_items]\n        combined_marginal = marginal_values1 + marginal_values2\n        flip_candidate_idx = included_items[np.argmax(combined_marginal)]\n\n        if current_weight - weight_lst[flip_candidate_idx] <= capacity:\n            new_solution[flip_candidate_idx] = 0\n            current_weight -= weight_lst[flip_candidate_idx]\n\n    # Probabilistic swapping: add items with high marginal value\n    if len(available_items) > 0:\n        marginal_values1 = value1_lst[available_items] / weight_lst[available_items]\n        marginal_values2 = value2_lst[available_items] / weight_lst[available_items]\n        combined_marginal = marginal_values1 + marginal_values2\n        probabilities = combined_marginal / np.sum(combined_marginal)\n        selected_item = np.random.choice(available_items, p=probabilities)\n\n        if current_weight + weight_lst[selected_item] <= capacity:\n            new_solution[selected_item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.756096703633535,
            2.829064041376114
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution based on objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    if len(archive) > 1:\n        # Calculate crowding distance for each solution\n        sorted_indices = np.argsort(objectives[:, 0])\n        objectives_sorted = objectives[sorted_indices]\n        distances = np.zeros(len(archive))\n        for i in range(1, len(archive)-1):\n            distances[sorted_indices[i]] = (objectives_sorted[i+1, 0] - objectives_sorted[i-1, 0]) / (objectives_sorted[-1, 0] - objectives_sorted[0, 0])\n        # Prefer solutions with high crowding distance (diverse)\n        selected_idx = np.argmax(distances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive bit-flipping and probabilistic swapping\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    available_items = np.where(new_solution == 0)[0]\n    included_items = np.where(new_solution == 1)[0]\n\n    # Adaptive bit-flipping: flip items with high marginal value\n    if len(included_items) > 0:\n        marginal_values1 = value1_lst[included_items] / weight_lst[included_items]\n        marginal_values2 = value2_lst[included_items] / weight_lst[included_items]\n        combined_marginal = marginal_values1 + marginal_values2\n        flip_candidate_idx = included_items[np.argmax(combined_marginal)]\n\n        if current_weight - weight_lst[flip_candidate_idx] <= capacity:\n            new_solution[flip_candidate_idx] = 0\n            current_weight -= weight_lst[flip_candidate_idx]\n\n    # Probabilistic swapping: add items with high marginal value\n    if len(available_items) > 0:\n        marginal_values1 = value1_lst[available_items] / weight_lst[available_items]\n        marginal_values2 = value2_lst[available_items] / weight_lst[available_items]\n        combined_marginal = marginal_values1 + marginal_values2\n        probabilities = combined_marginal / np.sum(combined_marginal)\n        selected_item = np.random.choice(available_items, p=probabilities)\n\n        if current_weight + weight_lst[selected_item] <= capacity:\n            new_solution[selected_item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 308,
        "algorithm": "{The heuristic selects a solution from the archive with the highest combined objective value, then applies a novel hybrid local search operator that combines random swaps with adaptive item replacement based on marginal gains, ensuring feasibility by dynamically adjusting the neighborhood size and re-evaluating potential moves.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective value\n    base_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Hybrid local search: random swaps + adaptive replacement\n    for _ in range(min(10, len(new_solution))):\n        # Random swap\n        if np.random.rand() < 0.7:\n            i, j = np.random.choice(len(new_solution), 2, replace=False)\n            if new_solution[i] != new_solution[j]:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                new_weight = np.sum(weight_lst[new_solution == 1])\n                if new_weight > capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                else:\n                    current_weight = new_weight\n                    current_value1 = np.sum(value1_lst[new_solution == 1])\n                    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n        # Adaptive replacement: remove low-value items and add high-value items\n        else:\n            # Remove items with low marginal value\n            included = np.where(new_solution == 1)[0]\n            if len(included) > 0:\n                marginal_values = (value1_lst[included] + value2_lst[included]) / weight_lst[included]\n                to_remove = included[np.argmin(marginal_values)]\n                new_solution[to_remove] = 0\n                current_weight -= weight_lst[to_remove]\n                current_value1 -= value1_lst[to_remove]\n                current_value2 -= value2_lst[to_remove]\n\n            # Add items with high marginal value\n            excluded = np.where(new_solution == 0)[0]\n            if len(excluded) > 0:\n                marginal_values = (value1_lst[excluded] + value2_lst[excluded]) / weight_lst[excluded]\n                candidates = excluded[marginal_values > 0]\n                if len(candidates) > 0:\n                    to_add = np.random.choice(candidates)\n                    if current_weight + weight_lst[to_add] <= capacity:\n                        new_solution[to_add] = 1\n                        current_weight += weight_lst[to_add]\n                        current_value1 += value1_lst[to_add]\n                        current_value2 += value2_lst[to_add]\n\n    return new_solution\n\n",
        "score": [
            -0.42499930268992675,
            5.270911127328873
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined objective value\n    base_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Hybrid local search: random swaps + adaptive replacement\n    for _ in range(min(10, len(new_solution))):\n        # Random swap\n        if np.random.rand() < 0.7:\n            i, j = np.random.choice(len(new_solution), 2, replace=False)\n            if new_solution[i] != new_solution[j]:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                new_weight = np.sum(weight_lst[new_solution == 1])\n                if new_weight > capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                else:\n                    current_weight = new_weight\n                    current_value1 = np.sum(value1_lst[new_solution == 1])\n                    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n        # Adaptive replacement: remove low-value items and add high-value items\n        else:\n            # Remove items with low marginal value\n            included = np.where(new_solution == 1)[0]\n            if len(included) > 0:\n                marginal_values = (value1_lst[included] + value2_lst[included]) / weight_lst[included]\n                to_remove = included[np.argmin(marginal_values)]\n                new_solution[to_remove] = 0\n                current_weight -= weight_lst[to_remove]\n                current_value1 -= value1_lst[to_remove]\n                current_value2 -= value2_lst[to_remove]\n\n            # Add items with high marginal value\n            excluded = np.where(new_solution == 0)[0]\n            if len(excluded) > 0:\n                marginal_values = (value1_lst[excluded] + value2_lst[excluded]) / weight_lst[excluded]\n                candidates = excluded[marginal_values > 0]\n                if len(candidates) > 0:\n                    to_add = np.random.choice(candidates)\n                    if current_weight + weight_lst[to_add] <= capacity:\n                        new_solution[to_add] = 1\n                        current_weight += weight_lst[to_add]\n                        current_value1 += value1_lst[to_add]\n                        current_value2 += value2_lst[to_add]\n\n    return new_solution\n\n"
    }
]