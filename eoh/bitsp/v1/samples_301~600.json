[
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 301,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))  # Select the solution with the highest combined cost\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: Combine 3-opt with a biased edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Apply a biased 3-opt move based on distance differences\n    if random.random() < 0.7:  # Higher probability for this move\n        # Reverse the segment between a and b, then reverse between b and c\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n    else:\n        # Swap edges with a bias towards reducing the larger distance\n        i, j = random.sample(range(n), 2)\n        if distance_matrix_1[new_solution[i], new_solution[j]] > distance_matrix_2[new_solution[i], new_solution[j]]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9552743593489962,
            2.705602526664734
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))  # Select the solution with the highest combined cost\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: Combine 3-opt with a biased edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Apply a biased 3-opt move based on distance differences\n    if random.random() < 0.7:  # Higher probability for this move\n        # Reverse the segment between a and b, then reverse between b and c\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n    else:\n        # Swap edges with a bias towards reducing the larger distance\n        i, j = random.sample(range(n), 2)\n        if distance_matrix_1[new_solution[i], new_solution[j]] > distance_matrix_2[new_solution[i], new_solution[j]]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 302,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Identify critical edges (those with high distance in either objective space)\n    critical_edges = []\n    for i in range(len(selected_solution)):\n        u = selected_solution[i]\n        v = selected_solution[(i + 1) % len(selected_solution)]\n        if (distance_matrix_1[u, v] > np.mean(distance_matrix_1) or\n            distance_matrix_2[u, v] > np.mean(distance_matrix_2)):\n            critical_edges.append(i)\n\n    if not critical_edges:\n        # If no critical edges, perform a biased random walk\n        i, j = np.random.choice(len(selected_solution), size=2, replace=False)\n        selected_solution[i], selected_solution[j] = selected_solution[j], selected_solution[i]\n        return selected_solution\n\n    # Perform a hybrid local search: insert a node from a critical edge into a random position\n    edge_idx = np.random.choice(critical_edges)\n    u = selected_solution[edge_idx]\n    v = selected_solution[(edge_idx + 1) % len(selected_solution)]\n\n    # Remove the edge and insert 'u' before 'v' in a random position\n    selected_solution = np.concatenate([selected_solution[:edge_idx], selected_solution[edge_idx+1:]])\n    insert_pos = np.random.randint(0, len(selected_solution) + 1)\n    selected_solution = np.insert(selected_solution, insert_pos, u)\n\n    return selected_solution\n\n",
        "score": [
            -0.659105024633155,
            4.98110032081604
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Identify critical edges (those with high distance in either objective space)\n    critical_edges = []\n    for i in range(len(selected_solution)):\n        u = selected_solution[i]\n        v = selected_solution[(i + 1) % len(selected_solution)]\n        if (distance_matrix_1[u, v] > np.mean(distance_matrix_1) or\n            distance_matrix_2[u, v] > np.mean(distance_matrix_2)):\n            critical_edges.append(i)\n\n    if not critical_edges:\n        # If no critical edges, perform a biased random walk\n        i, j = np.random.choice(len(selected_solution), size=2, replace=False)\n        selected_solution[i], selected_solution[j] = selected_solution[j], selected_solution[i]\n        return selected_solution\n\n    # Perform a hybrid local search: insert a node from a critical edge into a random position\n    edge_idx = np.random.choice(critical_edges)\n    u = selected_solution[edge_idx]\n    v = selected_solution[(edge_idx + 1) % len(selected_solution)]\n\n    # Remove the edge and insert 'u' before 'v' in a random position\n    selected_solution = np.concatenate([selected_solution[:edge_idx], selected_solution[edge_idx+1:]])\n    insert_pos = np.random.randint(0, len(selected_solution) + 1)\n    selected_solution = np.insert(selected_solution, insert_pos, u)\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 303,
        "algorithm": "{The algorithm selects a solution from the archive with the highest potential for improvement by combining dominance-based selection with a novel hybrid local search operator that dynamically combines edge swaps and path relinking, ensuring feasibility and diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: dynamic edge swap and path relinking\n    n = len(base_solution)\n    a, b = np.random.choice(n, size=2, replace=False)\n    c, d = np.random.choice(n, size=2, replace=False)\n\n    # Perform dynamic edge swap\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Apply path relinking to refine the solution\n    for _ in range(2):\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.742683348207742,
            2.9538063406944275
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: dynamic edge swap and path relinking\n    n = len(base_solution)\n    a, b = np.random.choice(n, size=2, replace=False)\n    c, d = np.random.choice(n, size=2, replace=False)\n\n    # Perform dynamic edge swap\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Apply path relinking to refine the solution\n    for _ in range(2):\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 304,
        "algorithm": "{A novel hybrid local search algorithm combines a multi-objective aware segment swap with a biased random walk to generate high-quality neighbors by intelligently reordering segments of the tour while maintaining feasibility and exploring both objective spaces' trade-offs.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Multi-segment swap with biased randomness\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Determine segment lengths based on solution quality\n    segment_length = max(2, min(5, n // 10))\n\n    # Randomly select two segments to swap\n    i = random.randint(0, n - segment_length)\n    j = random.randint(0, n - segment_length)\n\n    # Ensure segments are distinct\n    while abs(i - j) < segment_length:\n        j = random.randint(0, n - segment_length)\n\n    # Swap segments\n    seg1 = new_solution[i:i+segment_length]\n    seg2 = new_solution[j:j+segment_length]\n\n    new_solution[i:i+segment_length] = seg2\n    new_solution[j:j+segment_length] = seg1\n\n    # Optional: Apply biased random walk to further improve\n    if random.random() < 0.3:\n        k = random.randint(0, n - 3)\n        new_solution[k:k+3] = np.roll(new_solution[k:k+3], 1)\n\n    return new_solution\n\n",
        "score": [
            -0.9292439990475921,
            0.13021260499954224
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Multi-segment swap with biased randomness\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Determine segment lengths based on solution quality\n    segment_length = max(2, min(5, n // 10))\n\n    # Randomly select two segments to swap\n    i = random.randint(0, n - segment_length)\n    j = random.randint(0, n - segment_length)\n\n    # Ensure segments are distinct\n    while abs(i - j) < segment_length:\n        j = random.randint(0, n - segment_length)\n\n    # Swap segments\n    seg1 = new_solution[i:i+segment_length]\n    seg2 = new_solution[j:j+segment_length]\n\n    new_solution[i:i+segment_length] = seg2\n    new_solution[j:j+segment_length] = seg1\n\n    # Optional: Apply biased random walk to further improve\n    if random.random() < 0.3:\n        k = random.randint(0, n - 3)\n        new_solution[k:k+3] = np.roll(new_solution[k:k+3], 1)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 304,
        "algorithm": "{A novel hybrid local search algorithm combines a multi-objective aware segment swap with a biased random walk to generate high-quality neighbors by intelligently reordering segments of the tour while maintaining feasibility and exploring both objective spaces' trade-offs.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Multi-segment swap with biased randomness\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Determine segment lengths based on solution quality\n    segment_length = max(2, min(5, n // 10))\n\n    # Randomly select two segments to swap\n    i = random.randint(0, n - segment_length)\n    j = random.randint(0, n - segment_length)\n\n    # Ensure segments are distinct\n    while abs(i - j) < segment_length:\n        j = random.randint(0, n - segment_length)\n\n    # Swap segments\n    seg1 = new_solution[i:i+segment_length]\n    seg2 = new_solution[j:j+segment_length]\n\n    new_solution[i:i+segment_length] = seg2\n    new_solution[j:j+segment_length] = seg1\n\n    # Optional: Apply biased random walk to further improve\n    if random.random() < 0.3:\n        k = random.randint(0, n - 3)\n        new_solution[k:k+3] = np.roll(new_solution[k:k+3], 1)\n\n    return new_solution\n\n",
        "score": [
            -0.9292439990475921,
            0.13021260499954224
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Multi-segment swap with biased randomness\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Determine segment lengths based on solution quality\n    segment_length = max(2, min(5, n // 10))\n\n    # Randomly select two segments to swap\n    i = random.randint(0, n - segment_length)\n    j = random.randint(0, n - segment_length)\n\n    # Ensure segments are distinct\n    while abs(i - j) < segment_length:\n        j = random.randint(0, n - segment_length)\n\n    # Swap segments\n    seg1 = new_solution[i:i+segment_length]\n    seg2 = new_solution[j:j+segment_length]\n\n    new_solution[i:i+segment_length] = seg2\n    new_solution[j:j+segment_length] = seg1\n\n    # Optional: Apply biased random walk to further improve\n    if random.random() < 0.3:\n        k = random.randint(0, n - 3)\n        new_solution[k:k+3] = np.roll(new_solution[k:k+3], 1)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 305,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge swap\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Apply 2-opt between i-j and k-l\n        if i < j and k < l and i != k and j != l:\n            new_solution[i:j+1] = base_solution[i:j+1][::-1]\n            new_solution[k:l+1] = base_solution[k:l+1][::-1]\n\n        # Novel edge swap: swap edges i-j and k-l\n        if i != k and j != l:\n            new_solution[i], new_solution[j] = base_solution[k], base_solution[l]\n\n    return new_solution\n\n",
        "score": [
            -0.8806054280239833,
            1.6208088994026184
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge swap\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Apply 2-opt between i-j and k-l\n        if i < j and k < l and i != k and j != l:\n            new_solution[i:j+1] = base_solution[i:j+1][::-1]\n            new_solution[k:l+1] = base_solution[k:l+1][::-1]\n\n        # Novel edge swap: swap edges i-j and k-l\n        if i != k and j != l:\n            new_solution[i], new_solution[j] = base_solution[k], base_solution[l]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 306,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its dominance or diversity, then applies a hybrid local search combining edge-swapping and segment-reversal to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge-swapping and segment-reversal\n    n = len(new_solution)\n    a, b, c, d = sorted(random.sample(range(n), 4))\n\n    # Segment-reversal (partial inversion)\n    segment = new_solution[b:c+1]\n    new_solution[b:c+1] = segment[::-1]\n\n    # Edge-swap (swap two edges)\n    if random.random() < 0.5:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(set(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8302253729033344,
            2.4518110156059265
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge-swapping and segment-reversal\n    n = len(new_solution)\n    a, b, c, d = sorted(random.sample(range(n), 4))\n\n    # Segment-reversal (partial inversion)\n    segment = new_solution[b:c+1]\n    new_solution[b:c+1] = segment[::-1]\n\n    # Edge-swap (swap two edges)\n    if random.random() < 0.5:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(set(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 307,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = None\n    for sol, _ in archive:\n        dominated = False\n        for other_sol, _ in archive:\n            if (distance_matrix_1[other_sol[:-1], other_sol[1:]].sum() < distance_matrix_1[sol[:-1], sol[1:]].sum() and\n                distance_matrix_2[other_sol[:-1], other_sol[1:]].sum() < distance_matrix_2[sol[:-1], sol[1:]].sum()):\n                dominated = True\n                break\n        if not dominated:\n            selected = sol\n            break\n    if selected is None:\n        selected = archive[0][0]\n\n    # Hybrid local search: combine 3-opt with random segment reversal\n    new_solution = selected.copy()\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select three distinct indices\n    a, b, c = sorted(np.random.choice(np.arange(1, n-1), size=3, replace=False))\n\n    # Apply 3-opt: reverse segments between a-b, b-c, or a-c\n    option = np.random.randint(3)\n    if option == 0:\n        new_solution[a:b] = new_solution[a:b][::-1]\n    elif option == 1:\n        new_solution[b:c] = new_solution[b:c][::-1]\n    else:\n        new_solution[a:c] = new_solution[a:c][::-1]\n\n    # Randomly reverse a small segment to add diversity\n    if n > 4:\n        start = np.random.randint(1, n-2)\n        end = np.random.randint(start+1, n)\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8543033791651707,
            1.8942483067512512
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = None\n    for sol, _ in archive:\n        dominated = False\n        for other_sol, _ in archive:\n            if (distance_matrix_1[other_sol[:-1], other_sol[1:]].sum() < distance_matrix_1[sol[:-1], sol[1:]].sum() and\n                distance_matrix_2[other_sol[:-1], other_sol[1:]].sum() < distance_matrix_2[sol[:-1], sol[1:]].sum()):\n                dominated = True\n                break\n        if not dominated:\n            selected = sol\n            break\n    if selected is None:\n        selected = archive[0][0]\n\n    # Hybrid local search: combine 3-opt with random segment reversal\n    new_solution = selected.copy()\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select three distinct indices\n    a, b, c = sorted(np.random.choice(np.arange(1, n-1), size=3, replace=False))\n\n    # Apply 3-opt: reverse segments between a-b, b-c, or a-c\n    option = np.random.randint(3)\n    if option == 0:\n        new_solution[a:b] = new_solution[a:b][::-1]\n    elif option == 1:\n        new_solution[b:c] = new_solution[b:c][::-1]\n    else:\n        new_solution[a:c] = new_solution[a:c][::-1]\n\n    # Randomly reverse a small segment to add diversity\n    if n > 4:\n        start = np.random.randint(1, n-2)\n        end = np.random.randint(start+1, n)\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 308,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a hybrid of dominance and crowding distance, then applies a novel local search operator that combines edge swaps with a probabilistic node reinsertion mechanism to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        # If no non-dominated solutions, select the one with highest crowding distance\n        crowding_distances = []\n        sorted_archive = sorted(archive, key=lambda x: x[1][0])\n        for i in range(len(sorted_archive)):\n            if i == 0 or i == len(sorted_archive) - 1:\n                crowding_distances.append(float('inf'))\n            else:\n                dist = abs(sorted_archive[i+1][1][0] - sorted_archive[i-1][1][0]) + abs(sorted_archive[i+1][1][1] - sorted_archive[i-1][1][1])\n                crowding_distances.append(dist)\n        selected_idx = np.argmax(crowding_distances)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        # Among non-dominated, select the one with highest crowding distance\n        crowding_distances = []\n        sorted_non_dominated = sorted(non_dominated, key=lambda x: x[1][0])\n        for i in range(len(sorted_non_dominated)):\n            if i == 0 or i == len(sorted_non_dominated) - 1:\n                crowding_distances.append(float('inf'))\n            else:\n                dist = abs(sorted_non_dominated[i+1][1][0] - sorted_non_dominated[i-1][1][0]) + abs(sorted_non_dominated[i+1][1][1] - sorted_non_dominated[i-1][1][1])\n                crowding_distances.append(dist)\n        selected_idx = np.argmax(crowding_distances)\n        base_solution = non_dominated[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: edge swap with probabilistic reinsertion\n    if n > 3:\n        # Select a random segment to modify\n        seg_start = random.randint(0, n-3)\n        seg_end = random.randint(seg_start+1, min(seg_start+3, n-1))\n\n        # Perform edge swap\n        if random.random() < 0.7:  # 70% chance for edge swap\n            i, j = seg_start, seg_end\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:  # 30% chance for probabilistic reinsertion\n            # Remove and reinsert a random node\n            node_to_move = new_solution[seg_start]\n            new_solution = np.delete(new_solution, seg_start)\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    # The above operations already maintain feasibility by construction\n\n    return new_solution\n\n",
        "score": [
            -0.7912681668604842,
            1.4631431102752686
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        # If no non-dominated solutions, select the one with highest crowding distance\n        crowding_distances = []\n        sorted_archive = sorted(archive, key=lambda x: x[1][0])\n        for i in range(len(sorted_archive)):\n            if i == 0 or i == len(sorted_archive) - 1:\n                crowding_distances.append(float('inf'))\n            else:\n                dist = abs(sorted_archive[i+1][1][0] - sorted_archive[i-1][1][0]) + abs(sorted_archive[i+1][1][1] - sorted_archive[i-1][1][1])\n                crowding_distances.append(dist)\n        selected_idx = np.argmax(crowding_distances)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        # Among non-dominated, select the one with highest crowding distance\n        crowding_distances = []\n        sorted_non_dominated = sorted(non_dominated, key=lambda x: x[1][0])\n        for i in range(len(sorted_non_dominated)):\n            if i == 0 or i == len(sorted_non_dominated) - 1:\n                crowding_distances.append(float('inf'))\n            else:\n                dist = abs(sorted_non_dominated[i+1][1][0] - sorted_non_dominated[i-1][1][0]) + abs(sorted_non_dominated[i+1][1][1] - sorted_non_dominated[i-1][1][1])\n                crowding_distances.append(dist)\n        selected_idx = np.argmax(crowding_distances)\n        base_solution = non_dominated[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: edge swap with probabilistic reinsertion\n    if n > 3:\n        # Select a random segment to modify\n        seg_start = random.randint(0, n-3)\n        seg_end = random.randint(seg_start+1, min(seg_start+3, n-1))\n\n        # Perform edge swap\n        if random.random() < 0.7:  # 70% chance for edge swap\n            i, j = seg_start, seg_end\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:  # 30% chance for probabilistic reinsertion\n            # Remove and reinsert a random node\n            node_to_move = new_solution[seg_start]\n            new_solution = np.delete(new_solution, seg_start)\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    # The above operations already maintain feasibility by construction\n\n    return new_solution\n\n"
    }
]