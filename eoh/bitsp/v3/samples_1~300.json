[
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive 3-opt moves with a multi-objective crossover operator to explore diverse neighborhoods while balancing the two objectives, ensuring feasibility and high-quality solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive 3-opt with multi-objective crossover\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Perform 3-opt move\n    if np.random.rand() < 0.5:\n        # Option 1: Reverse segment between a and b\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:\n        # Option 2: Shift segment between a and b to position c\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n    # Multi-objective crossover: blend with another solution\n    if len(archive) > 1 and np.random.rand() < 0.3:\n        other_idx = np.random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0].copy()\n\n        # Blend segments from both solutions\n        crossover_point = np.random.randint(1, n)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by reinserting missing nodes\n        missing_nodes = [node for node in range(n) if node not in unique]\n        for node in missing_nodes:\n            pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8935638296452129,
            1.532308578491211
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive 3-opt with multi-objective crossover\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Perform 3-opt move\n    if np.random.rand() < 0.5:\n        # Option 1: Reverse segment between a and b\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:\n        # Option 2: Shift segment between a and b to position c\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n    # Multi-objective crossover: blend with another solution\n    if len(archive) > 1 and np.random.rand() < 0.3:\n        other_idx = np.random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0].copy()\n\n        # Blend segments from both solutions\n        crossover_point = np.random.randint(1, n)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by reinserting missing nodes\n        missing_nodes = [node for node in range(n) if node not in unique]\n        for node in missing_nodes:\n            pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive 3-opt moves with a multi-objective crossover operator to explore diverse neighborhoods while balancing the two objectives, ensuring feasibility and high-quality solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive 3-opt with multi-objective crossover\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Perform 3-opt move\n    if np.random.rand() < 0.5:\n        # Option 1: Reverse segment between a and b\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:\n        # Option 2: Shift segment between a and b to position c\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n    # Multi-objective crossover: blend with another solution\n    if len(archive) > 1 and np.random.rand() < 0.3:\n        other_idx = np.random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0].copy()\n\n        # Blend segments from both solutions\n        crossover_point = np.random.randint(1, n)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by reinserting missing nodes\n        missing_nodes = [node for node in range(n) if node not in unique]\n        for node in missing_nodes:\n            pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8935638296452129,
            1.532308578491211
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive 3-opt with multi-objective crossover\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Perform 3-opt move\n    if np.random.rand() < 0.5:\n        # Option 1: Reverse segment between a and b\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:\n        # Option 2: Shift segment between a and b to position c\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n    # Multi-objective crossover: blend with another solution\n    if len(archive) > 1 and np.random.rand() < 0.3:\n        other_idx = np.random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0].copy()\n\n        # Blend segments from both solutions\n        crossover_point = np.random.randint(1, n)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by reinserting missing nodes\n        missing_nodes = [node for node in range(n) if node not in unique]\n        for node in missing_nodes:\n            pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive 3-opt moves with a multi-objective crossover operator to explore diverse neighborhoods while balancing the two objectives, ensuring feasibility and high-quality solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive 3-opt with multi-objective crossover\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Perform 3-opt move\n    if np.random.rand() < 0.5:\n        # Option 1: Reverse segment between a and b\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:\n        # Option 2: Shift segment between a and b to position c\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n    # Multi-objective crossover: blend with another solution\n    if len(archive) > 1 and np.random.rand() < 0.3:\n        other_idx = np.random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0].copy()\n\n        # Blend segments from both solutions\n        crossover_point = np.random.randint(1, n)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by reinserting missing nodes\n        missing_nodes = [node for node in range(n) if node not in unique]\n        for node in missing_nodes:\n            pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8935638296452129,
            1.532308578491211
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive 3-opt with multi-objective crossover\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Perform 3-opt move\n    if np.random.rand() < 0.5:\n        # Option 1: Reverse segment between a and b\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:\n        # Option 2: Shift segment between a and b to position c\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n    # Multi-objective crossover: blend with another solution\n    if len(archive) > 1 and np.random.rand() < 0.3:\n        other_idx = np.random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0].copy()\n\n        # Blend segments from both solutions\n        crossover_point = np.random.randint(1, n)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by reinserting missing nodes\n        missing_nodes = [node for node in range(n) if node not in unique]\n        for node in missing_nodes:\n            pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a solution from the archive based on crowding distance and applies a combination of edge insertion and segment reversal to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Compute crowding distances for each solution\n        objectives = np.array([obj for _, obj in archive])\n        crowding_distances = np.zeros(len(archive))\n\n        for i in range(2):  # For each objective\n            sorted_indices = np.argsort(objectives[:, i])\n            crowding_distances[sorted_indices[0]] = np.inf\n            crowding_distances[sorted_indices[-1]] = np.inf\n\n            for j in range(1, len(archive)-1):\n                crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]) / (objectives[sorted_indices[-1], i] - objectives[sorted_indices[0], i] + 1e-10)\n\n        # Select solution with highest crowding distance (most in the middle of the Pareto front)\n        selected_idx = np.argmax(crowding_distances)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Edge insertion\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        if j - i > 1:\n            # Insert node at position i+1 between i and j\n            node = new_solution[i+1]\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [node], new_solution[j+1:]])\n\n        # Segment reversal with probability 0.5\n        if random.random() < 0.5:\n            i, j = random.sample(range(n), 2)\n            if i > j:\n                i, j = j, i\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.42800967395598133,
            2.198763847351074
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Compute crowding distances for each solution\n        objectives = np.array([obj for _, obj in archive])\n        crowding_distances = np.zeros(len(archive))\n\n        for i in range(2):  # For each objective\n            sorted_indices = np.argsort(objectives[:, i])\n            crowding_distances[sorted_indices[0]] = np.inf\n            crowding_distances[sorted_indices[-1]] = np.inf\n\n            for j in range(1, len(archive)-1):\n                crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]) / (objectives[sorted_indices[-1], i] - objectives[sorted_indices[0], i] + 1e-10)\n\n        # Select solution with highest crowding distance (most in the middle of the Pareto front)\n        selected_idx = np.argmax(crowding_distances)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Edge insertion\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        if j - i > 1:\n            # Insert node at position i+1 between i and j\n            node = new_solution[i+1]\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [node], new_solution[j+1:]])\n\n        # Segment reversal with probability 0.5\n        if random.random() < 0.5:\n            i, j = random.sample(range(n), 2)\n            if i > j:\n                i, j = j, i\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{This algorithm selects a promising solution from the archive by prioritizing those with high diversity or low dominance, then applies a hybrid local search combining edge swaps and path relinking to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive (prioritize non-dominated or diverse solutions)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps and path relinking\n    n = len(base_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n\n    # Edge swap (like 2-opt but more flexible)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = base_solution[i:j+1][::-1]\n\n    # Path relinking: replace a segment with a segment from another solution\n    if len(archive) > 1:\n        other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n        other_solution = archive[other_idx][0]\n        k, l = np.random.choice(n, size=2, replace=False)\n        if k > l:\n            k, l = l, k\n        new_solution[k:l+1] = other_solution[k:l+1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts > 1):\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8435405338577966,
            2.846975564956665
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive (prioritize non-dominated or diverse solutions)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps and path relinking\n    n = len(base_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n\n    # Edge swap (like 2-opt but more flexible)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = base_solution[i:j+1][::-1]\n\n    # Path relinking: replace a segment with a segment from another solution\n    if len(archive) > 1:\n        other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n        other_solution = archive[other_idx][0]\n        k, l = np.random.choice(n, size=2, replace=False)\n        if k > l:\n            k, l = l, k\n        new_solution[k:l+1] = other_solution[k:l+1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts > 1):\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{A novel hybrid local search operator combines adaptive edge exchange with probabilistic path relinking, dynamically balancing exploration and exploitation by selectively reordering segments of the tour based on edge dominance in both objective spaces while ensuring feasibility through constrained swaps.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = None\n    for sol, obj in archive:\n        if selected is None or (obj[0] > selected[1][0] and obj[1] > selected[1][1]):\n            selected = (sol, obj)\n\n    if selected is None:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive edge exchange with probabilistic path relinking\n    n = len(base_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    a, b = np.random.choice(n, 2, replace=False)\n\n    # Perform constrained edge exchange\n    if i < j and a < b:\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[a:b+1]\n        new_solution = np.concatenate([\n            new_solution[:i],\n            segment2,\n            new_solution[j+1:a],\n            segment1,\n            new_solution[b+1:]\n        ])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique[counts > 1]\n    for dup in duplicates:\n        missing = np.setdiff1d(np.arange(n), new_solution)\n        if len(missing) > 0:\n            idx = np.where(new_solution == dup)[0][1]\n            new_solution[idx] = missing[0]\n\n    return new_solution\n\n",
        "score": [
            -0.930048769313285,
            2.537386119365692
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = None\n    for sol, obj in archive:\n        if selected is None or (obj[0] > selected[1][0] and obj[1] > selected[1][1]):\n            selected = (sol, obj)\n\n    if selected is None:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive edge exchange with probabilistic path relinking\n    n = len(base_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    a, b = np.random.choice(n, 2, replace=False)\n\n    # Perform constrained edge exchange\n    if i < j and a < b:\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[a:b+1]\n        new_solution = np.concatenate([\n            new_solution[:i],\n            segment2,\n            new_solution[j+1:a],\n            segment1,\n            new_solution[b+1:]\n        ])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique[counts > 1]\n    for dup in duplicates:\n        missing = np.setdiff1d(np.arange(n), new_solution)\n        if len(missing) > 0:\n            idx = np.where(new_solution == dup)[0][1]\n            new_solution[idx] = missing[0]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{A novel hybrid local search operator combines adaptive edge exchange with probabilistic path relinking, dynamically balancing exploration and exploitation by selectively reordering segments of the tour based on edge dominance in both objective spaces while ensuring feasibility through constrained swaps.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = None\n    for sol, obj in archive:\n        if selected is None or (obj[0] > selected[1][0] and obj[1] > selected[1][1]):\n            selected = (sol, obj)\n\n    if selected is None:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive edge exchange with probabilistic path relinking\n    n = len(base_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    a, b = np.random.choice(n, 2, replace=False)\n\n    # Perform constrained edge exchange\n    if i < j and a < b:\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[a:b+1]\n        new_solution = np.concatenate([\n            new_solution[:i],\n            segment2,\n            new_solution[j+1:a],\n            segment1,\n            new_solution[b+1:]\n        ])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique[counts > 1]\n    for dup in duplicates:\n        missing = np.setdiff1d(np.arange(n), new_solution)\n        if len(missing) > 0:\n            idx = np.where(new_solution == dup)[0][1]\n            new_solution[idx] = missing[0]\n\n    return new_solution\n\n",
        "score": [
            -0.930048769313285,
            2.537386119365692
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = None\n    for sol, obj in archive:\n        if selected is None or (obj[0] > selected[1][0] and obj[1] > selected[1][1]):\n            selected = (sol, obj)\n\n    if selected is None:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive edge exchange with probabilistic path relinking\n    n = len(base_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    a, b = np.random.choice(n, 2, replace=False)\n\n    # Perform constrained edge exchange\n    if i < j and a < b:\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[a:b+1]\n        new_solution = np.concatenate([\n            new_solution[:i],\n            segment2,\n            new_solution[j+1:a],\n            segment1,\n            new_solution[b+1:]\n        ])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique[counts > 1]\n    for dup in duplicates:\n        missing = np.setdiff1d(np.arange(n), new_solution)\n        if len(missing) > 0:\n            idx = np.where(new_solution == dup)[0][1]\n            new_solution[idx] = missing[0]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (non-dominated or with high diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Edge insertion with path relinking\n    n = len(base_solution)\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        # Randomly select two segments to operate on\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n\n        # Extract segments\n        segment1 = base_solution[a:b]\n        segment2 = base_solution[c:d]\n\n        # Attempt to insert segment2 into segment1's position\n        temp_solution = np.concatenate([\n            base_solution[:a],\n            segment2,\n            base_solution[b:c],\n            segment1,\n            base_solution[d:]\n        ])\n\n        # Ensure validity (all nodes are unique and in order)\n        if len(np.unique(temp_solution)) == n:\n            # Evaluate the new solution's quality\n            cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n            # If improvement is found, update the solution\n            if (cost1 < archive[selected_idx][1][0]) or (cost2 < archive[selected_idx][1][1]):\n                new_solution = temp_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8173482682029688,
            4.721953451633453
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (non-dominated or with high diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Edge insertion with path relinking\n    n = len(base_solution)\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        # Randomly select two segments to operate on\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n\n        # Extract segments\n        segment1 = base_solution[a:b]\n        segment2 = base_solution[c:d]\n\n        # Attempt to insert segment2 into segment1's position\n        temp_solution = np.concatenate([\n            base_solution[:a],\n            segment2,\n            base_solution[b:c],\n            segment1,\n            base_solution[d:]\n        ])\n\n        # Ensure validity (all nodes are unique and in order)\n        if len(np.unique(temp_solution)) == n:\n            # Evaluate the new solution's quality\n            cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n            # If improvement is found, update the solution\n            if (cost1 < archive[selected_idx][1][0]) or (cost2 < archive[selected_idx][1][1]):\n                new_solution = temp_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{A novel hybrid local search strategy combines a dynamic edge-swap operator with a multi-objective aware insertion heuristic, prioritizing edges with high marginal gain in either objective space while maintaining feasibility through a probabilistic acceptance criterion to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: dynamic edge-swap with multi-objective insertion\n    n = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Randomly select two non-adjacent edges to swap\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        k, l = (i+1) % n, (j+1) % n\n\n        # Calculate marginal gains for both objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                 distance_matrix_1[new_solution[k], new_solution[l]]) - \\\n                (distance_matrix_1[new_solution[i], new_solution[k]] +\n                 distance_matrix_1[new_solution[j], new_solution[l]])\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                 distance_matrix_2[new_solution[k], new_solution[l]]) - \\\n                (distance_matrix_2[new_solution[i], new_solution[k]] +\n                 distance_matrix_2[new_solution[j], new_solution[l]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0:\n            # Perform the swap\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Additional multi-objective insertion step\n    for _ in range(3):\n        # Randomly select a node to reinsert\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n\n        # Remove the node and its adjacent edges\n        pred = new_solution[node_idx-1]\n        succ = new_solution[(node_idx+1) % n]\n\n        # Calculate potential insertion positions\n        possible_positions = [i for i in range(n) if i != node_idx and i != (node_idx-1) % n]\n\n        if not possible_positions:\n            continue\n\n        # Evaluate insertion positions based on marginal gains\n        best_pos = None\n        best_gain = (float('inf'), float('inf'))\n\n        for pos in possible_positions:\n            if pos == 0:\n                new_pred = new_solution[-1]\n                new_succ = new_solution[1]\n            else:\n                new_pred = new_solution[pos-1]\n                new_succ = new_solution[pos]\n\n            # Calculate gains for both objectives\n            delta1 = (distance_matrix_1[pred, succ] -\n                    (distance_matrix_1[pred, node] + distance_matrix_1[node, succ]) +\n                    (distance_matrix_1[new_pred, node] + distance_matrix_1[node, new_succ]))\n            delta2 = (distance_matrix_2[pred, succ] -\n                    (distance_matrix_2[pred, node] + distance_matrix_2[node, succ]) +\n                    (distance_matrix_2[new_pred, node] + distance_matrix_2[node, new_succ]))\n\n            # Update best position if at least one objective improves\n            if delta1 < best_gain[0] or delta2 < best_gain[1]:\n                best_gain = (delta1, delta2)\n                best_pos = pos\n\n        # Perform the insertion if improvement found\n        if best_pos is not None:\n            if best_pos == 0:\n                new_solution = np.concatenate(([node], new_solution[:-1]))\n            else:\n                new_solution = np.concatenate((new_solution[:best_pos], [node], new_solution[best_pos:]))\n                if node_idx < best_pos:\n                    new_solution = np.delete(new_solution, node_idx)\n                else:\n                    new_solution = np.delete(new_solution, node_idx+1)\n\n    return new_solution\n\n",
        "score": [
            -0.9363394807454479,
            4.9237014055252075
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: dynamic edge-swap with multi-objective insertion\n    n = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Randomly select two non-adjacent edges to swap\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        k, l = (i+1) % n, (j+1) % n\n\n        # Calculate marginal gains for both objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                 distance_matrix_1[new_solution[k], new_solution[l]]) - \\\n                (distance_matrix_1[new_solution[i], new_solution[k]] +\n                 distance_matrix_1[new_solution[j], new_solution[l]])\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                 distance_matrix_2[new_solution[k], new_solution[l]]) - \\\n                (distance_matrix_2[new_solution[i], new_solution[k]] +\n                 distance_matrix_2[new_solution[j], new_solution[l]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0:\n            # Perform the swap\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Additional multi-objective insertion step\n    for _ in range(3):\n        # Randomly select a node to reinsert\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n\n        # Remove the node and its adjacent edges\n        pred = new_solution[node_idx-1]\n        succ = new_solution[(node_idx+1) % n]\n\n        # Calculate potential insertion positions\n        possible_positions = [i for i in range(n) if i != node_idx and i != (node_idx-1) % n]\n\n        if not possible_positions:\n            continue\n\n        # Evaluate insertion positions based on marginal gains\n        best_pos = None\n        best_gain = (float('inf'), float('inf'))\n\n        for pos in possible_positions:\n            if pos == 0:\n                new_pred = new_solution[-1]\n                new_succ = new_solution[1]\n            else:\n                new_pred = new_solution[pos-1]\n                new_succ = new_solution[pos]\n\n            # Calculate gains for both objectives\n            delta1 = (distance_matrix_1[pred, succ] -\n                    (distance_matrix_1[pred, node] + distance_matrix_1[node, succ]) +\n                    (distance_matrix_1[new_pred, node] + distance_matrix_1[node, new_succ]))\n            delta2 = (distance_matrix_2[pred, succ] -\n                    (distance_matrix_2[pred, node] + distance_matrix_2[node, succ]) +\n                    (distance_matrix_2[new_pred, node] + distance_matrix_2[node, new_succ]))\n\n            # Update best position if at least one objective improves\n            if delta1 < best_gain[0] or delta2 < best_gain[1]:\n                best_gain = (delta1, delta2)\n                best_pos = pos\n\n        # Perform the insertion if improvement found\n        if best_pos is not None:\n            if best_pos == 0:\n                new_solution = np.concatenate(([node], new_solution[:-1]))\n            else:\n                new_solution = np.concatenate((new_solution[:best_pos], [node], new_solution[best_pos:]))\n                if node_idx < best_pos:\n                    new_solution = np.delete(new_solution, node_idx)\n                else:\n                    new_solution = np.delete(new_solution, node_idx+1)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{A novel hybrid local search strategy combines a dynamic edge-swap operator with a multi-objective aware insertion heuristic, prioritizing edges with high marginal gain in either objective space while maintaining feasibility through a probabilistic acceptance criterion to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: dynamic edge-swap with multi-objective insertion\n    n = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Randomly select two non-adjacent edges to swap\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        k, l = (i+1) % n, (j+1) % n\n\n        # Calculate marginal gains for both objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                 distance_matrix_1[new_solution[k], new_solution[l]]) - \\\n                (distance_matrix_1[new_solution[i], new_solution[k]] +\n                 distance_matrix_1[new_solution[j], new_solution[l]])\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                 distance_matrix_2[new_solution[k], new_solution[l]]) - \\\n                (distance_matrix_2[new_solution[i], new_solution[k]] +\n                 distance_matrix_2[new_solution[j], new_solution[l]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0:\n            # Perform the swap\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Additional multi-objective insertion step\n    for _ in range(3):\n        # Randomly select a node to reinsert\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n\n        # Remove the node and its adjacent edges\n        pred = new_solution[node_idx-1]\n        succ = new_solution[(node_idx+1) % n]\n\n        # Calculate potential insertion positions\n        possible_positions = [i for i in range(n) if i != node_idx and i != (node_idx-1) % n]\n\n        if not possible_positions:\n            continue\n\n        # Evaluate insertion positions based on marginal gains\n        best_pos = None\n        best_gain = (float('inf'), float('inf'))\n\n        for pos in possible_positions:\n            if pos == 0:\n                new_pred = new_solution[-1]\n                new_succ = new_solution[1]\n            else:\n                new_pred = new_solution[pos-1]\n                new_succ = new_solution[pos]\n\n            # Calculate gains for both objectives\n            delta1 = (distance_matrix_1[pred, succ] -\n                    (distance_matrix_1[pred, node] + distance_matrix_1[node, succ]) +\n                    (distance_matrix_1[new_pred, node] + distance_matrix_1[node, new_succ]))\n            delta2 = (distance_matrix_2[pred, succ] -\n                    (distance_matrix_2[pred, node] + distance_matrix_2[node, succ]) +\n                    (distance_matrix_2[new_pred, node] + distance_matrix_2[node, new_succ]))\n\n            # Update best position if at least one objective improves\n            if delta1 < best_gain[0] or delta2 < best_gain[1]:\n                best_gain = (delta1, delta2)\n                best_pos = pos\n\n        # Perform the insertion if improvement found\n        if best_pos is not None:\n            if best_pos == 0:\n                new_solution = np.concatenate(([node], new_solution[:-1]))\n            else:\n                new_solution = np.concatenate((new_solution[:best_pos], [node], new_solution[best_pos:]))\n                if node_idx < best_pos:\n                    new_solution = np.delete(new_solution, node_idx)\n                else:\n                    new_solution = np.delete(new_solution, node_idx+1)\n\n    return new_solution\n\n",
        "score": [
            -0.9363394807454479,
            4.9237014055252075
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: dynamic edge-swap with multi-objective insertion\n    n = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Randomly select two non-adjacent edges to swap\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        k, l = (i+1) % n, (j+1) % n\n\n        # Calculate marginal gains for both objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                 distance_matrix_1[new_solution[k], new_solution[l]]) - \\\n                (distance_matrix_1[new_solution[i], new_solution[k]] +\n                 distance_matrix_1[new_solution[j], new_solution[l]])\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                 distance_matrix_2[new_solution[k], new_solution[l]]) - \\\n                (distance_matrix_2[new_solution[i], new_solution[k]] +\n                 distance_matrix_2[new_solution[j], new_solution[l]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0:\n            # Perform the swap\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Additional multi-objective insertion step\n    for _ in range(3):\n        # Randomly select a node to reinsert\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n\n        # Remove the node and its adjacent edges\n        pred = new_solution[node_idx-1]\n        succ = new_solution[(node_idx+1) % n]\n\n        # Calculate potential insertion positions\n        possible_positions = [i for i in range(n) if i != node_idx and i != (node_idx-1) % n]\n\n        if not possible_positions:\n            continue\n\n        # Evaluate insertion positions based on marginal gains\n        best_pos = None\n        best_gain = (float('inf'), float('inf'))\n\n        for pos in possible_positions:\n            if pos == 0:\n                new_pred = new_solution[-1]\n                new_succ = new_solution[1]\n            else:\n                new_pred = new_solution[pos-1]\n                new_succ = new_solution[pos]\n\n            # Calculate gains for both objectives\n            delta1 = (distance_matrix_1[pred, succ] -\n                    (distance_matrix_1[pred, node] + distance_matrix_1[node, succ]) +\n                    (distance_matrix_1[new_pred, node] + distance_matrix_1[node, new_succ]))\n            delta2 = (distance_matrix_2[pred, succ] -\n                    (distance_matrix_2[pred, node] + distance_matrix_2[node, succ]) +\n                    (distance_matrix_2[new_pred, node] + distance_matrix_2[node, new_succ]))\n\n            # Update best position if at least one objective improves\n            if delta1 < best_gain[0] or delta2 < best_gain[1]:\n                best_gain = (delta1, delta2)\n                best_pos = pos\n\n        # Perform the insertion if improvement found\n        if best_pos is not None:\n            if best_pos == 0:\n                new_solution = np.concatenate(([node], new_solution[:-1]))\n            else:\n                new_solution = np.concatenate((new_solution[:best_pos], [node], new_solution[best_pos:]))\n                if node_idx < best_pos:\n                    new_solution = np.delete(new_solution, node_idx)\n                else:\n                    new_solution = np.delete(new_solution, node_idx+1)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{A hybrid local search operator combines a novel path relinking strategy with a dynamic edge exchange mechanism to generate high-quality neighbors by intelligently combining solution features from the archive while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = archive[np.random.choice(len(archive))][0].copy()\n\n    # Hybrid local search: Path relinking with dynamic edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment for path relinking\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point for the segment in a different solution\n    for sol, _ in archive:\n        if np.array_equal(sol, selected_solution):\n            continue\n\n        # Find the best matching segment in the other solution\n        best_match = None\n        best_score = float('inf')\n\n        for i in range(len(sol) - len(segment) + 1):\n            subsegment = sol[i:i+len(segment)]\n            # Calculate the score based on distance matrices\n            score = sum(distance_matrix_1[segment[j], subsegment[j]] + distance_matrix_2[segment[j], subsegment[j]] for j in range(len(segment)))\n            if score < best_score:\n                best_score = score\n                best_match = subsegment\n\n        if best_match is not None:\n            # Replace the segment with the best match\n            new_solution[a:b+1] = best_match\n            break\n\n    # Dynamic edge exchange: randomly swap edges with improved cost\n    for _ in range(5):  # Limit the number of attempts\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Check if the swap is feasible\n        if i == j or k == l or i == k or i == l or j == k or j == l:\n            continue\n\n        # Calculate the cost before and after the swap\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[k], new_solution[l]] +\n                    distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[k], new_solution[l]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[j], new_solution[l]] +\n                    distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[j], new_solution[l]])\n\n        if new_cost < old_cost:\n            # Perform the swap\n            new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n            new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n\n    return new_solution\n\n",
        "score": [
            -0.9304728870759312,
            1.616649866104126
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = archive[np.random.choice(len(archive))][0].copy()\n\n    # Hybrid local search: Path relinking with dynamic edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment for path relinking\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point for the segment in a different solution\n    for sol, _ in archive:\n        if np.array_equal(sol, selected_solution):\n            continue\n\n        # Find the best matching segment in the other solution\n        best_match = None\n        best_score = float('inf')\n\n        for i in range(len(sol) - len(segment) + 1):\n            subsegment = sol[i:i+len(segment)]\n            # Calculate the score based on distance matrices\n            score = sum(distance_matrix_1[segment[j], subsegment[j]] + distance_matrix_2[segment[j], subsegment[j]] for j in range(len(segment)))\n            if score < best_score:\n                best_score = score\n                best_match = subsegment\n\n        if best_match is not None:\n            # Replace the segment with the best match\n            new_solution[a:b+1] = best_match\n            break\n\n    # Dynamic edge exchange: randomly swap edges with improved cost\n    for _ in range(5):  # Limit the number of attempts\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Check if the swap is feasible\n        if i == j or k == l or i == k or i == l or j == k or j == l:\n            continue\n\n        # Calculate the cost before and after the swap\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[k], new_solution[l]] +\n                    distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[k], new_solution[l]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[j], new_solution[l]] +\n                    distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[j], new_solution[l]])\n\n        if new_cost < old_cost:\n            # Perform the swap\n            new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n            new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Combine edge exchange with path relinking\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Edge exchange: Randomly select two edges and swap their connections\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Create new edges\n    new_edges = [\n        (new_solution[a], new_solution[b]),\n        (new_solution[c], new_solution[d])\n    ]\n\n    # Reconstruct the tour\n    visited = set()\n    path = [new_solution[a]]\n    visited.add(new_solution[a])\n\n    while len(path) < n:\n        last_node = path[-1]\n        candidates = []\n\n        for edge in new_edges:\n            if edge[0] == last_node and edge[1] not in visited:\n                candidates.append(edge[1])\n            elif edge[1] == last_node and edge[0] not in visited:\n                candidates.append(edge[0])\n\n        if not candidates:\n            # Fallback: find next unvisited node\n            for node in new_solution:\n                if node not in visited:\n                    candidates.append(node)\n                    break\n\n        next_node = candidates[0]\n        path.append(next_node)\n        visited.add(next_node)\n\n    # Ensure the tour is valid\n    if len(path) != n or len(set(path)) != n:\n        # Fallback to simple 2-opt if reconstruction fails\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution = np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:]])\n    else:\n        new_solution = np.array(path)\n\n    return new_solution\n\n",
        "score": [
            -0.9949614965298221,
            1.9397221207618713
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Combine edge exchange with path relinking\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Edge exchange: Randomly select two edges and swap their connections\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Create new edges\n    new_edges = [\n        (new_solution[a], new_solution[b]),\n        (new_solution[c], new_solution[d])\n    ]\n\n    # Reconstruct the tour\n    visited = set()\n    path = [new_solution[a]]\n    visited.add(new_solution[a])\n\n    while len(path) < n:\n        last_node = path[-1]\n        candidates = []\n\n        for edge in new_edges:\n            if edge[0] == last_node and edge[1] not in visited:\n                candidates.append(edge[1])\n            elif edge[1] == last_node and edge[0] not in visited:\n                candidates.append(edge[0])\n\n        if not candidates:\n            # Fallback: find next unvisited node\n            for node in new_solution:\n                if node not in visited:\n                    candidates.append(node)\n                    break\n\n        next_node = candidates[0]\n        path.append(next_node)\n        visited.add(next_node)\n\n    # Ensure the tour is valid\n    if len(path) != n or len(set(path)) != n:\n        # Fallback to simple 2-opt if reconstruction fails\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution = np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:]])\n    else:\n        new_solution = np.array(path)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Combine edge exchange with path relinking\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Edge exchange: Randomly select two edges and swap their connections\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Create new edges\n    new_edges = [\n        (new_solution[a], new_solution[b]),\n        (new_solution[c], new_solution[d])\n    ]\n\n    # Reconstruct the tour\n    visited = set()\n    path = [new_solution[a]]\n    visited.add(new_solution[a])\n\n    while len(path) < n:\n        last_node = path[-1]\n        candidates = []\n\n        for edge in new_edges:\n            if edge[0] == last_node and edge[1] not in visited:\n                candidates.append(edge[1])\n            elif edge[1] == last_node and edge[0] not in visited:\n                candidates.append(edge[0])\n\n        if not candidates:\n            # Fallback: find next unvisited node\n            for node in new_solution:\n                if node not in visited:\n                    candidates.append(node)\n                    break\n\n        next_node = candidates[0]\n        path.append(next_node)\n        visited.add(next_node)\n\n    # Ensure the tour is valid\n    if len(path) != n or len(set(path)) != n:\n        # Fallback to simple 2-opt if reconstruction fails\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution = np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:]])\n    else:\n        new_solution = np.array(path)\n\n    return new_solution\n\n",
        "score": [
            -0.9949614965298221,
            1.9397221207618713
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Combine edge exchange with path relinking\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Edge exchange: Randomly select two edges and swap their connections\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Create new edges\n    new_edges = [\n        (new_solution[a], new_solution[b]),\n        (new_solution[c], new_solution[d])\n    ]\n\n    # Reconstruct the tour\n    visited = set()\n    path = [new_solution[a]]\n    visited.add(new_solution[a])\n\n    while len(path) < n:\n        last_node = path[-1]\n        candidates = []\n\n        for edge in new_edges:\n            if edge[0] == last_node and edge[1] not in visited:\n                candidates.append(edge[1])\n            elif edge[1] == last_node and edge[0] not in visited:\n                candidates.append(edge[0])\n\n        if not candidates:\n            # Fallback: find next unvisited node\n            for node in new_solution:\n                if node not in visited:\n                    candidates.append(node)\n                    break\n\n        next_node = candidates[0]\n        path.append(next_node)\n        visited.add(next_node)\n\n    # Ensure the tour is valid\n    if len(path) != n or len(set(path)) != n:\n        # Fallback to simple 2-opt if reconstruction fails\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution = np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:]])\n    else:\n        new_solution = np.array(path)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{This algorithm intelligently selects a solution from the archive with high potential for improvement, then applies a hybrid local search operator combining edge swaps, path relinking, and adaptive segment reversal to generate a high-quality neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest sum of objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(int(len(archive) * 0.2), len(archive) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Create a copy of the base solution\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    # 1. Random segment reversal with adaptive length\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # 2. Edge swap with objective-aware selection\n    i, j = sorted(random.sample(range(n), 2))\n    if random.random() < 0.5:  # Prefer swaps that improve both objectives\n        cost_diff1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]] -\n                      distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[j-1], new_solution[j]])\n        cost_diff2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]] -\n                      distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[j-1], new_solution[j]])\n        if cost_diff1 < 0 and cost_diff2 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # 3. Path relinking with probabilistic acceptance\n    if random.random() < 0.3:\n        target_solution = random.choice(archive)[0]\n        crossover_point = random.randint(1, n - 2)\n        new_solution[crossover_point:] = target_solution[crossover_point:]\n\n    # Ensure the solution remains feasible (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Fix duplicates by reinserting missing nodes\n        missing = set(range(n)) - set(new_solution)\n        duplicates = unique[counts > 1]\n        for dup in duplicates:\n            if missing:\n                new_solution[np.where(new_solution == dup)[0][1]] = missing.pop()\n\n    return new_solution\n\n",
        "score": [
            -0.8454426680822178,
            1.4327765703201294
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest sum of objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(int(len(archive) * 0.2), len(archive) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Create a copy of the base solution\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    # 1. Random segment reversal with adaptive length\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # 2. Edge swap with objective-aware selection\n    i, j = sorted(random.sample(range(n), 2))\n    if random.random() < 0.5:  # Prefer swaps that improve both objectives\n        cost_diff1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]] -\n                      distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[j-1], new_solution[j]])\n        cost_diff2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]] -\n                      distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[j-1], new_solution[j]])\n        if cost_diff1 < 0 and cost_diff2 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # 3. Path relinking with probabilistic acceptance\n    if random.random() < 0.3:\n        target_solution = random.choice(archive)[0]\n        crossover_point = random.randint(1, n - 2)\n        new_solution[crossover_point:] = target_solution[crossover_point:]\n\n    # Ensure the solution remains feasible (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Fix duplicates by reinserting missing nodes\n        missing = set(range(n)) - set(new_solution)\n        duplicates = unique[counts > 1]\n        for dup in duplicates:\n            if missing:\n                new_solution[np.where(new_solution == dup)[0][1]] = missing.pop()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{This algorithm intelligently selects a solution from the archive with high potential for improvement, then applies a hybrid local search operator combining edge swaps, path relinking, and adaptive segment reversal to generate a high-quality neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest sum of objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(int(len(archive) * 0.2), len(archive) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Create a copy of the base solution\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    # 1. Random segment reversal with adaptive length\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # 2. Edge swap with objective-aware selection\n    i, j = sorted(random.sample(range(n), 2))\n    if random.random() < 0.5:  # Prefer swaps that improve both objectives\n        cost_diff1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]] -\n                      distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[j-1], new_solution[j]])\n        cost_diff2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]] -\n                      distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[j-1], new_solution[j]])\n        if cost_diff1 < 0 and cost_diff2 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # 3. Path relinking with probabilistic acceptance\n    if random.random() < 0.3:\n        target_solution = random.choice(archive)[0]\n        crossover_point = random.randint(1, n - 2)\n        new_solution[crossover_point:] = target_solution[crossover_point:]\n\n    # Ensure the solution remains feasible (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Fix duplicates by reinserting missing nodes\n        missing = set(range(n)) - set(new_solution)\n        duplicates = unique[counts > 1]\n        for dup in duplicates:\n            if missing:\n                new_solution[np.where(new_solution == dup)[0][1]] = missing.pop()\n\n    return new_solution\n\n",
        "score": [
            -0.8454426680822178,
            1.4327765703201294
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest sum of objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(int(len(archive) * 0.2), len(archive) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Create a copy of the base solution\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    # 1. Random segment reversal with adaptive length\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # 2. Edge swap with objective-aware selection\n    i, j = sorted(random.sample(range(n), 2))\n    if random.random() < 0.5:  # Prefer swaps that improve both objectives\n        cost_diff1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]] -\n                      distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[j-1], new_solution[j]])\n        cost_diff2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]] -\n                      distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[j-1], new_solution[j]])\n        if cost_diff1 < 0 and cost_diff2 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # 3. Path relinking with probabilistic acceptance\n    if random.random() < 0.3:\n        target_solution = random.choice(archive)[0]\n        crossover_point = random.randint(1, n - 2)\n        new_solution[crossover_point:] = target_solution[crossover_point:]\n\n    # Ensure the solution remains feasible (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Fix duplicates by reinserting missing nodes\n        missing = set(range(n)) - set(new_solution)\n        duplicates = unique[counts > 1]\n        for dup in duplicates:\n            if missing:\n                new_solution[np.where(new_solution == dup)[0][1]] = missing.pop()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{The algorithm intelligently selects a solution from the archive by prioritizing those with the lowest combined objective values, then applies a hybrid local search combining edge swaps and segment reversals to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    base_solution = selected_solution.copy()\n\n    # Hybrid local search: combine edge swaps and segment reversals\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Randomly swap two edges\n    i, j = np.random.choice(n, size=2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates and covers all nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original segment\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.788190942393402,
            1.6549508571624756
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    base_solution = selected_solution.copy()\n\n    # Hybrid local search: combine edge swaps and segment reversals\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Randomly swap two edges\n    i, j = np.random.choice(n, size=2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates and covers all nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original segment\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{A novel hybrid local search operator combines edge exchange with segment reversal, where promising segments are selected based on Pareto dominance and non-dominated sorting to guide exploration in both objective spaces, while ensuring feasibility through intelligent edge swaps and segment flips.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combination of objectives (e.g., sum of normalized costs)\n        objectives = np.array([obj for _, obj in archive])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        scores = normalized.sum(axis=1)\n        selected_idx = np.argmin(scores)  # Prefer solutions with lower combined cost\n    else:\n        selected_idx = 0\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine segment reversal and edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Select a segment to reverse (promising based on distance improvement)\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, min(i + 5, n - 1))  # Limit segment length for efficiency\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    # Step 2: Apply edge exchange if it improves both objectives\n    if random.random() < 0.5:  # Probabilistic exchange\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate change in objectives\n            old_edges = [\n                (new_solution[a-1], new_solution[a]),\n                (new_solution[a], new_solution[a+1] if a+1 < n else new_solution[0]),\n                (new_solution[b-1], new_solution[b]),\n                (new_solution[b], new_solution[b+1] if b+1 < n else new_solution[0])\n            ]\n            new_edges = [\n                (new_solution[a-1], new_solution[b]),\n                (new_solution[b], new_solution[a+1] if a+1 < n else new_solution[0]),\n                (new_solution[b-1], new_solution[a]),\n                (new_solution[a], new_solution[b+1] if b+1 < n else new_solution[0])\n            ]\n\n            old_cost1 = sum(distance_matrix_1[u, v] for u, v in old_edges)\n            new_cost1 = sum(distance_matrix_1[u, v] for u, v in new_edges)\n            old_cost2 = sum(distance_matrix_2[u, v] for u, v in old_edges)\n            new_cost2 = sum(distance_matrix_2[u, v] for u, v in new_edges)\n\n            if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or \\\n               (new_cost1 <= old_cost1 and new_cost2 < old_cost2) or \\\n               (new_cost1 < old_cost1 and new_cost2 <= old_cost2):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility (no duplicates)\n    assert len(np.unique(new_solution)) == len(instance), \"Invalid TSP tour generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.6379068513724873,
            1.8012090921401978
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combination of objectives (e.g., sum of normalized costs)\n        objectives = np.array([obj for _, obj in archive])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        scores = normalized.sum(axis=1)\n        selected_idx = np.argmin(scores)  # Prefer solutions with lower combined cost\n    else:\n        selected_idx = 0\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine segment reversal and edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Select a segment to reverse (promising based on distance improvement)\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, min(i + 5, n - 1))  # Limit segment length for efficiency\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    # Step 2: Apply edge exchange if it improves both objectives\n    if random.random() < 0.5:  # Probabilistic exchange\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate change in objectives\n            old_edges = [\n                (new_solution[a-1], new_solution[a]),\n                (new_solution[a], new_solution[a+1] if a+1 < n else new_solution[0]),\n                (new_solution[b-1], new_solution[b]),\n                (new_solution[b], new_solution[b+1] if b+1 < n else new_solution[0])\n            ]\n            new_edges = [\n                (new_solution[a-1], new_solution[b]),\n                (new_solution[b], new_solution[a+1] if a+1 < n else new_solution[0]),\n                (new_solution[b-1], new_solution[a]),\n                (new_solution[a], new_solution[b+1] if b+1 < n else new_solution[0])\n            ]\n\n            old_cost1 = sum(distance_matrix_1[u, v] for u, v in old_edges)\n            new_cost1 = sum(distance_matrix_1[u, v] for u, v in new_edges)\n            old_cost2 = sum(distance_matrix_2[u, v] for u, v in old_edges)\n            new_cost2 = sum(distance_matrix_2[u, v] for u, v in new_edges)\n\n            if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or \\\n               (new_cost1 <= old_cost1 and new_cost2 < old_cost2) or \\\n               (new_cost1 < old_cost1 and new_cost2 <= old_cost2):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility (no duplicates)\n    assert len(np.unique(new_solution)) == len(instance), \"Invalid TSP tour generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search operator combining edge insertion and segment relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a balance between objective values and diversity\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: edge insertion + segment relocation\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomly select a segment of the tour\n    segment_start = np.random.randint(0, n)\n    segment_length = np.random.randint(2, min(5, n - 1))\n    segment_end = (segment_start + segment_length) % n\n\n    # Extract the segment\n    if segment_start < segment_end:\n        segment = new_solution[segment_start:segment_end]\n    else:\n        segment = np.concatenate((new_solution[segment_start:], new_solution[:segment_end]))\n\n    # Step 2: Remove the segment from the tour\n    remaining = np.setdiff1d(new_solution, segment)\n\n    # Step 3: Insert the segment at a new position\n    insert_pos = np.random.randint(0, len(remaining))\n    new_solution = np.concatenate((remaining[:insert_pos], segment, remaining[insert_pos:]))\n\n    # Step 4: Apply edge insertion for further improvement\n    for _ in range(2):  # Limit the number of edge insertions\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        if abs(i - j) < 2:\n            continue  # Skip if too close\n        i, j = min(i, j), max(i, j)\n        segment = new_solution[i:j]\n        new_solution = np.concatenate((new_solution[:i], new_solution[j:], segment))\n\n    return new_solution\n\n",
        "score": [
            -0.7189144650456105,
            2.3317665457725525
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a balance between objective values and diversity\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: edge insertion + segment relocation\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomly select a segment of the tour\n    segment_start = np.random.randint(0, n)\n    segment_length = np.random.randint(2, min(5, n - 1))\n    segment_end = (segment_start + segment_length) % n\n\n    # Extract the segment\n    if segment_start < segment_end:\n        segment = new_solution[segment_start:segment_end]\n    else:\n        segment = np.concatenate((new_solution[segment_start:], new_solution[:segment_end]))\n\n    # Step 2: Remove the segment from the tour\n    remaining = np.setdiff1d(new_solution, segment)\n\n    # Step 3: Insert the segment at a new position\n    insert_pos = np.random.randint(0, len(remaining))\n    new_solution = np.concatenate((remaining[:insert_pos], segment, remaining[insert_pos:]))\n\n    # Step 4: Apply edge insertion for further improvement\n    for _ in range(2):  # Limit the number of edge insertions\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        if abs(i - j) < 2:\n            continue  # Skip if too close\n        i, j = min(i, j), max(i, j)\n        segment = new_solution[i:j]\n        new_solution = np.concatenate((new_solution[:i], new_solution[j:], segment))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 13,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0))\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmin(scores)  # Select the solution with the lowest score (best trade-off)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator (combination of 3-opt and edge insertion)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to perform 3-opt\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    a, b, c = new_solution[i], new_solution[j], new_solution[k]\n\n    # Reconstruct the tour by reversing the middle segment and adjusting edges\n    new_segment = np.concatenate([new_solution[i:j], new_solution[j:k][::-1]])\n    new_solution = np.concatenate([new_solution[:i], new_segment, new_solution[k:]])\n\n    # Edge insertion: Insert a randomly selected edge from another part of the tour\n    if n > 4:\n        l, m = sorted(np.random.choice([x for x in range(n) if x not in {i, j, k}], 2, replace=False))\n        edge = new_solution[l:m+1]\n        new_solution = np.concatenate([new_solution[:l], new_solution[m+1:], edge])\n\n    return new_solution\n\n",
        "score": [
            -0.7459935194158311,
            2.2628541588783264
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0))\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmin(scores)  # Select the solution with the lowest score (best trade-off)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator (combination of 3-opt and edge insertion)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to perform 3-opt\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    a, b, c = new_solution[i], new_solution[j], new_solution[k]\n\n    # Reconstruct the tour by reversing the middle segment and adjusting edges\n    new_segment = np.concatenate([new_solution[i:j], new_solution[j:k][::-1]])\n    new_solution = np.concatenate([new_solution[:i], new_segment, new_solution[k:]])\n\n    # Edge insertion: Insert a randomly selected edge from another part of the tour\n    if n > 4:\n        l, m = sorted(np.random.choice([x for x in range(n) if x not in {i, j, k}], 2, replace=False))\n        edge = new_solution[l:m+1]\n        new_solution = np.concatenate([new_solution[:l], new_solution[m+1:], edge])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 14,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.5, 0.5]\n    archive.sort(key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: 2-opt with adaptive segment selection and insertion-based perturbation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive 2-opt segment selection\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:  # Ensure segment has at least 2 nodes\n            # Reverse the segment\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n            # Check if improvement in either objective\n            old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n            new_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n            new_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n            if (new_cost1 < old_cost1 or new_cost2 < old_cost2):\n                base_solution = new_solution.copy()\n            else:\n                new_solution = base_solution.copy()\n\n    # Step 2: Insertion-based perturbation for diversification\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8029517149602035,
            5.92678689956665
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.5, 0.5]\n    archive.sort(key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: 2-opt with adaptive segment selection and insertion-based perturbation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive 2-opt segment selection\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:  # Ensure segment has at least 2 nodes\n            # Reverse the segment\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n            # Check if improvement in either objective\n            old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n            new_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n            new_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n            if (new_cost1 < old_cost1 or new_cost2 < old_cost2):\n                base_solution = new_solution.copy()\n            else:\n                new_solution = base_solution.copy()\n\n    # Step 2: Insertion-based perturbation for diversification\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 15,
        "algorithm": "{This heuristic function selects a promising solution from the archive by prioritizing those with diverse objective values, then applies a hybrid local search operator combining edge insertion and node reordering to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by objective diversity (sum of differences)\n        archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]), reverse=True)\n        # Select top 30% or at least 1 solution\n        top_k = max(1, int(0.3 * len(archive)))\n        selected = random.choice(archive_sorted[:top_k])\n        base_solution = selected[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion with node reordering\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a segment to reorder\n        start = random.randint(0, n - 4)\n        end = random.randint(start + 2, min(start + 5, n - 1))\n\n        segment = new_solution[start:end+1]\n        # Reorder the segment with probability based on objective diversity\n        if random.random() < 0.7:  # Higher probability for diverse solutions\n            if random.random() < 0.5:\n                segment = segment[::-1]  # Reverse\n            else:\n                segment = np.roll(segment, random.randint(1, len(segment)-1))  # Rotate\n\n        # Insert the reordered segment back\n        new_solution = np.concatenate([new_solution[:start], segment, new_solution[end+1:]])\n\n        # Ensure feasibility by checking for duplicates\n        if len(np.unique(new_solution)) != n:\n            # If invalid, revert to original segment\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.4275866342491508,
            2.006838321685791
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by objective diversity (sum of differences)\n        archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]), reverse=True)\n        # Select top 30% or at least 1 solution\n        top_k = max(1, int(0.3 * len(archive)))\n        selected = random.choice(archive_sorted[:top_k])\n        base_solution = selected[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion with node reordering\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a segment to reorder\n        start = random.randint(0, n - 4)\n        end = random.randint(start + 2, min(start + 5, n - 1))\n\n        segment = new_solution[start:end+1]\n        # Reorder the segment with probability based on objective diversity\n        if random.random() < 0.7:  # Higher probability for diverse solutions\n            if random.random() < 0.5:\n                segment = segment[::-1]  # Reverse\n            else:\n                segment = np.roll(segment, random.randint(1, len(segment)-1))  # Rotate\n\n        # Insert the reordered segment back\n        new_solution = np.concatenate([new_solution[:start], segment, new_solution[end+1:]])\n\n        # Ensure feasibility by checking for duplicates\n        if len(np.unique(new_solution)) != n:\n            # If invalid, revert to original segment\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 16,
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge exchange with a novel segment inversion operator to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lower objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = objectives / np.max(objectives, axis=0)\n    combined_score = np.sum(normalized, axis=1)\n    selected_idx = np.argmin(combined_score)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Edge exchange with segment inversion\n    # Step 1: Random edge exchange\n    if n > 2:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment inversion\n    if n > 3:\n        start, end = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[start:end+1]\n        new_solution[start:end+1] = segment[::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple 2-opt if inversion causes duplicates\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7750805461067565,
            1.621289610862732
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lower objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = objectives / np.max(objectives, axis=0)\n    combined_score = np.sum(normalized, axis=1)\n    selected_idx = np.argmin(combined_score)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Edge exchange with segment inversion\n    # Step 1: Random edge exchange\n    if n > 2:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment inversion\n    if n > 3:\n        start, end = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[start:end+1]\n        new_solution[start:end+1] = segment[::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple 2-opt if inversion causes duplicates\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 17,
        "algorithm": "{This algorithm intelligently selects a high-quality solution from the archive based on objective diversity and applies a hybrid local search operator that combines edge swapping with a novel node reinsertion strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate objective diversity (normalized difference between objectives)\n        objectives = np.array([obj for _, obj in archive])\n        obj_diff = np.abs(objectives[:, 0] - objectives[:, 1])\n        obj_diff = obj_diff / (np.max(obj_diff) + 1e-10)  # Avoid division by zero\n        probabilities = obj_diff / np.sum(obj_diff)\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between edge swapping or node reinsertion based on a heuristic\n        if random.random() < 0.5:\n            # Edge swapping: select two non-adjacent edges and swap them\n            i = random.randint(0, n - 3)\n            j = random.randint(i + 2, n - 1)\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        else:\n            # Node reinsertion: remove a random node and reinsert it at the best position\n            remove_idx = random.randint(0, n - 1)\n            node = new_solution[remove_idx]\n            new_solution = np.delete(new_solution, remove_idx)\n\n            # Calculate insertion costs for all possible positions\n            insertion_costs = []\n            for i in range(n - 1):\n                # Calculate cost in both objectives\n                prev_node = new_solution[i - 1] if i > 0 else new_solution[-1]\n                next_node = new_solution[i]\n                cost1 = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                         - distance_matrix_1[prev_node, next_node])\n                cost2 = (distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                         - distance_matrix_2[prev_node, next_node])\n                insertion_costs.append((cost1 + cost2, i))  # Combined cost\n\n            # Insert at the position with minimal cost\n            best_cost, best_pos = min(insertion_costs)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6675730685172934,
            2.6409186124801636
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate objective diversity (normalized difference between objectives)\n        objectives = np.array([obj for _, obj in archive])\n        obj_diff = np.abs(objectives[:, 0] - objectives[:, 1])\n        obj_diff = obj_diff / (np.max(obj_diff) + 1e-10)  # Avoid division by zero\n        probabilities = obj_diff / np.sum(obj_diff)\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between edge swapping or node reinsertion based on a heuristic\n        if random.random() < 0.5:\n            # Edge swapping: select two non-adjacent edges and swap them\n            i = random.randint(0, n - 3)\n            j = random.randint(i + 2, n - 1)\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        else:\n            # Node reinsertion: remove a random node and reinsert it at the best position\n            remove_idx = random.randint(0, n - 1)\n            node = new_solution[remove_idx]\n            new_solution = np.delete(new_solution, remove_idx)\n\n            # Calculate insertion costs for all possible positions\n            insertion_costs = []\n            for i in range(n - 1):\n                # Calculate cost in both objectives\n                prev_node = new_solution[i - 1] if i > 0 else new_solution[-1]\n                next_node = new_solution[i]\n                cost1 = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                         - distance_matrix_1[prev_node, next_node])\n                cost2 = (distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                         - distance_matrix_2[prev_node, next_node])\n                insertion_costs.append((cost1 + cost2, i))  # Combined cost\n\n            # Insert at the position with minimal cost\n            best_cost, best_pos = min(insertion_costs)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 18,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with biased edge selection\n    n = len(base_solution)\n    # Randomly select two distinct edges to break\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n    while k in [i, j]:\n        k = random.randint(0, n-1)\n\n    # Reconnect nodes in a biased way (prioritize edges with high distance in either objective)\n    def edge_cost(a, b):\n        return distance_matrix_1[a, b] + distance_matrix_2[a, b]\n\n    # Find the best possible reconnection\n    best_cost = float('inf')\n    best_reconnection = None\n\n    for a in [i, j, k]:\n        for b in [i, j, k]:\n            if a != b:\n                # Try reconnecting edges\n                temp_solution = new_solution.copy()\n                temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n                cost = sum(edge_cost(temp_solution[i], temp_solution[(i+1)%n]) for i in range(n))\n                if cost < best_cost:\n                    best_cost = cost\n                    best_reconnection = temp_solution.copy()\n\n    if best_reconnection is not None:\n        new_solution = best_reconnection\n\n    return new_solution\n\n",
        "score": [
            -0.8956146350017844,
            2.7610047459602356
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with biased edge selection\n    n = len(base_solution)\n    # Randomly select two distinct edges to break\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n    while k in [i, j]:\n        k = random.randint(0, n-1)\n\n    # Reconnect nodes in a biased way (prioritize edges with high distance in either objective)\n    def edge_cost(a, b):\n        return distance_matrix_1[a, b] + distance_matrix_2[a, b]\n\n    # Find the best possible reconnection\n    best_cost = float('inf')\n    best_reconnection = None\n\n    for a in [i, j, k]:\n        for b in [i, j, k]:\n            if a != b:\n                # Try reconnecting edges\n                temp_solution = new_solution.copy()\n                temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n                cost = sum(edge_cost(temp_solution[i], temp_solution[(i+1)%n]) for i in range(n))\n                if cost < best_cost:\n                    best_cost = cost\n                    best_reconnection = temp_solution.copy()\n\n    if best_reconnection is not None:\n        new_solution = best_reconnection\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 19,
        "algorithm": "{A novel hybrid local search operator combines a randomized node insertion with a multi-objective aware edge swap, prioritizing solutions with diverse trade-offs in the archive while ensuring feasibility through strict validation of the generated neighbor.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with diverse trade-offs\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Normalize objectives and compute diversity score\n    norm_obj = np.array(objectives)\n    if len(norm_obj) > 0:\n        norm_obj = (norm_obj - norm_obj.min(axis=0)) / (norm_obj.max(axis=0) - norm_obj.min(axis=0) + 1e-8)\n        diversity = np.sum(np.abs(norm_obj[:, 0] - norm_obj[:, 1]))\n        selected_idx = np.argmax(diversity) if len(norm_obj) > 1 else 0\n    else:\n        selected_idx = 0\n\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: randomized insertion + multi-objective edge swap\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomized insertion\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    node = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Step 2: Multi-objective edge swap\n    for _ in range(min(3, n // 2)):\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Evaluate swap impact on both objectives\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n        # Accept if both objectives improve or at least one improves significantly\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (new_cost1 < current_cost1 * 0.9 and new_cost2 < current_cost2 * 1.1) or \\\n           (new_cost1 < current_cost1 * 1.1 and new_cost2 < current_cost2 * 0.9):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure solution is valid (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8528263769843989,
            2.491284728050232
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with diverse trade-offs\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Normalize objectives and compute diversity score\n    norm_obj = np.array(objectives)\n    if len(norm_obj) > 0:\n        norm_obj = (norm_obj - norm_obj.min(axis=0)) / (norm_obj.max(axis=0) - norm_obj.min(axis=0) + 1e-8)\n        diversity = np.sum(np.abs(norm_obj[:, 0] - norm_obj[:, 1]))\n        selected_idx = np.argmax(diversity) if len(norm_obj) > 1 else 0\n    else:\n        selected_idx = 0\n\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: randomized insertion + multi-objective edge swap\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomized insertion\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    node = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Step 2: Multi-objective edge swap\n    for _ in range(min(3, n // 2)):\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Evaluate swap impact on both objectives\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n        # Accept if both objectives improve or at least one improves significantly\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (new_cost1 < current_cost1 * 0.9 and new_cost2 < current_cost2 * 1.1) or \\\n           (new_cost1 < current_cost1 * 1.1 and new_cost2 < current_cost2 * 0.9):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure solution is valid (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 20,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_objectives = [(cost1 + cost2) / (np.sum(distance_matrix_1) + np.sum(distance_matrix_2)) for _, (cost1, cost2) in archive]\n    selected_idx = np.argmax(normalized_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a custom edge swap based on both distance matrices\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move on the first objective space\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform a custom edge swap based on the second objective space\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n    if distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]] < \\\n       distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.8805134702680882,
            5.236877799034119
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_objectives = [(cost1 + cost2) / (np.sum(distance_matrix_1) + np.sum(distance_matrix_2)) for _, (cost1, cost2) in archive]\n    selected_idx = np.argmax(normalized_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a custom edge swap based on both distance matrices\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move on the first objective space\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform a custom edge swap based on the second objective space\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n    if distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]] < \\\n       distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 21,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment reversal with multi-objective edge exchange, prioritizing high-crowding-distance solutions and dynamically adjusting segment lengths based on the Pareto front's diversity to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance in the Pareto front\n    def crowding_distance(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        distances = np.zeros(len(solutions))\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[:, m])\n            distances[sorted_idx[0]] = np.inf\n            distances[sorted_idx[-1]] = np.inf\n            for i in range(1, len(solutions) - 1):\n                distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive segment reversal with multi-objective edge exchange\n    n = len(base_solution)\n    segment_length = max(2, min(n // 4, 5))  # Adaptive segment length\n\n    # Randomly select a segment to reverse\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Multi-objective edge exchange\n    for _ in range(2):  # Perform limited exchanges\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        # Calculate cost change in both objectives\n        delta1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] +\n                  distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                  distance_matrix_1[base_solution[j-1], base_solution[i]] +\n                  distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                 (distance_matrix_1[base_solution[i-1], base_solution[i]] +\n                  distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                  distance_matrix_1[base_solution[j-1], base_solution[j]] +\n                  distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] +\n                  distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                  distance_matrix_2[base_solution[j-1], base_solution[i]] +\n                  distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                 (distance_matrix_2[base_solution[i-1], base_solution[i]] +\n                  distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                  distance_matrix_2[base_solution[j-1], base_solution[j]] +\n                  distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n\n        # Accept if both objectives improve or randomly with small probability\n        if (delta1 <= 0 and delta2 <= 0) or (np.random.random() < 0.05):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6761790652915869,
            3.2496062517166138
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance in the Pareto front\n    def crowding_distance(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        distances = np.zeros(len(solutions))\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[:, m])\n            distances[sorted_idx[0]] = np.inf\n            distances[sorted_idx[-1]] = np.inf\n            for i in range(1, len(solutions) - 1):\n                distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive segment reversal with multi-objective edge exchange\n    n = len(base_solution)\n    segment_length = max(2, min(n // 4, 5))  # Adaptive segment length\n\n    # Randomly select a segment to reverse\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Multi-objective edge exchange\n    for _ in range(2):  # Perform limited exchanges\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        # Calculate cost change in both objectives\n        delta1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] +\n                  distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                  distance_matrix_1[base_solution[j-1], base_solution[i]] +\n                  distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                 (distance_matrix_1[base_solution[i-1], base_solution[i]] +\n                  distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                  distance_matrix_1[base_solution[j-1], base_solution[j]] +\n                  distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] +\n                  distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                  distance_matrix_2[base_solution[j-1], base_solution[i]] +\n                  distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                 (distance_matrix_2[base_solution[i-1], base_solution[i]] +\n                  distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                  distance_matrix_2[base_solution[j-1], base_solution[j]] +\n                  distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n\n        # Accept if both objectives improve or randomly with small probability\n        if (delta1 <= 0 and delta2 <= 0) or (np.random.random() < 0.05):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 22,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    selected_solution, _ = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine edge insertion with segment reversal\n    n = len(new_solution)\n    # Randomly select two distinct positions\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    # Extract the segment to be reversed\n    segment = new_solution[a:b+1]\n    # Reverse the segment\n    segment_reversed = segment[::-1]\n    # Insert the reversed segment back\n    new_solution[a:b+1] = segment_reversed\n\n    # Additional random edge insertion to ensure diversity\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if c != d:\n        node = new_solution[d]\n        new_solution = np.concatenate([new_solution[:c+1], [node], new_solution[c+1:d], new_solution[d+1:]])\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if invalid\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8343363855186934,
            2.2901681065559387
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    selected_solution, _ = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine edge insertion with segment reversal\n    n = len(new_solution)\n    # Randomly select two distinct positions\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    # Extract the segment to be reversed\n    segment = new_solution[a:b+1]\n    # Reverse the segment\n    segment_reversed = segment[::-1]\n    # Insert the reversed segment back\n    new_solution[a:b+1] = segment_reversed\n\n    # Additional random edge insertion to ensure diversity\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if c != d:\n        node = new_solution[d]\n        new_solution = np.concatenate([new_solution[:c+1], [node], new_solution[c+1:d], new_solution[d+1:]])\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if invalid\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 23,
        "algorithm": "{A novel hybrid local search strategy that combines a randomized segment reallocation with a multi-objective-aware edge insertion heuristic to generate high-quality neighbors by intelligently selecting promising solutions from the archive and applying a non-standard perturbation to their structure while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on a combination of randomness and objective diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: segment reallocation with multi-objective edge insertion\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomly select a segment to reallocate\n    segment_start = random.randint(0, n - 3)\n    segment_length = random.randint(2, min(4, n - segment_start - 1))\n    segment = new_solution[segment_start:segment_start + segment_length]\n\n    # Remove the segment from the solution\n    remaining = np.concatenate([new_solution[:segment_start], new_solution[segment_start + segment_length:]])\n\n    # Step 2: Find the best insertion point for the segment based on multi-objective criteria\n    best_insert_pos = 0\n    best_score = float('inf')\n\n    for i in range(len(remaining)):\n        # Insert segment between i and i+1\n        candidate = np.concatenate([remaining[:i], segment, remaining[i:]])\n\n        # Calculate the total cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[j], candidate[(j+1) % n]] for j in range(n))\n        cost2 = sum(distance_matrix_2[candidate[j], candidate[(j+1) % n]] for j in range(n))\n\n        # Combine objectives using a simple sum (can be replaced with more sophisticated MOO techniques)\n        combined_cost = cost1 + cost2\n\n        if combined_cost < best_score:\n            best_score = combined_cost\n            best_insert_pos = i\n\n    # Insert the segment at the best position\n    new_solution = np.concatenate([remaining[:best_insert_pos], segment, remaining[best_insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7658369796028385,
            10.660884439945221
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on a combination of randomness and objective diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: segment reallocation with multi-objective edge insertion\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomly select a segment to reallocate\n    segment_start = random.randint(0, n - 3)\n    segment_length = random.randint(2, min(4, n - segment_start - 1))\n    segment = new_solution[segment_start:segment_start + segment_length]\n\n    # Remove the segment from the solution\n    remaining = np.concatenate([new_solution[:segment_start], new_solution[segment_start + segment_length:]])\n\n    # Step 2: Find the best insertion point for the segment based on multi-objective criteria\n    best_insert_pos = 0\n    best_score = float('inf')\n\n    for i in range(len(remaining)):\n        # Insert segment between i and i+1\n        candidate = np.concatenate([remaining[:i], segment, remaining[i:]])\n\n        # Calculate the total cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[j], candidate[(j+1) % n]] for j in range(n))\n        cost2 = sum(distance_matrix_2[candidate[j], candidate[(j+1) % n]] for j in range(n))\n\n        # Combine objectives using a simple sum (can be replaced with more sophisticated MOO techniques)\n        combined_cost = cost1 + cost2\n\n        if combined_cost < best_score:\n            best_score = combined_cost\n            best_insert_pos = i\n\n    # Insert the segment at the best position\n    new_solution = np.concatenate([remaining[:best_insert_pos], segment, remaining[best_insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 24,
        "algorithm": "{A novel hybrid local search operator combines a randomized edge-swapping strategy with a multi-objective path relinking mechanism, selectively improving segments of the tour based on Pareto dominance in both objective spaces to generate high-quality neighbors from promising solutions in the archive.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by sum of objectives to prioritize potentially non-dominated solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% or at least 1 solution\n        candidate_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from candidates\n        base_solution, _ = random.choice(candidate_solutions)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    # Step 1: Randomly select a segment to modify\n    segment_start = random.randint(0, n - 1)\n    segment_length = random.randint(2, min(5, n // 2))\n    segment_end = min(segment_start + segment_length, n)\n\n    # Step 2: Reverse the selected segment\n    new_solution[segment_start:segment_end] = new_solution[segment_start:segment_end][::-1]\n\n    # Step 3: Apply multi-objective path relinking\n    # Select a random node to relink\n    relink_node = random.choice(new_solution)\n    relink_pos = np.where(new_solution == relink_node)[0][0]\n\n    # Find the best insertion point considering both objectives\n    best_pos = relink_pos\n    best_improvement = 0\n\n    for pos in range(n):\n        if pos == relink_pos or (pos == relink_pos - 1) or (pos == (relink_pos + 1) % n):\n            continue\n\n        # Calculate cost change for both objectives\n        prev_node = new_solution[(relink_pos - 1) % n]\n        next_node = new_solution[(relink_pos + 1) % n]\n        new_prev_node = new_solution[(pos - 1) % n]\n        new_next_node = new_solution[pos]\n\n        cost1_old = distance_matrix_1[prev_node, next_node]\n        cost1_new = distance_matrix_1[prev_node, relink_node] + distance_matrix_1[relink_node, next_node]\n        cost1_new_pos = distance_matrix_1[new_prev_node, relink_node] + distance_matrix_1[relink_node, new_next_node]\n\n        cost2_old = distance_matrix_2[prev_node, next_node]\n        cost2_new = distance_matrix_2[prev_node, relink_node] + distance_matrix_2[relink_node, next_node]\n        cost2_new_pos = distance_matrix_2[new_prev_node, relink_node] + distance_matrix_2[relink_node, new_next_node]\n\n        # Calculate improvement (negative means better)\n        improvement1 = (cost1_new_pos - cost1_old) - (cost1_new - cost1_old)\n        improvement2 = (cost2_new_pos - cost2_old) - (cost2_new - cost2_old)\n\n        # Combine improvements (simple sum for this example)\n        total_improvement = improvement1 + improvement2\n\n        if total_improvement < best_improvement:\n            best_improvement = total_improvement\n            best_pos = pos\n\n    # Perform the relinking\n    if best_pos != relink_pos:\n        # Remove the node from current position\n        new_solution = np.delete(new_solution, relink_pos)\n        # Insert at best position\n        new_solution = np.insert(new_solution, best_pos, relink_node)\n\n    return new_solution\n\n",
        "score": [
            -0.7744608972922217,
            2.1439326405525208
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by sum of objectives to prioritize potentially non-dominated solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% or at least 1 solution\n        candidate_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from candidates\n        base_solution, _ = random.choice(candidate_solutions)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    # Step 1: Randomly select a segment to modify\n    segment_start = random.randint(0, n - 1)\n    segment_length = random.randint(2, min(5, n // 2))\n    segment_end = min(segment_start + segment_length, n)\n\n    # Step 2: Reverse the selected segment\n    new_solution[segment_start:segment_end] = new_solution[segment_start:segment_end][::-1]\n\n    # Step 3: Apply multi-objective path relinking\n    # Select a random node to relink\n    relink_node = random.choice(new_solution)\n    relink_pos = np.where(new_solution == relink_node)[0][0]\n\n    # Find the best insertion point considering both objectives\n    best_pos = relink_pos\n    best_improvement = 0\n\n    for pos in range(n):\n        if pos == relink_pos or (pos == relink_pos - 1) or (pos == (relink_pos + 1) % n):\n            continue\n\n        # Calculate cost change for both objectives\n        prev_node = new_solution[(relink_pos - 1) % n]\n        next_node = new_solution[(relink_pos + 1) % n]\n        new_prev_node = new_solution[(pos - 1) % n]\n        new_next_node = new_solution[pos]\n\n        cost1_old = distance_matrix_1[prev_node, next_node]\n        cost1_new = distance_matrix_1[prev_node, relink_node] + distance_matrix_1[relink_node, next_node]\n        cost1_new_pos = distance_matrix_1[new_prev_node, relink_node] + distance_matrix_1[relink_node, new_next_node]\n\n        cost2_old = distance_matrix_2[prev_node, next_node]\n        cost2_new = distance_matrix_2[prev_node, relink_node] + distance_matrix_2[relink_node, next_node]\n        cost2_new_pos = distance_matrix_2[new_prev_node, relink_node] + distance_matrix_2[relink_node, new_next_node]\n\n        # Calculate improvement (negative means better)\n        improvement1 = (cost1_new_pos - cost1_old) - (cost1_new - cost1_old)\n        improvement2 = (cost2_new_pos - cost2_old) - (cost2_new - cost2_old)\n\n        # Combine improvements (simple sum for this example)\n        total_improvement = improvement1 + improvement2\n\n        if total_improvement < best_improvement:\n            best_improvement = total_improvement\n            best_pos = pos\n\n    # Perform the relinking\n    if best_pos != relink_pos:\n        # Remove the node from current position\n        new_solution = np.delete(new_solution, relink_pos)\n        # Insert at best position\n        new_solution = np.insert(new_solution, best_pos, relink_node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 25,
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive edge swapping with probabilistic segment reversal, guided by both objective distances and dominance relationships to intelligently perturb solutions while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (higher score = more potential)\n    improvement_scores = []\n    for sol, obj in zip(solutions, objectives):\n        # Calculate current tour length in both spaces\n        cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(len(sol)-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(len(sol)-1)) + distance_matrix_2[sol[-1], sol[0]]\n\n        # Calculate potential improvement (difference from current to best known)\n        best_cost1 = min([o[0] for o in objectives])\n        best_cost2 = min([o[1] for o in objectives])\n        score = (cost1 - best_cost1) + (cost2 - best_cost2)\n        improvement_scores.append(score)\n\n    # Normalize scores to get probabilities\n    total = sum(improvement_scores)\n    if total == 0:\n        probabilities = [1.0 / len(improvement_scores)] * len(improvement_scores)\n    else:\n        probabilities = [score / total for score in improvement_scores]\n\n    # Select a solution with probability proportional to its improvement score\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive edge swapping based on both objectives\n    for i in range(n):\n        j = (i + 1) % n\n        k = (j + 1) % n\n\n        # Calculate cost in both spaces\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n        # Try swapping edges\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n        # Accept if both objectives improve or one improves significantly\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (random.random() < 0.3 and (new_cost1 < current_cost1 or new_cost2 < current_cost2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Step 2: Probabilistic segment reversal based on objective dominance\n    if random.random() < 0.5:  # 50% chance to perform segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        segment = new_solution[a:b+1]\n\n        # Calculate segment cost in both spaces\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Try reversing the segment\n        reversed_segment = segment[::-1]\n        reversed_cost1 = sum(distance_matrix_1[reversed_segment[i], reversed_segment[i+1]] for i in range(len(reversed_segment)-1))\n        reversed_cost2 = sum(distance_matrix_2[reversed_segment[i], reversed_segment[i+1]] for i in range(len(reversed_segment)-1))\n\n        # Accept if both objectives improve or one improves significantly\n        if (reversed_cost1 < segment_cost1 and reversed_cost2 < segment_cost2) or \\\n           (random.random() < 0.3 and (reversed_cost1 < segment_cost1 or reversed_cost2 < segment_cost2)):\n            new_solution[a:b+1] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8418839590666629,
            5.759984731674194
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (higher score = more potential)\n    improvement_scores = []\n    for sol, obj in zip(solutions, objectives):\n        # Calculate current tour length in both spaces\n        cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(len(sol)-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(len(sol)-1)) + distance_matrix_2[sol[-1], sol[0]]\n\n        # Calculate potential improvement (difference from current to best known)\n        best_cost1 = min([o[0] for o in objectives])\n        best_cost2 = min([o[1] for o in objectives])\n        score = (cost1 - best_cost1) + (cost2 - best_cost2)\n        improvement_scores.append(score)\n\n    # Normalize scores to get probabilities\n    total = sum(improvement_scores)\n    if total == 0:\n        probabilities = [1.0 / len(improvement_scores)] * len(improvement_scores)\n    else:\n        probabilities = [score / total for score in improvement_scores]\n\n    # Select a solution with probability proportional to its improvement score\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive edge swapping based on both objectives\n    for i in range(n):\n        j = (i + 1) % n\n        k = (j + 1) % n\n\n        # Calculate cost in both spaces\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n        # Try swapping edges\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n        # Accept if both objectives improve or one improves significantly\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (random.random() < 0.3 and (new_cost1 < current_cost1 or new_cost2 < current_cost2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Step 2: Probabilistic segment reversal based on objective dominance\n    if random.random() < 0.5:  # 50% chance to perform segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        segment = new_solution[a:b+1]\n\n        # Calculate segment cost in both spaces\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Try reversing the segment\n        reversed_segment = segment[::-1]\n        reversed_cost1 = sum(distance_matrix_1[reversed_segment[i], reversed_segment[i+1]] for i in range(len(reversed_segment)-1))\n        reversed_cost2 = sum(distance_matrix_2[reversed_segment[i], reversed_segment[i+1]] for i in range(len(reversed_segment)-1))\n\n        # Accept if both objectives improve or one improves significantly\n        if (reversed_cost1 < segment_cost1 and reversed_cost2 < segment_cost2) or \\\n           (random.random() < 0.3 and (reversed_cost1 < segment_cost1 or reversed_cost2 < segment_cost2)):\n            new_solution[a:b+1] = reversed_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 26,
        "algorithm": "{A novel hybrid local search strategy that combines a multi-objective-aware segment inversion with a dynamic edge swap mechanism to explore high-quality solutions in both objective spaces, prioritizing regions with diverse trade-offs and adaptive neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choice(range(len(archive)))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Segment inversion with dynamic edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective-aware segment inversion\n    # Find a segment with high potential for improvement in both objectives\n    segment_start = random.randint(0, n - 3)\n    segment_end = random.randint(segment_start + 1, min(segment_start + 5, n - 1))\n\n    # Calculate current and potential costs for the segment\n    current_cost1 = distance_matrix_1[new_solution[segment_start], new_solution[segment_end]] + \\\n                    distance_matrix_1[new_solution[segment_end], new_solution[(segment_start + 1) % n]]\n    current_cost2 = distance_matrix_2[new_solution[segment_start], new_solution[segment_end]] + \\\n                    distance_matrix_2[new_solution[segment_end], new_solution[(segment_start + 1) % n]]\n\n    # Try inverting the segment\n    inverted_segment = new_solution[segment_start:segment_end+1][::-1]\n    new_solution[segment_start:segment_end+1] = inverted_segment\n\n    # Step 2: Dynamic edge swap based on objective trade-offs\n    # Select two edges with potential for improvement\n    edge1 = random.randint(0, n - 1)\n    edge2 = random.randint(0, n - 1)\n    while edge1 == edge2 or abs(edge1 - edge2) == 1:\n        edge2 = random.randint(0, n - 1)\n\n    # Calculate potential improvement in both objectives\n    # For edge1: (new_solution[edge1], new_solution[edge1+1])\n    # For edge2: (new_solution[edge2], new_solution[edge2+1])\n    # Swap them if it improves at least one objective\n    temp = new_solution[edge1]\n    new_solution[edge1] = new_solution[edge2]\n    new_solution[edge2] = temp\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8797564197420802,
            2.099577307701111
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choice(range(len(archive)))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Segment inversion with dynamic edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective-aware segment inversion\n    # Find a segment with high potential for improvement in both objectives\n    segment_start = random.randint(0, n - 3)\n    segment_end = random.randint(segment_start + 1, min(segment_start + 5, n - 1))\n\n    # Calculate current and potential costs for the segment\n    current_cost1 = distance_matrix_1[new_solution[segment_start], new_solution[segment_end]] + \\\n                    distance_matrix_1[new_solution[segment_end], new_solution[(segment_start + 1) % n]]\n    current_cost2 = distance_matrix_2[new_solution[segment_start], new_solution[segment_end]] + \\\n                    distance_matrix_2[new_solution[segment_end], new_solution[(segment_start + 1) % n]]\n\n    # Try inverting the segment\n    inverted_segment = new_solution[segment_start:segment_end+1][::-1]\n    new_solution[segment_start:segment_end+1] = inverted_segment\n\n    # Step 2: Dynamic edge swap based on objective trade-offs\n    # Select two edges with potential for improvement\n    edge1 = random.randint(0, n - 1)\n    edge2 = random.randint(0, n - 1)\n    while edge1 == edge2 or abs(edge1 - edge2) == 1:\n        edge2 = random.randint(0, n - 1)\n\n    # Calculate potential improvement in both objectives\n    # For edge1: (new_solution[edge1], new_solution[edge1+1])\n    # For edge2: (new_solution[edge2], new_solution[edge2+1])\n    # Swap them if it improves at least one objective\n    temp = new_solution[edge1]\n    new_solution[edge1] = new_solution[edge2]\n    new_solution[edge2] = temp\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 27,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a hybrid local search strategy that combines edge swapping and node insertion, prioritizing solutions with lower combined objective values to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: edge swapping followed by node insertion\n    n = len(selected_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Edge swapping\n    if j - i > 1:\n        new_solution = selected_solution.copy()\n        new_solution[i:j] = selected_solution[i:j][::-1]\n    else:\n        # If edge swapping is not possible, perform node insertion\n        new_solution = selected_solution.copy()\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7468156717549774,
            2.147191345691681
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: edge swapping followed by node insertion\n    n = len(selected_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Edge swapping\n    if j - i > 1:\n        new_solution = selected_solution.copy()\n        new_solution[i:j] = selected_solution[i:j][::-1]\n    else:\n        # If edge swapping is not possible, perform node insertion\n        new_solution = selected_solution.copy()\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 28,
        "algorithm": "{A novel hybrid local search operator combines a multi-swap strategy with a dynamic segment reversal heuristic to explore diverse neighborhoods while preserving feasibility, prioritizing solutions with high potential for improvement based on Pareto dominance and crowding distance metrics.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-dominated or least crowded)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: dynamic multi-swap with segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select segments to swap or reverse\n    swap_size = np.random.randint(2, min(5, n // 2))\n    segment1_start = np.random.randint(0, n - swap_size)\n    segment1_end = segment1_start + swap_size\n\n    segment2_start = np.random.randint(0, n - swap_size)\n    while abs(segment2_start - segment1_start) < swap_size:\n        segment2_start = np.random.randint(0, n - swap_size)\n    segment2_end = segment2_start + swap_size\n\n    # Perform multi-swap\n    temp = new_solution[segment1_start:segment1_end].copy()\n    new_solution[segment1_start:segment1_end] = new_solution[segment2_start:segment2_end]\n    new_solution[segment2_start:segment2_end] = temp\n\n    # Dynamic segment reversal\n    if np.random.rand() < 0.5:\n        reverse_start = np.random.randint(0, n - 3)\n        reverse_end = np.random.randint(reverse_start + 2, n)\n        new_solution[reverse_start:reverse_end] = new_solution[reverse_start:reverse_end][::-1]\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts > 1):\n        # Fallback to 2-opt if feasibility is violated (unlikely due to careful segment selection)\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8640024193042082,
            2.1356781721115112
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-dominated or least crowded)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: dynamic multi-swap with segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select segments to swap or reverse\n    swap_size = np.random.randint(2, min(5, n // 2))\n    segment1_start = np.random.randint(0, n - swap_size)\n    segment1_end = segment1_start + swap_size\n\n    segment2_start = np.random.randint(0, n - swap_size)\n    while abs(segment2_start - segment1_start) < swap_size:\n        segment2_start = np.random.randint(0, n - swap_size)\n    segment2_end = segment2_start + swap_size\n\n    # Perform multi-swap\n    temp = new_solution[segment1_start:segment1_end].copy()\n    new_solution[segment1_start:segment1_end] = new_solution[segment2_start:segment2_end]\n    new_solution[segment2_start:segment2_end] = temp\n\n    # Dynamic segment reversal\n    if np.random.rand() < 0.5:\n        reverse_start = np.random.randint(0, n - 3)\n        reverse_end = np.random.randint(reverse_start + 2, n)\n        new_solution[reverse_start:reverse_end] = new_solution[reverse_start:reverse_end][::-1]\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts > 1):\n        # Fallback to 2-opt if feasibility is violated (unlikely due to careful segment selection)\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 29,
        "algorithm": "{A novel hybrid local search operator that combines random segment reversal with adaptive edge insertion, guided by Pareto dominance and dominance resistance to explore diverse neighborhoods while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high dominance resistance (non-dominated but close to Pareto front)\n    selected_solution = None\n    min_dominance_resistance = float('inf')\n    for sol, obj in archive:\n        dominance_count = 0\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominance_count += 1\n        if dominance_count < min_dominance_resistance:\n            min_dominance_resistance = dominance_count\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    # Apply hybrid local search: random segment reversal + adaptive edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Random segment reversal\n    if n > 3:\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Adaptive edge insertion\n    for _ in range(2):  # Perform 2 insertions\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = (j + 1) % n\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility by repairing if necessary\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.6966673560201098,
            2.2417944073677063
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high dominance resistance (non-dominated but close to Pareto front)\n    selected_solution = None\n    min_dominance_resistance = float('inf')\n    for sol, obj in archive:\n        dominance_count = 0\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominance_count += 1\n        if dominance_count < min_dominance_resistance:\n            min_dominance_resistance = dominance_count\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    # Apply hybrid local search: random segment reversal + adaptive edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Random segment reversal\n    if n > 3:\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Adaptive edge insertion\n    for _ in range(2):  # Perform 2 insertions\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = (j + 1) % n\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility by repairing if necessary\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 30,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective values and diversity, then applies a novel hybrid local search operator that combines edge insertion with a guided 3-opt-like move to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards better objectives and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = -np.sum(normalized_obj, axis=1) + 0.1 * np.random.rand(len(archive))\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Edge insertion with guided 3-opt-like move\n    n = len(base_solution)\n\n    # Step 1: Randomly select a segment to modify\n    start = random.randint(0, n-1)\n    length = random.randint(2, min(5, n//2))\n    end = (start + length) % n\n\n    # Step 2: Remove the segment and insert it in reverse order at a random position\n    segment = base_solution[start:end]\n    remaining = np.concatenate([base_solution[:start], base_solution[end:]])\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment[::-1], remaining[insert_pos:]])\n\n    # Step 3: Apply a guided 3-opt-like move to improve the solution\n    for _ in range(3):  # Limit iterations to avoid excessive computation\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Try different configurations\n        candidates = [\n            np.concatenate([new_solution[:i], new_solution[j:k+1], new_solution[i:j], new_solution[k+1:]]),\n            np.concatenate([new_solution[:i], new_solution[k:j-1:-1], new_solution[i:j], new_solution[k+1:]]),\n            np.concatenate([new_solution[:i], new_solution[j:k+1][::-1], new_solution[i:j], new_solution[k+1:]])\n        ]\n        # Evaluate candidates based on both objectives\n        best_candidate = new_solution\n        best_score = np.inf\n        for candidate in candidates:\n            score = (np.sum(distance_matrix_1[candidate[:-1], candidate[1:]]) +\n                     np.sum(distance_matrix_2[candidate[:-1], candidate[1:]]))\n            if score < best_score:\n                best_score = score\n                best_candidate = candidate\n        new_solution = best_candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7179610438849331,
            2.184485077857971
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards better objectives and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = -np.sum(normalized_obj, axis=1) + 0.1 * np.random.rand(len(archive))\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Edge insertion with guided 3-opt-like move\n    n = len(base_solution)\n\n    # Step 1: Randomly select a segment to modify\n    start = random.randint(0, n-1)\n    length = random.randint(2, min(5, n//2))\n    end = (start + length) % n\n\n    # Step 2: Remove the segment and insert it in reverse order at a random position\n    segment = base_solution[start:end]\n    remaining = np.concatenate([base_solution[:start], base_solution[end:]])\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment[::-1], remaining[insert_pos:]])\n\n    # Step 3: Apply a guided 3-opt-like move to improve the solution\n    for _ in range(3):  # Limit iterations to avoid excessive computation\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Try different configurations\n        candidates = [\n            np.concatenate([new_solution[:i], new_solution[j:k+1], new_solution[i:j], new_solution[k+1:]]),\n            np.concatenate([new_solution[:i], new_solution[k:j-1:-1], new_solution[i:j], new_solution[k+1:]]),\n            np.concatenate([new_solution[:i], new_solution[j:k+1][::-1], new_solution[i:j], new_solution[k+1:]])\n        ]\n        # Evaluate candidates based on both objectives\n        best_candidate = new_solution\n        best_score = np.inf\n        for candidate in candidates:\n            score = (np.sum(distance_matrix_1[candidate[:-1], candidate[1:]]) +\n                     np.sum(distance_matrix_2[candidate[:-1], candidate[1:]]))\n            if score < best_score:\n                best_score = score\n                best_candidate = candidate\n        new_solution = best_candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 31,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and non-dominated status, then applies a hybrid local search combining edge exchange and node reinsertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = 0\n    min_obj1 = float('inf')\n    for i, (sol, obj) in enumerate(archive):\n        if obj[0] < min_obj1:\n            min_obj1 = obj[0]\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange and node reinsertion\n    n = len(base_solution)\n    i, j = np.random.randint(0, n, 2)\n    while j == i:\n        j = np.random.randint(0, n)\n\n    # Edge exchange\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Node reinsertion\n    k = np.random.randint(0, n)\n    while k == i or k == j:\n        k = np.random.randint(0, n)\n\n    node_to_reinsert = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, new_pos, node_to_reinsert)\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if reinsertion causes duplicates\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8286978865456716,
            1.9050974249839783
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = 0\n    min_obj1 = float('inf')\n    for i, (sol, obj) in enumerate(archive):\n        if obj[0] < min_obj1:\n            min_obj1 = obj[0]\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange and node reinsertion\n    n = len(base_solution)\n    i, j = np.random.randint(0, n, 2)\n    while j == i:\n        j = np.random.randint(0, n)\n\n    # Edge exchange\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Node reinsertion\n    k = np.random.randint(0, n)\n    while k == i or k == j:\n        k = np.random.randint(0, n)\n\n    node_to_reinsert = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, new_pos, node_to_reinsert)\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if reinsertion causes duplicates\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 32,
        "algorithm": "{A hybrid local search method that combines a novel segment relocation strategy with adaptive perturbation to balance exploration and exploitation in multi-objective TSP, ensuring feasibility by preserving node uniqueness and tour continuity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(int(len(sorted_archive) * 0.3), len(sorted_archive) - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n    N = len(base_solution)\n\n    # Hybrid local search: segment relocation with adaptive perturbation\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment length (between 2 and N//4)\n    segment_length = random.randint(2, max(2, N // 4))\n\n    # Randomly select a start position for the segment\n    start_pos = random.randint(0, N - segment_length)\n\n    # Extract the segment\n    segment = new_solution[start_pos:start_pos + segment_length]\n\n    # Remove the segment from the solution\n    new_solution = np.concatenate([new_solution[:start_pos], new_solution[start_pos + segment_length:]])\n\n    # Insert the segment at a new random position\n    insert_pos = random.randint(0, N - segment_length)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Adaptive perturbation: with probability 0.2, swap two random nodes\n    if random.random() < 0.2:\n        i, j = random.sample(range(N), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8003723728445113,
            2.2321354746818542
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(int(len(sorted_archive) * 0.3), len(sorted_archive) - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n    N = len(base_solution)\n\n    # Hybrid local search: segment relocation with adaptive perturbation\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment length (between 2 and N//4)\n    segment_length = random.randint(2, max(2, N // 4))\n\n    # Randomly select a start position for the segment\n    start_pos = random.randint(0, N - segment_length)\n\n    # Extract the segment\n    segment = new_solution[start_pos:start_pos + segment_length]\n\n    # Remove the segment from the solution\n    new_solution = np.concatenate([new_solution[:start_pos], new_solution[start_pos + segment_length:]])\n\n    # Insert the segment at a new random position\n    insert_pos = random.randint(0, N - segment_length)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Adaptive perturbation: with probability 0.2, swap two random nodes\n    if random.random() < 0.2:\n        i, j = random.sample(range(N), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 33,
        "algorithm": "{The algorithm selects a solution from the archive with the highest potential for improvement by prioritizing solutions with lower objectives and applying a hybrid local search that combines edge insertion with a novel node-swap strategy to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: edge insertion + novel node-swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    # Novel node-swap: reverse the segment and swap nodes with a probability\n    if random.random() < 0.5:\n        segment = segment[::-1]\n    else:\n        for i in range(len(segment) // 2):\n            segment[i], segment[-i-1] = segment[-i-1], segment[i]\n\n    # Edge insertion: reinsert the modified segment at a random position\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility by removing duplicates and adding missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(len(instance)), unique_nodes)\n    if len(missing_nodes) > 0:\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6540250679485615,
            2.100440800189972
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: edge insertion + novel node-swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    # Novel node-swap: reverse the segment and swap nodes with a probability\n    if random.random() < 0.5:\n        segment = segment[::-1]\n    else:\n        for i in range(len(segment) // 2):\n            segment[i], segment[-i-1] = segment[-i-1], segment[i]\n\n    # Edge insertion: reinsert the modified segment at a random position\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility by removing duplicates and adding missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(len(instance)), unique_nodes)\n    if len(missing_nodes) > 0:\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 34,
        "algorithm": "{A novel hybrid local search operator combines edge exchange with a dynamic path inversion mechanism, prioritizing edges with high potential for multi-objective improvement by selectively inverting segments and swapping edges based on combined distance metrics to generate diverse, high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    def potential_score(solution, obj):\n        # Normalize objectives to avoid bias\n        max_obj1 = max(o[0] for _, o in archive)\n        max_obj2 = max(o[1] for _, o in archive)\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 != 0 else 0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 != 0 else 0\n        return norm_obj1 + norm_obj2\n\n    # Sort solutions by potential score (descending)\n    archive_sorted = sorted(archive, key=lambda x: -potential_score(x[0], x[1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Select a segment to invert\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n    inverted_segment = segment[::-1]\n\n    # Step 2: Calculate potential improvement\n    def calculate_improvement(original, new):\n        total_diff = 0\n        for k in range(len(original)):\n            if k == 0:\n                prev = original[-1]\n            else:\n                prev = original[k-1]\n            next_node = original[(k+1) % len(original)]\n            prev_new = new[k-1] if k > 0 else new[-1]\n            next_new = new[(k+1) % len(new)]\n            total_diff += (distance_matrix_1[prev, new[k]] + distance_matrix_2[prev, new[k]]) - (distance_matrix_1[prev, original[k]] + distance_matrix_2[prev, original[k]])\n            total_diff += (distance_matrix_1[new[k], next_node] + distance_matrix_2[new[k], next_node]) - (distance_matrix_1[original[k], next_node] + distance_matrix_2[original[k], next_node])\n        return total_diff\n\n    # Create candidate solutions\n    candidates = []\n    # Candidate 1: Inverted segment\n    candidate1 = new_solution.copy()\n    candidate1[i:j+1] = inverted_segment\n    candidates.append(candidate1)\n\n    # Candidate 2: Edge swap between two random nodes\n    candidate2 = new_solution.copy()\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    candidate2[a], candidate2[b] = candidate2[b], candidate2[a]\n    candidates.append(candidate2)\n\n    # Candidate 3: Combine inversion and edge swap\n    candidate3 = candidate2.copy()\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n    segment = candidate3[k:l+1]\n    candidate3[k:l+1] = segment[::-1]\n    candidates.append(candidate3)\n\n    # Select the best candidate\n    best_candidate = min(candidates, key=lambda x: calculate_improvement(base_solution, x))\n\n    return best_candidate\n\n",
        "score": [
            -0.9262318233903766,
            10.59069138765335
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    def potential_score(solution, obj):\n        # Normalize objectives to avoid bias\n        max_obj1 = max(o[0] for _, o in archive)\n        max_obj2 = max(o[1] for _, o in archive)\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 != 0 else 0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 != 0 else 0\n        return norm_obj1 + norm_obj2\n\n    # Sort solutions by potential score (descending)\n    archive_sorted = sorted(archive, key=lambda x: -potential_score(x[0], x[1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Select a segment to invert\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n    inverted_segment = segment[::-1]\n\n    # Step 2: Calculate potential improvement\n    def calculate_improvement(original, new):\n        total_diff = 0\n        for k in range(len(original)):\n            if k == 0:\n                prev = original[-1]\n            else:\n                prev = original[k-1]\n            next_node = original[(k+1) % len(original)]\n            prev_new = new[k-1] if k > 0 else new[-1]\n            next_new = new[(k+1) % len(new)]\n            total_diff += (distance_matrix_1[prev, new[k]] + distance_matrix_2[prev, new[k]]) - (distance_matrix_1[prev, original[k]] + distance_matrix_2[prev, original[k]])\n            total_diff += (distance_matrix_1[new[k], next_node] + distance_matrix_2[new[k], next_node]) - (distance_matrix_1[original[k], next_node] + distance_matrix_2[original[k], next_node])\n        return total_diff\n\n    # Create candidate solutions\n    candidates = []\n    # Candidate 1: Inverted segment\n    candidate1 = new_solution.copy()\n    candidate1[i:j+1] = inverted_segment\n    candidates.append(candidate1)\n\n    # Candidate 2: Edge swap between two random nodes\n    candidate2 = new_solution.copy()\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    candidate2[a], candidate2[b] = candidate2[b], candidate2[a]\n    candidates.append(candidate2)\n\n    # Candidate 3: Combine inversion and edge swap\n    candidate3 = candidate2.copy()\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n    segment = candidate3[k:l+1]\n    candidate3[k:l+1] = segment[::-1]\n    candidates.append(candidate3)\n\n    # Select the best candidate\n    best_candidate = min(candidates, key=lambda x: calculate_improvement(base_solution, x))\n\n    return best_candidate\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 35,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a distance-aware swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three segments to perform 3-opt\n    a, b, c = sorted(np.random.choice(np.arange(1, n), size=3, replace=False))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order\n    new_order = [segment1, segment2, segment3, segment4]\n    np.random.shuffle(new_order)\n    new_solution = np.concatenate(new_order)\n\n    # Distance-aware swap: find the two nodes with the highest combined distance and swap them\n    total_distances = distance_matrix_1 + distance_matrix_2\n    max_distance = -1\n    swap_i, swap_j = 0, 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if total_distances[new_solution[i], new_solution[j]] > max_distance:\n                max_distance = total_distances[new_solution[i], new_solution[j]]\n                swap_i, swap_j = i, j\n    new_solution[swap_i], new_solution[swap_j] = new_solution[swap_j], new_solution[swap_i]\n\n    return new_solution\n\n",
        "score": [
            -0.8319672650300187,
            4.878144085407257
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a distance-aware swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three segments to perform 3-opt\n    a, b, c = sorted(np.random.choice(np.arange(1, n), size=3, replace=False))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order\n    new_order = [segment1, segment2, segment3, segment4]\n    np.random.shuffle(new_order)\n    new_solution = np.concatenate(new_order)\n\n    # Distance-aware swap: find the two nodes with the highest combined distance and swap them\n    total_distances = distance_matrix_1 + distance_matrix_2\n    max_distance = -1\n    swap_i, swap_j = 0, 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if total_distances[new_solution[i], new_solution[j]] > max_distance:\n                max_distance = total_distances[new_solution[i], new_solution[j]]\n                swap_i, swap_j = i, j\n    new_solution[swap_i], new_solution[swap_j] = new_solution[swap_j], new_solution[swap_i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 36,
        "algorithm": "{A hybrid local search operator that combines a biased random walk with a novel edge-swapping strategy, prioritizing edges with high potential for reducing the total tour length in either objective space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a bias towards those with higher potential for improvement\n    weights = [1.0 / (1.0 + obj[0] + obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: biased random walk + edge-swapping\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Biased random walk to identify promising segments\n    start = random.randint(0, n - 1)\n    end = (start + random.randint(2, min(5, n - 1))) % n\n    segment = new_solution[start:end]\n\n    # Step 2: Evaluate edges in the segment for potential improvement\n    edges = [(segment[i], segment[(i + 1) % len(segment)]) for i in range(len(segment))]\n    edge_scores = []\n    for u, v in edges:\n        # Score based on potential reduction in both objectives\n        old_cost1 = distance_matrix_1[u, v]\n        old_cost2 = distance_matrix_2[u, v]\n        # Find the best possible replacement edge\n        min_cost1 = np.inf\n        min_cost2 = np.inf\n        best_u_replacement = u\n        best_v_replacement = v\n        for candidate in new_solution:\n            if candidate in segment:\n                continue\n            new_cost1 = distance_matrix_1[u, candidate] + distance_matrix_1[candidate, v]\n            new_cost2 = distance_matrix_2[u, candidate] + distance_matrix_2[candidate, v]\n            if new_cost1 < min_cost1 or new_cost2 < min_cost2:\n                min_cost1 = new_cost1\n                min_cost2 = new_cost2\n                best_u_replacement = candidate\n                best_v_replacement = candidate\n        # Score is the potential reduction in either objective\n        score = max((old_cost1 - min_cost1) / old_cost1, (old_cost2 - min_cost2) / old_cost2) if old_cost1 > 0 and old_cost2 > 0 else 0\n        edge_scores.append(score)\n\n    if edge_scores:\n        # Select the edge with the highest improvement potential\n        best_edge_idx = np.argmax(edge_scores)\n        u, v = edges[best_edge_idx]\n        # Find the best replacement edge\n        best_candidate = None\n        best_improvement = 0\n        for candidate in new_solution:\n            if candidate in segment:\n                continue\n            improvement = (distance_matrix_1[u, v] - (distance_matrix_1[u, candidate] + distance_matrix_1[candidate, v])) + \\\n                          (distance_matrix_2[u, v] - (distance_matrix_2[u, candidate] + distance_matrix_2[candidate, v]))\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_candidate = candidate\n\n        if best_candidate is not None:\n            # Perform the edge swap\n            u_idx = np.where(new_solution == u)[0][0]\n            v_idx = np.where(new_solution == v)[0][0]\n            if u_idx > v_idx:\n                u_idx, v_idx = v_idx, u_idx\n            # Insert the candidate between u and v\n            new_segment = np.concatenate([new_solution[u_idx:v_idx], [best_candidate]])\n            new_solution = np.concatenate([new_solution[:u_idx], new_segment, new_solution[v_idx:]])\n\n    return new_solution\n\n",
        "score": [
            -0.6684991753539847,
            11.985395848751068
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a bias towards those with higher potential for improvement\n    weights = [1.0 / (1.0 + obj[0] + obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: biased random walk + edge-swapping\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Biased random walk to identify promising segments\n    start = random.randint(0, n - 1)\n    end = (start + random.randint(2, min(5, n - 1))) % n\n    segment = new_solution[start:end]\n\n    # Step 2: Evaluate edges in the segment for potential improvement\n    edges = [(segment[i], segment[(i + 1) % len(segment)]) for i in range(len(segment))]\n    edge_scores = []\n    for u, v in edges:\n        # Score based on potential reduction in both objectives\n        old_cost1 = distance_matrix_1[u, v]\n        old_cost2 = distance_matrix_2[u, v]\n        # Find the best possible replacement edge\n        min_cost1 = np.inf\n        min_cost2 = np.inf\n        best_u_replacement = u\n        best_v_replacement = v\n        for candidate in new_solution:\n            if candidate in segment:\n                continue\n            new_cost1 = distance_matrix_1[u, candidate] + distance_matrix_1[candidate, v]\n            new_cost2 = distance_matrix_2[u, candidate] + distance_matrix_2[candidate, v]\n            if new_cost1 < min_cost1 or new_cost2 < min_cost2:\n                min_cost1 = new_cost1\n                min_cost2 = new_cost2\n                best_u_replacement = candidate\n                best_v_replacement = candidate\n        # Score is the potential reduction in either objective\n        score = max((old_cost1 - min_cost1) / old_cost1, (old_cost2 - min_cost2) / old_cost2) if old_cost1 > 0 and old_cost2 > 0 else 0\n        edge_scores.append(score)\n\n    if edge_scores:\n        # Select the edge with the highest improvement potential\n        best_edge_idx = np.argmax(edge_scores)\n        u, v = edges[best_edge_idx]\n        # Find the best replacement edge\n        best_candidate = None\n        best_improvement = 0\n        for candidate in new_solution:\n            if candidate in segment:\n                continue\n            improvement = (distance_matrix_1[u, v] - (distance_matrix_1[u, candidate] + distance_matrix_1[candidate, v])) + \\\n                          (distance_matrix_2[u, v] - (distance_matrix_2[u, candidate] + distance_matrix_2[candidate, v]))\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_candidate = candidate\n\n        if best_candidate is not None:\n            # Perform the edge swap\n            u_idx = np.where(new_solution == u)[0][0]\n            v_idx = np.where(new_solution == v)[0][0]\n            if u_idx > v_idx:\n                u_idx, v_idx = v_idx, u_idx\n            # Insert the candidate between u and v\n            new_segment = np.concatenate([new_solution[u_idx:v_idx], [best_candidate]])\n            new_solution = np.concatenate([new_solution[:u_idx], new_segment, new_solution[v_idx:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 37,
        "algorithm": "{The algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel hybrid local search operator that combines 3-opt with a variable-length segment relocation, ensuring feasibility while exploring high-quality regions of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (1 + obj[0] + obj[1]) for _, obj in archive],  # Higher weight for lower objectives\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: 3-opt with variable-length segment relocation\n    N = len(base_solution)\n    if N < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Step 1: Randomly select three edges to flip (3-opt)\n    a, b, c = sorted(random.sample(range(1, N), 3))\n    new_solution = np.concatenate([\n        new_solution[:a],\n        new_solution[b:c][::-1],\n        new_solution[a:b],\n        new_solution[c:]\n    ])\n\n    # Step 2: Variable-length segment relocation\n    seg_start = random.randint(0, N-4)  # Ensure at least 3 nodes remain\n    seg_length = random.randint(2, min(5, N - seg_start - 1))\n    seg_end = seg_start + seg_length\n    insert_pos = random.randint(0, N - seg_length)\n\n    # Extract segment and reinsert\n    segment = new_solution[seg_start:seg_end]\n    remaining = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n    new_solution = np.concatenate([\n        remaining[:insert_pos],\n        segment,\n        remaining[insert_pos:]\n    ])\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        return base_solution  # Fallback if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.8532168441334145,
            1.3126450777053833
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (1 + obj[0] + obj[1]) for _, obj in archive],  # Higher weight for lower objectives\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: 3-opt with variable-length segment relocation\n    N = len(base_solution)\n    if N < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Step 1: Randomly select three edges to flip (3-opt)\n    a, b, c = sorted(random.sample(range(1, N), 3))\n    new_solution = np.concatenate([\n        new_solution[:a],\n        new_solution[b:c][::-1],\n        new_solution[a:b],\n        new_solution[c:]\n    ])\n\n    # Step 2: Variable-length segment relocation\n    seg_start = random.randint(0, N-4)  # Ensure at least 3 nodes remain\n    seg_length = random.randint(2, min(5, N - seg_start - 1))\n    seg_end = seg_start + seg_length\n    insert_pos = random.randint(0, N - seg_length)\n\n    # Extract segment and reinsert\n    segment = new_solution[seg_start:seg_end]\n    remaining = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n    new_solution = np.concatenate([\n        remaining[:insert_pos],\n        segment,\n        remaining[insert_pos:]\n    ])\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        return base_solution  # Fallback if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 37,
        "algorithm": "{The algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel hybrid local search operator that combines 3-opt with a variable-length segment relocation, ensuring feasibility while exploring high-quality regions of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (1 + obj[0] + obj[1]) for _, obj in archive],  # Higher weight for lower objectives\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: 3-opt with variable-length segment relocation\n    N = len(base_solution)\n    if N < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Step 1: Randomly select three edges to flip (3-opt)\n    a, b, c = sorted(random.sample(range(1, N), 3))\n    new_solution = np.concatenate([\n        new_solution[:a],\n        new_solution[b:c][::-1],\n        new_solution[a:b],\n        new_solution[c:]\n    ])\n\n    # Step 2: Variable-length segment relocation\n    seg_start = random.randint(0, N-4)  # Ensure at least 3 nodes remain\n    seg_length = random.randint(2, min(5, N - seg_start - 1))\n    seg_end = seg_start + seg_length\n    insert_pos = random.randint(0, N - seg_length)\n\n    # Extract segment and reinsert\n    segment = new_solution[seg_start:seg_end]\n    remaining = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n    new_solution = np.concatenate([\n        remaining[:insert_pos],\n        segment,\n        remaining[insert_pos:]\n    ])\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        return base_solution  # Fallback if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.8532168441334145,
            1.3126450777053833
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (1 + obj[0] + obj[1]) for _, obj in archive],  # Higher weight for lower objectives\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: 3-opt with variable-length segment relocation\n    N = len(base_solution)\n    if N < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Step 1: Randomly select three edges to flip (3-opt)\n    a, b, c = sorted(random.sample(range(1, N), 3))\n    new_solution = np.concatenate([\n        new_solution[:a],\n        new_solution[b:c][::-1],\n        new_solution[a:b],\n        new_solution[c:]\n    ])\n\n    # Step 2: Variable-length segment relocation\n    seg_start = random.randint(0, N-4)  # Ensure at least 3 nodes remain\n    seg_length = random.randint(2, min(5, N - seg_start - 1))\n    seg_end = seg_start + seg_length\n    insert_pos = random.randint(0, N - seg_length)\n\n    # Extract segment and reinsert\n    segment = new_solution[seg_start:seg_end]\n    remaining = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n    new_solution = np.concatenate([\n        remaining[:insert_pos],\n        segment,\n        remaining[insert_pos:]\n    ])\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        return base_solution  # Fallback if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 38,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high objective diversity or low dominance counts, then applies a hybrid local search combining edge insertion and node relocation to generate a neighbor solution, ensuring feasibility and potential for multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the highest sum of objectives)\n    # This is a placeholder for a more sophisticated selection strategy\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and node relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    segment = new_solution[i:j]\n\n    # Relocate the segment to a new position\n    k = np.random.randint(0, n - len(segment))\n    if k >= i:\n        k += len(segment)\n\n    # Reconstruct the solution\n    new_solution = np.concatenate([\n        new_solution[:i],\n        new_solution[j:k],\n        segment,\n        new_solution[k:]\n    ])\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts > 1):\n        # Fallback to a simple swap if the operation fails\n        a, b = np.random.choice(n, size=2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9151064483312557,
            0.8612796068191528
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the highest sum of objectives)\n    # This is a placeholder for a more sophisticated selection strategy\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and node relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    segment = new_solution[i:j]\n\n    # Relocate the segment to a new position\n    k = np.random.randint(0, n - len(segment))\n    if k >= i:\n        k += len(segment)\n\n    # Reconstruct the solution\n    new_solution = np.concatenate([\n        new_solution[:i],\n        new_solution[j:k],\n        segment,\n        new_solution[k:]\n    ])\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts > 1):\n        # Fallback to a simple swap if the operation fails\n        a, b = np.random.choice(n, size=2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 38,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high objective diversity or low dominance counts, then applies a hybrid local search combining edge insertion and node relocation to generate a neighbor solution, ensuring feasibility and potential for multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the highest sum of objectives)\n    # This is a placeholder for a more sophisticated selection strategy\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and node relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    segment = new_solution[i:j]\n\n    # Relocate the segment to a new position\n    k = np.random.randint(0, n - len(segment))\n    if k >= i:\n        k += len(segment)\n\n    # Reconstruct the solution\n    new_solution = np.concatenate([\n        new_solution[:i],\n        new_solution[j:k],\n        segment,\n        new_solution[k:]\n    ])\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts > 1):\n        # Fallback to a simple swap if the operation fails\n        a, b = np.random.choice(n, size=2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9151064483312557,
            0.8612796068191528
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we select the one with the highest sum of objectives)\n    # This is a placeholder for a more sophisticated selection strategy\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and node relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    segment = new_solution[i:j]\n\n    # Relocate the segment to a new position\n    k = np.random.randint(0, n - len(segment))\n    if k >= i:\n        k += len(segment)\n\n    # Reconstruct the solution\n    new_solution = np.concatenate([\n        new_solution[:i],\n        new_solution[j:k],\n        segment,\n        new_solution[k:]\n    ])\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts > 1):\n        # Fallback to a simple swap if the operation fails\n        a, b = np.random.choice(n, size=2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 39,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([(cost1, cost2) for _, (cost1, cost2) in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    sum_normalized = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmin(sum_normalized)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment inversion strategy\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n    i, j = sorted(np.random.choice(N, 2, replace=False))\n\n    # Apply 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment inversion with probability 0.5\n    if np.random.rand() < 0.5:\n        k, l = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6543927282589328,
            2.0395163893699646
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([(cost1, cost2) for _, (cost1, cost2) in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    sum_normalized = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmin(sum_normalized)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment inversion strategy\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n    i, j = sorted(np.random.choice(N, 2, replace=False))\n\n    # Apply 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment inversion with probability 0.5\n    if np.random.rand() < 0.5:\n        k, l = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 40,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on its objective values, then applies a hybrid local search strategy combining edge insertion with a novel adaptive perturbation to explore high-potential regions in the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate normalized objectives to identify promising solutions\n    obj1 = np.array([o[0] for o in objectives])\n    obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (obj1 - np.min(obj1)) / (np.max(obj1) - np.min(obj1) + 1e-10)\n    norm_obj2 = (obj2 - np.min(obj2)) / (np.max(obj2) - np.min(obj2) + 1e-10)\n\n    # Combine objectives with weights to identify solutions with potential\n    combined_scores = 0.5 * norm_obj1 + 0.5 * norm_obj2\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search: adaptive edge insertion with perturbation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Select a random segment to modify\n    segment_size = max(2, min(5, n // 4))\n    start = np.random.randint(0, n - segment_size)\n    segment = new_solution[start:start + segment_size]\n\n    # Step 2: Remove the segment and reinsert it in a new position\n    remaining = np.concatenate([new_solution[:start], new_solution[start + segment_size:]])\n    insert_pos = np.random.randint(0, len(remaining) - segment_size + 1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 3: Adaptive perturbation based on objective space\n    if np.random.rand() < 0.3:  # 30% chance to apply perturbation\n        # Choose between objective spaces based on their relative costs\n        obj1_cost = sum(distance_matrix_1[new_solution[i], new_solution[(i + 1) % n]] for i in range(n))\n        obj2_cost = sum(distance_matrix_2[new_solution[i], new_solution[(i + 1) % n]] for i in range(n))\n\n        if obj1_cost > obj2_cost:\n            # Perturb in objective space 1\n            i, j = np.random.choice(n, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Perturb in objective space 2\n            i, j = np.random.choice(n, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8508639264378931,
            1.871767282485962
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate normalized objectives to identify promising solutions\n    obj1 = np.array([o[0] for o in objectives])\n    obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (obj1 - np.min(obj1)) / (np.max(obj1) - np.min(obj1) + 1e-10)\n    norm_obj2 = (obj2 - np.min(obj2)) / (np.max(obj2) - np.min(obj2) + 1e-10)\n\n    # Combine objectives with weights to identify solutions with potential\n    combined_scores = 0.5 * norm_obj1 + 0.5 * norm_obj2\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search: adaptive edge insertion with perturbation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Select a random segment to modify\n    segment_size = max(2, min(5, n // 4))\n    start = np.random.randint(0, n - segment_size)\n    segment = new_solution[start:start + segment_size]\n\n    # Step 2: Remove the segment and reinsert it in a new position\n    remaining = np.concatenate([new_solution[:start], new_solution[start + segment_size:]])\n    insert_pos = np.random.randint(0, len(remaining) - segment_size + 1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 3: Adaptive perturbation based on objective space\n    if np.random.rand() < 0.3:  # 30% chance to apply perturbation\n        # Choose between objective spaces based on their relative costs\n        obj1_cost = sum(distance_matrix_1[new_solution[i], new_solution[(i + 1) % n]] for i in range(n))\n        obj2_cost = sum(distance_matrix_2[new_solution[i], new_solution[(i + 1) % n]] for i in range(n))\n\n        if obj1_cost > obj2_cost:\n            # Perturb in objective space 1\n            i, j = np.random.choice(n, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Perturb in objective space 2\n            i, j = np.random.choice(n, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 41,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 3-opt with a greedy selection\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three edges to remove\n    i, j, k = sorted(np.random.choice(range(1, n-1), 3, replace=False))\n\n    # Generate all possible reconnections and select the one with the best combined cost reduction\n    candidates = []\n    for a in [new_solution[i-1], new_solution[i]]:\n        for b in [new_solution[j-1], new_solution[j]]:\n            for c in [new_solution[k-1], new_solution[k]]:\n                if len(set([a, b, c])) == 3:  # Ensure distinct nodes\n                    # Create a new candidate solution\n                    candidate = new_solution.copy()\n                    candidate[i:k] = candidate[i:k][::-1]  # Reverse the segment\n                    # Swap segments to create a new tour\n                    candidate = np.concatenate([candidate[:i], candidate[k:j], candidate[i:k], candidate[j:]])\n                    # Ensure it's a valid tour\n                    if len(set(candidate)) == n:\n                        # Calculate the new cost\n                        cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n                        cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n                        candidates.append((cost1 + cost2, candidate))\n\n    if candidates:\n        # Select the candidate with the best combined cost\n        _, new_solution = min(candidates, key=lambda x: x[0])\n\n    return new_solution\n\n",
        "score": [
            -0.9671502842372248,
            2.4461328983306885
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 3-opt with a greedy selection\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three edges to remove\n    i, j, k = sorted(np.random.choice(range(1, n-1), 3, replace=False))\n\n    # Generate all possible reconnections and select the one with the best combined cost reduction\n    candidates = []\n    for a in [new_solution[i-1], new_solution[i]]:\n        for b in [new_solution[j-1], new_solution[j]]:\n            for c in [new_solution[k-1], new_solution[k]]:\n                if len(set([a, b, c])) == 3:  # Ensure distinct nodes\n                    # Create a new candidate solution\n                    candidate = new_solution.copy()\n                    candidate[i:k] = candidate[i:k][::-1]  # Reverse the segment\n                    # Swap segments to create a new tour\n                    candidate = np.concatenate([candidate[:i], candidate[k:j], candidate[i:k], candidate[j:]])\n                    # Ensure it's a valid tour\n                    if len(set(candidate)) == n:\n                        # Calculate the new cost\n                        cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n                        cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n                        candidates.append((cost1 + cost2, candidate))\n\n    if candidates:\n        # Select the candidate with the best combined cost\n        _, new_solution = min(candidates, key=lambda x: x[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 42,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge insertion strategy\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Reverse the segment (2-opt-like move)\n    segment = segment[::-1]\n    new_solution[i:j+1] = segment\n\n    # Novel edge insertion: insert a random node from the segment elsewhere\n    if len(segment) > 1:\n        k = np.random.choice(len(segment))\n        node = segment[k]\n        pos = np.random.randint(0, n)\n        new_solution = np.insert(new_solution, pos, node)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][1])\n\n    return new_solution\n\n",
        "score": [
            -0.9558286387435234,
            1.3831904530525208
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge insertion strategy\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Reverse the segment (2-opt-like move)\n    segment = segment[::-1]\n    new_solution[i:j+1] = segment\n\n    # Novel edge insertion: insert a random node from the segment elsewhere\n    if len(segment) > 1:\n        k = np.random.choice(len(segment))\n        node = segment[k]\n        pos = np.random.randint(0, n)\n        new_solution = np.insert(new_solution, pos, node)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 43,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective tournament selection to prioritize solutions with Pareto-dominance and high diversity, followed by a dynamic edge-swap operator that adaptsively selects segments based on their contribution to both objectives, ensuring feasibility and high-quality neighbor solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution using multi-objective tournament selection\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n    selected_obj = archive[selected_idx][1]\n\n    # Step 2: Identify critical segments for both objectives\n    n = len(selected_solution)\n    segment_length = max(2, n // 5)\n\n    # Evaluate segments for both objectives\n    segment_costs_1 = []\n    segment_costs_2 = []\n    for i in range(0, n - segment_length + 1):\n        segment = selected_solution[i:i+segment_length]\n        cost_1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(segment_length - 1))\n        cost_2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(segment_length - 1))\n        segment_costs_1.append((i, cost_1))\n        segment_costs_2.append((i, cost_2))\n\n    # Sort segments by cost (ascending for minimization)\n    segment_costs_1.sort(key=lambda x: x[1])\n    segment_costs_2.sort(key=lambda x: x[1])\n\n    # Select top 20% of segments for each objective\n    top_segments_1 = [x[0] for x in segment_costs_1[:max(1, len(segment_costs_1) // 5)]]\n    top_segments_2 = [x[0] for x in segment_costs_2[:max(1, len(segment_costs_2) // 5)]]\n\n    # Combine and select a segment to perturb\n    candidate_segments = list(set(top_segments_1 + top_segments_2))\n    if not candidate_segments:\n        candidate_segments = [np.random.randint(0, n - segment_length + 1)]\n\n    selected_segment_start = np.random.choice(candidate_segments)\n    selected_segment = selected_solution[selected_segment_start:selected_segment_start + segment_length]\n\n    # Step 3: Apply dynamic edge-swap operator\n    new_solution = selected_solution.copy()\n    if len(selected_segment) >= 2:\n        # Randomly reverse a sub-segment or swap edges\n        if np.random.rand() < 0.5:\n            # Reverse the segment\n            new_solution[selected_segment_start:selected_segment_start + segment_length] = selected_segment[::-1]\n        else:\n            # Swap edges between two random positions in the segment\n            if len(selected_segment) >= 4:\n                i, j = np.random.choice(len(selected_segment) - 1, 2, replace=False)\n                new_solution[selected_segment_start + i], new_solution[selected_segment_start + j] = new_solution[selected_segment_start + j], new_solution[selected_segment_start + i]\n\n    return new_solution\n\n",
        "score": [
            -0.8325472370815408,
            2.734950363636017
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution using multi-objective tournament selection\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n    selected_obj = archive[selected_idx][1]\n\n    # Step 2: Identify critical segments for both objectives\n    n = len(selected_solution)\n    segment_length = max(2, n // 5)\n\n    # Evaluate segments for both objectives\n    segment_costs_1 = []\n    segment_costs_2 = []\n    for i in range(0, n - segment_length + 1):\n        segment = selected_solution[i:i+segment_length]\n        cost_1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(segment_length - 1))\n        cost_2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(segment_length - 1))\n        segment_costs_1.append((i, cost_1))\n        segment_costs_2.append((i, cost_2))\n\n    # Sort segments by cost (ascending for minimization)\n    segment_costs_1.sort(key=lambda x: x[1])\n    segment_costs_2.sort(key=lambda x: x[1])\n\n    # Select top 20% of segments for each objective\n    top_segments_1 = [x[0] for x in segment_costs_1[:max(1, len(segment_costs_1) // 5)]]\n    top_segments_2 = [x[0] for x in segment_costs_2[:max(1, len(segment_costs_2) // 5)]]\n\n    # Combine and select a segment to perturb\n    candidate_segments = list(set(top_segments_1 + top_segments_2))\n    if not candidate_segments:\n        candidate_segments = [np.random.randint(0, n - segment_length + 1)]\n\n    selected_segment_start = np.random.choice(candidate_segments)\n    selected_segment = selected_solution[selected_segment_start:selected_segment_start + segment_length]\n\n    # Step 3: Apply dynamic edge-swap operator\n    new_solution = selected_solution.copy()\n    if len(selected_segment) >= 2:\n        # Randomly reverse a sub-segment or swap edges\n        if np.random.rand() < 0.5:\n            # Reverse the segment\n            new_solution[selected_segment_start:selected_segment_start + segment_length] = selected_segment[::-1]\n        else:\n            # Swap edges between two random positions in the segment\n            if len(selected_segment) >= 4:\n                i, j = np.random.choice(len(selected_segment) - 1, 2, replace=False)\n                new_solution[selected_segment_start + i], new_solution[selected_segment_start + j] = new_solution[selected_segment_start + j], new_solution[selected_segment_start + i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 44,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a combined objective score, then applies a hybrid local search combining edge insertion and segment relocation, ensuring feasibility by validating each move and preserving the TSP tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = [obj for _, obj in archive]\n    # Normalize objectives to avoid division by zero\n    max_obj1 = max(obj[0] for obj in objectives) + 1e-6\n    max_obj2 = max(obj[1] for obj in objectives) + 1e-6\n    normalized_obj = [(obj[0]/max_obj1, obj[1]/max_obj2) for obj in objectives]\n    combined_scores = [1/(obj[0] + obj[1]) for obj in normalized_obj]\n    total_score = sum(combined_scores)\n    probabilities = [score/total_score for score in combined_scores]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: edge insertion + segment relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge insertion step\n    i, j = sorted(random.sample(range(n), 2))\n    if i != 0 and j != n-1:\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], segment])\n\n    # Segment relocation step\n    if n > 4:\n        a, b = sorted(random.sample(range(n), 2))\n        if a != 0 and b != n-1:\n            segment = new_solution[a:b+1]\n            new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n    # Validate the solution is a valid tour\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        # Fallback to a simple swap if invalid\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8480539837147433,
            2.067501962184906
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = [obj for _, obj in archive]\n    # Normalize objectives to avoid division by zero\n    max_obj1 = max(obj[0] for obj in objectives) + 1e-6\n    max_obj2 = max(obj[1] for obj in objectives) + 1e-6\n    normalized_obj = [(obj[0]/max_obj1, obj[1]/max_obj2) for obj in objectives]\n    combined_scores = [1/(obj[0] + obj[1]) for obj in normalized_obj]\n    total_score = sum(combined_scores)\n    probabilities = [score/total_score for score in combined_scores]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: edge insertion + segment relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge insertion step\n    i, j = sorted(random.sample(range(n), 2))\n    if i != 0 and j != n-1:\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], segment])\n\n    # Segment relocation step\n    if n > 4:\n        a, b = sorted(random.sample(range(n), 2))\n        if a != 0 and b != n-1:\n            segment = new_solution[a:b+1]\n            new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n    # Validate the solution is a valid tour\n    if len(set(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.arange(n)):\n        # Fallback to a simple swap if invalid\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 45,
        "algorithm": "{This heuristic selects a solution from the archive with a high variance in its objectives (indicating potential for improvement) and applies a hybrid local search combining edge swaps with a novel \"multi-objective path relinking\" to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective path relinking with edge swaps\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # Too small for meaningful operations\n\n    # Step 1: Perform a random edge swap\n    i, j = np.random.choice(n, size=2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Multi-objective path relinking - swap edges based on objective improvement\n    for _ in range(min(3, n // 2)):\n        # Find the worst edge in both objectives\n        worst_edge_idx = -1\n        worst_improvement = -float('inf')\n\n        for k in range(n - 1):\n            a, b = new_solution[k], new_solution[k + 1]\n            a_next, b_next = new_solution[(k + 1) % n], new_solution[(k + 2) % n]\n\n            # Calculate improvement if we swap a and b_next\n            delta_1 = (distance_matrix_1[a, b_next] + distance_matrix_1[b_next, a_next]) - (distance_matrix_1[a, b] + distance_matrix_1[b, a_next])\n            delta_2 = (distance_matrix_2[a, b_next] + distance_matrix_2[b_next, a_next]) - (distance_matrix_2[a, b] + distance_matrix_2[b, a_next])\n\n            # Multi-objective improvement metric (weighted sum)\n            improvement = 0.5 * delta_1 + 0.5 * delta_2\n\n            if improvement < worst_improvement:\n                worst_improvement = improvement\n                worst_edge_idx = k\n\n        if worst_edge_idx != -1:\n            # Perform the swap\n            k = worst_edge_idx\n            a, b = new_solution[k], new_solution[k + 1]\n            new_solution[k], new_solution[(k + 2) % n] = new_solution[(k + 2) % n], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.39173703227289935,
            3.0951988101005554
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective path relinking with edge swaps\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # Too small for meaningful operations\n\n    # Step 1: Perform a random edge swap\n    i, j = np.random.choice(n, size=2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Multi-objective path relinking - swap edges based on objective improvement\n    for _ in range(min(3, n // 2)):\n        # Find the worst edge in both objectives\n        worst_edge_idx = -1\n        worst_improvement = -float('inf')\n\n        for k in range(n - 1):\n            a, b = new_solution[k], new_solution[k + 1]\n            a_next, b_next = new_solution[(k + 1) % n], new_solution[(k + 2) % n]\n\n            # Calculate improvement if we swap a and b_next\n            delta_1 = (distance_matrix_1[a, b_next] + distance_matrix_1[b_next, a_next]) - (distance_matrix_1[a, b] + distance_matrix_1[b, a_next])\n            delta_2 = (distance_matrix_2[a, b_next] + distance_matrix_2[b_next, a_next]) - (distance_matrix_2[a, b] + distance_matrix_2[b, a_next])\n\n            # Multi-objective improvement metric (weighted sum)\n            improvement = 0.5 * delta_1 + 0.5 * delta_2\n\n            if improvement < worst_improvement:\n                worst_improvement = improvement\n                worst_edge_idx = k\n\n        if worst_edge_idx != -1:\n            # Perform the swap\n            k = worst_edge_idx\n            a, b = new_solution[k], new_solution[k + 1]\n            new_solution[k], new_solution[(k + 2) % n] = new_solution[(k + 2) % n], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 46,
        "algorithm": "{This heuristic function selects a promising solution from the archive by prioritizing those with lower combined objective values, then applies a hybrid local search combining edge swaps and segment reversals to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (lower combined objective)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(int(len(archive_sorted) * 0.2), len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal + edge swap\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(n - 1), 2))\n    c, d = sorted(random.sample(range(n - 1), 2))\n\n    # Reverse segments if they don't overlap\n    if (b < c) or (d < a):\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Edge swap for the two selected edges\n    if random.random() < 0.5:\n        i, j = sorted(random.sample(range(n - 1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(n - 1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8557983866371266,
            2.362140417098999
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (lower combined objective)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(int(len(archive_sorted) * 0.2), len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal + edge swap\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(n - 1), 2))\n    c, d = sorted(random.sample(range(n - 1), 2))\n\n    # Reverse segments if they don't overlap\n    if (b < c) or (d < a):\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Edge swap for the two selected edges\n    if random.random() < 0.5:\n        i, j = sorted(random.sample(range(n - 1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(n - 1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 47,
        "algorithm": "{A novel hybrid local search operator combines a multi-segment inversion with a dynamic edge exchange mechanism, guided by a Pareto-dominance-based selection criterion to intelligently explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1/(1 + obj[0] + obj[1]) for _, obj in archive], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: Multi-segment inversion with dynamic edge exchange\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select multiple segments and invert them\n    num_segments = random.randint(1, min(3, n // 3))\n    segments = sorted(random.sample(range(1, n), num_segments * 2))\n\n    for i in range(0, len(segments), 2):\n        start, end = segments[i], segments[i+1]\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Dynamic edge exchange based on objective improvement\n    for _ in range(3):  # Limit iterations to avoid excessive computation\n        i, j = random.sample(range(n), 2)\n        if i == j:\n            continue\n\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[j-1], base_solution[j]]\n        current_cost2 = distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[j-1], base_solution[j]]\n\n        new_cost1 = distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j-1], base_solution[i]]\n        new_cost2 = distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j-1], base_solution[i]]\n\n        # Accept if either objective improves\n        if new_cost1 < current_cost1 or new_cost2 < current_cost2:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8497016720026298,
            1.4179699420928955
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1/(1 + obj[0] + obj[1]) for _, obj in archive], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: Multi-segment inversion with dynamic edge exchange\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select multiple segments and invert them\n    num_segments = random.randint(1, min(3, n // 3))\n    segments = sorted(random.sample(range(1, n), num_segments * 2))\n\n    for i in range(0, len(segments), 2):\n        start, end = segments[i], segments[i+1]\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Dynamic edge exchange based on objective improvement\n    for _ in range(3):  # Limit iterations to avoid excessive computation\n        i, j = random.sample(range(n), 2)\n        if i == j:\n            continue\n\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[j-1], base_solution[j]]\n        current_cost2 = distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[j-1], base_solution[j]]\n\n        new_cost1 = distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j-1], base_solution[i]]\n        new_cost2 = distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j-1], base_solution[i]]\n\n        # Accept if either objective improves\n        if new_cost1 < current_cost1 or new_cost2 < current_cost2:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 48,
        "algorithm": "{A novel hybrid local search operator combines a biased random walk with a multi-objective aware edge exchange strategy, prioritizing edges with high potential for reducing both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: biased random walk with multi-objective edge exchange\n    n = len(new_solution)\n    for _ in range(min(5, n // 2)):  # Limit the number of operations\n        # Select a random segment to modify\n        start = np.random.randint(0, n - 2)\n        end = np.random.randint(start + 2, min(start + 10, n))\n\n        # Calculate potential edge improvements\n        current_edges = [(new_solution[i], new_solution[i+1]) for i in range(n-1)] + [(new_solution[-1], new_solution[0])]\n        potential_edges = []\n\n        for i in range(start, end):\n            for j in range(i+2, end):\n                # Try reversing the segment between i and j\n                candidate = new_solution.copy()\n                candidate[i:j] = candidate[i:j][::-1]\n\n                # Calculate new edges\n                new_edges = [(candidate[k], candidate[k+1]) for k in range(n-1)] + [(candidate[-1], candidate[0])]\n\n                # Calculate improvement potential\n                improvement = 0\n                for e_old, e_new in zip(current_edges, new_edges):\n                    if e_old != e_new:\n                        improvement += (distance_matrix_1[e_old[0], e_old[1]] - distance_matrix_1[e_new[0], e_new[1]]) / distance_matrix_1[e_old[0], e_old[1]]\n                        improvement += (distance_matrix_2[e_old[0], e_old[1]] - distance_matrix_2[e_new[0], e_new[1]]) / distance_matrix_2[e_old[0], e_old[1]]\n\n                potential_edges.append((improvement, candidate))\n\n        if potential_edges:\n            # Select the candidate with highest improvement\n            potential_edges.sort(key=lambda x: x[0], reverse=True)\n            new_solution = potential_edges[0][1]\n\n    return new_solution\n\n",
        "score": [
            -0.5918242207808817,
            6.408999979496002
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: biased random walk with multi-objective edge exchange\n    n = len(new_solution)\n    for _ in range(min(5, n // 2)):  # Limit the number of operations\n        # Select a random segment to modify\n        start = np.random.randint(0, n - 2)\n        end = np.random.randint(start + 2, min(start + 10, n))\n\n        # Calculate potential edge improvements\n        current_edges = [(new_solution[i], new_solution[i+1]) for i in range(n-1)] + [(new_solution[-1], new_solution[0])]\n        potential_edges = []\n\n        for i in range(start, end):\n            for j in range(i+2, end):\n                # Try reversing the segment between i and j\n                candidate = new_solution.copy()\n                candidate[i:j] = candidate[i:j][::-1]\n\n                # Calculate new edges\n                new_edges = [(candidate[k], candidate[k+1]) for k in range(n-1)] + [(candidate[-1], candidate[0])]\n\n                # Calculate improvement potential\n                improvement = 0\n                for e_old, e_new in zip(current_edges, new_edges):\n                    if e_old != e_new:\n                        improvement += (distance_matrix_1[e_old[0], e_old[1]] - distance_matrix_1[e_new[0], e_new[1]]) / distance_matrix_1[e_old[0], e_old[1]]\n                        improvement += (distance_matrix_2[e_old[0], e_old[1]] - distance_matrix_2[e_new[0], e_new[1]]) / distance_matrix_2[e_old[0], e_old[1]]\n\n                potential_edges.append((improvement, candidate))\n\n        if potential_edges:\n            # Select the candidate with highest improvement\n            potential_edges.sort(key=lambda x: x[0], reverse=True)\n            new_solution = potential_edges[0][1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 49,
        "algorithm": "{My heuristic function selects a solution from the archive by prioritizing those with the best Pareto front rankings, then applies a hybrid local search combining edge exchange and segment inversion to explore the solution space beyond standard 2-opt moves, ensuring feasibility and diversity in the neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (sum of normalized costs)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    combined_cost = normalized_costs.sum(axis=1)\n    selected_idx = np.argmin(combined_cost)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: edge exchange + segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to exchange or invert\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    k, l = sorted(np.random.choice(n, size=2, replace=False))\n\n    # Edge exchange (swap two edges)\n    if np.random.rand() < 0.5:\n        new_solution[[i, j]] = new_solution[[j, i]]\n    else:\n        # Segment inversion (reverse a segment)\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility (no duplicates and all nodes are visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if inversion causes duplicates\n        new_solution = base_solution.copy()\n        new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n",
        "score": [
            -0.49460085730110653,
            2.1594502925872803
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (sum of normalized costs)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    combined_cost = normalized_costs.sum(axis=1)\n    selected_idx = np.argmin(combined_cost)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: edge exchange + segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to exchange or invert\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    k, l = sorted(np.random.choice(n, size=2, replace=False))\n\n    # Edge exchange (swap two edges)\n    if np.random.rand() < 0.5:\n        new_solution[[i, j]] = new_solution[[j, i]]\n    else:\n        # Segment inversion (reverse a segment)\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility (no duplicates and all nodes are visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if inversion causes duplicates\n        new_solution = base_solution.copy()\n        new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 50,
        "algorithm": "{A novel heuristic function selects a solution from the archive based on a weighted dominance score, then applies a hybrid local search combining edge swaps and segment reversals to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a weighted dominance score\n    scores = []\n    for sol, obj in archive:\n        # Calculate a score based on the objectives (lower is better)\n        score = sum(obj)  # Simple sum of objectives for selection\n        scores.append(score)\n\n    # Select the solution with the lowest score (promising for improvement)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: segment reversal and edge swap\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct segments\n    a, b = sorted(np.random.choice(range(n), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(n), size=2, replace=False))\n\n    # Segment reversal\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge swap (if segments are valid)\n    if c < d and a < b:\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Ensure feasibility (no duplicates)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8690789269899968,
            2.1059229969978333
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a weighted dominance score\n    scores = []\n    for sol, obj in archive:\n        # Calculate a score based on the objectives (lower is better)\n        score = sum(obj)  # Simple sum of objectives for selection\n        scores.append(score)\n\n    # Select the solution with the lowest score (promising for improvement)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: segment reversal and edge swap\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two distinct segments\n    a, b = sorted(np.random.choice(range(n), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(n), size=2, replace=False))\n\n    # Segment reversal\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge swap (if segments are valid)\n    if c < d and a < b:\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Ensure feasibility (no duplicates)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 51,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a promising solution from the archive, then applies a combination of edge-swapping and path-relinking techniques to explore non-dominated regions while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: edge-swapping with path-relinking\n    n = len(base_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    k, l = np.random.choice(n, size=2, replace=False)\n\n    # Edge-swapping: swap edges (i,j) and (k,l) with (i,k) and (j,l)\n    new_solution[i], new_solution[j], new_solution[k], new_solution[l] = (\n        new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n    )\n\n    # Path-relinking: interpolate between base and new solution\n    for idx in range(n):\n        if np.random.rand() < 0.3:  # 30% chance to keep base's node\n            new_solution[idx] = base_solution[idx]\n\n    # Ensure feasibility by repairing invalid tours\n    if len(np.unique(new_solution)) != n:\n        # If duplicates exist, reconstruct a valid tour\n        missing = set(range(n)) - set(new_solution)\n        for idx in range(n):\n            if new_solution[idx] not in set(new_solution[:idx]):\n                continue\n            if missing:\n                new_solution[idx] = missing.pop()\n\n    return new_solution\n\n",
        "score": [
            -0.9239408850938581,
            2.382020056247711
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: edge-swapping with path-relinking\n    n = len(base_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    k, l = np.random.choice(n, size=2, replace=False)\n\n    # Edge-swapping: swap edges (i,j) and (k,l) with (i,k) and (j,l)\n    new_solution[i], new_solution[j], new_solution[k], new_solution[l] = (\n        new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n    )\n\n    # Path-relinking: interpolate between base and new solution\n    for idx in range(n):\n        if np.random.rand() < 0.3:  # 30% chance to keep base's node\n            new_solution[idx] = base_solution[idx]\n\n    # Ensure feasibility by repairing invalid tours\n    if len(np.unique(new_solution)) != n:\n        # If duplicates exist, reconstruct a valid tour\n        missing = set(range(n)) - set(new_solution)\n        for idx in range(n):\n            if new_solution[idx] not in set(new_solution[:idx]):\n                continue\n            if missing:\n                new_solution[idx] = missing.pop()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 52,
        "algorithm": "{This heuristic function selects a solution from the archive with high potential for improvement by prioritizing solutions with the lowest combined objective values, then applies a hybrid local search operator that combines edge swaps with a novel path relinking strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest combined objective)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge swaps with path relinking\n    if n > 3:\n        # Randomly select a segment to modify\n        start = np.random.randint(0, n-3)\n        end = np.random.randint(start+2, min(start+5, n))\n        segment = new_solution[start:end+1]\n\n        # Reverse the segment (edge swap)\n        new_solution[start:end+1] = segment[::-1]\n\n        # Path relinking: replace a random node with a node from a high-quality solution\n        if len(archive) > 1:\n            high_quality_solution = archive_sorted[1][0]\n            node_to_replace = np.random.randint(0, n)\n            candidate_node = high_quality_solution[np.random.randint(0, n)]\n            if candidate_node not in new_solution:\n                new_solution[node_to_replace] = candidate_node\n\n    return new_solution\n\n",
        "score": [
            -0.6261639471014645,
            4.15197890996933
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest combined objective)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge swaps with path relinking\n    if n > 3:\n        # Randomly select a segment to modify\n        start = np.random.randint(0, n-3)\n        end = np.random.randint(start+2, min(start+5, n))\n        segment = new_solution[start:end+1]\n\n        # Reverse the segment (edge swap)\n        new_solution[start:end+1] = segment[::-1]\n\n        # Path relinking: replace a random node with a node from a high-quality solution\n        if len(archive) > 1:\n            high_quality_solution = archive_sorted[1][0]\n            node_to_replace = np.random.randint(0, n)\n            candidate_node = high_quality_solution[np.random.randint(0, n)]\n            if candidate_node not in new_solution:\n                new_solution[node_to_replace] = candidate_node\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 53,
        "algorithm": "{The new algorithm intelligently selects a promising solution from the archive based on its objective values and applies a hybrid local search operator that combines edge insertion with a novel node swap strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly among top 30% in either objective)\n    objectives = [obj for _, obj in archive]\n    sorted_obj1 = sorted(objectives, key=lambda x: x[0])\n    sorted_obj2 = sorted(objectives, key=lambda x: x[1])\n    threshold1 = sorted_obj1[int(len(archive) * 0.7)][0]\n    threshold2 = sorted_obj2[int(len(archive) * 0.7)][1]\n    candidates = [(sol, obj) for sol, obj in archive if obj[0] <= threshold1 or obj[1] <= threshold2]\n\n    if not candidates:\n        candidates = archive\n\n    selected = random.choice(candidates)[0].copy()\n    new_solution = selected.copy()\n\n    # Hybrid local search operator: edge insertion + novel node swap\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Edge insertion: move segment [i..j] to position k\n    segment = new_solution[i:j+1]\n    k = random.randint(0, n - len(segment))\n    if k > i:\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n    else:\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:i], new_solution[j+1:]])\n\n    # Novel node swap: swap two nodes not in the same segment\n    a, b = random.sample(range(n), 2)\n    if (a < i <= j < b) or (b < i <= j < a):\n        pass  # Skip if nodes are in the same segment\n    else:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7945894158855443,
            1.0209113955497742
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly among top 30% in either objective)\n    objectives = [obj for _, obj in archive]\n    sorted_obj1 = sorted(objectives, key=lambda x: x[0])\n    sorted_obj2 = sorted(objectives, key=lambda x: x[1])\n    threshold1 = sorted_obj1[int(len(archive) * 0.7)][0]\n    threshold2 = sorted_obj2[int(len(archive) * 0.7)][1]\n    candidates = [(sol, obj) for sol, obj in archive if obj[0] <= threshold1 or obj[1] <= threshold2]\n\n    if not candidates:\n        candidates = archive\n\n    selected = random.choice(candidates)[0].copy()\n    new_solution = selected.copy()\n\n    # Hybrid local search operator: edge insertion + novel node swap\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Edge insertion: move segment [i..j] to position k\n    segment = new_solution[i:j+1]\n    k = random.randint(0, n - len(segment))\n    if k > i:\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n    else:\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:i], new_solution[j+1:]])\n\n    # Novel node swap: swap two nodes not in the same segment\n    a, b = random.sample(range(n), 2)\n    if (a < i <= j < b) or (b < i <= j < a):\n        pass  # Skip if nodes are in the same segment\n    else:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 54,
        "algorithm": "{A novel hybrid local search algorithm that combines a multi-objective aware segment inversion with a probabilistic edge exchange, guided by Pareto dominance and diversity metrics to intelligently select and modify promising segments of the tour while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Rank solutions by Pareto dominance and diversity\n        dominated_counts = [0] * len(archive)\n        for i, (sol_i, obj_i) in enumerate(archive):\n            for j, (sol_j, obj_j) in enumerate(archive):\n                if i != j:\n                    if (obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1]) and (obj_i[0] < obj_j[0] or obj_i[1] < obj_j[1]):\n                        dominated_counts[j] += 1\n\n        # Select non-dominated solutions with probability proportional to their diversity\n        non_dominated = [i for i, cnt in enumerate(dominated_counts) if cnt == 0]\n        if non_dominated:\n            selected_idx = random.choices(non_dominated, weights=[1/(dominated_counts[i]+1) for i in non_dominated], k=1)[0]\n        else:\n            selected_idx = random.randint(0, len(archive)-1)\n\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just do a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Hybrid operator: Multi-segment inversion with probabilistic edge exchange\n    # Select a segment to invert\n    seg_start = random.randint(0, n-3)\n    seg_length = random.randint(2, min(5, n-seg_start-1))\n    seg_end = seg_start + seg_length\n\n    # Invert the segment\n    new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Probabilistically exchange edges with neighbors\n    for i in range(seg_start, seg_end):\n        if random.random() < 0.3:  # 30% chance to exchange\n            neighbor_pos = (i + 1) % n\n            # Calculate edge costs before and after exchange\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[neighbor_pos]] + distance_matrix_1[new_solution[(i-1)%n], new_solution[i]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[neighbor_pos]] + distance_matrix_2[new_solution[(i-1)%n], new_solution[i]]\n\n            # Try exchanging\n            temp = new_solution[i]\n            new_solution[i] = new_solution[neighbor_pos]\n            new_solution[neighbor_pos] = temp\n\n            new_cost1 = distance_matrix_1[new_solution[i], new_solution[neighbor_pos]] + distance_matrix_1[new_solution[(i-1)%n], new_solution[i]]\n            new_cost2 = distance_matrix_2[new_solution[i], new_solution[neighbor_pos]] + distance_matrix_2[new_solution[(i-1)%n], new_solution[i]]\n\n            # Accept if improvement in at least one objective\n            if not (new_cost1 > current_cost1 and new_cost2 > current_cost2):\n                pass  # Keep the exchange\n            else:\n                # Revert if no improvement\n                temp = new_solution[i]\n                new_solution[i] = new_solution[neighbor_pos]\n                new_solution[neighbor_pos] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.7981698465399012,
            1.9734175205230713
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Rank solutions by Pareto dominance and diversity\n        dominated_counts = [0] * len(archive)\n        for i, (sol_i, obj_i) in enumerate(archive):\n            for j, (sol_j, obj_j) in enumerate(archive):\n                if i != j:\n                    if (obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1]) and (obj_i[0] < obj_j[0] or obj_i[1] < obj_j[1]):\n                        dominated_counts[j] += 1\n\n        # Select non-dominated solutions with probability proportional to their diversity\n        non_dominated = [i for i, cnt in enumerate(dominated_counts) if cnt == 0]\n        if non_dominated:\n            selected_idx = random.choices(non_dominated, weights=[1/(dominated_counts[i]+1) for i in non_dominated], k=1)[0]\n        else:\n            selected_idx = random.randint(0, len(archive)-1)\n\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just do a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Hybrid operator: Multi-segment inversion with probabilistic edge exchange\n    # Select a segment to invert\n    seg_start = random.randint(0, n-3)\n    seg_length = random.randint(2, min(5, n-seg_start-1))\n    seg_end = seg_start + seg_length\n\n    # Invert the segment\n    new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Probabilistically exchange edges with neighbors\n    for i in range(seg_start, seg_end):\n        if random.random() < 0.3:  # 30% chance to exchange\n            neighbor_pos = (i + 1) % n\n            # Calculate edge costs before and after exchange\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[neighbor_pos]] + distance_matrix_1[new_solution[(i-1)%n], new_solution[i]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[neighbor_pos]] + distance_matrix_2[new_solution[(i-1)%n], new_solution[i]]\n\n            # Try exchanging\n            temp = new_solution[i]\n            new_solution[i] = new_solution[neighbor_pos]\n            new_solution[neighbor_pos] = temp\n\n            new_cost1 = distance_matrix_1[new_solution[i], new_solution[neighbor_pos]] + distance_matrix_1[new_solution[(i-1)%n], new_solution[i]]\n            new_cost2 = distance_matrix_2[new_solution[i], new_solution[neighbor_pos]] + distance_matrix_2[new_solution[(i-1)%n], new_solution[i]]\n\n            # Accept if improvement in at least one objective\n            if not (new_cost1 > current_cost1 and new_cost2 > current_cost2):\n                pass  # Keep the exchange\n            else:\n                # Revert if no improvement\n                temp = new_solution[i]\n                new_solution[i] = new_solution[neighbor_pos]\n                new_solution[neighbor_pos] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 55,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of cost diversity and non-dominated status, then applies a hybrid local search combining edge-insertion and segment-reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal + edge insertion\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a random segment to reverse\n        start = np.random.randint(0, n-3)\n        end = np.random.randint(start+2, n)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Insert a random edge from another part of the tour\n        insert_pos = np.random.randint(0, n)\n        if insert_pos < start or insert_pos > end:\n            node = new_solution[insert_pos]\n            new_solution = np.delete(new_solution, insert_pos)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.8036516968587726,
            2.3799909353256226
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal + edge insertion\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a random segment to reverse\n        start = np.random.randint(0, n-3)\n        end = np.random.randint(start+2, n)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Insert a random edge from another part of the tour\n        insert_pos = np.random.randint(0, n)\n        if insert_pos < start or insert_pos > end:\n            node = new_solution[insert_pos]\n            new_solution = np.delete(new_solution, insert_pos)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 56,
        "algorithm": "{A hybrid local search algorithm that combines edge exchange with adaptive segment inversion, prioritizing solutions with high crowding distance in the objective space to explore under-represented regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances for all solutions in the archive\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n    for m in range(2):  # For each objective\n        sorted_indices = np.argsort(objectives[:, m])\n        sorted_objectives = objectives[sorted_indices, m]\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, len(archive) - 1):\n            crowding_distances[sorted_indices[i]] += (sorted_objectives[i+1] - sorted_objectives[i-1])\n\n    # Select a solution with high crowding distance (promising for improvement)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive segment inversion with edge exchange\n    n = len(base_solution)\n    if n < 4:\n        # Simple swap if tour is too small\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Determine segment length based on solution quality\n        segment_length = max(2, min(n // 4, np.random.randint(2, n // 2)))\n\n        # Select two non-overlapping segments\n        a, b = sorted(np.random.choice(n - segment_length, 2, replace=False))\n        seg1 = slice(a, a + segment_length)\n        seg2 = slice(b, b + segment_length)\n\n        # Invert segments with probability based on their quality\n        if np.random.rand() < 0.7:  # Higher probability for better segments\n            new_solution[seg1] = new_solution[seg1][::-1]\n        if np.random.rand() < 0.7:\n            new_solution[seg2] = new_solution[seg2][::-1]\n\n        # Edge exchange between segments\n        if np.random.rand() < 0.5:\n            temp = new_solution[seg1].copy()\n            new_solution[seg1] = new_solution[seg2]\n            new_solution[seg2] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.5025001720095811,
            1.6058762073516846
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances for all solutions in the archive\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n    for m in range(2):  # For each objective\n        sorted_indices = np.argsort(objectives[:, m])\n        sorted_objectives = objectives[sorted_indices, m]\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, len(archive) - 1):\n            crowding_distances[sorted_indices[i]] += (sorted_objectives[i+1] - sorted_objectives[i-1])\n\n    # Select a solution with high crowding distance (promising for improvement)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive segment inversion with edge exchange\n    n = len(base_solution)\n    if n < 4:\n        # Simple swap if tour is too small\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Determine segment length based on solution quality\n        segment_length = max(2, min(n // 4, np.random.randint(2, n // 2)))\n\n        # Select two non-overlapping segments\n        a, b = sorted(np.random.choice(n - segment_length, 2, replace=False))\n        seg1 = slice(a, a + segment_length)\n        seg2 = slice(b, b + segment_length)\n\n        # Invert segments with probability based on their quality\n        if np.random.rand() < 0.7:  # Higher probability for better segments\n            new_solution[seg1] = new_solution[seg1][::-1]\n        if np.random.rand() < 0.7:\n            new_solution[seg2] = new_solution[seg2][::-1]\n\n        # Edge exchange between segments\n        if np.random.rand() < 0.5:\n            temp = new_solution[seg1].copy()\n            new_solution[seg1] = new_solution[seg2]\n            new_solution[seg2] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 57,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Combine edge exchange with segment reversal\n    n = len(selected)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution = selected.copy()\n\n    # Edge exchange: Swap edges between two segments\n    if j - i > 1:\n        segment = new_solution[i:j]\n        new_solution[i:j] = np.concatenate([segment[1:], segment[:1]])\n\n    # Segment reversal: Reverse a random segment\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k:l] = new_solution[k:l][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8820413563367937,
            2.0019208192825317
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Combine edge exchange with segment reversal\n    n = len(selected)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution = selected.copy()\n\n    # Edge exchange: Swap edges between two segments\n    if j - i > 1:\n        segment = new_solution[i:j]\n        new_solution[i:j] = np.concatenate([segment[1:], segment[:1]])\n\n    # Segment reversal: Reverse a random segment\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k:l] = new_solution[k:l][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 58,
        "algorithm": "{A hybrid local search algorithm that combines a novel segment-swap operator with a probabilistic edge selection mechanism to intelligently explore the solution space, ensuring feasibility while balancing exploration and exploitation in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]) / 2)  # Sort by average objective value\n    selected_solution = archive[0][0].copy()  # Select the best solution\n\n    # Generate a neighbor using a hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment to modify\n    segment_start = random.randint(0, n - 2)\n    segment_end = random.randint(segment_start + 1, n - 1)\n    segment = new_solution[segment_start:segment_end]\n\n    # Step 2: Identify promising edges to swap\n    candidates = []\n    for i in range(segment_start, segment_end):\n        for j in range(n):\n            if j not in segment:\n                # Calculate the cost difference for both objectives\n                cost_diff_1 = (distance_matrix_1[new_solution[i-1], j] + distance_matrix_1[j, new_solution[i+1 if i+1 < n else 0]]) - distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[i+1 if i+1 < n else 0]]\n                cost_diff_2 = (distance_matrix_2[new_solution[i-1], j] + distance_matrix_2[j, new_solution[i+1 if i+1 < n else 0]]) - distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[i+1 if i+1 < n else 0]]\n                candidates.append((cost_diff_1 + cost_diff_2, i, j))\n\n    if candidates:\n        # Select the best candidate based on combined cost improvement\n        candidates.sort(key=lambda x: x[0])\n        best_candidate = candidates[0]\n        _, i, j = best_candidate\n        new_solution[i] = j\n\n    # Step 3: Apply a probabilistic edge swap for further improvement\n    if random.random() < 0.3:  # 30% chance of additional swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9976314514837442,
            13.705745697021484
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]) / 2)  # Sort by average objective value\n    selected_solution = archive[0][0].copy()  # Select the best solution\n\n    # Generate a neighbor using a hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment to modify\n    segment_start = random.randint(0, n - 2)\n    segment_end = random.randint(segment_start + 1, n - 1)\n    segment = new_solution[segment_start:segment_end]\n\n    # Step 2: Identify promising edges to swap\n    candidates = []\n    for i in range(segment_start, segment_end):\n        for j in range(n):\n            if j not in segment:\n                # Calculate the cost difference for both objectives\n                cost_diff_1 = (distance_matrix_1[new_solution[i-1], j] + distance_matrix_1[j, new_solution[i+1 if i+1 < n else 0]]) - distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[i+1 if i+1 < n else 0]]\n                cost_diff_2 = (distance_matrix_2[new_solution[i-1], j] + distance_matrix_2[j, new_solution[i+1 if i+1 < n else 0]]) - distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[i+1 if i+1 < n else 0]]\n                candidates.append((cost_diff_1 + cost_diff_2, i, j))\n\n    if candidates:\n        # Select the best candidate based on combined cost improvement\n        candidates.sort(key=lambda x: x[0])\n        best_candidate = candidates[0]\n        _, i, j = best_candidate\n        new_solution[i] = j\n\n    # Step 3: Apply a probabilistic edge swap for further improvement\n    if random.random() < 0.3:  # 30% chance of additional swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 58,
        "algorithm": "{A hybrid local search algorithm that combines a novel segment-swap operator with a probabilistic edge selection mechanism to intelligently explore the solution space, ensuring feasibility while balancing exploration and exploitation in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]) / 2)  # Sort by average objective value\n    selected_solution = archive[0][0].copy()  # Select the best solution\n\n    # Generate a neighbor using a hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment to modify\n    segment_start = random.randint(0, n - 2)\n    segment_end = random.randint(segment_start + 1, n - 1)\n    segment = new_solution[segment_start:segment_end]\n\n    # Step 2: Identify promising edges to swap\n    candidates = []\n    for i in range(segment_start, segment_end):\n        for j in range(n):\n            if j not in segment:\n                # Calculate the cost difference for both objectives\n                cost_diff_1 = (distance_matrix_1[new_solution[i-1], j] + distance_matrix_1[j, new_solution[i+1 if i+1 < n else 0]]) - distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[i+1 if i+1 < n else 0]]\n                cost_diff_2 = (distance_matrix_2[new_solution[i-1], j] + distance_matrix_2[j, new_solution[i+1 if i+1 < n else 0]]) - distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[i+1 if i+1 < n else 0]]\n                candidates.append((cost_diff_1 + cost_diff_2, i, j))\n\n    if candidates:\n        # Select the best candidate based on combined cost improvement\n        candidates.sort(key=lambda x: x[0])\n        best_candidate = candidates[0]\n        _, i, j = best_candidate\n        new_solution[i] = j\n\n    # Step 3: Apply a probabilistic edge swap for further improvement\n    if random.random() < 0.3:  # 30% chance of additional swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9976314514837442,
            13.705745697021484
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]) / 2)  # Sort by average objective value\n    selected_solution = archive[0][0].copy()  # Select the best solution\n\n    # Generate a neighbor using a hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment to modify\n    segment_start = random.randint(0, n - 2)\n    segment_end = random.randint(segment_start + 1, n - 1)\n    segment = new_solution[segment_start:segment_end]\n\n    # Step 2: Identify promising edges to swap\n    candidates = []\n    for i in range(segment_start, segment_end):\n        for j in range(n):\n            if j not in segment:\n                # Calculate the cost difference for both objectives\n                cost_diff_1 = (distance_matrix_1[new_solution[i-1], j] + distance_matrix_1[j, new_solution[i+1 if i+1 < n else 0]]) - distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[i+1 if i+1 < n else 0]]\n                cost_diff_2 = (distance_matrix_2[new_solution[i-1], j] + distance_matrix_2[j, new_solution[i+1 if i+1 < n else 0]]) - distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[i+1 if i+1 < n else 0]]\n                candidates.append((cost_diff_1 + cost_diff_2, i, j))\n\n    if candidates:\n        # Select the best candidate based on combined cost improvement\n        candidates.sort(key=lambda x: x[0])\n        best_candidate = candidates[0]\n        _, i, j = best_candidate\n        new_solution[i] = j\n\n    # Step 3: Apply a probabilistic edge swap for further improvement\n    if random.random() < 0.3:  # 30% chance of additional swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 59,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=[1.0 / len(archive) for _ in range(len(archive))])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 3-opt with adaptive segment selection\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three segments\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    segment1 = base_solution[a:b]\n    segment2 = base_solution[b:c]\n    segment3 = np.concatenate([base_solution[c:], base_solution[:a]])\n\n    # Recombine segments in a new order with probability of improvement\n    if np.random.rand() < 0.5:\n        new_solution = np.concatenate([segment1, segment3, segment2])\n    else:\n        new_solution = np.concatenate([segment2, segment1, segment3])\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if 3-opt fails\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution = np.concatenate([base_solution[:i], base_solution[i:j][::-1], base_solution[j:]])\n\n    return new_solution\n\n",
        "score": [
            -0.86861383762878,
            2.217988073825836
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=[1.0 / len(archive) for _ in range(len(archive))])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 3-opt with adaptive segment selection\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three segments\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    segment1 = base_solution[a:b]\n    segment2 = base_solution[b:c]\n    segment3 = np.concatenate([base_solution[c:], base_solution[:a]])\n\n    # Recombine segments in a new order with probability of improvement\n    if np.random.rand() < 0.5:\n        new_solution = np.concatenate([segment1, segment3, segment2])\n    else:\n        new_solution = np.concatenate([segment2, segment1, segment3])\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if 3-opt fails\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution = np.concatenate([base_solution[:i], base_solution[i:j][::-1], base_solution[j:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 60,
        "algorithm": "{This algorithm selects a promising solution from the archive by prioritizing those with non-dominated objectives, then applies a hybrid local search combining edge exchange and segment inversion to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_sol = archive[np.random.randint(len(archive))][0].copy()\n    else:\n        selected_sol = non_dominated[np.random.randint(len(non_dominated))][0].copy()\n\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge exchange and segment inversion\n    if n > 3:\n        # Randomly select two distinct edges to exchange\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n\n        # Perform edge exchange\n        if i < j:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        else:\n            new_solution[j+1:i+1] = new_solution[j+1:i+1][::-1]\n\n        # Randomly select a segment to invert\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        while b == a or b == (a + 1) % n or b == (a - 1) % n:\n            b = np.random.randint(0, n)\n\n        if a < b:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        else:\n            new_solution[b:a+1] = new_solution[b:a+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9186988940035901,
            1.920704424381256
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_sol = archive[np.random.randint(len(archive))][0].copy()\n    else:\n        selected_sol = non_dominated[np.random.randint(len(non_dominated))][0].copy()\n\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge exchange and segment inversion\n    if n > 3:\n        # Randomly select two distinct edges to exchange\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n\n        # Perform edge exchange\n        if i < j:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        else:\n            new_solution[j+1:i+1] = new_solution[j+1:i+1][::-1]\n\n        # Randomly select a segment to invert\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        while b == a or b == (a + 1) % n or b == (a - 1) % n:\n            b = np.random.randint(0, n)\n\n        if a < b:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        else:\n            new_solution[b:a+1] = new_solution[b:a+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 61,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] if x[1][0] * x[1][1] != 0 else 1))[0]\n\n    # Apply a hybrid local search: combine 2-opt with a novel edge insertion strategy\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select segments for hybrid operation\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Reverse segment (similar to 2-opt)\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Insert segment (novel insertion)\n    segment = new_solution[c:d]\n    new_solution = np.concatenate([new_solution[:c], segment, new_solution[d:]])\n\n    # Ensure feasibility by removing duplicates\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    # If missing nodes, append them in order\n    missing = set(range(n)) - set(new_solution)\n    if missing:\n        new_solution = np.concatenate([new_solution, np.array(list(missing))])\n\n    return new_solution\n\n",
        "score": [
            -0.4249624872389415,
            2.134046971797943
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] if x[1][0] * x[1][1] != 0 else 1))[0]\n\n    # Apply a hybrid local search: combine 2-opt with a novel edge insertion strategy\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select segments for hybrid operation\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Reverse segment (similar to 2-opt)\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Insert segment (novel insertion)\n    segment = new_solution[c:d]\n    new_solution = np.concatenate([new_solution[:c], segment, new_solution[d:]])\n\n    # Ensure feasibility by removing duplicates\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    # If missing nodes, append them in order\n    missing = set(range(n)) - set(new_solution)\n    if missing:\n        new_solution = np.concatenate([new_solution, np.array(list(missing))])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 62,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search combining edge reinsertion and a novel 3-opt-like segment relocation strategy to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by inverse cost)\n    costs = [obj[0] + obj[1] for _, obj in archive]\n    weights = [1.0 / (cost + 1e-6) for cost in costs]  # Avoid division by zero\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: edge reinsertion followed by 3-opt-like segment relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge reinsertion step\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        removed_edge = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, removed_edge)\n\n    # 3-opt-like segment relocation\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8314679413789191,
            2.043655276298523
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by inverse cost)\n    costs = [obj[0] + obj[1] for _, obj in archive]\n    weights = [1.0 / (cost + 1e-6) for cost in costs]  # Avoid division by zero\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: edge reinsertion followed by 3-opt-like segment relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge reinsertion step\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        removed_edge = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, removed_edge)\n\n    # 3-opt-like segment relocation\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 63,
        "algorithm": "{A novel local search operator combines a biased random selection of solutions from the archive, followed by a hybrid edge-swap and segment-reversal strategy that intelligently balances exploration and exploitation, ensuring feasibility while diversifying search through objective-aware perturbations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        selected = archive[0][0].copy()\n    else:\n        # Calculate dominance ranks (simplified: higher rank for non-dominated solutions)\n        ranks = np.zeros(len(archive))\n        for i in range(len(archive)):\n            dominated = False\n            for j in range(len(archive)):\n                if i != j:\n                    if archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]:\n                        if archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]:\n                            dominated = True\n                            break\n            if not dominated:\n                ranks[i] = 1  # Non-dominated\n            else:\n                ranks[i] = 2  # Dominated\n\n        # Select with probability inversely proportional to rank\n        probs = 1 / (ranks + 1e-6)\n        probs = probs / probs.sum()\n        idx = np.random.choice(len(archive), p=probs)\n        selected = archive[idx][0].copy()\n\n    new_solution = selected.copy()\n\n    # Hybrid local search: segment reversal with edge swap\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select a segment to reverse\n    a = random.randint(0, n-2)\n    b = random.randint(a+1, n-1)\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select two edges to swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If infeasible, revert to original segment\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8096094960545003,
            2.571800708770752
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        selected = archive[0][0].copy()\n    else:\n        # Calculate dominance ranks (simplified: higher rank for non-dominated solutions)\n        ranks = np.zeros(len(archive))\n        for i in range(len(archive)):\n            dominated = False\n            for j in range(len(archive)):\n                if i != j:\n                    if archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]:\n                        if archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]:\n                            dominated = True\n                            break\n            if not dominated:\n                ranks[i] = 1  # Non-dominated\n            else:\n                ranks[i] = 2  # Dominated\n\n        # Select with probability inversely proportional to rank\n        probs = 1 / (ranks + 1e-6)\n        probs = probs / probs.sum()\n        idx = np.random.choice(len(archive), p=probs)\n        selected = archive[idx][0].copy()\n\n    new_solution = selected.copy()\n\n    # Hybrid local search: segment reversal with edge swap\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select a segment to reverse\n    a = random.randint(0, n-2)\n    b = random.randint(a+1, n-1)\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select two edges to swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If infeasible, revert to original segment\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 64,
        "algorithm": "{This algorithm selects a solution from the archive based on its potential for improvement (using a weighted combination of objective values) and applies a hybrid local search operator that combines edge swaps and node reinsertions to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with potential for improvement (lower combined objective)\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.uniform(0.3, 0.7)  # Random weight for objectives\n    combined = objectives[:, 0] * weights + objectives[:, 1] * (1 - weights)\n    selected_idx = np.argmin(combined)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge swaps and node reinsertions\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment for edge swap\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select a node to reinsert\n    c = np.random.randint(0, n)\n    node = new_solution[c]\n    new_solution = np.delete(new_solution, c)\n    d = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, d, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7743169422639692,
            1.9295827150344849
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with potential for improvement (lower combined objective)\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.uniform(0.3, 0.7)  # Random weight for objectives\n    combined = objectives[:, 0] * weights + objectives[:, 1] * (1 - weights)\n    selected_idx = np.argmin(combined)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge swaps and node reinsertions\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment for edge swap\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select a node to reinsert\n    c = np.random.randint(0, n)\n    node = new_solution[c]\n    new_solution = np.delete(new_solution, c)\n    d = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, d, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 65,
        "algorithm": "{The heuristic function selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search strategy combining edge exchange with a novel segment inversion operator to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choice([i for i in range(len(archive))\n                                if not any(archive[i][1][0] > other[1][0] and archive[i][1][1] > other[1][1]\n                                          for other in archive)])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange with segment inversion\n    n = len(base_solution)\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Edge exchange\n    new_solution[a:b+1] = base_solution[a:b+1][::-1]\n    new_solution[c:d+1] = base_solution[c:d+1][::-1]\n\n    # Segment inversion (novel operator)\n    if random.random() < 0.5:\n        k = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - k)\n        new_solution[start:start+k] = base_solution[start:start+k][::-1]\n\n    # Ensure feasibility (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing = set(range(n)) - set(new_solution)\n        duplicates = [x for x in new_solution if list(new_solution).count(x) > 1]\n        for dup in duplicates:\n            idx = np.where(new_solution == dup)[0][0]\n            new_solution[idx] = next(iter(missing))\n\n    return new_solution\n\n",
        "score": [
            -0.815764037953026,
            1.8111326098442078
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choice([i for i in range(len(archive))\n                                if not any(archive[i][1][0] > other[1][0] and archive[i][1][1] > other[1][1]\n                                          for other in archive)])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange with segment inversion\n    n = len(base_solution)\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Edge exchange\n    new_solution[a:b+1] = base_solution[a:b+1][::-1]\n    new_solution[c:d+1] = base_solution[c:d+1][::-1]\n\n    # Segment inversion (novel operator)\n    if random.random() < 0.5:\n        k = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - k)\n        new_solution[start:start+k] = base_solution[start:start+k][::-1]\n\n    # Ensure feasibility (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing = set(range(n)) - set(new_solution)\n        duplicates = [x for x in new_solution if list(new_solution).count(x) > 1]\n        for dup in duplicates:\n            idx = np.where(new_solution == dup)[0][0]\n            new_solution[idx] = next(iter(missing))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 66,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swapping strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select three distinct edges to perform 3-opt\n    a, b, c = sorted(random.sample(range(1, n), 3))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Create 7 possible 3-opt permutations and evaluate them\n    candidates = [\n        np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n        np.concatenate([segment1, segment3, segment2, segment4]),\n        np.concatenate([segment1, segment3[::-1], segment2, segment4]),\n        np.concatenate([segment1, segment2, segment3[::-1], segment4]),\n        np.concatenate([segment1, segment4, segment3, segment2]),\n        np.concatenate([segment1, segment4, segment3[::-1], segment2]),\n        np.concatenate([segment1, segment2[::-1], segment3[::-1], segment4])\n    ]\n\n    # Evaluate all candidates using the combined objective\n    def evaluate(sol):\n        cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        return cost1 + cost2\n\n    best_candidate = min(candidates, key=evaluate)\n    new_solution = best_candidate.copy()\n\n    # Step 2: Novel edge-swapping strategy (swap edges that reduce both objectives)\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n\n        # Create two new solutions by swapping edges\n        candidate1 = new_solution.copy()\n        candidate1[i:j+1] = candidate1[i:j+1][::-1]\n\n        candidate2 = new_solution.copy()\n        candidate2[i], candidate2[j] = candidate2[j], candidate2[i]\n\n        # Evaluate both candidates\n        candidates = [candidate1, candidate2]\n        best_new = min(candidates, key=evaluate)\n\n        # Only accept if improvement is found\n        if evaluate(best_new) < evaluate(new_solution):\n            new_solution = best_new.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6689131421379788,
            5.632494270801544
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swapping strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select three distinct edges to perform 3-opt\n    a, b, c = sorted(random.sample(range(1, n), 3))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Create 7 possible 3-opt permutations and evaluate them\n    candidates = [\n        np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n        np.concatenate([segment1, segment3, segment2, segment4]),\n        np.concatenate([segment1, segment3[::-1], segment2, segment4]),\n        np.concatenate([segment1, segment2, segment3[::-1], segment4]),\n        np.concatenate([segment1, segment4, segment3, segment2]),\n        np.concatenate([segment1, segment4, segment3[::-1], segment2]),\n        np.concatenate([segment1, segment2[::-1], segment3[::-1], segment4])\n    ]\n\n    # Evaluate all candidates using the combined objective\n    def evaluate(sol):\n        cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        return cost1 + cost2\n\n    best_candidate = min(candidates, key=evaluate)\n    new_solution = best_candidate.copy()\n\n    # Step 2: Novel edge-swapping strategy (swap edges that reduce both objectives)\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n\n        # Create two new solutions by swapping edges\n        candidate1 = new_solution.copy()\n        candidate1[i:j+1] = candidate1[i:j+1][::-1]\n\n        candidate2 = new_solution.copy()\n        candidate2[i], candidate2[j] = candidate2[j], candidate2[i]\n\n        # Evaluate both candidates\n        candidates = [candidate1, candidate2]\n        best_new = min(candidates, key=evaluate)\n\n        # Only accept if improvement is found\n        if evaluate(best_new) < evaluate(new_solution):\n            new_solution = best_new.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 67,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: max(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Combine edge insertion with a biased 3-opt-like move\n    n = len(base_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Extract segments and reinsert them in a different order\n    segment1 = base_solution[i:j]\n    segment2 = base_solution[j:k]\n    segment3 = np.concatenate([base_solution[:i], base_solution[k:]])\n\n    # Reconstruct with a random permutation of segments\n    segments = [segment1, segment2, segment3]\n    np.random.shuffle(segments)\n    new_solution = np.concatenate(segments)\n\n    # Ensure feasibility (no duplicates, all nodes included)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) == n and np.array_equal(np.sort(unique_nodes), np.sort(base_solution)):\n        return new_solution\n\n    # Fallback: simple swap if above fails\n    a, b = np.random.choice(n, 2, replace=False)\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    return new_solution\n\n",
        "score": [
            -0.6045849491698043,
            1.4978870153427124
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: max(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Combine edge insertion with a biased 3-opt-like move\n    n = len(base_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Extract segments and reinsert them in a different order\n    segment1 = base_solution[i:j]\n    segment2 = base_solution[j:k]\n    segment3 = np.concatenate([base_solution[:i], base_solution[k:]])\n\n    # Reconstruct with a random permutation of segments\n    segments = [segment1, segment2, segment3]\n    np.random.shuffle(segments)\n    new_solution = np.concatenate(segments)\n\n    # Ensure feasibility (no duplicates, all nodes included)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) == n and np.array_equal(np.sort(unique_nodes), np.sort(base_solution)):\n        return new_solution\n\n    # Fallback: simple swap if above fails\n    a, b = np.random.choice(n, 2, replace=False)\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 68,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing solutions with low objective values and high diversity, then applies a hybrid local search combining edge insertion, path reversal, and segment swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with low objectives and high diversity\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(len(archive_sorted) - 1, int(len(archive_sorted) * 0.3))\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion, path reversal, and segment swapping\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Edge insertion\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:\n        segment = new_solution[i+1:j]\n        new_solution = np.concatenate([new_solution[:i+1], segment[::-1], new_solution[j:]])\n\n    # Step 2: Path reversal\n    k, l = sorted(random.sample(range(n), 2))\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Step 3: Segment swapping\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    if b - a > 1 and d - c > 1:\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[c:d]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b:c], segment1, new_solution[d:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8325139867935047,
            1.8838674426078796
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with low objectives and high diversity\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(len(archive_sorted) - 1, int(len(archive_sorted) * 0.3))\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion, path reversal, and segment swapping\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Edge insertion\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:\n        segment = new_solution[i+1:j]\n        new_solution = np.concatenate([new_solution[:i+1], segment[::-1], new_solution[j:]])\n\n    # Step 2: Path reversal\n    k, l = sorted(random.sample(range(n), 2))\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Step 3: Segment swapping\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    if b - a > 1 and d - c > 1:\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[c:d]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b:c], segment1, new_solution[d:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 69,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = random.choice(archive)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swapping and segment reversal\n    n = len(new_solution)\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Edge swapping: reverse a segment and swap edges\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    if random.random() < 0.5:\n        new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid tour: duplicate nodes\"\n    assert np.all(np.sort(new_solution) == np.arange(n)), \"Invalid tour: missing nodes\"\n\n    return new_solution\n\n",
        "score": [
            -0.9020065849558969,
            2.0914050936698914
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = random.choice(archive)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swapping and segment reversal\n    n = len(new_solution)\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Edge swapping: reverse a segment and swap edges\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    if random.random() < 0.5:\n        new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid tour: duplicate nodes\"\n    assert np.all(np.sort(new_solution) == np.arange(n)), \"Invalid tour: missing nodes\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 70,
        "algorithm": "{A hybrid local search strategy that combines a novel segment-based perturbation with a relaxed 3-opt move to explore the solution space while ensuring feasibility, favoring solutions with high potential for improvement in both objectives by intelligently selecting candidates from the archive.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_sol = random.choice(archive)[0].copy()\n    new_solution = selected_sol.copy()\n\n    # Hybrid local search: segment-based perturbation + relaxed 3-opt\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply the operator\n\n    # Step 1: Segment-based perturbation\n    segment_size = max(2, n // 5)\n    start = random.randint(0, n - segment_size - 1)\n    segment = new_solution[start:start + segment_size]\n    np.random.shuffle(segment)\n    new_solution[start:start + segment_size] = segment\n\n    # Step 2: Relaxed 3-opt (allow some flexibility in the move)\n    i, j, k = sorted(random.sample(range(n), 3))\n    if random.random() < 0.5:\n        # Option 1: Reverse the segment between i and j\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Option 2: Rotate the segment between i and k\n        segment = new_solution[i:k]\n        shift = random.randint(1, len(segment) - 1)\n        new_solution[i:k] = np.roll(segment, shift)\n\n    return new_solution\n\n",
        "score": [
            -0.8231763244228614,
            1.6602434515953064
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_sol = random.choice(archive)[0].copy()\n    new_solution = selected_sol.copy()\n\n    # Hybrid local search: segment-based perturbation + relaxed 3-opt\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply the operator\n\n    # Step 1: Segment-based perturbation\n    segment_size = max(2, n // 5)\n    start = random.randint(0, n - segment_size - 1)\n    segment = new_solution[start:start + segment_size]\n    np.random.shuffle(segment)\n    new_solution[start:start + segment_size] = segment\n\n    # Step 2: Relaxed 3-opt (allow some flexibility in the move)\n    i, j, k = sorted(random.sample(range(n), 3))\n    if random.random() < 0.5:\n        # Option 1: Reverse the segment between i and j\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Option 2: Rotate the segment between i and k\n        segment = new_solution[i:k]\n        shift = random.randint(1, len(segment) - 1)\n        new_solution[i:k] = np.roll(segment, shift)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 71,
        "algorithm": "{A hybrid local search operator combines a novel segment relocation strategy with a dynamic edge-swapping heuristic to explore diverse neighborhoods while maintaining feasibility, ensuring high-quality solutions across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Segment relocation with dynamic edge swapping\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Step 1: Randomly select a segment to relocate\n    segment_start = random.randint(0, n - 3)\n    segment_end = random.randint(segment_start + 1, min(segment_start + 3, n - 1))\n    segment = new_solution[segment_start:segment_end + 1]\n\n    # Step 2: Remove the segment and insert it elsewhere\n    new_solution = np.concatenate([new_solution[:segment_start], new_solution[segment_end + 1:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 3: Dynamic edge swapping based on edge quality\n    for _ in range(2):  # Limit swaps to avoid excessive computation\n        i = random.randint(0, len(new_solution) - 2)\n        j = random.randint(i + 1, len(new_solution) - 1)\n\n        # Calculate edge quality in both objectives\n        edge1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        edge2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        swapped_edge1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]\n        swapped_edge2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]]\n\n        # Swap if it improves both objectives\n        if (swapped_edge1 < edge1 and swapped_edge2 < edge2):\n            new_solution[i+1:j+1] = new_solution[j:i:-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8676176397430114,
            1.2007045149803162
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Segment relocation with dynamic edge swapping\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Step 1: Randomly select a segment to relocate\n    segment_start = random.randint(0, n - 3)\n    segment_end = random.randint(segment_start + 1, min(segment_start + 3, n - 1))\n    segment = new_solution[segment_start:segment_end + 1]\n\n    # Step 2: Remove the segment and insert it elsewhere\n    new_solution = np.concatenate([new_solution[:segment_start], new_solution[segment_end + 1:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 3: Dynamic edge swapping based on edge quality\n    for _ in range(2):  # Limit swaps to avoid excessive computation\n        i = random.randint(0, len(new_solution) - 2)\n        j = random.randint(i + 1, len(new_solution) - 1)\n\n        # Calculate edge quality in both objectives\n        edge1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        edge2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        swapped_edge1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]\n        swapped_edge2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]]\n\n        # Swap if it improves both objectives\n        if (swapped_edge1 < edge1 and swapped_edge2 < edge2):\n            new_solution[i+1:j+1] = new_solution[j:i:-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 72,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on dominance and diversity, then applies a hybrid local search combining edge insertion and segment reversal to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Edge insertion + segment reversal\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Randomly insert an edge from another part of the tour\n    if n > 3:\n        c = random.randint(0, n-1)\n        while c == a or c == b:\n            c = random.randint(0, n-1)\n        edge = new_solution[c]\n        new_solution = np.delete(new_solution, c)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, edge)\n\n    return new_solution\n\n",
        "score": [
            -0.9061101459979586,
            1.6964836120605469
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Edge insertion + segment reversal\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Randomly insert an edge from another part of the tour\n    if n > 3:\n        c = random.randint(0, n-1)\n        while c == a or c == b:\n            c = random.randint(0, n-1)\n        edge = new_solution[c]\n        new_solution = np.delete(new_solution, c)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, edge)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 73,
        "algorithm": "{This algorithm intelligently selects a high-potential solution from the archive based on a combined objective score, then applies a hybrid local search combining edge-swapping and node-insertion strategies to generate a neighbor solution while ensuring feasibility and diversity in exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution, (cost1, cost2) = archive[selected_idx]\n    base_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine edge-swapping and node-insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge-swapping (2-opt variant with random selection)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Node-insertion (randomly move a node to another position)\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure validity (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8869627831532743,
            1.7475422620773315
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution, (cost1, cost2) = archive[selected_idx]\n    base_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine edge-swapping and node-insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge-swapping (2-opt variant with random selection)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Node-insertion (randomly move a node to another position)\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure validity (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 74,
        "algorithm": "{A novel heuristic selects a solution from the archive by prioritizing those with high variance in objectives, then applies a hybrid local search combining edge exchange and segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([abs(obj[0] - obj[1]) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange and segment inversion\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Edge exchange (swap edges)\n    if j - i > 1:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment inversion (reverse a segment)\n    if j - i > 2:\n        k, l = np.random.choice(range(i+1, j), 2, replace=False)\n        k, l = min(k, l), max(k, l)\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.3579791768104803,
            1.7928019165992737
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([abs(obj[0] - obj[1]) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange and segment inversion\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Edge exchange (swap edges)\n    if j - i > 1:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment inversion (reverse a segment)\n    if j - i > 2:\n        k, l = np.random.choice(range(i+1, j), 2, replace=False)\n        k, l = min(k, l), max(k, l)\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 75,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by prioritizing those with lower objective values, then applies a hybrid local search combining segment inversion and edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lower objective values)\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_idx = min(3, len(archive) - 1)  # Select from top 3 or all if archive is small\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion + edge swap\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Edge swap if it improves at least one objective\n    for _ in range(3):  # Try a few random edge swaps\n        k, l = sorted(random.sample(range(n), 2))\n        if k == l:\n            continue\n\n        # Calculate current and new edge costs\n        current_edges = [(new_solution[k-1], new_solution[k]), (new_solution[l-1], new_solution[l])]\n        new_edges = [(new_solution[k-1], new_solution[l]), (new_solution[l-1], new_solution[k])]\n\n        current_cost1 = sum(distance_matrix_1[a, b] for a, b in current_edges)\n        new_cost1 = sum(distance_matrix_1[a, b] for a, b in new_edges)\n        current_cost2 = sum(distance_matrix_2[a, b] for a, b in current_edges)\n        new_cost2 = sum(distance_matrix_2[a, b] for a, b in new_edges)\n\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.6658376176517817,
            1.129931926727295
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lower objective values)\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_idx = min(3, len(archive) - 1)  # Select from top 3 or all if archive is small\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion + edge swap\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Edge swap if it improves at least one objective\n    for _ in range(3):  # Try a few random edge swaps\n        k, l = sorted(random.sample(range(n), 2))\n        if k == l:\n            continue\n\n        # Calculate current and new edge costs\n        current_edges = [(new_solution[k-1], new_solution[k]), (new_solution[l-1], new_solution[l])]\n        new_edges = [(new_solution[k-1], new_solution[l]), (new_solution[l-1], new_solution[k])]\n\n        current_cost1 = sum(distance_matrix_1[a, b] for a, b in current_edges)\n        new_cost1 = sum(distance_matrix_1[a, b] for a, b in new_edges)\n        current_cost2 = sum(distance_matrix_2[a, b] for a, b in current_edges)\n        new_cost2 = sum(distance_matrix_2[a, b] for a, b in new_edges)\n\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 76,
        "algorithm": "{This algorithm selects a promising solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines edge swaps and node relocations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high cost)\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))  # Sort by descending total cost\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: combine edge swaps and node relocations\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j]\n\n    # Apply edge swap or node relocation based on random choice\n    if np.random.rand() < 0.5:\n        # Edge swap\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n    else:\n        # Node relocation\n        k = np.random.randint(0, n)\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Ensure the solution remains feasible (no duplicates)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by restoring missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for missing in missing_nodes:\n            pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, pos, missing)\n            new_solution = new_solution[:n]  # Ensure no duplicates\n\n    return new_solution\n\n",
        "score": [
            -0.8955761096005344,
            0.9269310832023621
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high cost)\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))  # Sort by descending total cost\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: combine edge swaps and node relocations\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j]\n\n    # Apply edge swap or node relocation based on random choice\n    if np.random.rand() < 0.5:\n        # Edge swap\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n    else:\n        # Node relocation\n        k = np.random.randint(0, n)\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Ensure the solution remains feasible (no duplicates)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by restoring missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for missing in missing_nodes:\n            pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, pos, missing)\n            new_solution = new_solution[:n]  # Ensure no duplicates\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 77,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest total cost (sum of both objectives) as the base\n    base_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Generate a neighbor using a hybrid local search: a combination of segment reversal and node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select a node to insert elsewhere\n    if n > 2:\n        node = np.random.choice(new_solution)\n        mask = new_solution != node\n        remaining_nodes = new_solution[mask]\n        pos = np.random.randint(0, n-1)\n        new_solution = np.insert(remaining_nodes, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9301034362099903,
            2.0065890550613403
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest total cost (sum of both objectives) as the base\n    base_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Generate a neighbor using a hybrid local search: a combination of segment reversal and node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select a node to insert elsewhere\n    if n > 2:\n        node = np.random.choice(new_solution)\n        mask = new_solution != node\n        remaining_nodes = new_solution[mask]\n        pos = np.random.randint(0, n-1)\n        new_solution = np.insert(remaining_nodes, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 78,
        "algorithm": "{A novel hybrid local search operator combines a randomized edge-swap strategy with a Pareto-dominance-aware segment reversal to explore diverse neighborhoods while prioritizing solutions with high potential for multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by a combination of objective values (normalized for comparison)\n        objectives = np.array([obj for _, obj in archive])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        scores = normalized[:, 0] * 0.6 + normalized[:, 1] * 0.4  # Weighted sum\n        probabilities = np.exp(-scores)  # Higher scores get lower probabilities (higher potential)\n        probabilities /= probabilities.sum()\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomized edge swap (with distance-aware selection)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Check if swap improves both objectives (Pareto-dominance aware)\n    def get_cost(sol, dist_mat):\n        cost = 0\n        for k in range(len(sol)):\n            cost += dist_mat[sol[k-1], sol[k]]\n        return cost\n\n    current_cost1 = get_cost(new_solution, distance_matrix_1)\n    current_cost2 = get_cost(new_solution, distance_matrix_2)\n\n    # Create a candidate solution with the swap\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]\n\n    candidate_cost1 = get_cost(candidate, distance_matrix_1)\n    candidate_cost2 = get_cost(candidate, distance_matrix_2)\n\n    # Accept if Pareto-dominant or if both costs are better\n    if (candidate_cost1 <= current_cost1 and candidate_cost2 <= current_cost2) and \\\n       (candidate_cost1 < current_cost1 or candidate_cost2 < current_cost2):\n        new_solution = candidate\n    else:\n        # Step 2: If swap doesn't help, perform a segment reversal\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        candidate = new_solution.copy()\n        candidate[a:b+1] = reversed_segment\n\n        candidate_cost1 = get_cost(candidate, distance_matrix_1)\n        candidate_cost2 = get_cost(candidate, distance_matrix_2)\n\n        if (candidate_cost1 <= current_cost1 and candidate_cost2 <= current_cost2) and \\\n           (candidate_cost1 < current_cost1 or candidate_cost2 < current_cost2):\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.5791302766985392,
            3.878117024898529
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by a combination of objective values (normalized for comparison)\n        objectives = np.array([obj for _, obj in archive])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        scores = normalized[:, 0] * 0.6 + normalized[:, 1] * 0.4  # Weighted sum\n        probabilities = np.exp(-scores)  # Higher scores get lower probabilities (higher potential)\n        probabilities /= probabilities.sum()\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomized edge swap (with distance-aware selection)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Check if swap improves both objectives (Pareto-dominance aware)\n    def get_cost(sol, dist_mat):\n        cost = 0\n        for k in range(len(sol)):\n            cost += dist_mat[sol[k-1], sol[k]]\n        return cost\n\n    current_cost1 = get_cost(new_solution, distance_matrix_1)\n    current_cost2 = get_cost(new_solution, distance_matrix_2)\n\n    # Create a candidate solution with the swap\n    candidate = new_solution.copy()\n    candidate[i], candidate[j] = candidate[j], candidate[i]\n\n    candidate_cost1 = get_cost(candidate, distance_matrix_1)\n    candidate_cost2 = get_cost(candidate, distance_matrix_2)\n\n    # Accept if Pareto-dominant or if both costs are better\n    if (candidate_cost1 <= current_cost1 and candidate_cost2 <= current_cost2) and \\\n       (candidate_cost1 < current_cost1 or candidate_cost2 < current_cost2):\n        new_solution = candidate\n    else:\n        # Step 2: If swap doesn't help, perform a segment reversal\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        candidate = new_solution.copy()\n        candidate[a:b+1] = reversed_segment\n\n        candidate_cost1 = get_cost(candidate, distance_matrix_1)\n        candidate_cost2 = get_cost(candidate, distance_matrix_2)\n\n        if (candidate_cost1 <= current_cost1 and candidate_cost2 <= current_cost2) and \\\n           (candidate_cost1 < current_cost1 or candidate_cost2 < current_cost2):\n            new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 79,
        "algorithm": "{This heuristic selects a solution from the archive with high potential for improvement by evaluating both objectives, then applies a hybrid local search combining edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly insert a node elsewhere\n    if n > 2:\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        l = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If not feasible, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6563148979484084,
            1.9990858435630798
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly insert a node elsewhere\n    if n > 2:\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        l = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If not feasible, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 80,
        "algorithm": "{A novel hybrid local search operator combines a randomized segment reversal with a multi-objective edge exchange heuristic, prioritizing solutions with Pareto-efficient fronts and leveraging both distance matrices to guide exploration of trade-offs between objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not on Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: randomized segment reversal + multi-objective edge exchange\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Random segment reversal\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective edge exchange\n    for _ in range(min(3, n // 2)):  # Limit iterations for efficiency\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k == l:\n            continue\n\n        # Evaluate potential exchange in both objectives\n        current_cost = (distance_matrix_1[base_solution[k-1], base_solution[k]] + distance_matrix_1[base_solution[l-1], base_solution[l]],\n                        distance_matrix_2[base_solution[k-1], base_solution[k]] + distance_matrix_2[base_solution[l-1], base_solution[l]])\n        new_cost = (distance_matrix_1[base_solution[k-1], base_solution[l]] + distance_matrix_1[base_solution[l-1], base_solution[k]],\n                    distance_matrix_2[base_solution[k-1], base_solution[l]] + distance_matrix_2[base_solution[l-1], base_solution[k]])\n\n        # Accept if at least one objective improves\n        if new_cost[0] < current_cost[0] or new_cost[1] < current_cost[1]:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7886411366577999,
            2.1263644099235535
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not on Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: randomized segment reversal + multi-objective edge exchange\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Random segment reversal\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective edge exchange\n    for _ in range(min(3, n // 2)):  # Limit iterations for efficiency\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k == l:\n            continue\n\n        # Evaluate potential exchange in both objectives\n        current_cost = (distance_matrix_1[base_solution[k-1], base_solution[k]] + distance_matrix_1[base_solution[l-1], base_solution[l]],\n                        distance_matrix_2[base_solution[k-1], base_solution[k]] + distance_matrix_2[base_solution[l-1], base_solution[l]])\n        new_cost = (distance_matrix_1[base_solution[k-1], base_solution[l]] + distance_matrix_1[base_solution[l-1], base_solution[k]],\n                    distance_matrix_2[base_solution[k-1], base_solution[l]] + distance_matrix_2[base_solution[l-1], base_solution[k]])\n\n        # Accept if at least one objective improves\n        if new_cost[0] < current_cost[0] or new_cost[1] < current_cost[1]:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 81,
        "algorithm": "{This algorithm selects a promising solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining edge insertion with a novel adaptive perturbation strategy to generate a high-quality neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive cannot be empty\")\n\n    # Select a promising solution based on weighted sum of objectives\n    weights = np.random.dirichlet(np.ones(2))\n    weighted_scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: adaptive edge insertion with perturbation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine perturbation range based on solution quality\n    perturbation_range = max(1, int(0.1 * n * (1 - np.random.rand())))\n\n    # Randomly select a segment to perturb\n    start = np.random.randint(0, n - perturbation_range)\n    segment = new_solution[start:start + perturbation_range]\n\n    # Apply adaptive edge insertion\n    for i in range(len(segment)):\n        node = segment[i]\n        # Find best insertion position considering both objectives\n        best_pos = -1\n        best_cost = float('inf')\n\n        for pos in range(n):\n            if pos >= start and pos < start + perturbation_range:\n                continue  # Skip the current segment\n\n            # Calculate cost for insertion at position 'pos'\n            if pos == 0:\n                cost1 = distance_matrix_1[new_solution[-1], node] + distance_matrix_1[node, new_solution[pos]] - distance_matrix_1[new_solution[-1], new_solution[pos]]\n                cost2 = distance_matrix_2[new_solution[-1], node] + distance_matrix_2[node, new_solution[pos]] - distance_matrix_2[new_solution[-1], new_solution[pos]]\n            elif pos == n:\n                cost1 = distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[0]] - distance_matrix_1[new_solution[pos-1], new_solution[0]]\n                cost2 = distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[0]] - distance_matrix_2[new_solution[pos-1], new_solution[0]]\n            else:\n                cost1 = distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]] - distance_matrix_1[new_solution[pos-1], new_solution[pos]]\n                cost2 = distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]] - distance_matrix_2[new_solution[pos-1], new_solution[pos]]\n\n            total_cost = weights[0] * cost1 + weights[1] * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        # Insert the node at the best position\n        if best_pos != -1:\n            new_solution = np.insert(new_solution, best_pos, node)\n            if best_pos <= start:\n                start += 1  # Adjust start position if we inserted before it\n\n    # Ensure the solution remains a valid tour\n    new_solution = np.unique(new_solution, return_index=True)[1]\n    new_solution.sort()\n    new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.9570099156180736,
            1.6207062005996704
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive cannot be empty\")\n\n    # Select a promising solution based on weighted sum of objectives\n    weights = np.random.dirichlet(np.ones(2))\n    weighted_scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: adaptive edge insertion with perturbation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine perturbation range based on solution quality\n    perturbation_range = max(1, int(0.1 * n * (1 - np.random.rand())))\n\n    # Randomly select a segment to perturb\n    start = np.random.randint(0, n - perturbation_range)\n    segment = new_solution[start:start + perturbation_range]\n\n    # Apply adaptive edge insertion\n    for i in range(len(segment)):\n        node = segment[i]\n        # Find best insertion position considering both objectives\n        best_pos = -1\n        best_cost = float('inf')\n\n        for pos in range(n):\n            if pos >= start and pos < start + perturbation_range:\n                continue  # Skip the current segment\n\n            # Calculate cost for insertion at position 'pos'\n            if pos == 0:\n                cost1 = distance_matrix_1[new_solution[-1], node] + distance_matrix_1[node, new_solution[pos]] - distance_matrix_1[new_solution[-1], new_solution[pos]]\n                cost2 = distance_matrix_2[new_solution[-1], node] + distance_matrix_2[node, new_solution[pos]] - distance_matrix_2[new_solution[-1], new_solution[pos]]\n            elif pos == n:\n                cost1 = distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[0]] - distance_matrix_1[new_solution[pos-1], new_solution[0]]\n                cost2 = distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[0]] - distance_matrix_2[new_solution[pos-1], new_solution[0]]\n            else:\n                cost1 = distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]] - distance_matrix_1[new_solution[pos-1], new_solution[pos]]\n                cost2 = distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]] - distance_matrix_2[new_solution[pos-1], new_solution[pos]]\n\n            total_cost = weights[0] * cost1 + weights[1] * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        # Insert the node at the best position\n        if best_pos != -1:\n            new_solution = np.insert(new_solution, best_pos, node)\n            if best_pos <= start:\n                start += 1  # Adjust start position if we inserted before it\n\n    # Ensure the solution remains a valid tour\n    new_solution = np.unique(new_solution, return_index=True)[1]\n    new_solution.sort()\n    new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 82,
        "algorithm": "{A novel hybrid local search operator combines a multi-segment inversion strategy with a dynamic edge swapping mechanism, prioritizing high-potential regions in the archive and adaptively balancing improvements across both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: np.std(x[1]))\n\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search: Multi-segment inversion with dynamic edge swapping\n    if random.random() < 0.7:  # 70% chance for multi-segment inversion\n        # Randomly select 2-4 segments and invert them\n        num_segments = random.randint(2, 4)\n        segment_indices = sorted(random.sample(range(1, n), num_segments - 1))\n        segments = [base_solution[i:j] for i, j in zip([0] + segment_indices, segment_indices + [n])]\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n    else:  # Dynamic edge swapping\n        # Identify edges with high potential for improvement in both objectives\n        edge_costs = []\n        for i in range(n):\n            j = (i + 1) % n\n            cost1 = distance_matrix_1[base_solution[i], base_solution[j]]\n            cost2 = distance_matrix_2[base_solution[i], base_solution[j]]\n            edge_costs.append((cost1 + cost2, i))\n\n        # Select top 20% of edges with highest combined cost\n        top_edges = sorted(edge_costs, key=lambda x: -x[0])[:max(1, int(0.2 * n))]\n        if top_edges:\n            # Swap a random pair of nodes from the top edges\n            idx1, idx2 = random.sample([x[1] for x in top_edges], 2)\n            new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n:\n        # Fallback to simple 2-opt if hybrid operator fails\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = np.concatenate((base_solution[:i], base_solution[i:j+1][::-1], base_solution[j+1:]))\n\n    return new_solution\n\n",
        "score": [
            -0.4024446238121046,
            3.808393657207489
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: np.std(x[1]))\n\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search: Multi-segment inversion with dynamic edge swapping\n    if random.random() < 0.7:  # 70% chance for multi-segment inversion\n        # Randomly select 2-4 segments and invert them\n        num_segments = random.randint(2, 4)\n        segment_indices = sorted(random.sample(range(1, n), num_segments - 1))\n        segments = [base_solution[i:j] for i, j in zip([0] + segment_indices, segment_indices + [n])]\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n    else:  # Dynamic edge swapping\n        # Identify edges with high potential for improvement in both objectives\n        edge_costs = []\n        for i in range(n):\n            j = (i + 1) % n\n            cost1 = distance_matrix_1[base_solution[i], base_solution[j]]\n            cost2 = distance_matrix_2[base_solution[i], base_solution[j]]\n            edge_costs.append((cost1 + cost2, i))\n\n        # Select top 20% of edges with highest combined cost\n        top_edges = sorted(edge_costs, key=lambda x: -x[0])[:max(1, int(0.2 * n))]\n        if top_edges:\n            # Swap a random pair of nodes from the top edges\n            idx1, idx2 = random.sample([x[1] for x in top_edges], 2)\n            new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n:\n        # Fallback to simple 2-opt if hybrid operator fails\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = np.concatenate((base_solution[:i], base_solution[i:j+1][::-1], base_solution[j+1:]))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 83,
        "algorithm": "{This heuristic selects a solution from the archive with high potential for improvement by prioritizing those with low objective values and applies a novel hybrid local search operator that combines edge exchange and node reinsertion to explore the solution space creatively while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search operator: Edge exchange + Node reinsertion\n    new_solution = selected_solution.copy()\n\n    # Edge exchange: Swap two non-adjacent edges\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Ensure edges are not adjacent\n    if j - i > 1:\n        new_solution[i+1:j] = np.flip(new_solution[i+1:j])\n\n    # Node reinsertion: Remove a node and reinsert it elsewhere\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n\n    pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.703784965529004,
            2.3312134742736816
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search operator: Edge exchange + Node reinsertion\n    new_solution = selected_solution.copy()\n\n    # Edge exchange: Swap two non-adjacent edges\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Ensure edges are not adjacent\n    if j - i > 1:\n        new_solution[i+1:j] = np.flip(new_solution[i+1:j])\n\n    # Node reinsertion: Remove a node and reinsert it elsewhere\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n\n    pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 84,
        "algorithm": "{This heuristic selects a solution from the archive with a high objective value variance, indicating potential for improvement, and applies a hybrid local search combining edge swaps and node insertions to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    variances = [(i, (obj[0] - obj[1])**2) for i, (sol, obj) in enumerate(archive)]\n    selected_idx = max(variances, key=lambda x: x[1])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps and node insertions\n    n = len(base_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Randomly select two distinct edges to swap\n        a, b = np.random.choice(n, size=2, replace=False)\n        i, j = min(a, b), max(a, b)\n\n        # Edge swap\n        temp = new_solution[i:j+1]\n        new_solution[i:j+1] = temp[::-1]\n\n        # Randomly select a node to reinsert\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n\n        # Ensure feasibility (no duplicates or missing nodes)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.4023168496959438,
            2.465157449245453
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    variances = [(i, (obj[0] - obj[1])**2) for i, (sol, obj) in enumerate(archive)]\n    selected_idx = max(variances, key=lambda x: x[1])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps and node insertions\n    n = len(base_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Randomly select two distinct edges to swap\n        a, b = np.random.choice(n, size=2, replace=False)\n        i, j = min(a, b), max(a, b)\n\n        # Edge swap\n        temp = new_solution[i:j+1]\n        new_solution[i:j+1] = temp[::-1]\n\n        # Randomly select a node to reinsert\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n\n        # Ensure feasibility (no duplicates or missing nodes)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 85,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on a combination of objective diversity and local search potential, then applies a hybrid local search operator that combines edge insertion with a novel adaptive 3-opt variant to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by objective diversity (sum of normalized objectives)\n        objectives = np.array([obj for _, obj in archive])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        diversity = normalized.sum(axis=1)\n        selected_idx = np.argmax(diversity)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Adaptive 3-opt with edge insertion\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment = new_solution[a:b+1]\n\n    # Try different configurations\n    configs = [\n        np.concatenate([new_solution[:a], segment[::-1], new_solution[b+1:]]),  # Reverse segment\n        np.concatenate([new_solution[:a], segment, new_solution[b+1:c+1], segment[::-1], new_solution[c+1:]]),  # 3-opt\n        np.concatenate([new_solution[:a], new_solution[b+1:c+1], new_solution[a:b+1], new_solution[c+1:]])  # Rotate segments\n    ]\n\n    # Evaluate all configurations\n    best_config = None\n    best_score = float('inf')\n\n    for config in configs:\n        # Calculate total distance for both objectives\n        dist1 = sum(distance_matrix_1[config[i], config[i+1]] for i in range(n-1))\n        dist1 += distance_matrix_1[config[-1], config[0]]  # Return to start\n\n        dist2 = sum(distance_matrix_2[config[i], config[i+1]] for i in range(n-1))\n        dist2 += distance_matrix_2[config[-1], config[0]]  # Return to start\n\n        score = dist1 + dist2  # Simple aggregation (could use Pareto dominance)\n\n        if score < best_score:\n            best_score = score\n            best_config = config.copy()\n\n    if best_config is not None:\n        new_solution = best_config\n\n    # Additional edge insertion\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:\n        # Remove a random edge and insert it elsewhere\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.869977514286147,
            2.126450002193451
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by objective diversity (sum of normalized objectives)\n        objectives = np.array([obj for _, obj in archive])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        diversity = normalized.sum(axis=1)\n        selected_idx = np.argmax(diversity)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Adaptive 3-opt with edge insertion\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment = new_solution[a:b+1]\n\n    # Try different configurations\n    configs = [\n        np.concatenate([new_solution[:a], segment[::-1], new_solution[b+1:]]),  # Reverse segment\n        np.concatenate([new_solution[:a], segment, new_solution[b+1:c+1], segment[::-1], new_solution[c+1:]]),  # 3-opt\n        np.concatenate([new_solution[:a], new_solution[b+1:c+1], new_solution[a:b+1], new_solution[c+1:]])  # Rotate segments\n    ]\n\n    # Evaluate all configurations\n    best_config = None\n    best_score = float('inf')\n\n    for config in configs:\n        # Calculate total distance for both objectives\n        dist1 = sum(distance_matrix_1[config[i], config[i+1]] for i in range(n-1))\n        dist1 += distance_matrix_1[config[-1], config[0]]  # Return to start\n\n        dist2 = sum(distance_matrix_2[config[i], config[i+1]] for i in range(n-1))\n        dist2 += distance_matrix_2[config[-1], config[0]]  # Return to start\n\n        score = dist1 + dist2  # Simple aggregation (could use Pareto dominance)\n\n        if score < best_score:\n            best_score = score\n            best_config = config.copy()\n\n    if best_config is not None:\n        new_solution = best_config\n\n    # Additional edge insertion\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:\n        # Remove a random edge and insert it elsewhere\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 86,
        "algorithm": "{The heuristic function selects a promising solution from the archive using a combination of dominance and crowding distance metrics, then applies a novel hybrid local search operator that combines node insertion with a biased random walk to explore high-quality neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution using dominance and crowding distance\n    def compute_crowding_distance(solutions, objectives):\n        n = len(solutions)\n        crowding = [0] * n\n        for m in range(2):\n            sorted_idx = np.argsort([obj[m] for obj in objectives])\n            crowding[sorted_idx[0]] = float('inf')\n            crowding[sorted_idx[-1]] = float('inf')\n            min_obj, max_obj = objectives[sorted_idx[0]][m], objectives[sorted_idx[-1]][m]\n            if min_obj == max_obj:\n                continue\n            for i in range(1, n-1):\n                crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1]][m] - objectives[sorted_idx[i-1]][m]) / (max_obj - min_obj)\n        return crowding\n\n    solutions, objectives = zip(*archive)\n    crowding = compute_crowding_distance(solutions, objectives)\n    # Select solutions with high crowding distance (diverse) and non-dominated\n    candidates = []\n    for i, solution in enumerate(solutions):\n        dominated = False\n        for j, obj_j in enumerate(objectives):\n            if i != j and obj_j[0] <= objectives[i][0] and obj_j[1] <= objectives[i][1] and (obj_j[0] < objectives[i][0] or obj_j[1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            candidates.append((crowding[i], solution))\n    if not candidates:\n        candidates = list(zip(crowding, solutions))\n    candidates.sort(reverse=True, key=lambda x: x[0])\n    selected_solution = candidates[0][1].copy()\n\n    # Hybrid local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Biased random walk to explore high-quality neighborhoods\n    for _ in range(2):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            # Compute cost change for both objectives\n            delta1 = (distance_matrix_1[new_solution[(i-1)%n], new_solution[j]] +\n                     distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                    (distance_matrix_1[new_solution[(i-1)%n], new_solution[i]] +\n                     distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n            delta2 = (distance_matrix_2[new_solution[(i-1)%n], new_solution[j]] +\n                     distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                    (distance_matrix_2[new_solution[(i-1)%n], new_solution[i]] +\n                     distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n            # Accept with probability based on cost improvement\n            if (delta1 < 0 and delta2 < 0) or random.random() < 0.7:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Node insertion with objective-aware selection\n    for _ in range(3):\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        # Find best insertion position considering both objectives\n        best_pos = i\n        best_score = 0\n        for j in range(n):\n            if j == i or j == (i-1)%n or j == (i+1)%n:\n                continue\n            # Compute cost change for both objectives\n            delta1 = (distance_matrix_1[new_solution[(j-1)%n], node] +\n                     distance_matrix_1[node, new_solution[j]]) - \\\n                    (distance_matrix_1[new_solution[(i-1)%n], new_solution[i]] +\n                     distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n            delta2 = (distance_matrix_2[new_solution[(j-1)%n], node] +\n                     distance_matrix_2[node, new_solution[j]]) - \\\n                    (distance_matrix_2[new_solution[(i-1)%n], new_solution[i]] +\n                     distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n            # Score combines both objectives with random bias\n            score = - (delta1 + delta2) + random.uniform(-0.1, 0.1)\n            if score > best_score:\n                best_score = score\n                best_pos = j\n        if best_pos != i:\n            # Perform insertion\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            if best_pos > i:\n                best_pos -= 1\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8580904546647609,
            3.6758488416671753
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution using dominance and crowding distance\n    def compute_crowding_distance(solutions, objectives):\n        n = len(solutions)\n        crowding = [0] * n\n        for m in range(2):\n            sorted_idx = np.argsort([obj[m] for obj in objectives])\n            crowding[sorted_idx[0]] = float('inf')\n            crowding[sorted_idx[-1]] = float('inf')\n            min_obj, max_obj = objectives[sorted_idx[0]][m], objectives[sorted_idx[-1]][m]\n            if min_obj == max_obj:\n                continue\n            for i in range(1, n-1):\n                crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1]][m] - objectives[sorted_idx[i-1]][m]) / (max_obj - min_obj)\n        return crowding\n\n    solutions, objectives = zip(*archive)\n    crowding = compute_crowding_distance(solutions, objectives)\n    # Select solutions with high crowding distance (diverse) and non-dominated\n    candidates = []\n    for i, solution in enumerate(solutions):\n        dominated = False\n        for j, obj_j in enumerate(objectives):\n            if i != j and obj_j[0] <= objectives[i][0] and obj_j[1] <= objectives[i][1] and (obj_j[0] < objectives[i][0] or obj_j[1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            candidates.append((crowding[i], solution))\n    if not candidates:\n        candidates = list(zip(crowding, solutions))\n    candidates.sort(reverse=True, key=lambda x: x[0])\n    selected_solution = candidates[0][1].copy()\n\n    # Hybrid local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Biased random walk to explore high-quality neighborhoods\n    for _ in range(2):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            # Compute cost change for both objectives\n            delta1 = (distance_matrix_1[new_solution[(i-1)%n], new_solution[j]] +\n                     distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                    (distance_matrix_1[new_solution[(i-1)%n], new_solution[i]] +\n                     distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n            delta2 = (distance_matrix_2[new_solution[(i-1)%n], new_solution[j]] +\n                     distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                    (distance_matrix_2[new_solution[(i-1)%n], new_solution[i]] +\n                     distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n            # Accept with probability based on cost improvement\n            if (delta1 < 0 and delta2 < 0) or random.random() < 0.7:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Node insertion with objective-aware selection\n    for _ in range(3):\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        # Find best insertion position considering both objectives\n        best_pos = i\n        best_score = 0\n        for j in range(n):\n            if j == i or j == (i-1)%n or j == (i+1)%n:\n                continue\n            # Compute cost change for both objectives\n            delta1 = (distance_matrix_1[new_solution[(j-1)%n], node] +\n                     distance_matrix_1[node, new_solution[j]]) - \\\n                    (distance_matrix_1[new_solution[(i-1)%n], new_solution[i]] +\n                     distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n            delta2 = (distance_matrix_2[new_solution[(j-1)%n], node] +\n                     distance_matrix_2[node, new_solution[j]]) - \\\n                    (distance_matrix_2[new_solution[(i-1)%n], new_solution[i]] +\n                     distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n            # Score combines both objectives with random bias\n            score = - (delta1 + delta2) + random.uniform(-0.1, 0.1)\n            if score > best_score:\n                best_score = score\n                best_pos = j\n        if best_pos != i:\n            # Perform insertion\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            if best_pos > i:\n                best_pos -= 1\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 87,
        "algorithm": "{The algorithm selects a solution from the archive based on a combined objective score, then applies a hybrid local search operator that combines edge swaps and node reinsertions to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its combined objective score\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    min_obj = np.min(objectives)\n    max_obj = np.max(objectives)\n    if max_obj == min_obj:\n        probs = np.ones(len(archive)) / len(archive)\n    else:\n        normalized = (max_obj - objectives) / (max_obj - min_obj)\n        probs = normalized / np.sum(normalized)\n\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        # For small instances, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between edge swap or node reinsertion\n        if random.random() < 0.5:\n            # Edge swap (like 2-opt but with more flexibility)\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Node reinsertion with improved position selection\n            i = random.randint(0, n-1)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            # Find best insertion position based on both objectives\n            best_pos = 0\n            best_score = float('inf')\n            for pos in range(len(new_solution)):\n                temp_solution = np.insert(new_solution, pos, node)\n                # Calculate cost in both spaces\n                cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(len(temp_solution)))\n                cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(len(temp_solution)))\n                score = cost1 + cost2\n                if score < best_score:\n                    best_score = score\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7581332346217302,
            7.475386738777161
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its combined objective score\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    min_obj = np.min(objectives)\n    max_obj = np.max(objectives)\n    if max_obj == min_obj:\n        probs = np.ones(len(archive)) / len(archive)\n    else:\n        normalized = (max_obj - objectives) / (max_obj - min_obj)\n        probs = normalized / np.sum(normalized)\n\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        # For small instances, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose between edge swap or node reinsertion\n        if random.random() < 0.5:\n            # Edge swap (like 2-opt but with more flexibility)\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Node reinsertion with improved position selection\n            i = random.randint(0, n-1)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            # Find best insertion position based on both objectives\n            best_pos = 0\n            best_score = float('inf')\n            for pos in range(len(new_solution)):\n                temp_solution = np.insert(new_solution, pos, node)\n                # Calculate cost in both spaces\n                cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(len(temp_solution)))\n                cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(len(temp_solution)))\n                score = cost1 + cost2\n                if score < best_score:\n                    best_score = score\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 88,
        "algorithm": "{The heuristic selects a solution from the archive with the highest sum of normalized objective values, then applies a hybrid local search operator that combines 3-opt and a novel segment reordering strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 2, min(start + 10, n - 1))\n\n    # Extract the segment\n    segment = new_solution[start:end+1]\n\n    # Apply 3-opt within the segment\n    if len(segment) >= 3:\n        i, j, k = random.sample(range(len(segment)), 3)\n        i, j, k = sorted([i, j, k])\n        segment[i:j+1] = segment[i:j+1][::-1]\n        segment[j:k+1] = segment[j:k+1][::-1]\n\n    # Reinsert the modified segment\n    new_solution[start:end+1] = segment\n\n    # Apply segment reordering (novel operator)\n    if random.random() < 0.5:\n        # Split into two segments and swap them\n        split = random.randint(1, n - 2)\n        new_solution = np.concatenate([new_solution[split:], new_solution[:split]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9447057595511678,
            1.8598763346672058
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 2, min(start + 10, n - 1))\n\n    # Extract the segment\n    segment = new_solution[start:end+1]\n\n    # Apply 3-opt within the segment\n    if len(segment) >= 3:\n        i, j, k = random.sample(range(len(segment)), 3)\n        i, j, k = sorted([i, j, k])\n        segment[i:j+1] = segment[i:j+1][::-1]\n        segment[j:k+1] = segment[j:k+1][::-1]\n\n    # Reinsert the modified segment\n    new_solution[start:end+1] = segment\n\n    # Apply segment reordering (novel operator)\n    if random.random() < 0.5:\n        # Split into two segments and swap them\n        split = random.randint(1, n - 2)\n        new_solution = np.concatenate([new_solution[split:], new_solution[:split]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 89,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objective values (lower is better)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution near the middle to balance exploration and exploitation\n        selected_idx = min(len(archive_sorted) // 2, len(archive_sorted) - 1)\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply the operator\n\n    # Randomly select a segment to reverse\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 5, n - 1))  # Limit segment size for efficiency\n    segment = new_solution[start:end+1]\n    reversed_segment = segment[::-1]\n\n    # Calculate the cost of the current and reversed segment\n    def segment_cost(seg):\n        cost1 = sum(distance_matrix_1[seg[i], seg[i+1]] for i in range(len(seg)-1))\n        cost2 = sum(distance_matrix_2[seg[i], seg[i+1]] for i in range(len(seg)-1))\n        return cost1 + cost2\n\n    current_cost = segment_cost(segment)\n    reversed_cost = segment_cost(reversed_segment)\n\n    # If reversing improves the solution, apply it\n    if reversed_cost < current_cost:\n        new_solution[start:end+1] = reversed_segment\n\n    # Edge insertion: try to insert a random edge from the solution into a new position\n    if n > 4:\n        # Select a random edge (i, i+1)\n        i = random.randint(0, n - 2)\n        edge_a, edge_b = new_solution[i], new_solution[i+1]\n\n        # Remove the edge from the solution\n        temp_solution = np.concatenate((new_solution[:i], new_solution[i+2:]))\n\n        # Find the best position to insert the edge back\n        best_pos = -1\n        best_cost = float('inf')\n\n        for pos in range(len(temp_solution)):\n            # Try inserting edge_a -> edge_b at position pos\n            candidate = np.insert(temp_solution, pos, [edge_a, edge_b])\n            cost1 = sum(distance_matrix_1[candidate[j], candidate[j+1]] for j in range(len(candidate)-1))\n            cost2 = sum(distance_matrix_2[candidate[j], candidate[j+1]] for j in range(len(candidate)-1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.insert(temp_solution, best_pos, [edge_a, edge_b])\n\n    return new_solution\n\n",
        "score": [
            -0.8828160362220834,
            12.535006046295166
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objective values (lower is better)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution near the middle to balance exploration and exploitation\n        selected_idx = min(len(archive_sorted) // 2, len(archive_sorted) - 1)\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply the operator\n\n    # Randomly select a segment to reverse\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 5, n - 1))  # Limit segment size for efficiency\n    segment = new_solution[start:end+1]\n    reversed_segment = segment[::-1]\n\n    # Calculate the cost of the current and reversed segment\n    def segment_cost(seg):\n        cost1 = sum(distance_matrix_1[seg[i], seg[i+1]] for i in range(len(seg)-1))\n        cost2 = sum(distance_matrix_2[seg[i], seg[i+1]] for i in range(len(seg)-1))\n        return cost1 + cost2\n\n    current_cost = segment_cost(segment)\n    reversed_cost = segment_cost(reversed_segment)\n\n    # If reversing improves the solution, apply it\n    if reversed_cost < current_cost:\n        new_solution[start:end+1] = reversed_segment\n\n    # Edge insertion: try to insert a random edge from the solution into a new position\n    if n > 4:\n        # Select a random edge (i, i+1)\n        i = random.randint(0, n - 2)\n        edge_a, edge_b = new_solution[i], new_solution[i+1]\n\n        # Remove the edge from the solution\n        temp_solution = np.concatenate((new_solution[:i], new_solution[i+2:]))\n\n        # Find the best position to insert the edge back\n        best_pos = -1\n        best_cost = float('inf')\n\n        for pos in range(len(temp_solution)):\n            # Try inserting edge_a -> edge_b at position pos\n            candidate = np.insert(temp_solution, pos, [edge_a, edge_b])\n            cost1 = sum(distance_matrix_1[candidate[j], candidate[j+1]] for j in range(len(candidate)-1))\n            cost2 = sum(distance_matrix_2[candidate[j], candidate[j+1]] for j in range(len(candidate)-1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.insert(temp_solution, best_pos, [edge_a, edge_b])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 90,
        "algorithm": "{The heuristic function selects a solution from the archive based on the highest combined improvement potential in both objectives, then applies a hybrid 2-opt and segment reversal operator to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_solution = random.choice(archive_solutions)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: 2-opt with segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Apply segment reversal if it improves both objectives\n    def calculate_cost(sol, dist_matrix):\n        cost = 0\n        for i in range(len(sol)):\n            cost += dist_matrix[sol[i-1], sol[i]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Try segment reversal\n    temp_solution = new_solution.copy()\n    temp_solution[a:b+1] = temp_solution[a:b+1][::-1]\n    temp_solution[c:d+1] = temp_solution[c:d+1][::-1]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or random.random() < 0.3:\n        new_solution = temp_solution\n\n    # Apply 2-opt if it improves both objectives\n    i, j = sorted(random.sample(range(n), 2))\n    temp_solution = new_solution.copy()\n    temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or random.random() < 0.3:\n        new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8144529551673554,
            2.365090847015381
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_solution = random.choice(archive_solutions)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: 2-opt with segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Apply segment reversal if it improves both objectives\n    def calculate_cost(sol, dist_matrix):\n        cost = 0\n        for i in range(len(sol)):\n            cost += dist_matrix[sol[i-1], sol[i]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Try segment reversal\n    temp_solution = new_solution.copy()\n    temp_solution[a:b+1] = temp_solution[a:b+1][::-1]\n    temp_solution[c:d+1] = temp_solution[c:d+1][::-1]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or random.random() < 0.3:\n        new_solution = temp_solution\n\n    # Apply 2-opt if it improves both objectives\n    i, j = sorted(random.sample(range(n), 2))\n    temp_solution = new_solution.copy()\n    temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or random.random() < 0.3:\n        new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 91,
        "algorithm": "{A novel hybrid local search operator combines a biased random walk with a dynamic edge exchange mechanism, prioritizing edges with high potential for reducing both objectives while preserving feasibility, and intelligently selects solutions from the archive based on their domination and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their domination level (simplified: lower sum of objectives)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% solutions\n        top_solutions = archive_sorted[:max(1, len(archive) // 3)]\n        # Randomly select from top solutions\n        base_solution = random.choice(top_solutions)[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Hybrid local search: combine biased random walk with dynamic edge exchange\n    for _ in range(10):  # Number of perturbation steps\n        # Select a random segment to perturb\n        seg_start = random.randint(0, n_nodes - 3)\n        seg_end = random.randint(seg_start + 1, min(seg_start + 5, n_nodes - 1))\n\n        # Calculate potential improvement for both objectives\n        def calculate_improvement(solution):\n            cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n_nodes-1)) + distance_matrix_1[solution[-1], solution[0]]\n            cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n_nodes-1)) + distance_matrix_2[solution[-1], solution[0]]\n            return (cost1, cost2)\n\n        current_cost = calculate_improvement(new_solution)\n\n        # Try different perturbations\n        candidates = []\n        # Option 1: Reverse segment\n        candidate1 = new_solution.copy()\n        candidate1[seg_start:seg_end+1] = candidate1[seg_start:seg_end+1][::-1]\n        candidates.append((candidate1, calculate_improvement(candidate1)))\n\n        # Option 2: Shift segment\n        candidate2 = new_solution.copy()\n        seg = candidate2[seg_start:seg_end+1]\n        candidate2 = np.concatenate([candidate2[:seg_start], candidate2[seg_end+1:], seg])\n        candidates.append((candidate2, calculate_improvement(candidate2)))\n\n        # Option 3: Swap two random nodes\n        candidate3 = new_solution.copy()\n        i, j = random.sample(range(n_nodes), 2)\n        candidate3[i], candidate3[j] = candidate3[j], candidate3[i]\n        candidates.append((candidate3, calculate_improvement(candidate3)))\n\n        # Select best candidate that improves both objectives\n        best_candidate = None\n        best_improvement = (float('inf'), float('inf'))\n\n        for candidate, (cost1, cost2) in candidates:\n            if (cost1 < current_cost[0] and cost2 < current_cost[1]):\n                if (cost1 + cost2) < (best_improvement[0] + best_improvement[1]):\n                    best_candidate = candidate\n                    best_improvement = (cost1, cost2)\n\n        if best_candidate is not None:\n            new_solution = best_candidate\n        else:\n            # If no improvement, make a random small change\n            i, j = random.sample(range(n_nodes), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7598368575651686,
            10.985661566257477
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their domination level (simplified: lower sum of objectives)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% solutions\n        top_solutions = archive_sorted[:max(1, len(archive) // 3)]\n        # Randomly select from top solutions\n        base_solution = random.choice(top_solutions)[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Hybrid local search: combine biased random walk with dynamic edge exchange\n    for _ in range(10):  # Number of perturbation steps\n        # Select a random segment to perturb\n        seg_start = random.randint(0, n_nodes - 3)\n        seg_end = random.randint(seg_start + 1, min(seg_start + 5, n_nodes - 1))\n\n        # Calculate potential improvement for both objectives\n        def calculate_improvement(solution):\n            cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n_nodes-1)) + distance_matrix_1[solution[-1], solution[0]]\n            cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n_nodes-1)) + distance_matrix_2[solution[-1], solution[0]]\n            return (cost1, cost2)\n\n        current_cost = calculate_improvement(new_solution)\n\n        # Try different perturbations\n        candidates = []\n        # Option 1: Reverse segment\n        candidate1 = new_solution.copy()\n        candidate1[seg_start:seg_end+1] = candidate1[seg_start:seg_end+1][::-1]\n        candidates.append((candidate1, calculate_improvement(candidate1)))\n\n        # Option 2: Shift segment\n        candidate2 = new_solution.copy()\n        seg = candidate2[seg_start:seg_end+1]\n        candidate2 = np.concatenate([candidate2[:seg_start], candidate2[seg_end+1:], seg])\n        candidates.append((candidate2, calculate_improvement(candidate2)))\n\n        # Option 3: Swap two random nodes\n        candidate3 = new_solution.copy()\n        i, j = random.sample(range(n_nodes), 2)\n        candidate3[i], candidate3[j] = candidate3[j], candidate3[i]\n        candidates.append((candidate3, calculate_improvement(candidate3)))\n\n        # Select best candidate that improves both objectives\n        best_candidate = None\n        best_improvement = (float('inf'), float('inf'))\n\n        for candidate, (cost1, cost2) in candidates:\n            if (cost1 < current_cost[0] and cost2 < current_cost[1]):\n                if (cost1 + cost2) < (best_improvement[0] + best_improvement[1]):\n                    best_candidate = candidate\n                    best_improvement = (cost1, cost2)\n\n        if best_candidate is not None:\n            new_solution = best_candidate\n        else:\n            # If no improvement, make a random small change\n            i, j = random.sample(range(n_nodes), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 92,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([(obj[0] + obj[1]) / (1 + np.random.random()) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a novel local search operator: \"Partial Shuffle and Reinsertion\"\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    k = np.random.randint(2, min(5, n // 2))  # Random segment length\n\n    # Select a random segment and shuffle it\n    start = np.random.randint(0, n - k)\n    segment = new_solution[start:start + k]\n    np.random.shuffle(segment)\n    new_solution[start:start + k] = segment\n\n    # Reinsert the shuffled segment elsewhere to maintain feasibility\n    new_pos = np.random.randint(0, n - k)\n    if new_pos != start:\n        # Remove the segment and insert it at the new position\n        remaining = np.delete(new_solution, np.arange(start, start + k))\n        new_solution = np.insert(remaining, new_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            -0.8477788275270453,
            1.7817022204399109
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([(obj[0] + obj[1]) / (1 + np.random.random()) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a novel local search operator: \"Partial Shuffle and Reinsertion\"\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    k = np.random.randint(2, min(5, n // 2))  # Random segment length\n\n    # Select a random segment and shuffle it\n    start = np.random.randint(0, n - k)\n    segment = new_solution[start:start + k]\n    np.random.shuffle(segment)\n    new_solution[start:start + k] = segment\n\n    # Reinsert the shuffled segment elsewhere to maintain feasibility\n    new_pos = np.random.randint(0, n - k)\n    if new_pos != start:\n        # Remove the segment and insert it at the new position\n        remaining = np.delete(new_solution, np.arange(start, start + k))\n        new_solution = np.insert(remaining, new_pos, segment)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 93,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    normalized_obj = [(o1 / max(o1 for _, (o1, _) in archive), o2 / max(o2 for _, (_, o2) in archive)) for o1, o2 in objectives]\n    scores = [o1 + o2 for o1, o2 in normalized_obj]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Randomly select 3 segments and perform a 3-opt-like move\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    i, j, k = sorted(random.sample(range(1, n-1), 3))\n\n    # Create 6 possible configurations and choose the best one\n    candidates = [\n        new_solution.copy(),  # Original\n        np.concatenate([new_solution[:i], new_solution[i:j][::-1], new_solution[j:]]),  # Reverse i-j\n        np.concatenate([new_solution[:j], new_solution[j:k][::-1], new_solution[k:]]),  # Reverse j-k\n        np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j], new_solution[k:]]),  # Swap i-j and j-k\n        np.concatenate([new_solution[:i], new_solution[k:j:-1], new_solution[i:k], new_solution[j:]]),  # Complex reorder\n        np.concatenate([new_solution[:j], new_solution[i:j], new_solution[j:k][::-1], new_solution[k:]]),  # Another complex reorder\n    ]\n\n    # Evaluate all candidates using both objectives and select the best one\n    best_candidate = None\n    best_score = float('inf')\n\n    for candidate in candidates:\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n        score = cost1 + cost2  # Combined score\n\n        if score < best_score:\n            best_score = score\n            best_candidate = candidate.copy()\n\n    return best_candidate\n\n",
        "score": [
            -0.9071104171103288,
            7.076843440532684
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    normalized_obj = [(o1 / max(o1 for _, (o1, _) in archive), o2 / max(o2 for _, (_, o2) in archive)) for o1, o2 in objectives]\n    scores = [o1 + o2 for o1, o2 in normalized_obj]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Randomly select 3 segments and perform a 3-opt-like move\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    i, j, k = sorted(random.sample(range(1, n-1), 3))\n\n    # Create 6 possible configurations and choose the best one\n    candidates = [\n        new_solution.copy(),  # Original\n        np.concatenate([new_solution[:i], new_solution[i:j][::-1], new_solution[j:]]),  # Reverse i-j\n        np.concatenate([new_solution[:j], new_solution[j:k][::-1], new_solution[k:]]),  # Reverse j-k\n        np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j], new_solution[k:]]),  # Swap i-j and j-k\n        np.concatenate([new_solution[:i], new_solution[k:j:-1], new_solution[i:k], new_solution[j:]]),  # Complex reorder\n        np.concatenate([new_solution[:j], new_solution[i:j], new_solution[j:k][::-1], new_solution[k:]]),  # Another complex reorder\n    ]\n\n    # Evaluate all candidates using both objectives and select the best one\n    best_candidate = None\n    best_score = float('inf')\n\n    for candidate in candidates:\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n        score = cost1 + cost2  # Combined score\n\n        if score < best_score:\n            best_score = score\n            best_candidate = candidate.copy()\n\n    return best_candidate\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 94,
        "algorithm": "{A novel hybrid local search algorithm that combines a randomized segment reversal with a multi-objective-aware edge exchange to intelligently explore the solution space while ensuring feasibility, focusing on diverse segments and high-potential edges for improved convergence across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = [sol for sol, _ in archive if len(np.unique(sol)) == len(sol)]\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n    base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: randomized segment reversal with multi-objective edge exchange\n    if random.random() < 0.5:  # Segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n    else:  # Edge exchange\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Verify feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if hybrid fails\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8857165534326575,
            2.70816171169281
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = [sol for sol, _ in archive if len(np.unique(sol)) == len(sol)]\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n    base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: randomized segment reversal with multi-objective edge exchange\n    if random.random() < 0.5:  # Segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n    else:  # Edge exchange\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Verify feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if hybrid fails\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 95,
        "algorithm": "{A novel hybrid local search operator combines a multi-segment inversion strategy with adaptive edge insertion, leveraging both objective-specific distance matrices to intelligently explore the solution space while ensuring feasibility through a two-phase validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = random.choice(archive)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Phase 1: Multi-segment inversion with adaptive segment length\n    segment_length = max(2, min(5, n // 4))\n    start = random.randint(0, n - segment_length - 1)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Phase 2: Adaptive edge insertion based on both objectives\n    for _ in range(2):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        if i != j:\n            # Calculate edge costs in both objectives\n            cost1 = distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]]\n            cost2 = distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]]\n            new_cost1 = distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]]\n            new_cost2 = distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]]\n\n            # Accept if both objectives improve or one improves significantly\n            if (cost1 < new_cost1 and cost2 <= new_cost2) or (cost1 <= new_cost1 and cost2 < new_cost2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8231477165675641,
            1.7200492024421692
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = random.choice(archive)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Phase 1: Multi-segment inversion with adaptive segment length\n    segment_length = max(2, min(5, n // 4))\n    start = random.randint(0, n - segment_length - 1)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Phase 2: Adaptive edge insertion based on both objectives\n    for _ in range(2):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        if i != j:\n            # Calculate edge costs in both objectives\n            cost1 = distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]]\n            cost2 = distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]]\n            new_cost1 = distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]]\n            new_cost2 = distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]]\n\n            # Accept if both objectives improve or one improves significantly\n            if (cost1 < new_cost1 and cost2 <= new_cost2) or (cost1 <= new_cost1 and cost2 < new_cost2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 96,
        "algorithm": "{This algorithm intelligently selects a non-dominated solution from the archive, identifies critical segments with high edge costs in both objectives, and applies a hybrid local search combining edge insertion and segment reversal to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_sol = archive[np.random.randint(len(archive))][0]\n    else:\n        selected_sol = non_dominated[np.random.randint(len(non_dominated))][0]\n\n    base_solution = selected_sol.copy()\n    new_solution = base_solution.copy()\n\n    # Identify critical segments with high edge costs in both objectives\n    n = len(base_solution)\n    total_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    total_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n\n    # Find the most costly edges in both objectives\n    max_cost1 = -1\n    max_cost2 = -1\n    pos1, pos2 = 0, 0\n\n    for i in range(n):\n        cost1 = distance_matrix_1[base_solution[i], base_solution[(i+1)%n]]\n        cost2 = distance_matrix_2[base_solution[i], base_solution[(i+1)%n]]\n        if cost1 > max_cost1:\n            max_cost1 = cost1\n            pos1 = i\n        if cost2 > max_cost2:\n            max_cost2 = cost2\n            pos2 = i\n\n    # Apply hybrid local search: edge insertion for one objective, segment reversal for the other\n    if np.random.rand() < 0.5:\n        # Edge insertion for the first objective\n        if pos1 != (pos1+1)%n:\n            a, b = base_solution[pos1], base_solution[(pos1+1)%n]\n            new_solution = base_solution.copy()\n            # Find the best insertion point for the edge (a, b)\n            best_pos = -1\n            best_cost = float('inf')\n            for i in range(n):\n                if i != pos1 and i != (pos1+1)%n:\n                    cost = distance_matrix_1[base_solution[i], a] + distance_matrix_1[b, base_solution[(i+1)%n]] - distance_matrix_1[base_solution[i], base_solution[(i+1)%n]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n            if best_pos != -1:\n                new_solution = np.concatenate([base_solution[:best_pos+1], [a, b], base_solution[best_pos+1:]])\n                new_solution = np.delete(new_solution, [pos1, (pos1+1)%n])\n    else:\n        # Segment reversal for the second objective\n        if pos2 != (pos2+1)%n:\n            new_solution = base_solution.copy()\n            # Reverse a segment around the most costly edge\n            segment_length = min(3, n//2)  # Limit segment length for efficiency\n            start = (pos2 - segment_length//2) % n\n            end = (start + segment_length) % n\n            if start < end:\n                new_solution[start:end] = new_solution[start:end][::-1]\n            else:\n                new_solution[start:] = new_solution[start:][::-1]\n                new_solution[:end] = new_solution[:end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7879386298434856,
            13.368920981884003
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_sol = archive[np.random.randint(len(archive))][0]\n    else:\n        selected_sol = non_dominated[np.random.randint(len(non_dominated))][0]\n\n    base_solution = selected_sol.copy()\n    new_solution = base_solution.copy()\n\n    # Identify critical segments with high edge costs in both objectives\n    n = len(base_solution)\n    total_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    total_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n\n    # Find the most costly edges in both objectives\n    max_cost1 = -1\n    max_cost2 = -1\n    pos1, pos2 = 0, 0\n\n    for i in range(n):\n        cost1 = distance_matrix_1[base_solution[i], base_solution[(i+1)%n]]\n        cost2 = distance_matrix_2[base_solution[i], base_solution[(i+1)%n]]\n        if cost1 > max_cost1:\n            max_cost1 = cost1\n            pos1 = i\n        if cost2 > max_cost2:\n            max_cost2 = cost2\n            pos2 = i\n\n    # Apply hybrid local search: edge insertion for one objective, segment reversal for the other\n    if np.random.rand() < 0.5:\n        # Edge insertion for the first objective\n        if pos1 != (pos1+1)%n:\n            a, b = base_solution[pos1], base_solution[(pos1+1)%n]\n            new_solution = base_solution.copy()\n            # Find the best insertion point for the edge (a, b)\n            best_pos = -1\n            best_cost = float('inf')\n            for i in range(n):\n                if i != pos1 and i != (pos1+1)%n:\n                    cost = distance_matrix_1[base_solution[i], a] + distance_matrix_1[b, base_solution[(i+1)%n]] - distance_matrix_1[base_solution[i], base_solution[(i+1)%n]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = i\n            if best_pos != -1:\n                new_solution = np.concatenate([base_solution[:best_pos+1], [a, b], base_solution[best_pos+1:]])\n                new_solution = np.delete(new_solution, [pos1, (pos1+1)%n])\n    else:\n        # Segment reversal for the second objective\n        if pos2 != (pos2+1)%n:\n            new_solution = base_solution.copy()\n            # Reverse a segment around the most costly edge\n            segment_length = min(3, n//2)  # Limit segment length for efficiency\n            start = (pos2 - segment_length//2) % n\n            end = (start + segment_length) % n\n            if start < end:\n                new_solution[start:end] = new_solution[start:end][::-1]\n            else:\n                new_solution[start:] = new_solution[start:][::-1]\n                new_solution[:end] = new_solution[:end][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 97,
        "algorithm": "{A novel local search strategy that combines a biased random selection of solutions from the archive, followed by a hybrid edge-swapping and segment-reversal operator to explore high-quality neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by the sum of normalized objectives (prioritize non-dominated)\n    normalized_objectives = [(obj[0] / np.max(distance_matrix_1), obj[1] / np.max(distance_matrix_2)) for _, obj in archive]\n    scores = [sum(norm_obj) for norm_obj in normalized_objectives]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search (edge swap + segment reversal)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Randomly swap two edges\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8850869258592521,
            2.65757954120636
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by the sum of normalized objectives (prioritize non-dominated)\n    normalized_objectives = [(obj[0] / np.max(distance_matrix_1), obj[1] / np.max(distance_matrix_2)) for _, obj in archive]\n    scores = [sum(norm_obj) for norm_obj in normalized_objectives]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search (edge swap + segment reversal)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Randomly swap two edges\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 98,
        "algorithm": "{The algorithm intelligently selects a solution from the archive by prioritizing those with the highest potential for improvement, then applies a novel hybrid local search that combines edge swaps with adaptive segment inversions to explore diverse neighborhoods while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their combined objective values (ascending)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the top 30% with higher probability\n        selection_pool = archive_sorted[:max(1, int(len(archive) * 0.3))]\n        base_solution = random.choice(selection_pool)[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment inversion with edge swaps\n    if n > 3:\n        # Randomly choose between two strategies\n        if random.random() < 0.5:\n            # Strategy 1: Adaptive segment inversion\n            start = random.randint(0, n-2)\n            end = random.randint(start+1, min(start+5, n-1))  # Limit segment length\n            segment = new_solution[start:end+1]\n            if random.random() < 0.7:  # 70% chance to reverse\n                new_solution[start:end+1] = segment[::-1]\n            else:  # 30% chance to rotate\n                shift = random.randint(1, len(segment)-1)\n                new_solution[start:end+1] = np.roll(segment, shift)\n        else:\n            # Strategy 2: Edge swaps with objective-aware selection\n            i, j = sorted(random.sample(range(n), 2))\n            # Check if swap improves at least one objective\n            old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n            old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n            if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not feasible\"\n\n    return new_solution\n\n",
        "score": [
            -0.705770353705344,
            1.3772069215774536
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their combined objective values (ascending)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the top 30% with higher probability\n        selection_pool = archive_sorted[:max(1, int(len(archive) * 0.3))]\n        base_solution = random.choice(selection_pool)[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment inversion with edge swaps\n    if n > 3:\n        # Randomly choose between two strategies\n        if random.random() < 0.5:\n            # Strategy 1: Adaptive segment inversion\n            start = random.randint(0, n-2)\n            end = random.randint(start+1, min(start+5, n-1))  # Limit segment length\n            segment = new_solution[start:end+1]\n            if random.random() < 0.7:  # 70% chance to reverse\n                new_solution[start:end+1] = segment[::-1]\n            else:  # 30% chance to rotate\n                shift = random.randint(1, len(segment)-1)\n                new_solution[start:end+1] = np.roll(segment, shift)\n        else:\n            # Strategy 2: Edge swaps with objective-aware selection\n            i, j = sorted(random.sample(range(n), 2))\n            # Check if swap improves at least one objective\n            old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n            old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n            if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not feasible\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 99,
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of its objective values and diversity, then applies a hybrid local search operator that combines edge insertion with a novel segment relocation strategy to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choice(range(len(archive)))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Step 1: Random segment relocation with edge insertion\n    if N > 3:\n        # Select a random segment\n        seg_start = random.randint(0, N-3)\n        seg_length = random.randint(2, min(3, N-seg_start-1))\n        seg_end = seg_start + seg_length\n\n        # Extract the segment\n        segment = new_solution[seg_start:seg_end]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n\n        # Find the best insertion point for the segment\n        best_insert_pos = 0\n        best_improvement = 0\n\n        for i in range(len(new_solution)):\n            # Insert segment at position i\n            candidate = np.insert(new_solution, i, segment)\n            # Calculate improvement in both objectives\n            cost1 = sum(distance_matrix_1[candidate[j], candidate[j+1]] for j in range(len(candidate)-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[j], candidate[j+1]] for j in range(len(candidate)-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            improvement = - (cost1 + cost2)  # Negative because we want to minimize\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_insert_pos = i\n\n        # Insert the segment at the best position\n        new_solution = np.insert(new_solution, best_insert_pos, segment)\n\n    # Step 2: Random 2-opt improvement (but only if it improves both objectives)\n    if N > 2:\n        i, j = sorted(random.sample(range(N), 2))\n        if i != j:\n            # Try reverse segment\n            candidate = new_solution.copy()\n            candidate[i:j+1] = candidate[i:j+1][::-1]\n\n            # Calculate costs\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(len(candidate)-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(len(candidate)-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n            # Accept if both objectives improve\n            original_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(len(new_solution)-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            original_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(len(new_solution)-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n            if (cost1 < original_cost1 and cost2 < original_cost2):\n                new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7848142311485058,
            12.206766724586487
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choice(range(len(archive)))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Step 1: Random segment relocation with edge insertion\n    if N > 3:\n        # Select a random segment\n        seg_start = random.randint(0, N-3)\n        seg_length = random.randint(2, min(3, N-seg_start-1))\n        seg_end = seg_start + seg_length\n\n        # Extract the segment\n        segment = new_solution[seg_start:seg_end]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n\n        # Find the best insertion point for the segment\n        best_insert_pos = 0\n        best_improvement = 0\n\n        for i in range(len(new_solution)):\n            # Insert segment at position i\n            candidate = np.insert(new_solution, i, segment)\n            # Calculate improvement in both objectives\n            cost1 = sum(distance_matrix_1[candidate[j], candidate[j+1]] for j in range(len(candidate)-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[j], candidate[j+1]] for j in range(len(candidate)-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            improvement = - (cost1 + cost2)  # Negative because we want to minimize\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_insert_pos = i\n\n        # Insert the segment at the best position\n        new_solution = np.insert(new_solution, best_insert_pos, segment)\n\n    # Step 2: Random 2-opt improvement (but only if it improves both objectives)\n    if N > 2:\n        i, j = sorted(random.sample(range(N), 2))\n        if i != j:\n            # Try reverse segment\n            candidate = new_solution.copy()\n            candidate[i:j+1] = candidate[i:j+1][::-1]\n\n            # Calculate costs\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(len(candidate)-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(len(candidate)-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n            # Accept if both objectives improve\n            original_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(len(new_solution)-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            original_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(len(new_solution)-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n            if (cost1 < original_cost1 and cost2 < original_cost2):\n                new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 100,
        "algorithm": "{A novel hybrid local search approach that combines edge exchange with adaptive segment reversal, guided by Pareto dominance and objective-specific distance metrics to generate high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (non-dominated and high variance in objectives)\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1e-6))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive segment reversal with edge exchange\n    n = len(base_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Segment reversal with objective-aware selection\n    segment = base_solution[i:j+1]\n    if np.random.rand() < 0.5:\n        # Objective 1-aware reversal\n        segment_costs = [distance_matrix_1[segment[k-1], segment[k]] for k in range(len(segment))]\n        if sum(segment_costs) > np.mean(segment_costs) * len(segment) * 0.9:\n            segment = segment[::-1]\n    else:\n        # Objective 2-aware reversal\n        segment_costs = [distance_matrix_2[segment[k-1], segment[k]] for k in range(len(segment))]\n        if sum(segment_costs) > np.mean(segment_costs) * len(segment) * 0.9:\n            segment = segment[::-1]\n\n    new_solution[i:j+1] = segment\n\n    # Edge exchange with objective balance\n    if np.random.rand() < 0.3:\n        k, l = np.random.choice(n, size=2, replace=False)\n        if distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]] > \\\n           distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.669346774286004,
            1.8261968493461609
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (non-dominated and high variance in objectives)\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1e-6))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive segment reversal with edge exchange\n    n = len(base_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Segment reversal with objective-aware selection\n    segment = base_solution[i:j+1]\n    if np.random.rand() < 0.5:\n        # Objective 1-aware reversal\n        segment_costs = [distance_matrix_1[segment[k-1], segment[k]] for k in range(len(segment))]\n        if sum(segment_costs) > np.mean(segment_costs) * len(segment) * 0.9:\n            segment = segment[::-1]\n    else:\n        # Objective 2-aware reversal\n        segment_costs = [distance_matrix_2[segment[k-1], segment[k]] for k in range(len(segment))]\n        if sum(segment_costs) > np.mean(segment_costs) * len(segment) * 0.9:\n            segment = segment[::-1]\n\n    new_solution[i:j+1] = segment\n\n    # Edge exchange with objective balance\n    if np.random.rand() < 0.3:\n        k, l = np.random.choice(n, size=2, replace=False)\n        if distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]] > \\\n           distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 101,
        "algorithm": "{A hybrid local search operator that combines a multi-segment inversion with a dynamic segment length adjustment based on the Pareto dominance of neighboring solutions in both objective spaces, while ensuring feasibility by maintaining a valid TSP tour.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_obj1, current_obj2 = archive[selected_idx][1]\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Determine segment length dynamically based on solution quality\n    segment_length = max(3, min(n // 3, int(n * (1 - (current_obj1 + current_obj2) / (sum(distance_matrix_1[0]) + sum(distance_matrix_2[0]))))))\n\n    # Hybrid local search: multi-segment inversion with dynamic adjustment\n    for _ in range(3):  # Perform multiple iterations\n        # Select a random segment to invert\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Invert the segment\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Check feasibility and adjust segment length if needed\n        if len(np.unique(new_solution)) != n:\n            # If invalid, revert and try a smaller segment\n            new_solution = base_solution.copy()\n            segment_length = max(2, segment_length // 2)\n            continue\n\n        # Calculate new objectives\n        new_obj1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        new_obj2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        # Accept if at least one objective improves\n        if new_obj1 < current_obj1 or new_obj2 < current_obj2:\n            base_solution = new_solution.copy()\n            current_obj1, current_obj2 = new_obj1, new_obj2\n        else:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8077765723844,
            2.7971526384353638
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_obj1, current_obj2 = archive[selected_idx][1]\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Determine segment length dynamically based on solution quality\n    segment_length = max(3, min(n // 3, int(n * (1 - (current_obj1 + current_obj2) / (sum(distance_matrix_1[0]) + sum(distance_matrix_2[0]))))))\n\n    # Hybrid local search: multi-segment inversion with dynamic adjustment\n    for _ in range(3):  # Perform multiple iterations\n        # Select a random segment to invert\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Invert the segment\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Check feasibility and adjust segment length if needed\n        if len(np.unique(new_solution)) != n:\n            # If invalid, revert and try a smaller segment\n            new_solution = base_solution.copy()\n            segment_length = max(2, segment_length // 2)\n            continue\n\n        # Calculate new objectives\n        new_obj1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        new_obj2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        # Accept if at least one objective improves\n        if new_obj1 < current_obj1 or new_obj2 < current_obj2:\n            base_solution = new_solution.copy()\n            current_obj1, current_obj2 = new_obj1, new_obj2\n        else:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 102,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Perform a hybrid 3-opt and edge-swap operation\n    n = len(new_solution)\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Extract segments\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Recombine segments in a new order (3-opt)\n    new_order = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Apply edge-swap to potentially improve the solution\n    if np.random.rand() < 0.5:\n        swap_pos1, swap_pos2 = np.random.choice(n, size=2, replace=False)\n        new_order[swap_pos1], new_order[swap_pos2] = new_order[swap_pos2], new_order[swap_pos1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_order)) == n:\n        new_solution = new_order\n\n    return new_solution\n\n",
        "score": [
            -0.6449623494552846,
            2.330491065979004
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Perform a hybrid 3-opt and edge-swap operation\n    n = len(new_solution)\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Extract segments\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Recombine segments in a new order (3-opt)\n    new_order = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Apply edge-swap to potentially improve the solution\n    if np.random.rand() < 0.5:\n        swap_pos1, swap_pos2 = np.random.choice(n, size=2, replace=False)\n        new_order[swap_pos1], new_order[swap_pos2] = new_order[swap_pos2], new_order[swap_pos1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_order)) == n:\n        new_solution = new_order\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 103,
        "algorithm": "{A novel hybrid local search strategy that combines edge reinsertion with a multi-objective-aware segment reversal to explore diverse solution spaces while ensuring feasibility and potential for Pareto improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., worst in one objective)\n    objectives = [obj for _, obj in archive]\n    objectives = np.array(objectives)\n    ranks = np.argsort(objectives[:, 0])  # Rank by first objective\n    selected_idx = np.random.choice(ranks[-max(1, len(ranks)//3):])  # Select from top 33% worst\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge reinsertion + segment reversal\n    n = len(new_solution)\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = min(a, b), max(a, b)\n\n    # Edge reinsertion: remove segment [a:b] and reinsert it at a random position\n    segment = new_solution[a:b]\n    remaining = np.concatenate([new_solution[:a], new_solution[b:]])\n    insert_pos = np.random.randint(len(remaining) + 1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Segment reversal: reverse a random segment to explore different structures\n    if b - a > 2:  # Only reverse if segment has >2 nodes\n        c, d = np.random.choice(range(a, b), size=2, replace=False)\n        c, d = min(c, d), max(c, d)\n        new_solution[c:d] = new_solution[c:d][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    assert len(set(new_solution)) == n, \"Invalid neighbor: duplicate nodes\"\n    assert np.array_equal(np.sort(new_solution), np.arange(n)), \"Invalid neighbor: missing nodes\"\n\n    return new_solution\n\n",
        "score": [
            -0.9081259076889096,
            2.4978633522987366
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., worst in one objective)\n    objectives = [obj for _, obj in archive]\n    objectives = np.array(objectives)\n    ranks = np.argsort(objectives[:, 0])  # Rank by first objective\n    selected_idx = np.random.choice(ranks[-max(1, len(ranks)//3):])  # Select from top 33% worst\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge reinsertion + segment reversal\n    n = len(new_solution)\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = min(a, b), max(a, b)\n\n    # Edge reinsertion: remove segment [a:b] and reinsert it at a random position\n    segment = new_solution[a:b]\n    remaining = np.concatenate([new_solution[:a], new_solution[b:]])\n    insert_pos = np.random.randint(len(remaining) + 1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Segment reversal: reverse a random segment to explore different structures\n    if b - a > 2:  # Only reverse if segment has >2 nodes\n        c, d = np.random.choice(range(a, b), size=2, replace=False)\n        c, d = min(c, d), max(c, d)\n        new_solution[c:d] = new_solution[c:d][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    assert len(set(new_solution)) == n, \"Invalid neighbor: duplicate nodes\"\n    assert np.array_equal(np.sort(new_solution), np.arange(n)), \"Invalid neighbor: missing nodes\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 104,
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive segment swapping with constrained edge insertion to intelligently explore the solution space while ensuring feasibility and multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest combined cost)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform adaptive segment swapping\n    n = len(base_solution)\n    segment_length = max(2, min(5, n // 10))  # Adaptive segment length\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Swap segments between two random positions\n    other_start = np.random.randint(0, n - segment_length)\n    while abs(other_start - start) < segment_length:  # Ensure non-overlapping segments\n        other_start = np.random.randint(0, n - segment_length)\n    other_end = other_start + segment_length\n\n    # Perform the swap\n    segment1 = new_solution[start:end]\n    segment2 = new_solution[other_start:other_end]\n    new_solution[start:end] = segment2\n    new_solution[other_start:other_end] = segment1\n\n    # Perform constrained edge insertion for further improvement\n    for _ in range(3):  # Limit number of insertions\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            # Calculate cost change for both objectives\n            old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n            # Perform insertion\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n            # Revert if not beneficial for both objectives\n            if not (new_cost1 < old_cost1 and new_cost2 < old_cost2):\n                temp = new_solution[i]\n                new_solution[i] = new_solution[j]\n                new_solution[j] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.8915383202933533,
            0.48202669620513916
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest combined cost)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform adaptive segment swapping\n    n = len(base_solution)\n    segment_length = max(2, min(5, n // 10))  # Adaptive segment length\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Swap segments between two random positions\n    other_start = np.random.randint(0, n - segment_length)\n    while abs(other_start - start) < segment_length:  # Ensure non-overlapping segments\n        other_start = np.random.randint(0, n - segment_length)\n    other_end = other_start + segment_length\n\n    # Perform the swap\n    segment1 = new_solution[start:end]\n    segment2 = new_solution[other_start:other_end]\n    new_solution[start:end] = segment2\n    new_solution[other_start:other_end] = segment1\n\n    # Perform constrained edge insertion for further improvement\n    for _ in range(3):  # Limit number of insertions\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            # Calculate cost change for both objectives\n            old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n            # Perform insertion\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n            # Revert if not beneficial for both objectives\n            if not (new_cost1 < old_cost1 and new_cost2 < old_cost2):\n                temp = new_solution[i]\n                new_solution[i] = new_solution[j]\n                new_solution[j] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 104,
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive segment swapping with constrained edge insertion to intelligently explore the solution space while ensuring feasibility and multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest combined cost)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform adaptive segment swapping\n    n = len(base_solution)\n    segment_length = max(2, min(5, n // 10))  # Adaptive segment length\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Swap segments between two random positions\n    other_start = np.random.randint(0, n - segment_length)\n    while abs(other_start - start) < segment_length:  # Ensure non-overlapping segments\n        other_start = np.random.randint(0, n - segment_length)\n    other_end = other_start + segment_length\n\n    # Perform the swap\n    segment1 = new_solution[start:end]\n    segment2 = new_solution[other_start:other_end]\n    new_solution[start:end] = segment2\n    new_solution[other_start:other_end] = segment1\n\n    # Perform constrained edge insertion for further improvement\n    for _ in range(3):  # Limit number of insertions\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            # Calculate cost change for both objectives\n            old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n            # Perform insertion\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n            # Revert if not beneficial for both objectives\n            if not (new_cost1 < old_cost1 and new_cost2 < old_cost2):\n                temp = new_solution[i]\n                new_solution[i] = new_solution[j]\n                new_solution[j] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.8915383202933533,
            0.48202669620513916
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest combined cost)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform adaptive segment swapping\n    n = len(base_solution)\n    segment_length = max(2, min(5, n // 10))  # Adaptive segment length\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Swap segments between two random positions\n    other_start = np.random.randint(0, n - segment_length)\n    while abs(other_start - start) < segment_length:  # Ensure non-overlapping segments\n        other_start = np.random.randint(0, n - segment_length)\n    other_end = other_start + segment_length\n\n    # Perform the swap\n    segment1 = new_solution[start:end]\n    segment2 = new_solution[other_start:other_end]\n    new_solution[start:end] = segment2\n    new_solution[other_start:other_end] = segment1\n\n    # Perform constrained edge insertion for further improvement\n    for _ in range(3):  # Limit number of insertions\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            # Calculate cost change for both objectives\n            old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n            # Perform insertion\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n            # Revert if not beneficial for both objectives\n            if not (new_cost1 < old_cost1 and new_cost2 < old_cost2):\n                temp = new_solution[i]\n                new_solution[i] = new_solution[j]\n                new_solution[j] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 105,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: a combination of 3-opt and node insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to modify\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    c = np.random.randint(0, n)\n    a, b, c = sorted([a, b, c])\n\n    # Apply 3-opt: reverse the middle segment\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Apply node insertion: move a random node to a new position\n    node = new_solution[np.random.randint(0, n)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = np.random.randint(0, n)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -1.0176091025550207,
            2.2093617916107178
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: a combination of 3-opt and node insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to modify\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    c = np.random.randint(0, n)\n    a, b, c = sorted([a, b, c])\n\n    # Apply 3-opt: reverse the middle segment\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Apply node insertion: move a random node to a new position\n    node = new_solution[np.random.randint(0, n)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = np.random.randint(0, n)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 105,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: a combination of 3-opt and node insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to modify\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    c = np.random.randint(0, n)\n    a, b, c = sorted([a, b, c])\n\n    # Apply 3-opt: reverse the middle segment\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Apply node insertion: move a random node to a new position\n    node = new_solution[np.random.randint(0, n)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = np.random.randint(0, n)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -1.0176091025550207,
            2.2093617916107178
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: a combination of 3-opt and node insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to modify\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    c = np.random.randint(0, n)\n    a, b, c = sorted([a, b, c])\n\n    # Apply 3-opt: reverse the middle segment\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Apply node insertion: move a random node to a new position\n    node = new_solution[np.random.randint(0, n)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = np.random.randint(0, n)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 106,
        "algorithm": "{A hybrid local search algorithm that combines adaptive edge swapping with a novel multi-objective segment relocation strategy, prioritizing solutions with high potential for improvement while ensuring feasibility through intelligent constraint-aware perturbations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value (potential for improvement)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive segment relocation with multi-objective consideration\n    n = len(base_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Determine segment size based on instance size\n    segment_size = max(2, min(4, n // 4))\n\n    # Randomly select a segment to relocate\n    start = np.random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n\n    # Evaluate potential insertion points based on both objectives\n    best_pos = -1\n    best_cost = float('inf')\n\n    for pos in range(n - segment_size + 1):\n        if pos == start:\n            continue  # Skip current position\n\n        # Create temporary solution\n        temp_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[start+segment_size:pos],\n            segment,\n            new_solution[pos:]\n        ])\n\n        # Calculate total cost for both objectives\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        # Combine costs with adaptive weighting\n        alpha = 0.5  # Can be adjusted based on problem characteristics\n        combined_cost = alpha * cost1 + (1 - alpha) * cost2\n\n        if combined_cost < best_cost:\n            best_cost = combined_cost\n            best_pos = pos\n\n    if best_pos != -1:\n        # Apply the best relocation\n        temp_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[start+segment_size:best_pos],\n            segment,\n            new_solution[best_pos:]\n        ])\n        new_solution = temp_solution\n\n    # Additional local improvement: adaptive edge swapping\n    for _ in range(2):  # Limit to 2 iterations for efficiency\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate cost difference\n        old_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n        if new_cost < old_cost:\n            # Reverse the segment between i and j\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9168827086899644,
            9.407511234283447
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value (potential for improvement)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive segment relocation with multi-objective consideration\n    n = len(base_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Determine segment size based on instance size\n    segment_size = max(2, min(4, n // 4))\n\n    # Randomly select a segment to relocate\n    start = np.random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n\n    # Evaluate potential insertion points based on both objectives\n    best_pos = -1\n    best_cost = float('inf')\n\n    for pos in range(n - segment_size + 1):\n        if pos == start:\n            continue  # Skip current position\n\n        # Create temporary solution\n        temp_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[start+segment_size:pos],\n            segment,\n            new_solution[pos:]\n        ])\n\n        # Calculate total cost for both objectives\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        # Combine costs with adaptive weighting\n        alpha = 0.5  # Can be adjusted based on problem characteristics\n        combined_cost = alpha * cost1 + (1 - alpha) * cost2\n\n        if combined_cost < best_cost:\n            best_cost = combined_cost\n            best_pos = pos\n\n    if best_pos != -1:\n        # Apply the best relocation\n        temp_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[start+segment_size:best_pos],\n            segment,\n            new_solution[best_pos:]\n        ])\n        new_solution = temp_solution\n\n    # Additional local improvement: adaptive edge swapping\n    for _ in range(2):  # Limit to 2 iterations for efficiency\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate cost difference\n        old_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n        if new_cost < old_cost:\n            # Reverse the segment between i and j\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 107,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on a hybrid selection criteria, then applies a novel local search operator that combines edge swaps with path relinking to explore high-quality neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine edge swaps with path relinking\n    n = len(base_solution)\n    i, j, k, l = sorted(random.sample(range(n), 4))\n\n    # Perform a 4-opt move (generalized edge swaps)\n    new_solution[i:j] = base_solution[i:j][::-1]\n    new_solution[k:l] = base_solution[k:l][::-1]\n\n    # Path relinking: blend segments from another solution\n    if len(archive) > 1:\n        other_solution = archive[(selected_idx + 1) % len(archive)][0]\n        relink_point = random.randint(1, n-2)\n        new_solution[relink_point:] = other_solution[relink_point:]\n\n    # Ensure feasibility by repairing invalid tours\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, replace them with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for idx in np.where(np.in1d(new_solution, new_solution, invert=True))[0]:\n            new_solution[idx] = missing_nodes[0]\n            missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.8840108749937868,
            0.5787209868431091
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine edge swaps with path relinking\n    n = len(base_solution)\n    i, j, k, l = sorted(random.sample(range(n), 4))\n\n    # Perform a 4-opt move (generalized edge swaps)\n    new_solution[i:j] = base_solution[i:j][::-1]\n    new_solution[k:l] = base_solution[k:l][::-1]\n\n    # Path relinking: blend segments from another solution\n    if len(archive) > 1:\n        other_solution = archive[(selected_idx + 1) % len(archive)][0]\n        relink_point = random.randint(1, n-2)\n        new_solution[relink_point:] = other_solution[relink_point:]\n\n    # Ensure feasibility by repairing invalid tours\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, replace them with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for idx in np.where(np.in1d(new_solution, new_solution, invert=True))[0]:\n            new_solution[idx] = missing_nodes[0]\n            missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 108,
        "algorithm": "{A hybrid local search algorithm that combines a novel segment inversion operator with a biased random walk to explore diverse neighborhoods while maintaining feasibility, ensuring solutions are valid TSP tours by always preserving node uniqueness and completeness.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with lower total cost\n    costs = [sum(obj) for _, obj in archive]\n    min_cost = min(costs)\n    max_cost = max(costs)\n    if max_cost == min_cost:\n        probabilities = [1.0 / len(archive)] * len(archive)\n    else:\n        normalized_costs = [(max_cost - cost) / (max_cost - min_cost) for cost in costs]\n        total = sum(normalized_costs)\n        probabilities = [cost / total for cost in normalized_costs]\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Segment inversion with biased random walk\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine segment length (adaptive)\n    segment_length = min(5, max(2, n // 10))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Invert the segment\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Apply biased random walk to further refine\n    for _ in range(2):\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        # Swap segments with bias towards reducing cost\n        current_cost = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i-1], new_solution[i]] + \\\n                       distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i-1], new_solution[j]] + \\\n                   distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        if new_cost < current_cost and random.random() < 0.7:  # Accept better moves with 70% probability\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6784596498997368,
            1.3260590434074402
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with lower total cost\n    costs = [sum(obj) for _, obj in archive]\n    min_cost = min(costs)\n    max_cost = max(costs)\n    if max_cost == min_cost:\n        probabilities = [1.0 / len(archive)] * len(archive)\n    else:\n        normalized_costs = [(max_cost - cost) / (max_cost - min_cost) for cost in costs]\n        total = sum(normalized_costs)\n        probabilities = [cost / total for cost in normalized_costs]\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Segment inversion with biased random walk\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine segment length (adaptive)\n    segment_length = min(5, max(2, n // 10))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Invert the segment\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Apply biased random walk to further refine\n    for _ in range(2):\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        # Swap segments with bias towards reducing cost\n        current_cost = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i-1], new_solution[i]] + \\\n                       distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i-1], new_solution[j]] + \\\n                   distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        if new_cost < current_cost and random.random() < 0.7:  # Accept better moves with 70% probability\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 109,
        "algorithm": "{This heuristic selects a solution from the archive with high potential for improvement by prioritizing those with diverse trade-offs between objectives, then applies a hybrid local search combining edge insertion and segment relocation to explore high-quality neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with diverse trade-offs\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Normalize objectives\n        min_obj = objectives.min(axis=0)\n        max_obj = objectives.max(axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n\n        # Select solution with highest diversity in trade-offs\n        diversity = np.std(normalized, axis=1)\n        selected_idx = np.argmax(diversity)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge insertion\n    n = len(new_solution)\n    a, b = np.random.choice(n, 2, replace=False)\n    c, d = np.random.choice(n, 2, replace=False)\n\n    if a > b:\n        a, b = b, a\n    if c > d:\n        c, d = d, c\n\n    # Extract segments\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    # Relocate segments\n    if a < c:\n        new_solution = np.concatenate([\n            new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n        ])\n    else:\n        new_solution = np.concatenate([\n            new_solution[:c], segment1, new_solution[d+1:a], segment2, new_solution[b+1:]\n        ])\n\n    # Edge insertion for further improvement\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        if np.random.rand() < 0.5:\n            # Insert segment\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], segment[::-1], new_solution[j+1:]])\n        else:\n            # Swap nodes\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by inserting missing nodes\n        missing = np.setdiff1d(np.arange(n), unique)\n        for missing_node in missing:\n            pos = np.random.randint(n)\n            new_solution = np.insert(new_solution, pos, missing_node)\n\n    return new_solution\n\n",
        "score": [
            -0.5784668780093856,
            1.286418378353119
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with diverse trade-offs\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Normalize objectives\n        min_obj = objectives.min(axis=0)\n        max_obj = objectives.max(axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n\n        # Select solution with highest diversity in trade-offs\n        diversity = np.std(normalized, axis=1)\n        selected_idx = np.argmax(diversity)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation + edge insertion\n    n = len(new_solution)\n    a, b = np.random.choice(n, 2, replace=False)\n    c, d = np.random.choice(n, 2, replace=False)\n\n    if a > b:\n        a, b = b, a\n    if c > d:\n        c, d = d, c\n\n    # Extract segments\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    # Relocate segments\n    if a < c:\n        new_solution = np.concatenate([\n            new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n        ])\n    else:\n        new_solution = np.concatenate([\n            new_solution[:c], segment1, new_solution[d+1:a], segment2, new_solution[b+1:]\n        ])\n\n    # Edge insertion for further improvement\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        if np.random.rand() < 0.5:\n            # Insert segment\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], segment[::-1], new_solution[j+1:]])\n        else:\n            # Swap nodes\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by inserting missing nodes\n        missing = np.setdiff1d(np.arange(n), unique)\n        for missing_node in missing:\n            pos = np.random.randint(n)\n            new_solution = np.insert(new_solution, pos, missing_node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 110,
        "algorithm": "{A novel hybrid local search operator combines a randomized edge exchange with a guided segment relocation, prioritizing solutions with high crowding distance in the archive to explore less-explored regions while maintaining feasibility through a validation step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance (promising for exploration)\n    def crowding_distance(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        distances = np.zeros(len(objectives))\n        for m in range(objectives.shape[1]):\n            sorted_idx = np.argsort(objectives[:, m])\n            distances[sorted_idx[0]] = distances[sorted_idx[-1]] = np.inf\n            for i in range(1, len(solutions) - 1):\n                distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized edge exchange + guided segment relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Random edge exchange\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    if i != j:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Guided segment relocation\n    segment_start = random.randint(0, n - 3)\n    segment_end = random.randint(segment_start + 1, n - 1)\n    segment = new_solution[segment_start:segment_end + 1]\n\n    # Find best insertion point based on both objectives\n    best_pos = -1\n    best_score = float('inf')\n\n    for pos in range(n - len(segment)):\n        if pos >= segment_start and pos < segment_end:\n            continue\n\n        candidate = np.concatenate([\n            new_solution[:pos],\n            segment,\n            new_solution[pos:segment_start],\n            new_solution[segment_end + 1:]\n        ])\n\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        score = cost1 + cost2\n\n        if score < best_score:\n            best_score = score\n            best_pos = pos\n\n    if best_pos != -1:\n        candidate = np.concatenate([\n            new_solution[:best_pos],\n            segment,\n            new_solution[best_pos:segment_start],\n            new_solution[segment_end + 1:]\n        ])\n        new_solution = candidate\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        new_solution = base_solution.copy()\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7110794624235284,
            7.026569485664368
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance (promising for exploration)\n    def crowding_distance(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        distances = np.zeros(len(objectives))\n        for m in range(objectives.shape[1]):\n            sorted_idx = np.argsort(objectives[:, m])\n            distances[sorted_idx[0]] = distances[sorted_idx[-1]] = np.inf\n            for i in range(1, len(solutions) - 1):\n                distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized edge exchange + guided segment relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Random edge exchange\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    if i != j:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Guided segment relocation\n    segment_start = random.randint(0, n - 3)\n    segment_end = random.randint(segment_start + 1, n - 1)\n    segment = new_solution[segment_start:segment_end + 1]\n\n    # Find best insertion point based on both objectives\n    best_pos = -1\n    best_score = float('inf')\n\n    for pos in range(n - len(segment)):\n        if pos >= segment_start and pos < segment_end:\n            continue\n\n        candidate = np.concatenate([\n            new_solution[:pos],\n            segment,\n            new_solution[pos:segment_start],\n            new_solution[segment_end + 1:]\n        ])\n\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        score = cost1 + cost2\n\n        if score < best_score:\n            best_score = score\n            best_pos = pos\n\n    if best_pos != -1:\n        candidate = np.concatenate([\n            new_solution[:best_pos],\n            segment,\n            new_solution[best_pos:segment_start],\n            new_solution[segment_end + 1:]\n        ])\n        new_solution = candidate\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        new_solution = base_solution.copy()\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 111,
        "algorithm": "{A novel hybrid local search strategy combines edge swapping with segment reordering, prioritizing critical edges in both objective spaces and dynamically adjusting the search based on Pareto dominance and solution diversity to explore high-potential regions of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Segment reordering + edge swapping\n    n = len(base_solution)\n    i, j = np.random.randint(0, n, size=2)\n    if i > j:\n        i, j = j, i\n\n    # Segment reordering (reverse a segment)\n    new_solution[i:j+1] = base_solution[i:j+1][::-1]\n\n    # Edge swapping (swap two edges if beneficial in both objectives)\n    k, l = np.random.randint(0, n, size=2)\n    if k > l:\n        k, l = l, k\n\n    # Check if swapping improves both objectives\n    current_cost1 = distance_matrix_1[base_solution[k-1], base_solution[k]] + distance_matrix_1[base_solution[l], base_solution[(l+1)%n]]\n    current_cost2 = distance_matrix_2[base_solution[k-1], base_solution[k]] + distance_matrix_2[base_solution[l], base_solution[(l+1)%n]]\n    new_cost1 = distance_matrix_1[base_solution[k-1], base_solution[l]] + distance_matrix_1[base_solution[k], base_solution[(l+1)%n]]\n    new_cost2 = distance_matrix_2[base_solution[k-1], base_solution[l]] + distance_matrix_2[base_solution[k], base_solution[(l+1)%n]]\n\n    if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7969943551089418,
            2.164729118347168
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Segment reordering + edge swapping\n    n = len(base_solution)\n    i, j = np.random.randint(0, n, size=2)\n    if i > j:\n        i, j = j, i\n\n    # Segment reordering (reverse a segment)\n    new_solution[i:j+1] = base_solution[i:j+1][::-1]\n\n    # Edge swapping (swap two edges if beneficial in both objectives)\n    k, l = np.random.randint(0, n, size=2)\n    if k > l:\n        k, l = l, k\n\n    # Check if swapping improves both objectives\n    current_cost1 = distance_matrix_1[base_solution[k-1], base_solution[k]] + distance_matrix_1[base_solution[l], base_solution[(l+1)%n]]\n    current_cost2 = distance_matrix_2[base_solution[k-1], base_solution[k]] + distance_matrix_2[base_solution[l], base_solution[(l+1)%n]]\n    new_cost1 = distance_matrix_1[base_solution[k-1], base_solution[l]] + distance_matrix_1[base_solution[k], base_solution[(l+1)%n]]\n    new_cost2 = distance_matrix_2[base_solution[k-1], base_solution[l]] + distance_matrix_2[base_solution[k], base_solution[(l+1)%n]]\n\n    if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 112,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a solution from the archive based on its potential for improvement, then applies a combination of edge-swapping and segment reordering to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search strategy: combine edge-swapping and segment reordering\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Edge-swapping (randomly select two edges and swap their positions)\n    if n > 2:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Segment reordering (randomly select a segment and reinsert it elsewhere)\n    if n > 3:\n        seg_start, seg_end = sorted(random.sample(range(n), 2))\n        segment = new_solution[seg_start:seg_end]\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:],\n            segment\n        ])\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(set(new_solution)) != n:\n        # Revert to a simpler edge-swap if the above causes duplicates\n        new_solution = selected_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8816315227195599,
            1.5964537858963013
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search strategy: combine edge-swapping and segment reordering\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Edge-swapping (randomly select two edges and swap their positions)\n    if n > 2:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Segment reordering (randomly select a segment and reinsert it elsewhere)\n    if n > 3:\n        seg_start, seg_end = sorted(random.sample(range(n), 2))\n        segment = new_solution[seg_start:seg_end]\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:],\n            segment\n        ])\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(set(new_solution)) != n:\n        # Revert to a simpler edge-swap if the above causes duplicates\n        new_solution = selected_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 113,
        "algorithm": "{The new algorithm intelligently selects a solution from the archive based on a weighted combination of its objective values and their dominance, then applies a hybrid local search combining 3-opt with a novel segment reversal operator to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    weights = 1 - np.mean(normalized, axis=1)  # Prefer solutions with lower normalized objectives\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select 3 distinct edges\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # With probability 0.5, apply segment reversal between random points\n    if random.random() < 0.5:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Verify feasibility (should never fail due to implementation)\n    assert len(new_solution) == len(set(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            -0.8963524611280952,
            2.435145854949951
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    weights = 1 - np.mean(normalized, axis=1)  # Prefer solutions with lower normalized objectives\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select 3 distinct edges\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # With probability 0.5, apply segment reversal between random points\n    if random.random() < 0.5:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Verify feasibility (should never fail due to implementation)\n    assert len(new_solution) == len(set(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 114,
        "algorithm": "{A novel heuristic function selects a solution from the archive based on a weighted combination of objective values and diversity, then applies a hybrid local search combining edge insertion with a customized 3-opt move to generate a high-quality neighbor solution while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its diversity and objective values\n    objectives = np.array([obj for _, obj in archive])\n    weights = 1 / (objectives[:, 0] + objectives[:, 1] + 1e-6)  # Avoid division by zero\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Edge insertion + customized 3-opt\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Step 1: Edge insertion (remove a random edge and reinsert it optimally)\n    i = random.randint(0, n-1)\n    j = (i + 1) % n\n    a, b = new_solution[i], new_solution[j]\n\n    # Remove edge (a, b)\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n    # Find the best position to reinsert (a, b) to minimize both objectives\n    best_pos = 0\n    best_cost = float('inf')\n    for pos in range(len(new_solution)):\n        candidate = np.insert(new_solution, pos, [a, b])\n        cost = (distance_matrix_1[candidate[:-1], candidate[1:]].sum() +\n                distance_matrix_2[candidate[:-1], candidate[1:]].sum())\n        if cost < best_cost:\n            best_cost = cost\n            best_pos = pos\n\n    new_solution = np.insert(new_solution, best_pos, [a, b])\n\n    # Step 2: Customized 3-opt move (select 3 non-consecutive edges and reconnect optimally)\n    if n >= 6:\n        # Select 3 edges that are not consecutive\n        edges = []\n        while len(edges) < 3:\n            idx = random.randint(0, n-1)\n            if idx not in edges and (idx+1)%n not in edges:\n                edges.append(idx)\n\n        edges.sort()\n        i1, i2, i3 = edges\n        j1, j2, j3 = (i1+1)%n, (i2+1)%n, (i3+1)%n\n\n        # Extract segments\n        seg1 = new_solution[:i1+1]\n        seg2 = new_solution[i1+1:i2+1]\n        seg3 = new_solution[i2+1:i3+1]\n        seg4 = new_solution[i3+1:]\n\n        # Try all 8 possible reconnections\n        candidates = [\n            np.concatenate([seg1, seg2[::-1], seg3[::-1], seg4]),\n            np.concatenate([seg1, seg3, seg2[::-1], seg4]),\n            np.concatenate([seg1, seg2, seg3[::-1], seg4]),\n            np.concatenate([seg1, seg2, seg3, seg4[::-1]]),\n            np.concatenate([seg1, seg3[::-1], seg2, seg4]),\n            np.concatenate([seg1, seg2[::-1], seg3, seg4]),\n            np.concatenate([seg1, seg3, seg2, seg4[::-1]]),\n            np.concatenate([seg1, seg2[::-1], seg3[::-1], seg4[::-1]])\n        ]\n\n        # Select the best reconnection\n        best_candidate = new_solution.copy()\n        best_cost = (distance_matrix_1[best_candidate[:-1], best_candidate[1:]].sum() +\n                     distance_matrix_2[best_candidate[:-1], best_candidate[1:]].sum())\n\n        for candidate in candidates:\n            cost = (distance_matrix_1[candidate[:-1], candidate[1:]].sum() +\n                    distance_matrix_2[candidate[:-1], candidate[1:]].sum())\n            if cost < best_cost:\n                best_cost = cost\n                best_candidate = candidate.copy()\n\n        new_solution = best_candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8327501892932131,
            7.220642149448395
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its diversity and objective values\n    objectives = np.array([obj for _, obj in archive])\n    weights = 1 / (objectives[:, 0] + objectives[:, 1] + 1e-6)  # Avoid division by zero\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Edge insertion + customized 3-opt\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Step 1: Edge insertion (remove a random edge and reinsert it optimally)\n    i = random.randint(0, n-1)\n    j = (i + 1) % n\n    a, b = new_solution[i], new_solution[j]\n\n    # Remove edge (a, b)\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n    # Find the best position to reinsert (a, b) to minimize both objectives\n    best_pos = 0\n    best_cost = float('inf')\n    for pos in range(len(new_solution)):\n        candidate = np.insert(new_solution, pos, [a, b])\n        cost = (distance_matrix_1[candidate[:-1], candidate[1:]].sum() +\n                distance_matrix_2[candidate[:-1], candidate[1:]].sum())\n        if cost < best_cost:\n            best_cost = cost\n            best_pos = pos\n\n    new_solution = np.insert(new_solution, best_pos, [a, b])\n\n    # Step 2: Customized 3-opt move (select 3 non-consecutive edges and reconnect optimally)\n    if n >= 6:\n        # Select 3 edges that are not consecutive\n        edges = []\n        while len(edges) < 3:\n            idx = random.randint(0, n-1)\n            if idx not in edges and (idx+1)%n not in edges:\n                edges.append(idx)\n\n        edges.sort()\n        i1, i2, i3 = edges\n        j1, j2, j3 = (i1+1)%n, (i2+1)%n, (i3+1)%n\n\n        # Extract segments\n        seg1 = new_solution[:i1+1]\n        seg2 = new_solution[i1+1:i2+1]\n        seg3 = new_solution[i2+1:i3+1]\n        seg4 = new_solution[i3+1:]\n\n        # Try all 8 possible reconnections\n        candidates = [\n            np.concatenate([seg1, seg2[::-1], seg3[::-1], seg4]),\n            np.concatenate([seg1, seg3, seg2[::-1], seg4]),\n            np.concatenate([seg1, seg2, seg3[::-1], seg4]),\n            np.concatenate([seg1, seg2, seg3, seg4[::-1]]),\n            np.concatenate([seg1, seg3[::-1], seg2, seg4]),\n            np.concatenate([seg1, seg2[::-1], seg3, seg4]),\n            np.concatenate([seg1, seg3, seg2, seg4[::-1]]),\n            np.concatenate([seg1, seg2[::-1], seg3[::-1], seg4[::-1]])\n        ]\n\n        # Select the best reconnection\n        best_candidate = new_solution.copy()\n        best_cost = (distance_matrix_1[best_candidate[:-1], best_candidate[1:]].sum() +\n                     distance_matrix_2[best_candidate[:-1], best_candidate[1:]].sum())\n\n        for candidate in candidates:\n            cost = (distance_matrix_1[candidate[:-1], candidate[1:]].sum() +\n                    distance_matrix_2[candidate[:-1], candidate[1:]].sum())\n            if cost < best_cost:\n                best_cost = cost\n                best_candidate = candidate.copy()\n\n        new_solution = best_candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 115,
        "algorithm": "{A novel hybrid local search algorithm combines adaptive segment relinking with biased random-key crossover to intelligently recombine solution segments, while dynamically adjusting the search focus based on objective dominance and diversity to generate high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with preference towards non-dominated or diverse solutions\n    selected_index = random.choices(\n        range(len(archive)),\n        weights=[1.0 / (1 + i) for i in range(len(archive))],  # Prefer earlier solutions\n        k=1\n    )[0]\n    base_solution = archive[selected_index][0].copy()\n\n    # Hybrid local search: Adaptive Segment Relinking with Biased Random-Key Crossover\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Step 1: Randomly select a segment to relink\n    segment_start = random.randint(0, n - 1)\n    segment_length = random.randint(2, min(8, n // 2))\n    segment_end = (segment_start + segment_length) % n\n\n    # Step 2: Find a reference solution from the archive\n    ref_index = random.randint(0, len(archive) - 1)\n    ref_solution = archive[ref_index][0]\n\n    # Step 3: Adaptive segment relinking\n    if segment_start < segment_end:\n        segment = ref_solution[segment_start:segment_end]\n    else:\n        segment = np.concatenate([ref_solution[segment_start:], ref_solution[:segment_end]])\n\n    # Step 4: Insert the segment into the base solution with bias towards better edges\n    for i in range(len(segment)):\n        pos = (segment_start + i) % n\n        candidate = segment[i]\n\n        # Bias insertion based on edge quality in both objectives\n        current_node = new_solution[pos]\n        next_node = new_solution[(pos + 1) % n]\n\n        # Evaluate insertion cost in both objectives\n        cost1 = (distance_matrix_1[current_node, candidate] +\n                 distance_matrix_1[candidate, next_node] -\n                 distance_matrix_1[current_node, next_node])\n        cost2 = (distance_matrix_2[current_node, candidate] +\n                 distance_matrix_2[candidate, next_node] -\n                 distance_matrix_2[current_node, next_node])\n\n        # If insertion improves both objectives, accept\n        if cost1 < 0 and cost2 < 0:\n            new_solution[pos] = candidate\n        else:\n            # Otherwise, accept with probability based on improvement\n            prob = np.exp(-(abs(cost1) + abs(cost2)) / (distance_matrix_1.mean() + distance_matrix_2.mean()))\n            if random.random() < prob:\n                new_solution[pos] = candidate\n\n    # Step 5: Random-key crossover for further diversification\n    if random.random() < 0.3:  # 30% chance to apply crossover\n        other_solution = archive[random.randint(0, len(archive) - 1)][0]\n        crossover_point = random.randint(1, n - 1)\n\n        # Random-key crossover with bias towards better edges\n        for i in range(crossover_point, n):\n            candidate = other_solution[i]\n            current_node = new_solution[i]\n            next_node = new_solution[(i + 1) % n]\n\n            # Evaluate potential swap\n            cost1 = (distance_matrix_1[current_node, candidate] +\n                     distance_matrix_1[candidate, next_node] -\n                     distance_matrix_1[current_node, next_node])\n            cost2 = (distance_matrix_2[current_node, candidate] +\n                     distance_matrix_2[candidate, next_node] -\n                     distance_matrix_2[current_node, next_node])\n\n            # Accept swap if it improves both objectives\n            if cost1 < 0 and cost2 < 0:\n                new_solution[i] = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.594978992653433,
            1.8093995451927185
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with preference towards non-dominated or diverse solutions\n    selected_index = random.choices(\n        range(len(archive)),\n        weights=[1.0 / (1 + i) for i in range(len(archive))],  # Prefer earlier solutions\n        k=1\n    )[0]\n    base_solution = archive[selected_index][0].copy()\n\n    # Hybrid local search: Adaptive Segment Relinking with Biased Random-Key Crossover\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Step 1: Randomly select a segment to relink\n    segment_start = random.randint(0, n - 1)\n    segment_length = random.randint(2, min(8, n // 2))\n    segment_end = (segment_start + segment_length) % n\n\n    # Step 2: Find a reference solution from the archive\n    ref_index = random.randint(0, len(archive) - 1)\n    ref_solution = archive[ref_index][0]\n\n    # Step 3: Adaptive segment relinking\n    if segment_start < segment_end:\n        segment = ref_solution[segment_start:segment_end]\n    else:\n        segment = np.concatenate([ref_solution[segment_start:], ref_solution[:segment_end]])\n\n    # Step 4: Insert the segment into the base solution with bias towards better edges\n    for i in range(len(segment)):\n        pos = (segment_start + i) % n\n        candidate = segment[i]\n\n        # Bias insertion based on edge quality in both objectives\n        current_node = new_solution[pos]\n        next_node = new_solution[(pos + 1) % n]\n\n        # Evaluate insertion cost in both objectives\n        cost1 = (distance_matrix_1[current_node, candidate] +\n                 distance_matrix_1[candidate, next_node] -\n                 distance_matrix_1[current_node, next_node])\n        cost2 = (distance_matrix_2[current_node, candidate] +\n                 distance_matrix_2[candidate, next_node] -\n                 distance_matrix_2[current_node, next_node])\n\n        # If insertion improves both objectives, accept\n        if cost1 < 0 and cost2 < 0:\n            new_solution[pos] = candidate\n        else:\n            # Otherwise, accept with probability based on improvement\n            prob = np.exp(-(abs(cost1) + abs(cost2)) / (distance_matrix_1.mean() + distance_matrix_2.mean()))\n            if random.random() < prob:\n                new_solution[pos] = candidate\n\n    # Step 5: Random-key crossover for further diversification\n    if random.random() < 0.3:  # 30% chance to apply crossover\n        other_solution = archive[random.randint(0, len(archive) - 1)][0]\n        crossover_point = random.randint(1, n - 1)\n\n        # Random-key crossover with bias towards better edges\n        for i in range(crossover_point, n):\n            candidate = other_solution[i]\n            current_node = new_solution[i]\n            next_node = new_solution[(i + 1) % n]\n\n            # Evaluate potential swap\n            cost1 = (distance_matrix_1[current_node, candidate] +\n                     distance_matrix_1[candidate, next_node] -\n                     distance_matrix_1[current_node, next_node])\n            cost2 = (distance_matrix_2[current_node, candidate] +\n                     distance_matrix_2[candidate, next_node] -\n                     distance_matrix_2[current_node, next_node])\n\n            # Accept swap if it improves both objectives\n            if cost1 < 0 and cost2 < 0:\n                new_solution[i] = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 116,
        "algorithm": "{A novel hybrid local search operator combines a dynamic edge-swap strategy with a biased random walk to explore the solution space, prioritizing edges with high potential for improvement in both objectives while ensuring feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: max(x[1]))\n    selected_solution = random.choices(archive_sorted[:len(archive_sorted)//2], k=1)[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: dynamic edge-swap with biased random walk\n    for _ in range(5):  # Number of iterations\n        # Select two edges to swap with bias toward high-improvement edges\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        k = random.randint(0, n-1)\n        l = random.randint(0, n-1)\n\n        # Calculate potential improvement in both objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[k], new_solution[l]] -\n                 (distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[j], new_solution[l]]))\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[k], new_solution[l]] -\n                 (distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[j], new_solution[l]]))\n\n        # Apply swap if it improves at least one objective\n        if delta1 < 0 or delta2 < 0:\n            new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n            new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n\n        # Biased random walk: occasionally accept worse solutions\n        elif random.random() < 0.1:\n            new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n            new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n\n    return new_solution\n\n",
        "score": [
            -0.8103569696200337,
            2.1825093030929565
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: max(x[1]))\n    selected_solution = random.choices(archive_sorted[:len(archive_sorted)//2], k=1)[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: dynamic edge-swap with biased random walk\n    for _ in range(5):  # Number of iterations\n        # Select two edges to swap with bias toward high-improvement edges\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        k = random.randint(0, n-1)\n        l = random.randint(0, n-1)\n\n        # Calculate potential improvement in both objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[k], new_solution[l]] -\n                 (distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[j], new_solution[l]]))\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[k], new_solution[l]] -\n                 (distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[j], new_solution[l]]))\n\n        # Apply swap if it improves at least one objective\n        if delta1 < 0 or delta2 < 0:\n            new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n            new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n\n        # Biased random walk: occasionally accept worse solutions\n        elif random.random() < 0.1:\n            new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n            new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 117,
        "algorithm": "{A novel hybrid local search algorithm that combines a randomized segment inversion with a multi-objective-aware edge selection to explore high-quality solutions while ensuring feasibility, by first selecting a solution with high potential for improvement based on non-dominated fronts and then applying a dynamic segment inversion operator guided by both distance matrices to generate diverse neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution based on non-dominated fronts and improvement potential\n    def dominates(a, b):\n        return a[0] <= b[0] and a[1] <= b[1] and (a[0] < b[0] or a[1] < b[1])\n\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if dominates(other_obj, obj):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        # If no non-dominated solutions, select randomly\n        base_solution, _ = random.choice(archive)\n    else:\n        # Select the solution with highest potential for improvement\n        base_solution, _ = max(non_dominated, key=lambda x: sum(x[1]))\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search operator\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select a segment to invert\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+10, n-1))  # Limit segment size to 10 for efficiency\n\n    # Invert the segment\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 3: Apply multi-objective-aware edge selection\n    # Find edges that could be improved in either objective space\n    for i in range(n):\n        current_node = new_solution[i]\n        next_node = new_solution[(i+1) % n]\n\n        # Consider swapping with a nearby node in either space\n        for j in range(i+2, min(i+6, n)):  # Limit search window to 5 nodes\n            candidate_node = new_solution[j]\n\n            # Check improvement in both objectives\n            old_dist1 = distance_matrix_1[current_node, next_node]\n            new_dist1 = distance_matrix_1[current_node, candidate_node] + distance_matrix_1[candidate_node, next_node]\n\n            old_dist2 = distance_matrix_2[current_node, next_node]\n            new_dist2 = distance_matrix_2[current_node, candidate_node] + distance_matrix_2[candidate_node, next_node]\n\n            if (new_dist1 < old_dist1 or new_dist2 < old_dist2) and random.random() < 0.7:  # 70% chance to accept improvement\n                # Perform the swap\n                new_solution[i+1:j+1] = new_solution[j:i:-1]\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7042694075938032,
            3.24998140335083
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution based on non-dominated fronts and improvement potential\n    def dominates(a, b):\n        return a[0] <= b[0] and a[1] <= b[1] and (a[0] < b[0] or a[1] < b[1])\n\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if dominates(other_obj, obj):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        # If no non-dominated solutions, select randomly\n        base_solution, _ = random.choice(archive)\n    else:\n        # Select the solution with highest potential for improvement\n        base_solution, _ = max(non_dominated, key=lambda x: sum(x[1]))\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search operator\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select a segment to invert\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, min(start+10, n-1))  # Limit segment size to 10 for efficiency\n\n    # Invert the segment\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 3: Apply multi-objective-aware edge selection\n    # Find edges that could be improved in either objective space\n    for i in range(n):\n        current_node = new_solution[i]\n        next_node = new_solution[(i+1) % n]\n\n        # Consider swapping with a nearby node in either space\n        for j in range(i+2, min(i+6, n)):  # Limit search window to 5 nodes\n            candidate_node = new_solution[j]\n\n            # Check improvement in both objectives\n            old_dist1 = distance_matrix_1[current_node, next_node]\n            new_dist1 = distance_matrix_1[current_node, candidate_node] + distance_matrix_1[candidate_node, next_node]\n\n            old_dist2 = distance_matrix_2[current_node, next_node]\n            new_dist2 = distance_matrix_2[current_node, candidate_node] + distance_matrix_2[candidate_node, next_node]\n\n            if (new_dist1 < old_dist1 or new_dist2 < old_dist2) and random.random() < 0.7:  # 70% chance to accept improvement\n                # Perform the swap\n                new_solution[i+1:j+1] = new_solution[j:i:-1]\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 118,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of squared differences from the mean objectives\n        objectives = np.array([obj for _, obj in archive])\n        mean_obj = np.mean(objectives, axis=0)\n        variance_scores = np.sum((objectives - mean_obj) ** 2, axis=1)\n        selected_idx = np.argmax(variance_scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Edge insertion with dynamic segment swap\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Edge insertion: Remove segment [i..j] and reinsert it at a random position\n    segment = new_solution[i:j+1]\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Dynamic segment swap: Swap a random segment with another segment of similar length\n    if n > 3:\n        seg_len = random.randint(2, min(5, n // 2))\n        k = random.randint(0, n - seg_len)\n        segment_k = new_solution[k:k+seg_len]\n\n        # Find another segment of similar length\n        l = random.randint(0, n - seg_len)\n        while abs(l - k) < seg_len:  # Ensure segments are not overlapping\n            l = random.randint(0, n - seg_len)\n\n        segment_l = new_solution[l:l+seg_len]\n        new_solution[k:k+seg_len] = segment_l\n        new_solution[l:l+seg_len] = segment_k\n\n    return new_solution\n\n",
        "score": [
            -0.9283349697660599,
            0.5008966326713562
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of squared differences from the mean objectives\n        objectives = np.array([obj for _, obj in archive])\n        mean_obj = np.mean(objectives, axis=0)\n        variance_scores = np.sum((objectives - mean_obj) ** 2, axis=1)\n        selected_idx = np.argmax(variance_scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Edge insertion with dynamic segment swap\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Edge insertion: Remove segment [i..j] and reinsert it at a random position\n    segment = new_solution[i:j+1]\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Dynamic segment swap: Swap a random segment with another segment of similar length\n    if n > 3:\n        seg_len = random.randint(2, min(5, n // 2))\n        k = random.randint(0, n - seg_len)\n        segment_k = new_solution[k:k+seg_len]\n\n        # Find another segment of similar length\n        l = random.randint(0, n - seg_len)\n        while abs(l - k) < seg_len:  # Ensure segments are not overlapping\n            l = random.randint(0, n - seg_len)\n\n        segment_l = new_solution[l:l+seg_len]\n        new_solution[k:k+seg_len] = segment_l\n        new_solution[l:l+seg_len] = segment_k\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 119,
        "algorithm": "{A novel hybrid local search operator combines edge-swapping with path-relinking, iteratively selecting promising edges from non-dominated solutions in the archive and merging them with a base solution to create high-quality neighbors, while ensuring feasibility through careful edge validation and cycle detection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with high potential for improvement\n    base_solution, _ = max(archive, key=lambda x: np.mean(x[1]))\n\n    # Create a neighbor using a hybrid edge-swapping and path-relinking approach\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two non-adjacent edges to swap\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n    if j - i == 1 or (j == n-1 and i == 0):\n        # If adjacent, try to find non-adjacent edges\n        candidates = [(a, b) for a in range(n) for b in range(a+2, n) if b != (a+1) % n]\n        if candidates:\n            i, j = candidates[np.random.randint(len(candidates))]\n\n    # Perform edge-swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply path-relinking with another random solution from archive\n    if len(archive) > 1:\n        other_solution, _ = archive[np.random.randint(1, len(archive))]\n        # Find common edges and merge paths\n        common_edges = set(zip(base_solution, np.roll(base_solution, -1))) & set(zip(other_solution, np.roll(other_solution, -1)))\n        if common_edges:\n            edge = common_edges.pop()\n            # Find paths from base to other solution and merge\n            idx1 = np.where((base_solution == edge[0]) & (np.roll(base_solution, -1) == edge[1]))[0][0]\n            idx2 = np.where((other_solution == edge[0]) & (np.roll(other_solution, -1) == edge[1]))[0][0]\n            path1 = base_solution[idx1:idx1+2]\n            path2 = other_solution[idx2:idx2+2]\n            # Merge paths ensuring no duplicates\n            merged = np.concatenate([path1, path2[::-1]])\n            unique, indices = np.unique(merged, return_index=True)\n            merged = merged[np.sort(indices)]\n            # Replace segment in new_solution\n            start = np.where(new_solution == edge[0])[0][0]\n            end = np.where(new_solution == edge[1])[0][0]\n            if start > end:\n                new_solution = np.concatenate([new_solution[end:start+1], new_solution[start+1:], new_solution[:end]])\n            else:\n                new_solution = np.concatenate([new_solution[:start], new_solution[end:], new_solution[start:end+1]])\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9600650638992427,
            3.8733893036842346
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with high potential for improvement\n    base_solution, _ = max(archive, key=lambda x: np.mean(x[1]))\n\n    # Create a neighbor using a hybrid edge-swapping and path-relinking approach\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two non-adjacent edges to swap\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n    if j - i == 1 or (j == n-1 and i == 0):\n        # If adjacent, try to find non-adjacent edges\n        candidates = [(a, b) for a in range(n) for b in range(a+2, n) if b != (a+1) % n]\n        if candidates:\n            i, j = candidates[np.random.randint(len(candidates))]\n\n    # Perform edge-swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply path-relinking with another random solution from archive\n    if len(archive) > 1:\n        other_solution, _ = archive[np.random.randint(1, len(archive))]\n        # Find common edges and merge paths\n        common_edges = set(zip(base_solution, np.roll(base_solution, -1))) & set(zip(other_solution, np.roll(other_solution, -1)))\n        if common_edges:\n            edge = common_edges.pop()\n            # Find paths from base to other solution and merge\n            idx1 = np.where((base_solution == edge[0]) & (np.roll(base_solution, -1) == edge[1]))[0][0]\n            idx2 = np.where((other_solution == edge[0]) & (np.roll(other_solution, -1) == edge[1]))[0][0]\n            path1 = base_solution[idx1:idx1+2]\n            path2 = other_solution[idx2:idx2+2]\n            # Merge paths ensuring no duplicates\n            merged = np.concatenate([path1, path2[::-1]])\n            unique, indices = np.unique(merged, return_index=True)\n            merged = merged[np.sort(indices)]\n            # Replace segment in new_solution\n            start = np.where(new_solution == edge[0])[0][0]\n            end = np.where(new_solution == edge[1])[0][0]\n            if start > end:\n                new_solution = np.concatenate([new_solution[end:start+1], new_solution[start+1:], new_solution[:end]])\n            else:\n                new_solution = np.concatenate([new_solution[:start], new_solution[end:], new_solution[start:end+1]])\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 120,
        "algorithm": "{A novel hybrid local search operator combines edge swapping with a dynamic segment reversal strategy, prioritizing non-dominated solutions in the archive to balance exploration and exploitation, while ensuring feasibility through careful edge validation and segment selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (non-dominated or with high diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with dynamic segment length\n    n = len(new_solution)\n    segment_length = np.random.randint(2, min(5, n // 2))  # Dynamic segment length\n    start = np.random.randint(0, n - segment_length)\n\n    # Reverse the segment to create a new neighbor\n    segment = new_solution[start:start + segment_length]\n    new_solution[start:start + segment_length] = segment[::-1]\n\n    # Validate the new solution is a valid tour\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7722337839833882,
            2.112805426120758
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (non-dominated or with high diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with dynamic segment length\n    n = len(new_solution)\n    segment_length = np.random.randint(2, min(5, n // 2))  # Dynamic segment length\n    start = np.random.randint(0, n - segment_length)\n\n    # Reverse the segment to create a new neighbor\n    segment = new_solution[start:start + segment_length]\n    new_solution[start:start + segment_length] = segment[::-1]\n\n    # Validate the new solution is a valid tour\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 121,
        "algorithm": "{A novel hybrid local search operator combines a randomized 2-opt-like segment reversal with a multi-objective aware segment insertion heuristic to intelligently explore the solution space while ensuring feasibility, prioritizing solutions with high potential for improvement in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = 1 - normalized.mean(axis=1)  # Higher weight for solutions with worse objectives\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Segment reversal with multi-objective aware insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Multi-objective aware insertion: Find best insertion point for the reversed segment\n    best_insert_pos = -1\n    min_total_cost = float('inf')\n\n    for i in range(n):\n        if i >= a and i <= b:\n            continue  # Skip positions within the reversed segment\n\n        # Try inserting the reversed segment at position i\n        candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n        cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        total_cost = cost1 + cost2  # Simple aggregation; could be replaced with Pareto-dominance check\n\n        if total_cost < min_total_cost:\n            min_total_cost = total_cost\n            best_insert_pos = i\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9883445750493569,
            6.949977397918701
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = 1 - normalized.mean(axis=1)  # Higher weight for solutions with worse objectives\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Segment reversal with multi-objective aware insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Multi-objective aware insertion: Find best insertion point for the reversed segment\n    best_insert_pos = -1\n    min_total_cost = float('inf')\n\n    for i in range(n):\n        if i >= a and i <= b:\n            continue  # Skip positions within the reversed segment\n\n        # Try inserting the reversed segment at position i\n        candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n        cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        total_cost = cost1 + cost2  # Simple aggregation; could be replaced with Pareto-dominance check\n\n        if total_cost < min_total_cost:\n            min_total_cost = total_cost\n            best_insert_pos = i\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 122,
        "algorithm": "{A novel hybrid local search algorithm that intelligently combines edge exchange, node reinsertion, and path relinking to explore high-quality solutions in bi-objective TSP by dynamically selecting the most promising operator based on the current solution's structure and objective trade-offs.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange, node reinsertion, and path relinking\n    n = len(base_solution)\n\n    # Step 1: Edge exchange (swap two edges)\n    if n > 3:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Node reinsertion (remove and reinsert a node)\n    if n > 2:\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 3: Path relinking (blend with another solution)\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0]\n        for i in range(n):\n            if np.random.rand() < 0.3:  # 30% chance to take node from other solution\n                node = other_solution[i]\n                if node not in new_solution:\n                    new_solution[i] = node\n\n    # Ensure feasibility (no duplicates and all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.8929114055749057,
            2.646850347518921
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange, node reinsertion, and path relinking\n    n = len(base_solution)\n\n    # Step 1: Edge exchange (swap two edges)\n    if n > 3:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Node reinsertion (remove and reinsert a node)\n    if n > 2:\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 3: Path relinking (blend with another solution)\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0]\n        for i in range(n):\n            if np.random.rand() < 0.3:  # 30% chance to take node from other solution\n                node = other_solution[i]\n                if node not in new_solution:\n                    new_solution[i] = node\n\n    # Ensure feasibility (no duplicates and all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 123,
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive segment inversion with dynamic edge swapping, prioritizing non-dominated segments and leveraging multi-objective edge importance metrics to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high variance in objectives)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate edge importance scores combining both objectives\n    n = len(base_solution)\n    edge_scores = np.zeros(n)\n    for i in range(n):\n        u, v = base_solution[i], base_solution[(i + 1) % n]\n        edge_scores[i] = distance_matrix_1[u, v] + distance_matrix_2[u, v]\n\n    # Identify segments to invert or swap based on edge importance\n    threshold = np.percentile(edge_scores, 75)\n    critical_edges = np.where(edge_scores > threshold)[0]\n\n    if len(critical_edges) >= 2:\n        # Hybrid local search: adaptive segment inversion or dynamic edge swapping\n        if random.random() < 0.7:  # 70% chance for adaptive segment inversion\n            # Select two critical edges and invert the segment between them\n            a, b = random.sample(list(critical_edges), 2)\n            a, b = min(a, b), max(a, b)\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        else:  # 30% chance for dynamic edge swapping\n            # Swap two edges that are not adjacent\n            i, j = random.sample(range(n), 2)\n            if abs(i - j) > 1:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Fallback to simple swap if not enough critical edges\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8879133761704774,
            3.022653818130493
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high variance in objectives)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate edge importance scores combining both objectives\n    n = len(base_solution)\n    edge_scores = np.zeros(n)\n    for i in range(n):\n        u, v = base_solution[i], base_solution[(i + 1) % n]\n        edge_scores[i] = distance_matrix_1[u, v] + distance_matrix_2[u, v]\n\n    # Identify segments to invert or swap based on edge importance\n    threshold = np.percentile(edge_scores, 75)\n    critical_edges = np.where(edge_scores > threshold)[0]\n\n    if len(critical_edges) >= 2:\n        # Hybrid local search: adaptive segment inversion or dynamic edge swapping\n        if random.random() < 0.7:  # 70% chance for adaptive segment inversion\n            # Select two critical edges and invert the segment between them\n            a, b = random.sample(list(critical_edges), 2)\n            a, b = min(a, b), max(a, b)\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        else:  # 30% chance for dynamic edge swapping\n            # Swap two edges that are not adjacent\n            i, j = random.sample(range(n), 2)\n            if abs(i - j) > 1:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Fallback to simple swap if not enough critical edges\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 124,
        "algorithm": "{A novel hybrid local search strategy combines adaptive segment reversal with multi-objective k-opt moves, dynamically adjusting segment lengths based on the relative costs of the two objectives to explore diverse neighborhoods while preserving feasibility and promoting Pareto-efficient improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive)-1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive k-opt with dynamic segment lengths\n    n = len(base_solution)\n    k = random.randint(2, min(5, n//2))  # Random k for k-opt\n\n    # Select k segments to reverse or shift\n    segments = sorted(random.sample(range(1, n), k))\n    segments = [0] + segments + [n]\n\n    # Apply adaptive reversal/shift based on objective costs\n    for i in range(len(segments)-1):\n        start, end = segments[i], segments[i+1]\n        if random.random() < 0.7:  # Higher probability for reversal\n            new_solution[start:end] = new_solution[start:end][::-1]\n        else:  # Shift segment\n            shift_size = random.randint(1, min(3, end-start))\n            new_solution[start:end] = np.roll(new_solution[start:end], shift_size)\n\n    # Ensure validity by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt like move\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7487564732150453,
            2.1574320793151855
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive)-1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive k-opt with dynamic segment lengths\n    n = len(base_solution)\n    k = random.randint(2, min(5, n//2))  # Random k for k-opt\n\n    # Select k segments to reverse or shift\n    segments = sorted(random.sample(range(1, n), k))\n    segments = [0] + segments + [n]\n\n    # Apply adaptive reversal/shift based on objective costs\n    for i in range(len(segments)-1):\n        start, end = segments[i], segments[i+1]\n        if random.random() < 0.7:  # Higher probability for reversal\n            new_solution[start:end] = new_solution[start:end][::-1]\n        else:  # Shift segment\n            shift_size = random.randint(1, min(3, end-start))\n            new_solution[start:end] = np.roll(new_solution[start:end], shift_size)\n\n    # Ensure validity by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt like move\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 125,
        "algorithm": "{The algorithm selects a solution from the archive based on a hybrid of Pareto dominance and crowding distance, then applies a novel 3-opt-like local search that intelligently combines edge swaps and partial route reversals to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or non-dominated\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate crowding distances\n    crowding_distances = np.zeros(len(solutions))\n    for i in range(2):  # For each objective\n        sorted_indices = np.argsort([obj[i] for obj in objectives])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        if len(solutions) > 2:\n            for j in range(1, len(solutions)-1):\n                crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1]][i] - objectives[sorted_indices[j-1]][i]) / (objectives[sorted_indices[-1]][i] - objectives[sorted_indices[0]][i])\n\n    # Combine Pareto dominance and crowding distance for selection\n    non_dominated = []\n    for i, sol in enumerate(solutions):\n        is_dominated = False\n        for j, other_sol in enumerate(solutions):\n            if i != j and objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1] and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append(i)\n\n    # Prefer non-dominated solutions with high crowding distance\n    if non_dominated:\n        candidates = [i for i in non_dominated if crowding_distances[i] > 0]\n        if candidates:\n            selected_idx = random.choice(candidates)\n        else:\n            selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = np.argmax(crowding_distances)\n\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt-like with partial reversals\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select 3 distinct edges to modify\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Apply the hybrid move\n    if random.random() < 0.5:\n        # Partial reversal between b and c\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n    else:\n        # Edge swap between (a,b) and (b,c)\n        new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7532648009464058,
            2.196004569530487
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or non-dominated\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate crowding distances\n    crowding_distances = np.zeros(len(solutions))\n    for i in range(2):  # For each objective\n        sorted_indices = np.argsort([obj[i] for obj in objectives])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        if len(solutions) > 2:\n            for j in range(1, len(solutions)-1):\n                crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1]][i] - objectives[sorted_indices[j-1]][i]) / (objectives[sorted_indices[-1]][i] - objectives[sorted_indices[0]][i])\n\n    # Combine Pareto dominance and crowding distance for selection\n    non_dominated = []\n    for i, sol in enumerate(solutions):\n        is_dominated = False\n        for j, other_sol in enumerate(solutions):\n            if i != j and objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1] and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append(i)\n\n    # Prefer non-dominated solutions with high crowding distance\n    if non_dominated:\n        candidates = [i for i in non_dominated if crowding_distances[i] > 0]\n        if candidates:\n            selected_idx = random.choice(candidates)\n        else:\n            selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = np.argmax(crowding_distances)\n\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt-like with partial reversals\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select 3 distinct edges to modify\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Apply the hybrid move\n    if random.random() < 0.5:\n        # Partial reversal between b and c\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n    else:\n        # Edge swap between (a,b) and (b,c)\n        new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 126,
        "algorithm": "{This algorithm selects a promising solution from the archive by prioritizing those with the highest sum of normalized objective values, then applies a hybrid local search combining edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal with edge insertion\n    if n >= 4:\n        # Randomly select two segments\n        i, j = sorted(random.sample(range(1, n), 2))\n        k, l = sorted(random.sample(range(1, n), 2))\n\n        # Reverse the first segment\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Insert the second segment\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[l:]])\n\n        # Ensure no node is repeated (feasibility check)\n        if len(np.unique(new_solution)) != n:\n            # If invalid, revert to base solution\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8522228475500541,
            1.385624885559082
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal with edge insertion\n    if n >= 4:\n        # Randomly select two segments\n        i, j = sorted(random.sample(range(1, n), 2))\n        k, l = sorted(random.sample(range(1, n), 2))\n\n        # Reverse the first segment\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Insert the second segment\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[l:]])\n\n        # Ensure no node is repeated (feasibility check)\n        if len(np.unique(new_solution)) != n:\n            # If invalid, revert to base solution\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 127,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest potential for improvement (lowest objective values)\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n\n    # Generate a neighbor using a hybrid local search: edge swap + path reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Perform an edge swap to further refine\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i != j:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7795240669034129,
            2.263802647590637
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest potential for improvement (lowest objective values)\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n\n    # Generate a neighbor using a hybrid local search: edge swap + path reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Perform an edge swap to further refine\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i != j:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 128,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_idx = 0\n    min_cost = float('inf')\n    for i, (sol, (cost1, cost2)) in enumerate(archive):\n        combined_cost = 0.5 * cost1 + 0.5 * cost2\n        if combined_cost < min_cost:\n            min_cost = combined_cost\n            best_idx = i\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge-swapping strategy\n    n = len(new_solution)\n    for i in range(n - 2):\n        for j in range(i + 2, n):\n            # Standard 2-opt\n            if j - i > 1:\n                new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n            # Novel edge-swapping: swap edges between non-adjacent nodes\n            if j - i > 2 and np.random.rand() < 0.5:\n                k = np.random.randint(i + 1, j)\n                new_solution[k], new_solution[j] = new_solution[j], new_solution[k]\n\n            # Check feasibility and keep if better\n            if np.all(np.unique(new_solution) == np.arange(n)):\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.8137120513976013,
            5.765724360942841
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_idx = 0\n    min_cost = float('inf')\n    for i, (sol, (cost1, cost2)) in enumerate(archive):\n        combined_cost = 0.5 * cost1 + 0.5 * cost2\n        if combined_cost < min_cost:\n            min_cost = combined_cost\n            best_idx = i\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge-swapping strategy\n    n = len(new_solution)\n    for i in range(n - 2):\n        for j in range(i + 2, n):\n            # Standard 2-opt\n            if j - i > 1:\n                new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n            # Novel edge-swapping: swap edges between non-adjacent nodes\n            if j - i > 2 and np.random.rand() < 0.5:\n                k = np.random.randint(i + 1, j)\n                new_solution[k], new_solution[j] = new_solution[j], new_solution[k]\n\n            # Check feasibility and keep if better\n            if np.all(np.unique(new_solution) == np.arange(n)):\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 129,
        "algorithm": "{The algorithm intelligently selects a high-performing solution from the archive by prioritizing those with lower combined objective values, then applies a hybrid local search combining edge swaps and segment reversals to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swap + segment reversal\n    n = len(new_solution)\n    if n >= 4:\n        # Edge swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment reversal\n        start, end = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9025144827017466,
            1.5914838910102844
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swap + segment reversal\n    n = len(new_solution)\n    if n >= 4:\n        # Edge swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment reversal\n        start, end = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 130,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected = archive_sorted[min(3, len(archive_sorted) - 1)][0].copy()\n\n    # Hybrid local search: combine edge reversal and node insertion\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Edge reversal (partial 2-opt)\n    i, j = np.random.randint(0, n, size=2)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Node insertion with objective-aware selection\n    if np.random.rand() < 0.5:\n        # Select a node with high potential for improvement\n        node_to_move = np.random.choice(new_solution)\n        idx = np.where(new_solution == node_to_move)[0][0]\n        new_solution = np.delete(new_solution, idx)\n        # Insert at position that improves both objectives\n        best_pos = 0\n        best_score = float('inf')\n        for pos in range(len(new_solution)):\n            temp_solution = np.insert(new_solution, pos, node_to_move)\n            cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            if cost1 + cost2 < best_score:\n                best_score = cost1 + cost2\n                best_pos = pos\n        new_solution = np.insert(new_solution, best_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.6246031207572366,
            8.432058155536652
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected = archive_sorted[min(3, len(archive_sorted) - 1)][0].copy()\n\n    # Hybrid local search: combine edge reversal and node insertion\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Edge reversal (partial 2-opt)\n    i, j = np.random.randint(0, n, size=2)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Node insertion with objective-aware selection\n    if np.random.rand() < 0.5:\n        # Select a node with high potential for improvement\n        node_to_move = np.random.choice(new_solution)\n        idx = np.where(new_solution == node_to_move)[0][0]\n        new_solution = np.delete(new_solution, idx)\n        # Insert at position that improves both objectives\n        best_pos = 0\n        best_score = float('inf')\n        for pos in range(len(new_solution)):\n            temp_solution = np.insert(new_solution, pos, node_to_move)\n            cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            if cost1 + cost2 < best_score:\n                best_score = cost1 + cost2\n                best_pos = pos\n        new_solution = np.insert(new_solution, best_pos, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 131,
        "algorithm": "{A novel hybrid local search algorithm combines a multi-objective clustering step to identify promising regions in the archive, followed by a dynamic 3-opt-like move that adaptively selects segments based on both objective costs and spatial proximity, ensuring feasibility while exploring diverse neighborhoods.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Use a combination of Pareto dominance and crowding distance to select a solution\n    def pareto_dominance(a, b):\n        return (a[0] <= b[0] and a[1] <= b[1]) and (a[0] < b[0] or a[1] < b[1])\n\n    def crowding_distance(solutions, objectives):\n        distances = np.zeros(len(solutions))\n        for m in range(2):\n            sorted_idx = np.argsort([obj[m] for obj in objectives])\n            distances[sorted_idx[0]] = np.inf\n            distances[sorted_idx[-1]] = np.inf\n            for i in range(1, len(solutions) - 1):\n                if objectives[sorted_idx[i+1]][m] == objectives[sorted_idx[i-1]][m]:\n                    continue\n                distances[sorted_idx[i]] += (objectives[sorted_idx[i+1]][m] - objectives[sorted_idx[i-1]][m]) / (objectives[sorted_idx[-1]][m] - objectives[sorted_idx[0]][m])\n        return distances\n\n    objectives = [obj for _, obj in archive]\n    solutions = [sol for sol, _ in archive]\n\n    # Identify non-dominated solutions\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and pareto_dominance(other_obj, obj):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        # Select from non-dominated solutions using crowding distance\n        non_dominated_solutions = [solutions[i] for i in non_dominated]\n        non_dominated_objectives = [objectives[i] for i in non_dominated]\n        distances = crowding_distance(non_dominated_solutions, non_dominated_objectives)\n        selected_idx = np.argmax(distances)\n        base_solution = non_dominated_solutions[selected_idx].copy()\n    else:\n        # If no non-dominated solutions, select randomly\n        selected_idx = random.randint(0, len(archive) - 1)\n        base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a novel hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select three random segments to modify (dynamic 3-opt-like move)\n    a, b, c = sorted(random.sample(range(1, n-1), 3))\n\n    # Create three segments: [0..a-1], [a..b-1], [b..c-1], [c..n]\n    segments = [\n        new_solution[:a],\n        new_solution[a:b],\n        new_solution[b:c],\n        new_solution[c:]\n    ]\n\n    # Recombine segments in a new order that minimizes both objectives\n    possible_orders = [\n        [segments[0], segments[1], segments[2], segments[3]],\n        [segments[0], segments[1], segments[3], segments[2]],\n        [segments[0], segments[2], segments[1], segments[3]],\n        [segments[0], segments[2], segments[3], segments[1]],\n        [segments[0], segments[3], segments[1], segments[2]],\n        [segments[0], segments[3], segments[2], segments[1]],\n    ]\n\n    best_order = None\n    best_cost = (float('inf'), float('inf'))\n\n    for order in possible_orders:\n        candidate = np.concatenate(order)\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(1, n)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(1, n)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n        # Use a weighted sum to balance both objectives\n        weight = 0.5\n        total_cost = weight * cost1 + (1 - weight) * cost2\n\n        if total_cost < sum(best_cost):\n            best_cost = (cost1, cost2)\n            best_order = order\n\n    if best_order:\n        new_solution = np.concatenate(best_order)\n\n    return new_solution\n\n",
        "score": [
            -0.662898100614769,
            2.169652998447418
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Use a combination of Pareto dominance and crowding distance to select a solution\n    def pareto_dominance(a, b):\n        return (a[0] <= b[0] and a[1] <= b[1]) and (a[0] < b[0] or a[1] < b[1])\n\n    def crowding_distance(solutions, objectives):\n        distances = np.zeros(len(solutions))\n        for m in range(2):\n            sorted_idx = np.argsort([obj[m] for obj in objectives])\n            distances[sorted_idx[0]] = np.inf\n            distances[sorted_idx[-1]] = np.inf\n            for i in range(1, len(solutions) - 1):\n                if objectives[sorted_idx[i+1]][m] == objectives[sorted_idx[i-1]][m]:\n                    continue\n                distances[sorted_idx[i]] += (objectives[sorted_idx[i+1]][m] - objectives[sorted_idx[i-1]][m]) / (objectives[sorted_idx[-1]][m] - objectives[sorted_idx[0]][m])\n        return distances\n\n    objectives = [obj for _, obj in archive]\n    solutions = [sol for sol, _ in archive]\n\n    # Identify non-dominated solutions\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and pareto_dominance(other_obj, obj):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        # Select from non-dominated solutions using crowding distance\n        non_dominated_solutions = [solutions[i] for i in non_dominated]\n        non_dominated_objectives = [objectives[i] for i in non_dominated]\n        distances = crowding_distance(non_dominated_solutions, non_dominated_objectives)\n        selected_idx = np.argmax(distances)\n        base_solution = non_dominated_solutions[selected_idx].copy()\n    else:\n        # If no non-dominated solutions, select randomly\n        selected_idx = random.randint(0, len(archive) - 1)\n        base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a novel hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select three random segments to modify (dynamic 3-opt-like move)\n    a, b, c = sorted(random.sample(range(1, n-1), 3))\n\n    # Create three segments: [0..a-1], [a..b-1], [b..c-1], [c..n]\n    segments = [\n        new_solution[:a],\n        new_solution[a:b],\n        new_solution[b:c],\n        new_solution[c:]\n    ]\n\n    # Recombine segments in a new order that minimizes both objectives\n    possible_orders = [\n        [segments[0], segments[1], segments[2], segments[3]],\n        [segments[0], segments[1], segments[3], segments[2]],\n        [segments[0], segments[2], segments[1], segments[3]],\n        [segments[0], segments[2], segments[3], segments[1]],\n        [segments[0], segments[3], segments[1], segments[2]],\n        [segments[0], segments[3], segments[2], segments[1]],\n    ]\n\n    best_order = None\n    best_cost = (float('inf'), float('inf'))\n\n    for order in possible_orders:\n        candidate = np.concatenate(order)\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(1, n)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(1, n)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n        # Use a weighted sum to balance both objectives\n        weight = 0.5\n        total_cost = weight * cost1 + (1 - weight) * cost2\n\n        if total_cost < sum(best_cost):\n            best_cost = (cost1, cost2)\n            best_order = order\n\n    if best_order:\n        new_solution = np.concatenate(best_order)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 132,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge-swap heuristic\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    # Reverse the segment (3-opt-like move)\n    segment = segment[::-1]\n    new_solution[a:b+1] = segment\n\n    # Custom edge-swap: if the segment is small, try swapping edges\n    if (b - a + 1) <= 3:\n        for _ in range(2):\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing = set(range(n)) - set(unique)\n        duplicates = unique[counts > 1]\n        for dup in duplicates:\n            for miss in missing:\n                if miss not in new_solution:\n                    new_solution[np.where(new_solution == dup)[0][1]] = miss\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7267604026135417,
            2.2270816564559937
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge-swap heuristic\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    # Reverse the segment (3-opt-like move)\n    segment = segment[::-1]\n    new_solution[a:b+1] = segment\n\n    # Custom edge-swap: if the segment is small, try swapping edges\n    if (b - a + 1) <= 3:\n        for _ in range(2):\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        missing = set(range(n)) - set(unique)\n        duplicates = unique[counts > 1]\n        for dup in duplicates:\n            for miss in missing:\n                if miss not in new_solution:\n                    new_solution[np.where(new_solution == dup)[0][1]] = miss\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 133,
        "algorithm": "{A novel hybrid local search operator combines a randomized segment reversal with a multi-objective edge exchange, prioritizing high-potential solutions from the archive by selecting those with the best Pareto front dominance while dynamically adjusting the search focus based on objective trade-offs.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% by combined cost)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    candidate_indices = min(5, len(archive_sorted))\n    selected_idx = random.randint(0, candidate_indices - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: randomized segment reversal + multi-objective edge exchange\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply operators\n\n    # Step 1: Random segment reversal\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 2: Multi-objective edge exchange\n    # Select two random edges and swap their nodes if it improves both objectives\n    i, j = sorted(random.sample(range(n), 2))\n    node_i, node_j = new_solution[i], new_solution[j]\n    cost_before = (distance_matrix_1[new_solution[i-1], node_i] + distance_matrix_1[node_i, new_solution[(i+1)%n]] +\n                   distance_matrix_1[new_solution[j-1], node_j] + distance_matrix_1[node_j, new_solution[(j+1)%n]] +\n                   distance_matrix_2[new_solution[i-1], node_i] + distance_matrix_2[node_i, new_solution[(i+1)%n]] +\n                   distance_matrix_2[new_solution[j-1], node_j] + distance_matrix_2[node_j, new_solution[(j+1)%n]])\n\n    # Swap nodes i and j\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    cost_after = (distance_matrix_1[new_solution[i-1], node_j] + distance_matrix_1[node_j, new_solution[(i+1)%n]] +\n                  distance_matrix_1[new_solution[j-1], node_i] + distance_matrix_1[node_i, new_solution[(j+1)%n]] +\n                  distance_matrix_2[new_solution[i-1], node_j] + distance_matrix_2[node_j, new_solution[(i+1)%n]] +\n                  distance_matrix_2[new_solution[j-1], node_i] + distance_matrix_2[node_i, new_solution[(j+1)%n]])\n\n    # Revert if not beneficial in both objectives\n    if cost_after >= cost_before:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6850851512892993,
            2.144261360168457
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% by combined cost)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    candidate_indices = min(5, len(archive_sorted))\n    selected_idx = random.randint(0, candidate_indices - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: randomized segment reversal + multi-objective edge exchange\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply operators\n\n    # Step 1: Random segment reversal\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 2: Multi-objective edge exchange\n    # Select two random edges and swap their nodes if it improves both objectives\n    i, j = sorted(random.sample(range(n), 2))\n    node_i, node_j = new_solution[i], new_solution[j]\n    cost_before = (distance_matrix_1[new_solution[i-1], node_i] + distance_matrix_1[node_i, new_solution[(i+1)%n]] +\n                   distance_matrix_1[new_solution[j-1], node_j] + distance_matrix_1[node_j, new_solution[(j+1)%n]] +\n                   distance_matrix_2[new_solution[i-1], node_i] + distance_matrix_2[node_i, new_solution[(i+1)%n]] +\n                   distance_matrix_2[new_solution[j-1], node_j] + distance_matrix_2[node_j, new_solution[(j+1)%n]])\n\n    # Swap nodes i and j\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    cost_after = (distance_matrix_1[new_solution[i-1], node_j] + distance_matrix_1[node_j, new_solution[(i+1)%n]] +\n                  distance_matrix_1[new_solution[j-1], node_i] + distance_matrix_1[node_i, new_solution[(j+1)%n]] +\n                  distance_matrix_2[new_solution[i-1], node_j] + distance_matrix_2[node_j, new_solution[(i+1)%n]] +\n                  distance_matrix_2[new_solution[j-1], node_i] + distance_matrix_2[node_i, new_solution[(j+1)%n]])\n\n    # Revert if not beneficial in both objectives\n    if cost_after >= cost_before:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 134,
        "algorithm": "{This heuristic function selects a solution from the archive based on a weighted randomness favoring high-potential solutions, then applies a novel hybrid local search combining 3-opt with a custom edge-swapping strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1.0 / (i + 1) for i in range(len(archive))]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with custom edge-swapping\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Randomly select 3 distinct edges to modify\n    edges = random.sample(range(n), 3)\n    edges.sort()\n\n    i, j, k = edges[0], edges[1], edges[2]\n\n    # Apply 3-opt move\n    if random.random() < 0.5:\n        # Reverse segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Reverse segment between j and k\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Custom edge-swapping: swap two non-adjacent edges\n    if random.random() < 0.3:\n        a, b = random.sample(range(n), 2)\n        if abs(a - b) > 1:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8547768010833263,
            1.7959972620010376
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1.0 / (i + 1) for i in range(len(archive))]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with custom edge-swapping\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Randomly select 3 distinct edges to modify\n    edges = random.sample(range(n), 3)\n    edges.sort()\n\n    i, j, k = edges[0], edges[1], edges[2]\n\n    # Apply 3-opt move\n    if random.random() < 0.5:\n        # Reverse segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Reverse segment between j and k\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Custom edge-swapping: swap two non-adjacent edges\n    if random.random() < 0.3:\n        a, b = random.sample(range(n), 2)\n        if abs(a - b) > 1:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 135,
        "algorithm": "{A novel hybrid local search operator combines a segment inversion strategy with a dynamic node reallocation mechanism, prioritizing solutions with high variance in objective costs to escape local optima while ensuring feasibility through a validation step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    variances = [abs(obj[0] - obj[1]) for (sol, obj) in archive]\n    if not variances:\n        return archive[0][0].copy()\n\n    max_variance_idx = np.argmax(variances)\n    base_solution = archive[max_variance_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply segment inversion\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select a segment to invert\n    start = np.random.randint(0, n - 2)\n    end = np.random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Dynamic node reallocation\n    for i in range(n):\n        if np.random.rand() < 0.1:  # 10% chance to reallocate a node\n            j = np.random.randint(0, n)\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate the solution is a valid tour\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.51921826038317,
            1.9507806897163391
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    variances = [abs(obj[0] - obj[1]) for (sol, obj) in archive]\n    if not variances:\n        return archive[0][0].copy()\n\n    max_variance_idx = np.argmax(variances)\n    base_solution = archive[max_variance_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply segment inversion\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select a segment to invert\n    start = np.random.randint(0, n - 2)\n    end = np.random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Dynamic node reallocation\n    for i in range(n):\n        if np.random.rand() < 0.1:  # 10% chance to reallocate a node\n            j = np.random.randint(0, n)\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate the solution is a valid tour\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 136,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search: combine edge insertion with segment reversal\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Reverse the first segment\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Insert the second segment at a random position\n    segment = new_solution[c:d]\n    insert_pos = random.randint(0, n - len(segment))\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility by removing duplicates\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    return new_solution\n\n",
        "score": [
            -0.9173961970523024,
            2.364371597766876
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search: combine edge insertion with segment reversal\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Reverse the first segment\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Insert the second segment at a random position\n    segment = new_solution[c:d]\n    insert_pos = random.randint(0, n - len(segment))\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility by removing duplicates\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 137,
        "algorithm": "{This heuristic selects a solution from the archive with high potential for local improvement by prioritizing those with below-average objective values, then applies a hybrid local search combining edge exchange and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    avg_obj = np.mean(objectives, axis=0)\n    candidates = [(sol, obj) for sol, obj in archive if (obj[0] < avg_obj[0] or obj[1] < avg_obj[1])]\n    if not candidates:\n        candidates = archive\n    selected = min(candidates, key=lambda x: sum(x[1]))[0]\n    base_solution = selected.copy()\n\n    # Hybrid local search: edge exchange + node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge exchange (swap two edges)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Node insertion (move a random node to a new position)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to edge exchange if insertion fails\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution = base_solution.copy()\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7607576981668263,
            1.6867411136627197
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    avg_obj = np.mean(objectives, axis=0)\n    candidates = [(sol, obj) for sol, obj in archive if (obj[0] < avg_obj[0] or obj[1] < avg_obj[1])]\n    if not candidates:\n        candidates = archive\n    selected = min(candidates, key=lambda x: sum(x[1]))[0]\n    base_solution = selected.copy()\n\n    # Hybrid local search: edge exchange + node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge exchange (swap two edges)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Node insertion (move a random node to a new position)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to edge exchange if insertion fails\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution = base_solution.copy()\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 138,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a biased random swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct positions to perform a 3-opt\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Apply 3-opt move\n    new_solution[a:b] = base_solution[a:b][::-1]\n    new_solution[b:c] = base_solution[b:c][::-1]\n\n    # With 50% probability, perform an additional biased random swap\n    if np.random.rand() < 0.5:\n        # Find the worst edge in both objectives\n        worst_edge = -1\n        max_diff = -1\n        for i in range(n):\n            j = (i + 1) % n\n            diff = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                    distance_matrix_2[new_solution[i], new_solution[j]])\n            if diff > max_diff:\n                max_diff = diff\n                worst_edge = i\n\n        if worst_edge != -1:\n            # Swap the worst edge with a random other edge\n            swap_pos = np.random.randint(0, n)\n            new_solution[worst_edge], new_solution[swap_pos] = new_solution[swap_pos], new_solution[worst_edge]\n\n    return new_solution\n\n",
        "score": [
            -0.9096548768925508,
            1.5745766162872314
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a biased random swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct positions to perform a 3-opt\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Apply 3-opt move\n    new_solution[a:b] = base_solution[a:b][::-1]\n    new_solution[b:c] = base_solution[b:c][::-1]\n\n    # With 50% probability, perform an additional biased random swap\n    if np.random.rand() < 0.5:\n        # Find the worst edge in both objectives\n        worst_edge = -1\n        max_diff = -1\n        for i in range(n):\n            j = (i + 1) % n\n            diff = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                    distance_matrix_2[new_solution[i], new_solution[j]])\n            if diff > max_diff:\n                max_diff = diff\n                worst_edge = i\n\n        if worst_edge != -1:\n            # Swap the worst edge with a random other edge\n            swap_pos = np.random.randint(0, n)\n            new_solution[worst_edge], new_solution[swap_pos] = new_solution[swap_pos], new_solution[worst_edge]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 139,
        "algorithm": "{The algorithm intelligently selects a solution from the archive by prioritizing those with high crowding distances or low objective values, then applies a hybrid local search combining edge swaps, node insertions, and a novel segment reversal strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution from the archive (prioritize those with high crowding distance or low objectives)\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / sum(x[1]))[0].copy()\n\n    # Hybrid local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of three local search strategies\n    strategy = random.choice(['edge_swap', 'node_insertion', 'segment_reversal'])\n\n    if strategy == 'edge_swap':\n        # Perform a random edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif strategy == 'node_insertion':\n        # Perform a random node insertion\n        i, j = sorted(random.sample(range(n), 2))\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    elif strategy == 'segment_reversal':\n        # Reverse a random segment of the tour\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6046307536002709,
            1.797491729259491
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution from the archive (prioritize those with high crowding distance or low objectives)\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / sum(x[1]))[0].copy()\n\n    # Hybrid local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of three local search strategies\n    strategy = random.choice(['edge_swap', 'node_insertion', 'segment_reversal'])\n\n    if strategy == 'edge_swap':\n        # Perform a random edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif strategy == 'node_insertion':\n        # Perform a random node insertion\n        i, j = sorted(random.sample(range(n), 2))\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    elif strategy == 'segment_reversal':\n        # Reverse a random segment of the tour\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 140,
        "algorithm": "{This heuristic selects a solution from the archive based on the average of its normalized objective values, then applies a hybrid local search combining edge swaps with a novel segment-based relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best average normalized objective\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    scores = np.mean(normalized, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: segment-based relocation with edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to relocate\n    start = np.random.randint(0, n - 2)\n    end = np.random.randint(start + 1, n)\n    segment = new_solution[start:end]\n\n    # Find the best insertion point for the segment\n    best_cost = float('inf')\n    best_pos = -1\n\n    for i in range(n - len(segment)):\n        if i >= start and i < end:\n            continue  # Skip the original segment position\n\n        # Temporarily insert the segment\n        temp_solution = np.concatenate([\n            new_solution[:i],\n            segment,\n            new_solution[i:start],\n            new_solution[end:]\n        ])\n\n        # Calculate the cost of the new solution\n        cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = i\n\n    if best_pos != -1:\n        # Perform the best segment relocation\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            segment,\n            new_solution[best_pos:start],\n            new_solution[end:]\n        ])\n\n    # Apply additional edge swaps for local refinement\n    for _ in range(min(3, n // 2)):\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate the cost before swap\n        before_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        before_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Calculate the cost after swap\n        after_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                       distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                       distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                       distance_matrix_1[new_solution[(i+1)%n], new_solution[j]])\n        after_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                       distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] +\n                       distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                       distance_matrix_2[new_solution[(i+1)%n], new_solution[j]])\n\n        if (after_cost1 + after_cost2) < (before_cost1 + before_cost2):\n            # Perform the swap\n            new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    return new_solution\n\n",
        "score": [
            -0.7117413647088875,
            7.664077639579773
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best average normalized objective\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    scores = np.mean(normalized, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: segment-based relocation with edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to relocate\n    start = np.random.randint(0, n - 2)\n    end = np.random.randint(start + 1, n)\n    segment = new_solution[start:end]\n\n    # Find the best insertion point for the segment\n    best_cost = float('inf')\n    best_pos = -1\n\n    for i in range(n - len(segment)):\n        if i >= start and i < end:\n            continue  # Skip the original segment position\n\n        # Temporarily insert the segment\n        temp_solution = np.concatenate([\n            new_solution[:i],\n            segment,\n            new_solution[i:start],\n            new_solution[end:]\n        ])\n\n        # Calculate the cost of the new solution\n        cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = i\n\n    if best_pos != -1:\n        # Perform the best segment relocation\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            segment,\n            new_solution[best_pos:start],\n            new_solution[end:]\n        ])\n\n    # Apply additional edge swaps for local refinement\n    for _ in range(min(3, n // 2)):\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate the cost before swap\n        before_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        before_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Calculate the cost after swap\n        after_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                       distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                       distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                       distance_matrix_1[new_solution[(i+1)%n], new_solution[j]])\n        after_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                       distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] +\n                       distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                       distance_matrix_2[new_solution[(i+1)%n], new_solution[j]])\n\n        if (after_cost1 + after_cost2) < (before_cost1 + before_cost2):\n            # Perform the swap\n            new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 141,
        "algorithm": "{A novel hybrid local search operator combines edge swapping with a dynamic segment reversal strategy, guided by Pareto dominance and objective-space diversity to explore high-quality solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (can be replaced with dominance-based selection)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the top 30% with a bias towards higher-ranked ones\n        selection_pool = sorted_archive[:max(1, len(archive) // 3)]\n        probabilities = np.linspace(1.0, 0.1, len(selection_pool))  # Higher probability for better solutions\n        probabilities /= probabilities.sum()\n        selected_idx = np.random.choice(len(selection_pool), p=probabilities)\n        base_solution = selection_pool[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Step 1: Select a segment to reverse (dynamic segment size)\n    segment_size = min(4, n // 2)  # Segment size between 2 and 4 nodes\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n    segment = new_solution[start:end]\n\n    # Step 2: Reverse the segment with probability 0.7, otherwise swap edges\n    if random.random() < 0.7:\n        new_solution[start:end] = segment[::-1]\n    else:\n        # Swap edges between segment and the rest of the solution\n        if start > 0 and end < n:\n            new_solution[start-1], new_solution[end] = new_solution[end], new_solution[start-1]\n\n    # Step 3: Perform edge swapping based on objective-space diversity\n    i, j = random.sample(range(n), 2)\n    # Check if swapping these edges improves at least one objective\n    original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n    new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n    original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n    new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n    if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7147597142335642,
            2.023814558982849
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (can be replaced with dominance-based selection)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the top 30% with a bias towards higher-ranked ones\n        selection_pool = sorted_archive[:max(1, len(archive) // 3)]\n        probabilities = np.linspace(1.0, 0.1, len(selection_pool))  # Higher probability for better solutions\n        probabilities /= probabilities.sum()\n        selected_idx = np.random.choice(len(selection_pool), p=probabilities)\n        base_solution = selection_pool[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Step 1: Select a segment to reverse (dynamic segment size)\n    segment_size = min(4, n // 2)  # Segment size between 2 and 4 nodes\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n    segment = new_solution[start:end]\n\n    # Step 2: Reverse the segment with probability 0.7, otherwise swap edges\n    if random.random() < 0.7:\n        new_solution[start:end] = segment[::-1]\n    else:\n        # Swap edges between segment and the rest of the solution\n        if start > 0 and end < n:\n            new_solution[start-1], new_solution[end] = new_solution[end], new_solution[start-1]\n\n    # Step 3: Perform edge swapping based on objective-space diversity\n    i, j = random.sample(range(n), 2)\n    # Check if swapping these edges improves at least one objective\n    original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n    new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n    original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n    new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n    if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 142,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge exchange\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two segments to reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Randomly select two edges to exchange\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if c != d:\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7891967901994993,
            2.3156235814094543
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge exchange\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two segments to reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Randomly select two edges to exchange\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if c != d:\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 143,
        "algorithm": "{A novel heuristic function that selects a promising solution from the archive based on a combination of cost dominance and diversity, then applies a hybrid local search combining edge insertion and node swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def select_candidate():\n        # Sort solutions by their objective values (ascending)\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        # Select top 20% of solutions\n        top_candidates = sorted_archive[:max(1, len(sorted_archive) // 5)]\n        # Randomly select one from top candidates\n        return top_candidates[np.random.randint(0, len(top_candidates))][0]\n\n    base_solution = select_candidate().copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Edge insertion + Node swapping\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful changes\n\n    # Edge insertion step\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    # Remove nodes between i and j\n    removed_nodes = new_solution[i+1:j]\n    # Reinsert them in reverse order\n    new_solution = np.concatenate([new_solution[:i+1], removed_nodes[::-1], new_solution[j:]])\n\n    # Node swapping step\n    k, l = np.random.choice(n, 2, replace=False)\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution is still a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8097459232877908,
            1.987980604171753
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def select_candidate():\n        # Sort solutions by their objective values (ascending)\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        # Select top 20% of solutions\n        top_candidates = sorted_archive[:max(1, len(sorted_archive) // 5)]\n        # Randomly select one from top candidates\n        return top_candidates[np.random.randint(0, len(top_candidates))][0]\n\n    base_solution = select_candidate().copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Edge insertion + Node swapping\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful changes\n\n    # Edge insertion step\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    # Remove nodes between i and j\n    removed_nodes = new_solution[i+1:j]\n    # Reinsert them in reverse order\n    new_solution = np.concatenate([new_solution[:i+1], removed_nodes[::-1], new_solution[j:]])\n\n    # Node swapping step\n    k, l = np.random.choice(n, 2, replace=False)\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution is still a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 144,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a combination of objective values and diversity, then applies a novel hybrid local search operator that combines edge exchange and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., not dominated by many others)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange and node insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No room for improvement\n\n    # Step 1: Random edge exchange (similar to 2-opt but with a twist)\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node insertion with objective-aware selection\n    # Find the node with the highest combined cost in the current solution\n    total_cost = np.zeros(n)\n    for k in range(n):\n        prev = new_solution[k-1]\n        curr = new_solution[k]\n        next_node = new_solution[(k+1) % n]\n        total_cost[k] = distance_matrix_1[prev, curr] + distance_matrix_2[prev, curr] + \\\n                         distance_matrix_1[curr, next_node] + distance_matrix_2[curr, next_node]\n    worst_node_idx = np.argmax(total_cost)\n    worst_node = new_solution[worst_node_idx]\n\n    # Find the best insertion position for the worst node\n    best_insert_pos = -1\n    best_cost_reduction = 0\n    for pos in range(n):\n        if pos == worst_node_idx or (pos+1)%n == worst_node_idx:\n            continue  # Skip adjacent positions\n        prev = new_solution[pos-1]\n        next_node = new_solution[pos]\n        # Cost before insertion\n        old_cost = distance_matrix_1[prev, worst_node] + distance_matrix_2[prev, worst_node] + \\\n                   distance_matrix_1[worst_node, next_node] + distance_matrix_2[worst_node, next_node]\n        # Cost after insertion\n        new_cost = distance_matrix_1[prev, next_node] + distance_matrix_2[prev, next_node]\n        # Cost reduction\n        reduction = old_cost - new_cost\n        if reduction > best_cost_reduction:\n            best_cost_reduction = reduction\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        # Remove worst node and insert at best position\n        new_solution = np.delete(new_solution, worst_node_idx)\n        new_solution = np.insert(new_solution, best_insert_pos, worst_node)\n\n    return new_solution\n\n",
        "score": [
            -0.7196385747879672,
            2.433849275112152
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., not dominated by many others)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange and node insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No room for improvement\n\n    # Step 1: Random edge exchange (similar to 2-opt but with a twist)\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node insertion with objective-aware selection\n    # Find the node with the highest combined cost in the current solution\n    total_cost = np.zeros(n)\n    for k in range(n):\n        prev = new_solution[k-1]\n        curr = new_solution[k]\n        next_node = new_solution[(k+1) % n]\n        total_cost[k] = distance_matrix_1[prev, curr] + distance_matrix_2[prev, curr] + \\\n                         distance_matrix_1[curr, next_node] + distance_matrix_2[curr, next_node]\n    worst_node_idx = np.argmax(total_cost)\n    worst_node = new_solution[worst_node_idx]\n\n    # Find the best insertion position for the worst node\n    best_insert_pos = -1\n    best_cost_reduction = 0\n    for pos in range(n):\n        if pos == worst_node_idx or (pos+1)%n == worst_node_idx:\n            continue  # Skip adjacent positions\n        prev = new_solution[pos-1]\n        next_node = new_solution[pos]\n        # Cost before insertion\n        old_cost = distance_matrix_1[prev, worst_node] + distance_matrix_2[prev, worst_node] + \\\n                   distance_matrix_1[worst_node, next_node] + distance_matrix_2[worst_node, next_node]\n        # Cost after insertion\n        new_cost = distance_matrix_1[prev, next_node] + distance_matrix_2[prev, next_node]\n        # Cost reduction\n        reduction = old_cost - new_cost\n        if reduction > best_cost_reduction:\n            best_cost_reduction = reduction\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        # Remove worst node and insert at best position\n        new_solution = np.delete(new_solution, worst_node_idx)\n        new_solution = np.insert(new_solution, best_insert_pos, worst_node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 145,
        "algorithm": "{A novel hybrid local search operator combines a probabilistic edge exchange mechanism with a biased random walk, prioritizing segments with high edge diversity and low objective costs to intelligently perturb solutions while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]) / 2)  # Sort by average cost\n    selected_solution = archive[np.random.randint(0, max(1, len(archive) // 2))][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if n > 4:\n        # Step 1: Identify segments with high edge diversity\n        edge_scores = []\n        for i in range(n):\n            a, b, c = new_solution[i], new_solution[(i+1)%n], new_solution[(i+2)%n]\n            cost1 = distance_matrix_1[a, b] + distance_matrix_1[b, c]\n            cost2 = distance_matrix_2[a, b] + distance_matrix_2[b, c]\n            edge_scores.append((cost1 + cost2) / 2)\n\n        # Step 2: Select a segment with high score\n        segment_start = np.argmax(edge_scores)\n        segment_length = np.random.randint(2, min(4, n-1))\n\n        # Step 3: Apply a biased random walk\n        segment = new_solution[segment_start:segment_start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[segment_start:segment_start+segment_length] = segment\n\n        # Ensure feasibility by checking for duplicates\n        unique, counts = np.unique(new_solution, return_counts=True)\n        if len(unique) != n:\n            # If invalid, revert to a simple swap\n            i, j = np.random.choice(n, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6519120608954072,
            6.577167749404907
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]) / 2)  # Sort by average cost\n    selected_solution = archive[np.random.randint(0, max(1, len(archive) // 2))][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if n > 4:\n        # Step 1: Identify segments with high edge diversity\n        edge_scores = []\n        for i in range(n):\n            a, b, c = new_solution[i], new_solution[(i+1)%n], new_solution[(i+2)%n]\n            cost1 = distance_matrix_1[a, b] + distance_matrix_1[b, c]\n            cost2 = distance_matrix_2[a, b] + distance_matrix_2[b, c]\n            edge_scores.append((cost1 + cost2) / 2)\n\n        # Step 2: Select a segment with high score\n        segment_start = np.argmax(edge_scores)\n        segment_length = np.random.randint(2, min(4, n-1))\n\n        # Step 3: Apply a biased random walk\n        segment = new_solution[segment_start:segment_start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[segment_start:segment_start+segment_length] = segment\n\n        # Ensure feasibility by checking for duplicates\n        unique, counts = np.unique(new_solution, return_counts=True)\n        if len(unique) != n:\n            # If invalid, revert to a simple swap\n            i, j = np.random.choice(n, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 146,
        "algorithm": "{A hybrid local search operator that combines a randomized segment inversion with a multi-objective-aware edge swap to explore high-quality neighborhoods while maintaining feasibility, ensuring diverse exploration and efficient convergence.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Apply a hybrid local search operator\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Step 1: Random segment inversion (explores diverse neighborhoods)\n    start, end = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Multi-objective-aware edge swap (exploits objective-specific improvements)\n    for _ in range(2):  # Limit swaps to maintain efficiency\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate cost change in both objectives\n        old_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[i]] + distance_matrix_1[selected_solution[j-1], selected_solution[j]]\n        new_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[j]] + distance_matrix_1[selected_solution[j-1], selected_solution[i]]\n\n        old_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[i]] + distance_matrix_2[selected_solution[j-1], selected_solution[j]]\n        new_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[j]] + distance_matrix_2[selected_solution[j-1], selected_solution[i]]\n\n        # Accept if at least one objective improves\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9198652263490913,
            2.404254734516144
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Apply a hybrid local search operator\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Step 1: Random segment inversion (explores diverse neighborhoods)\n    start, end = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Multi-objective-aware edge swap (exploits objective-specific improvements)\n    for _ in range(2):  # Limit swaps to maintain efficiency\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate cost change in both objectives\n        old_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[i]] + distance_matrix_1[selected_solution[j-1], selected_solution[j]]\n        new_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[j]] + distance_matrix_1[selected_solution[j-1], selected_solution[i]]\n\n        old_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[i]] + distance_matrix_2[selected_solution[j-1], selected_solution[j]]\n        new_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[j]] + distance_matrix_2[selected_solution[j-1], selected_solution[i]]\n\n        # Accept if at least one objective improves\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 147,
        "algorithm": "{A hybrid local search algorithm that combines edge swapping with a novel segment inversion strategy, prioritizing solutions with high objective diversity and applying a probabilistic selection to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity\n    def objective_diversity(sol):\n        cost1, cost2 = sol[1]\n        return abs(cost1 - cost2)\n\n    # Sort solutions by diversity (higher diversity first)\n    sorted_archive = sorted(archive, key=objective_diversity, reverse=True)\n\n    # Select top 20% of solutions, then randomly choose one\n    top_n = max(1, len(sorted_archive) // 5)\n    selected_sol = random.choice(sorted_archive[:top_n])[0].copy()\n\n    new_solution = selected_sol.copy()\n\n    # Hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two random edges\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment inversion with probabilistic edge swapping\n        if random.random() < 0.7:\n            # Segment inversion\n            start, end = sorted(random.sample(range(n), 2))\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n        else:\n            # Edge swapping\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.33733461852281904,
            2.0729750394821167
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity\n    def objective_diversity(sol):\n        cost1, cost2 = sol[1]\n        return abs(cost1 - cost2)\n\n    # Sort solutions by diversity (higher diversity first)\n    sorted_archive = sorted(archive, key=objective_diversity, reverse=True)\n\n    # Select top 20% of solutions, then randomly choose one\n    top_n = max(1, len(sorted_archive) // 5)\n    selected_sol = random.choice(sorted_archive[:top_n])[0].copy()\n\n    new_solution = selected_sol.copy()\n\n    # Hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two random edges\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment inversion with probabilistic edge swapping\n        if random.random() < 0.7:\n            # Segment inversion\n            start, end = sorted(random.sample(range(n), 2))\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n        else:\n            # Edge swapping\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 148,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a hybrid of crowding distance and objective diversity, then applies a novel 3-opt-inspired local search that adaptively balances edge swaps and segment reversals to explore both objective spaces efficiently while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distances (simplified)\n        objectives = np.array([obj for _, obj in archive])\n        crowding = np.zeros(len(archive))\n        for i in range(2):  # For each objective\n            sorted_idx = np.argsort(objectives[:, i])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n            for j in range(1, len(archive)-1):\n                crowding[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i])\n\n        # Select solution with highest crowding distance\n        selected_idx = np.argmax(crowding)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive 3-opt with objective-aware segment selection\n    for _ in range(3):  # Perform multiple perturbations\n        # Select segments based on objective improvement potential\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n        # Calculate potential improvement in both objectives\n        def cost_change(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n            return cost1, cost2\n\n        original_cost1, original_cost2 = cost_change(new_solution)\n\n        # Try different configurations\n        configs = [\n            np.concatenate([new_solution[:a], new_solution[a:b][::-1], new_solution[b:c], new_solution[c:]]),\n            np.concatenate([new_solution[:a], new_solution[b:c], new_solution[a:b], new_solution[c:]]),\n            np.concatenate([new_solution[:a], new_solution[b:c][::-1], new_solution[a:b], new_solution[c:]])\n        ]\n\n        best_config = new_solution.copy()\n        best_improvement = 0\n\n        for config in configs:\n            config_cost1, config_cost2 = cost_change(config)\n            improvement = (original_cost1 - config_cost1) + (original_cost2 - config_cost2)\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_config = config.copy()\n\n        new_solution = best_config.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6192666899023276,
            6.528953909873962
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distances (simplified)\n        objectives = np.array([obj for _, obj in archive])\n        crowding = np.zeros(len(archive))\n        for i in range(2):  # For each objective\n            sorted_idx = np.argsort(objectives[:, i])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n            for j in range(1, len(archive)-1):\n                crowding[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i])\n\n        # Select solution with highest crowding distance\n        selected_idx = np.argmax(crowding)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive 3-opt with objective-aware segment selection\n    for _ in range(3):  # Perform multiple perturbations\n        # Select segments based on objective improvement potential\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n        # Calculate potential improvement in both objectives\n        def cost_change(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n            return cost1, cost2\n\n        original_cost1, original_cost2 = cost_change(new_solution)\n\n        # Try different configurations\n        configs = [\n            np.concatenate([new_solution[:a], new_solution[a:b][::-1], new_solution[b:c], new_solution[c:]]),\n            np.concatenate([new_solution[:a], new_solution[b:c], new_solution[a:b], new_solution[c:]]),\n            np.concatenate([new_solution[:a], new_solution[b:c][::-1], new_solution[a:b], new_solution[c:]])\n        ]\n\n        best_config = new_solution.copy()\n        best_improvement = 0\n\n        for config in configs:\n            config_cost1, config_cost2 = cost_change(config)\n            improvement = (original_cost1 - config_cost1) + (original_cost2 - config_cost2)\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_config = config.copy()\n\n        new_solution = best_config.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 149,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a solution from the archive based on non-dominated potential and applies a combination of edge-swap and segment-reversal operations to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (non-dominated or randomly chosen)\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search: combine edge-swap and segment-reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly swap two edges\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8853567094292571,
            2.124360203742981
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (non-dominated or randomly chosen)\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search: combine edge-swap and segment-reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly swap two edges\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 150,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive based on non-dominated or high-potential solutions, then applies a hybrid local search combining edge insertion and path relinking to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = None\n    min_total_cost = float('inf')\n\n    for sol, obj in archive:\n        total_cost = obj[0] + obj[1]\n        if total_cost < min_total_cost:\n            min_total_cost = total_cost\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # Hybrid approach: edge insertion combined with path relinking\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to relink\n    start = np.random.randint(0, n - 2)\n    end = np.random.randint(start + 1, n)\n    segment = new_solution[start:end]\n\n    # Randomly select another solution from the archive for path relinking\n    if len(archive) > 1:\n        other_solution = archive[np.random.randint(1, len(archive))][0]\n        # Find common nodes between the two solutions\n        common_nodes = np.intersect1d(new_solution, other_solution)\n        if len(common_nodes) > 0:\n            # Relink the segment with the common nodes\n            for node in common_nodes:\n                if node in segment:\n                    continue\n                idx = np.where(new_solution == node)[0]\n                if len(idx) > 0:\n                    # Insert the node into the segment\n                    insert_pos = np.random.randint(start, end)\n                    new_solution = np.insert(new_solution, insert_pos, node)\n                    break\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, remove them and fill with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([unique_nodes, missing_nodes])\n\n    return new_solution\n\n",
        "score": [
            -0.9961118392170916,
            0.5099982023239136
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = None\n    min_total_cost = float('inf')\n\n    for sol, obj in archive:\n        total_cost = obj[0] + obj[1]\n        if total_cost < min_total_cost:\n            min_total_cost = total_cost\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # Hybrid approach: edge insertion combined with path relinking\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to relink\n    start = np.random.randint(0, n - 2)\n    end = np.random.randint(start + 1, n)\n    segment = new_solution[start:end]\n\n    # Randomly select another solution from the archive for path relinking\n    if len(archive) > 1:\n        other_solution = archive[np.random.randint(1, len(archive))][0]\n        # Find common nodes between the two solutions\n        common_nodes = np.intersect1d(new_solution, other_solution)\n        if len(common_nodes) > 0:\n            # Relink the segment with the common nodes\n            for node in common_nodes:\n                if node in segment:\n                    continue\n                idx = np.where(new_solution == node)[0]\n                if len(idx) > 0:\n                    # Insert the node into the segment\n                    insert_pos = np.random.randint(start, end)\n                    new_solution = np.insert(new_solution, insert_pos, node)\n                    break\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, remove them and fill with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([unique_nodes, missing_nodes])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 151,
        "algorithm": "{A novel hybrid local search operator combines edge-based swaps with a multi-objective-aware segment relocation, prioritizing solutions with diverse objective trade-offs and dynamically adjusting neighborhood exploration based on Pareto-frontier dominance and edge criticality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distance to identify diverse solutions\n        objectives = np.array([obj for _, obj in archive])\n        min_obj = np.min(objectives, axis=0)\n        max_obj = np.max(objectives, axis=0)\n        crowding = np.zeros(len(archive))\n\n        for i in range(2):  # For each objective\n            sorted_idx = np.argsort(objectives[:, i])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n            for j in range(1, len(archive)-1):\n                if max_obj[i] != min_obj[i]:\n                    crowding[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (max_obj[i] - min_obj[i])\n\n        # Select a solution with high crowding distance (diverse) or non-dominated\n        selected_idx = np.argmax(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-segment relocation with edge criticality\n    n = len(base_solution)\n    # Randomly select a segment length (2 to n//4)\n    segment_len = random.randint(2, max(2, n // 4))\n\n    # Identify critical edges (high contribution to total cost)\n    total_cost1 = sum(distance_matrix_1[base_solution[i-1], base_solution[i]] for i in range(n))\n    total_cost2 = sum(distance_matrix_2[base_solution[i-1], base_solution[i]] for i in range(n))\n\n    # Find edges with high contribution to either objective\n    critical_edges = []\n    for i in range(n):\n        cost1 = distance_matrix_1[base_solution[i-1], base_solution[i]]\n        cost2 = distance_matrix_2[base_solution[i-1], base_solution[i]]\n        if cost1 > total_cost1 * 0.1 or cost2 > total_cost2 * 0.1:\n            critical_edges.append(i)\n\n    if critical_edges:\n        # Relocate a segment around a critical edge\n        critical_pos = random.choice(critical_edges)\n        start = random.randint(0, n - segment_len - 1)\n        segment = new_solution[start:start+segment_len]\n\n        # Insert segment after critical edge (or before if at end)\n        if critical_pos == n-1:\n            new_solution = np.concatenate([new_solution[:critical_pos], segment, new_solution[critical_pos:start], new_solution[start+segment_len:]])\n        else:\n            new_solution = np.concatenate([new_solution[:critical_pos+1], segment, new_solution[critical_pos+1:start], new_solution[start+segment_len:]])\n    else:\n        # Fallback to random segment relocation\n        start = random.randint(0, n - segment_len - 1)\n        segment = new_solution[start:start+segment_len]\n        pos = random.randint(0, n - segment_len - 1)\n        if pos >= start:\n            pos += segment_len\n        new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:start], new_solution[start+segment_len:]])\n\n    return new_solution\n\n",
        "score": [
            -0.44838815032971546,
            2.518904209136963
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distance to identify diverse solutions\n        objectives = np.array([obj for _, obj in archive])\n        min_obj = np.min(objectives, axis=0)\n        max_obj = np.max(objectives, axis=0)\n        crowding = np.zeros(len(archive))\n\n        for i in range(2):  # For each objective\n            sorted_idx = np.argsort(objectives[:, i])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n            for j in range(1, len(archive)-1):\n                if max_obj[i] != min_obj[i]:\n                    crowding[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (max_obj[i] - min_obj[i])\n\n        # Select a solution with high crowding distance (diverse) or non-dominated\n        selected_idx = np.argmax(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-segment relocation with edge criticality\n    n = len(base_solution)\n    # Randomly select a segment length (2 to n//4)\n    segment_len = random.randint(2, max(2, n // 4))\n\n    # Identify critical edges (high contribution to total cost)\n    total_cost1 = sum(distance_matrix_1[base_solution[i-1], base_solution[i]] for i in range(n))\n    total_cost2 = sum(distance_matrix_2[base_solution[i-1], base_solution[i]] for i in range(n))\n\n    # Find edges with high contribution to either objective\n    critical_edges = []\n    for i in range(n):\n        cost1 = distance_matrix_1[base_solution[i-1], base_solution[i]]\n        cost2 = distance_matrix_2[base_solution[i-1], base_solution[i]]\n        if cost1 > total_cost1 * 0.1 or cost2 > total_cost2 * 0.1:\n            critical_edges.append(i)\n\n    if critical_edges:\n        # Relocate a segment around a critical edge\n        critical_pos = random.choice(critical_edges)\n        start = random.randint(0, n - segment_len - 1)\n        segment = new_solution[start:start+segment_len]\n\n        # Insert segment after critical edge (or before if at end)\n        if critical_pos == n-1:\n            new_solution = np.concatenate([new_solution[:critical_pos], segment, new_solution[critical_pos:start], new_solution[start+segment_len:]])\n        else:\n            new_solution = np.concatenate([new_solution[:critical_pos+1], segment, new_solution[critical_pos+1:start], new_solution[start+segment_len:]])\n    else:\n        # Fallback to random segment relocation\n        start = random.randint(0, n - segment_len - 1)\n        segment = new_solution[start:start+segment_len]\n        pos = random.randint(0, n - segment_len - 1)\n        if pos >= start:\n            pos += segment_len\n        new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:start], new_solution[start+segment_len:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 152,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on its potential for improvement, using a hybrid local search strategy that combines edge exchanges with a novel segment relocation mechanism to explore the solution space more effectively while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: choose a solution with high potential for improvement\n    # Here, we select a solution with the highest sum of normalized objective values\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: segment relocation with edge exchanges\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to relocate\n    start = np.random.randint(0, n)\n    length = np.random.randint(2, min(5, n - 1))\n    end = (start + length) % n\n\n    if start < end:\n        segment = new_solution[start:end]\n        remaining = np.concatenate([new_solution[:start], new_solution[end:]])\n    else:\n        segment = np.concatenate([new_solution[start:], new_solution[:end]])\n        remaining = new_solution[end:start]\n\n    # Find the best insertion point for the segment\n    best_cost = float('inf')\n    best_pos = -1\n\n    for i in range(len(remaining)):\n        # Insert segment at position i\n        candidate = np.concatenate([remaining[:i], segment, remaining[i:]])\n        # Calculate total cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([remaining[:best_pos], segment, remaining[best_pos:]])\n\n    # Additional edge exchange for further optimization\n    for _ in range(2):  # Limit to 2 exchanges to maintain diversity\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate current and swapped costs\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        swapped_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n        swapped_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n\n        if (swapped_cost1 + swapped_cost2) < (current_cost1 + current_cost2):\n            # Perform the exchange\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9160488520724125,
            10.219389081001282
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: choose a solution with high potential for improvement\n    # Here, we select a solution with the highest sum of normalized objective values\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: segment relocation with edge exchanges\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to relocate\n    start = np.random.randint(0, n)\n    length = np.random.randint(2, min(5, n - 1))\n    end = (start + length) % n\n\n    if start < end:\n        segment = new_solution[start:end]\n        remaining = np.concatenate([new_solution[:start], new_solution[end:]])\n    else:\n        segment = np.concatenate([new_solution[start:], new_solution[:end]])\n        remaining = new_solution[end:start]\n\n    # Find the best insertion point for the segment\n    best_cost = float('inf')\n    best_pos = -1\n\n    for i in range(len(remaining)):\n        # Insert segment at position i\n        candidate = np.concatenate([remaining[:i], segment, remaining[i:]])\n        # Calculate total cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([remaining[:best_pos], segment, remaining[best_pos:]])\n\n    # Additional edge exchange for further optimization\n    for _ in range(2):  # Limit to 2 exchanges to maintain diversity\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate current and swapped costs\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        swapped_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n        swapped_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n\n        if (swapped_cost1 + swapped_cost2) < (current_cost1 + current_cost2):\n            # Perform the exchange\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 153,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: max(x[1]))\n    selected_solution = archive_sorted[min(len(archive_sorted) // 5, len(archive_sorted) - 1)][0].copy()\n\n    # Hybrid local search: perform edge exchange and segment reversal\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Edge exchange: swap two random edges that don't create duplicates\n    i, j = sorted(random.sample(range(n), 2))\n    if i != 0 and j != n - 1 and new_solution[i] != new_solution[j] and new_solution[i-1] != new_solution[j]:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment reversal: reverse a random segment to explore different configurations\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(set(new_solution)) != n:\n        # Fallback to a simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6147692487729962,
            1.9845439195632935
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: max(x[1]))\n    selected_solution = archive_sorted[min(len(archive_sorted) // 5, len(archive_sorted) - 1)][0].copy()\n\n    # Hybrid local search: perform edge exchange and segment reversal\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Edge exchange: swap two random edges that don't create duplicates\n    i, j = sorted(random.sample(range(n), 2))\n    if i != 0 and j != n - 1 and new_solution[i] != new_solution[j] and new_solution[i-1] != new_solution[j]:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment reversal: reverse a random segment to explore different configurations\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(set(new_solution)) != n:\n        # Fallback to a simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 154,
        "algorithm": "{A novel hybrid local search operator combines a multi-parent crossover with a constrained edge reassembly strategy, prioritizing solutions with high Pareto dominance and diverse edge distributions to generate improved neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by Pareto dominance (simplified: lower sum of objectives)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% of solutions\n        top_solutions = archive_sorted[:max(1, len(archive_sorted) // 3)]\n        # Further select based on edge diversity\n        selected = max(top_solutions, key=lambda x: len(set(zip(x[0][:-1], x[0][1:]))))\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine elements from multiple solutions\n    if len(archive) > 2:\n        # Select two additional solutions for crossover\n        other_solutions = [s for s in archive if not np.array_equal(s[0], base_solution)][:2]\n        for other_sol in other_solutions:\n            # Perform a constrained edge reassembly\n            i, j = sorted(random.sample(range(len(base_solution)), 2))\n            segment = other_sol[0][i:j]\n            # Ensure no duplicates and maintain tour continuity\n            temp = np.concatenate([base_solution[:i], segment, base_solution[j:]])\n            # Remove duplicates while preserving order\n            _, unique_indices = np.unique(temp, return_index=True)\n            temp = temp[np.sort(unique_indices)]\n            # Fill missing nodes from base_solution\n            missing = np.setdiff1d(base_solution, temp)\n            temp = np.concatenate([temp, missing])\n            # Ensure it's a valid tour\n            if len(temp) == len(base_solution):\n                new_solution = temp\n\n    # Apply a novel edge swap operation\n    if len(new_solution) > 3:\n        # Select a random segment to reverse\n        i, j = sorted(random.sample(range(1, len(new_solution)), 2))\n        segment = new_solution[i:j]\n        reversed_segment = segment[::-1]\n        temp = np.concatenate([new_solution[:i], reversed_segment, new_solution[j:]])\n        # Verify feasibility\n        if len(np.unique(temp)) == len(new_solution):\n            new_solution = temp\n\n    return new_solution\n\n",
        "score": [
            -0.7289247650750633,
            3.2445337176322937
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by Pareto dominance (simplified: lower sum of objectives)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% of solutions\n        top_solutions = archive_sorted[:max(1, len(archive_sorted) // 3)]\n        # Further select based on edge diversity\n        selected = max(top_solutions, key=lambda x: len(set(zip(x[0][:-1], x[0][1:]))))\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine elements from multiple solutions\n    if len(archive) > 2:\n        # Select two additional solutions for crossover\n        other_solutions = [s for s in archive if not np.array_equal(s[0], base_solution)][:2]\n        for other_sol in other_solutions:\n            # Perform a constrained edge reassembly\n            i, j = sorted(random.sample(range(len(base_solution)), 2))\n            segment = other_sol[0][i:j]\n            # Ensure no duplicates and maintain tour continuity\n            temp = np.concatenate([base_solution[:i], segment, base_solution[j:]])\n            # Remove duplicates while preserving order\n            _, unique_indices = np.unique(temp, return_index=True)\n            temp = temp[np.sort(unique_indices)]\n            # Fill missing nodes from base_solution\n            missing = np.setdiff1d(base_solution, temp)\n            temp = np.concatenate([temp, missing])\n            # Ensure it's a valid tour\n            if len(temp) == len(base_solution):\n                new_solution = temp\n\n    # Apply a novel edge swap operation\n    if len(new_solution) > 3:\n        # Select a random segment to reverse\n        i, j = sorted(random.sample(range(1, len(new_solution)), 2))\n        segment = new_solution[i:j]\n        reversed_segment = segment[::-1]\n        temp = np.concatenate([new_solution[:i], reversed_segment, new_solution[j:]])\n        # Verify feasibility\n        if len(np.unique(temp)) == len(new_solution):\n            new_solution = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 155,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    ranked_solutions = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_solution = random.choice(ranked_solutions[:max(1, len(ranked_solutions) // 2)])[0].copy()\n\n    # Hybrid local search: edge exchange followed by path relinking\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Edge exchange (swap two edges)\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Path relinking: partially replace with a high-quality solution\n    if len(archive) > 1:\n        guide_solution = random.choice(archive)[0]\n        k = random.randint(1, n // 2)\n        for idx in range(k):\n            pos = random.randint(0, n - 1)\n            new_solution[pos] = guide_solution[pos]\n\n    # Ensure feasibility by removing duplicates and adding missing nodes\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for idx in range(len(new_solution)):\n            if new_solution[idx] not in unique_nodes:\n                new_solution[idx] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.7215852308057786,
            0.9588713645935059
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    ranked_solutions = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_solution = random.choice(ranked_solutions[:max(1, len(ranked_solutions) // 2)])[0].copy()\n\n    # Hybrid local search: edge exchange followed by path relinking\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Edge exchange (swap two edges)\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Path relinking: partially replace with a high-quality solution\n    if len(archive) > 1:\n        guide_solution = random.choice(archive)[0]\n        k = random.randint(1, n // 2)\n        for idx in range(k):\n            pos = random.randint(0, n - 1)\n            new_solution[pos] = guide_solution[pos]\n\n    # Ensure feasibility by removing duplicates and adding missing nodes\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for idx in range(len(new_solution)):\n            if new_solution[idx] not in unique_nodes:\n                new_solution[idx] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 156,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    objective_variances = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objectives * (1 + objective_variances), axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to swap or reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform segment reversal and insertion\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n    new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the above operation causes duplicates\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9831144022677978,
            1.0303902626037598
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    objective_variances = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objectives * (1 + objective_variances), axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to swap or reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform segment reversal and insertion\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n    new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the above operation causes duplicates\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 157,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Apply a combination of edge insertion and segment reversal\n    n = len(new_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    k = np.random.randint(0, n)\n\n    # Ensure i < j < k for valid segment selection\n    i, j, k = sorted([i, j, k])\n\n    # Extract segments and insert them in a new order\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    remaining = np.concatenate([new_solution[:i], new_solution[k:]])\n\n    # Randomly choose between two insertion strategies\n    if np.random.random() < 0.5:\n        new_solution = np.concatenate([remaining, segment1, segment2])\n    else:\n        new_solution = np.concatenate([segment1, remaining, segment2])\n\n    # Ensure the solution remains a valid tour\n    assert len(np.unique(new_solution)) == n, \"Invalid tour generated\"\n    return new_solution\n\n",
        "score": [
            -0.8362425560001204,
            2.5656867027282715
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Apply a combination of edge insertion and segment reversal\n    n = len(new_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    k = np.random.randint(0, n)\n\n    # Ensure i < j < k for valid segment selection\n    i, j, k = sorted([i, j, k])\n\n    # Extract segments and insert them in a new order\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    remaining = np.concatenate([new_solution[:i], new_solution[k:]])\n\n    # Randomly choose between two insertion strategies\n    if np.random.random() < 0.5:\n        new_solution = np.concatenate([remaining, segment1, segment2])\n    else:\n        new_solution = np.concatenate([segment1, remaining, segment2])\n\n    # Ensure the solution remains a valid tour\n    assert len(np.unique(new_solution)) == n, \"Invalid tour generated\"\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 158,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive by evaluating both objectives, then applies a hybrid local search combining edge swaps, segment reversals, and probabilistic node insertions to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, randomly weighted by objective dominance)\n    weights = [1.0 / (1 + obj[0] + obj[1]) for _, obj in archive]\n    total_weight = sum(weights)\n    weights = [w / total_weight for w in weights]\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, segment reversals, and probabilistic insertions\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high-improvement probability\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        if (a != 0 or b != n-1) and (b - a > 1):\n            # Ensure it's a valid swap (not adjacent or wrapping edges)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Step 2: Segment reversal with objective-aware selection\n    if n > 4:\n        segment_start = random.randint(0, n - 3)\n        segment_end = random.randint(segment_start + 2, n - 1)\n        segment = new_solution[segment_start:segment_end]\n\n        # Decide reversal based on potential improvement\n        current_cost = distance_matrix_1[new_solution[segment_start-1], new_solution[segment_start]] + \\\n                       distance_matrix_1[new_solution[segment_end-1], new_solution[segment_end]] + \\\n                       distance_matrix_2[new_solution[segment_start-1], new_solution[segment_start]] + \\\n                       distance_matrix_2[new_solution[segment_end-1], new_solution[segment_end]]\n\n        reversed_cost = distance_matrix_1[new_solution[segment_start-1], new_solution[segment_end-1]] + \\\n                       distance_matrix_1[new_solution[segment_start], new_solution[segment_end]] + \\\n                       distance_matrix_2[new_solution[segment_start-1], new_solution[segment_end-1]] + \\\n                       distance_matrix_2[new_solution[segment_start], new_solution[segment_end]]\n\n        if reversed_cost < current_cost and random.random() < 0.7:  # 70% chance if better\n            new_solution[segment_start:segment_end] = segment[::-1]\n\n    # Step 3: Probabilistic node insertion\n    if n > 3:\n        node_to_move = random.choice(new_solution)\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n        new_pos = random.randint(0, n - 1)\n        if new_pos != current_pos and (abs(new_pos - current_pos) > 1 or n < 5):\n            new_solution = np.delete(new_solution, current_pos)\n            new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.7263411581300698,
            2.481520175933838
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, randomly weighted by objective dominance)\n    weights = [1.0 / (1 + obj[0] + obj[1]) for _, obj in archive]\n    total_weight = sum(weights)\n    weights = [w / total_weight for w in weights]\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, segment reversals, and probabilistic insertions\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high-improvement probability\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        if (a != 0 or b != n-1) and (b - a > 1):\n            # Ensure it's a valid swap (not adjacent or wrapping edges)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Step 2: Segment reversal with objective-aware selection\n    if n > 4:\n        segment_start = random.randint(0, n - 3)\n        segment_end = random.randint(segment_start + 2, n - 1)\n        segment = new_solution[segment_start:segment_end]\n\n        # Decide reversal based on potential improvement\n        current_cost = distance_matrix_1[new_solution[segment_start-1], new_solution[segment_start]] + \\\n                       distance_matrix_1[new_solution[segment_end-1], new_solution[segment_end]] + \\\n                       distance_matrix_2[new_solution[segment_start-1], new_solution[segment_start]] + \\\n                       distance_matrix_2[new_solution[segment_end-1], new_solution[segment_end]]\n\n        reversed_cost = distance_matrix_1[new_solution[segment_start-1], new_solution[segment_end-1]] + \\\n                       distance_matrix_1[new_solution[segment_start], new_solution[segment_end]] + \\\n                       distance_matrix_2[new_solution[segment_start-1], new_solution[segment_end-1]] + \\\n                       distance_matrix_2[new_solution[segment_start], new_solution[segment_end]]\n\n        if reversed_cost < current_cost and random.random() < 0.7:  # 70% chance if better\n            new_solution[segment_start:segment_end] = segment[::-1]\n\n    # Step 3: Probabilistic node insertion\n    if n > 3:\n        node_to_move = random.choice(new_solution)\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n        new_pos = random.randint(0, n - 1)\n        if new_pos != current_pos and (abs(new_pos - current_pos) > 1 or n < 5):\n            new_solution = np.delete(new_solution, current_pos)\n            new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 159,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (randomly choose among top 20% solutions by combined cost)\n    sorted_archive = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    top_solutions = sorted_archive[:max(1, len(sorted_archive) // 5)]\n    base_solution, _ = random.choice(top_solutions)\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge swaps and segment reversals\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly choose between edge swap or segment reversal\n    if random.random() < 0.5:\n        # Edge swap: randomly select two edges and swap their nodes\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Swap segments between i and j\n            new_solution[i+1:j] = new_solution[i+1:j][::-1]\n    else:\n        # Segment reversal: reverse a random segment of the tour\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains a valid tour (no duplicates)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7535594683824408,
            2.1167160272598267
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (randomly choose among top 20% solutions by combined cost)\n    sorted_archive = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    top_solutions = sorted_archive[:max(1, len(sorted_archive) // 5)]\n    base_solution, _ = random.choice(top_solutions)\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge swaps and segment reversals\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly choose between edge swap or segment reversal\n    if random.random() < 0.5:\n        # Edge swap: randomly select two edges and swap their nodes\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Swap segments between i and j\n            new_solution[i+1:j] = new_solution[i+1:j][::-1]\n    else:\n        # Segment reversal: reverse a random segment of the tour\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains a valid tour (no duplicates)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 160,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions or those with high diversity)\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search: combine edge swaps with path relinking\n    new_solution = selected_solution.copy()\n\n    # Step 1: Perform random edge swaps (like a limited 2-opt but more flexible)\n    n = len(new_solution)\n    for _ in range(min(3, n // 2)):  # Limit the number of swaps\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:  # Ensure a meaningful swap\n            new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment\n\n    # Step 2: Path relinking-inspired move (select a segment and shift it)\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    # Ensure the solution is valid (no duplicates, all nodes present)\n    assert len(new_solution) == len(selected_solution)\n    assert len(set(new_solution)) == len(selected_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.9870847539165016,
            2.181695878505707
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions or those with high diversity)\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search: combine edge swaps with path relinking\n    new_solution = selected_solution.copy()\n\n    # Step 1: Perform random edge swaps (like a limited 2-opt but more flexible)\n    n = len(new_solution)\n    for _ in range(min(3, n // 2)):  # Limit the number of swaps\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:  # Ensure a meaningful swap\n            new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment\n\n    # Step 2: Path relinking-inspired move (select a segment and shift it)\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    # Ensure the solution is valid (no duplicates, all nodes present)\n    assert len(new_solution) == len(selected_solution)\n    assert len(set(new_solution)) == len(selected_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 161,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on its objective values and applies a hybrid local search combining edge exchanges and segment reversals to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-frontier solutions)\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchanges and segment reversals\n    n = len(base_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Edge exchange with a random segment reversal\n    if j - i > 1:\n        k = np.random.randint(i + 1, j)\n        new_solution[i:k] = base_solution[i:k][::-1]\n        new_solution[k:j] = base_solution[k:j][::-1]\n\n    # Ensure the solution remains feasible\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7641870367160646,
            2.432038903236389
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-frontier solutions)\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchanges and segment reversals\n    n = len(base_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Edge exchange with a random segment reversal\n    if j - i > 1:\n        k = np.random.randint(i + 1, j)\n        new_solution[i:k] = base_solution[i:k][::-1]\n        new_solution[k:j] = base_solution[k:j][::-1]\n\n    # Ensure the solution remains feasible\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 162,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: min(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion followed by segment reversal\n    n = len(base_solution)\n\n    # Edge insertion step\n    i, j = sorted(random.sample(range(n), 2))\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Segment reversal step\n    a, b = sorted(random.sample(range(n), 2))\n    if a != b:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.39125176394313055,
            1.8951785564422607
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: min(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion followed by segment reversal\n    n = len(base_solution)\n\n    # Edge insertion step\n    i, j = sorted(random.sample(range(n), 2))\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Segment reversal step\n    a, b = sorted(random.sample(range(n), 2))\n    if a != b:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 163,
        "algorithm": "{A novel hybrid local search algorithm that combines a multi-objective edge exchange strategy with a dynamic segment reversal mechanism to intelligently explore the solution space, ensuring feasibility while balancing exploration and exploitation across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: dynamic segment reversal with edge exchange\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to reverse\n    start = random.randint(0, n - 4)\n    end = random.randint(start + 2, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Edge exchange based on both objectives\n    for _ in range(2):  # Perform a limited number of exchanges\n        i, j = random.sample(range(n), 2)\n        # Check if swapping improves both objectives\n        if (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] <\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) and \\\n           (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] <\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9337563651205192,
            1.7007758021354675
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: dynamic segment reversal with edge exchange\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to reverse\n    start = random.randint(0, n - 4)\n    end = random.randint(start + 2, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Edge exchange based on both objectives\n    for _ in range(2):  # Perform a limited number of exchanges\n        i, j = random.sample(range(n), 2)\n        # Check if swapping improves both objectives\n        if (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] <\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) and \\\n           (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] <\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 164,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distances (simplified for this example)\n        objectives = np.array([obj for _, obj in archive])\n        crowding_distances = np.zeros(len(objectives))\n        for m in range(2):\n            sorted_indices = np.argsort(objectives[:, m])\n            crowding_distances[sorted_indices[0]] = np.inf\n            crowding_distances[sorted_indices[-1]] = np.inf\n            for i in range(1, len(objectives) - 1):\n                crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n        selected_idx = np.argmax(crowding_distances)\n    else:\n        selected_idx = 0\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # We use a combination of edge insertion and segment reversal for diversification\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select two edges and insert them in a different position\n    if n > 4:\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        edge1 = new_solution[c:c+2]\n        edge2 = new_solution[d:d+2]\n        new_solution = np.concatenate([new_solution[:c], edge2, new_solution[c+2:d], edge1, new_solution[d+2:]])\n\n    return new_solution\n\n",
        "score": [
            -0.5382301493524944,
            2.8308331966400146
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distances (simplified for this example)\n        objectives = np.array([obj for _, obj in archive])\n        crowding_distances = np.zeros(len(objectives))\n        for m in range(2):\n            sorted_indices = np.argsort(objectives[:, m])\n            crowding_distances[sorted_indices[0]] = np.inf\n            crowding_distances[sorted_indices[-1]] = np.inf\n            for i in range(1, len(objectives) - 1):\n                crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n        selected_idx = np.argmax(crowding_distances)\n    else:\n        selected_idx = 0\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # We use a combination of edge insertion and segment reversal for diversification\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select two edges and insert them in a different position\n    if n > 4:\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        edge1 = new_solution[c:c+2]\n        edge2 = new_solution[d:d+2]\n        new_solution = np.concatenate([new_solution[:c], edge2, new_solution[c+2:d], edge1, new_solution[d+2:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 165,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: max(x[1]))\n\n    # Create a copy of the selected solution to modify\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search operator: a combination of edge exchange and node insertion\n    # Step 1: Randomly select two edges and reverse the segment between them (partial 2-opt)\n    a, b = sorted(np.random.choice(len(new_solution), 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 2: Randomly select a node and insert it into a new position (node insertion)\n    node = np.random.choice(new_solution)\n    pos = np.random.randint(len(new_solution))\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8646402241224276,
            2.0942888855934143
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: max(x[1]))\n\n    # Create a copy of the selected solution to modify\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search operator: a combination of edge exchange and node insertion\n    # Step 1: Randomly select two edges and reverse the segment between them (partial 2-opt)\n    a, b = sorted(np.random.choice(len(new_solution), 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 2: Randomly select a node and insert it into a new position (node insertion)\n    node = np.random.choice(new_solution)\n    pos = np.random.randint(len(new_solution))\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 166,
        "algorithm": "{This algorithm selects a promising solution from the archive by prioritizing those with lower total objective costs, then applies a hybrid local search combining edge insertion and segment reversal to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to operate on\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Edge insertion: remove segment and reinsert in a different position\n    segment = new_solution[i:j+1]\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    k = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:k], segment, remaining[k:]])\n\n    # Segment reversal: reverse a random segment\n    if len(new_solution) > 2:\n        a, b = random.sample(range(len(new_solution)), 2)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6606151836945924,
            1.977719247341156
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to operate on\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Edge insertion: remove segment and reinsert in a different position\n    segment = new_solution[i:j+1]\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    k = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:k], segment, remaining[k:]])\n\n    # Segment reversal: reverse a random segment\n    if len(new_solution) > 2:\n        a, b = random.sample(range(len(new_solution)), 2)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 167,
        "algorithm": "{The heuristic function selects a solution from the archive with high potential for improvement by prioritizing those with the worst objective values, then applies a novel hybrid local search operator that combines 3-opt with a biased random walk to explore diverse neighborhoods while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: 3-opt with biased random walk\n    for _ in range(10):  # Number of attempts\n        # Select three random edges\n        i, j, k = sorted(random.sample(range(1, N), 3))\n\n        # Apply 3-opt move\n        new_order = np.concatenate([\n            new_solution[:i],\n            new_solution[j:k][::-1],\n            new_solution[i:j],\n            new_solution[k:]\n        ])\n\n        # Check feasibility and accept if better\n        if len(np.unique(new_order)) == N:\n            new_solution = new_order\n\n        # Biased random walk: sometimes accept worse solutions\n        if random.random() < 0.2:\n            new_solution = base_solution.copy()\n            # Randomly perturb the solution\n            a, b = random.sample(range(N), 2)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6068690047285622,
            2.8781450390815735
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: 3-opt with biased random walk\n    for _ in range(10):  # Number of attempts\n        # Select three random edges\n        i, j, k = sorted(random.sample(range(1, N), 3))\n\n        # Apply 3-opt move\n        new_order = np.concatenate([\n            new_solution[:i],\n            new_solution[j:k][::-1],\n            new_solution[i:j],\n            new_solution[k:]\n        ])\n\n        # Check feasibility and accept if better\n        if len(np.unique(new_order)) == N:\n            new_solution = new_order\n\n        # Biased random walk: sometimes accept worse solutions\n        if random.random() < 0.2:\n            new_solution = base_solution.copy()\n            # Randomly perturb the solution\n            a, b = random.sample(range(N), 2)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 168,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment inversion with multi-objective edge swaps to explore diverse neighborhoods while balancing exploration and exploitation, guided by Pareto dominance and solution quality metrics.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        return np.array([])\n\n    # Select a solution with high crowding distance or low dominance\n    selected_idx = np.random.choice(len(archive_solutions))\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    if n > 3:\n        segment_length = min(5, n // 2)\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Multi-objective edge swap\n    for _ in range(2):\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        # Check if swap improves both objectives\n        orig_cost1 = distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[j-1], base_solution[j]]\n        new_cost1 = distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j-1], base_solution[i]]\n        orig_cost2 = distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[j-1], base_solution[j]]\n        new_cost2 = distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j-1], base_solution[i]]\n\n        if (new_cost1 < orig_cost1 and new_cost2 < orig_cost2) or random.random() < 0.3:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8182595739232263,
            2.328096389770508
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        return np.array([])\n\n    # Select a solution with high crowding distance or low dominance\n    selected_idx = np.random.choice(len(archive_solutions))\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    if n > 3:\n        segment_length = min(5, n // 2)\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Multi-objective edge swap\n    for _ in range(2):\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        # Check if swap improves both objectives\n        orig_cost1 = distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[j-1], base_solution[j]]\n        new_cost1 = distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j-1], base_solution[i]]\n        orig_cost2 = distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[j-1], base_solution[j]]\n        new_cost2 = distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j-1], base_solution[i]]\n\n        if (new_cost1 < orig_cost1 and new_cost2 < orig_cost2) or random.random() < 0.3:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 169,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(base_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt between [i, j] and [k, l] if they are non-overlapping\n    if not (i <= k <= j or i <= l <= j):\n        new_solution[i:j+1] = base_solution[i:j+1][::-1]\n        new_solution[k:l+1] = base_solution[k:l+1][::-1]\n    else:\n        # Novel edge-swap: Swap edges (i, j) and (k, l) if they are non-adjacent\n        if abs(i - j) > 1 and abs(k - l) > 1:\n            new_solution[i], new_solution[j] = base_solution[j], base_solution[i]\n            new_solution[k], new_solution[l] = base_solution[l], base_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7821458225339543,
            1.9385000467300415
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(base_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt between [i, j] and [k, l] if they are non-overlapping\n    if not (i <= k <= j or i <= l <= j):\n        new_solution[i:j+1] = base_solution[i:j+1][::-1]\n        new_solution[k:l+1] = base_solution[k:l+1][::-1]\n    else:\n        # Novel edge-swap: Swap edges (i, j) and (k, l) if they are non-adjacent\n        if abs(i - j) > 1 and abs(k - l) > 1:\n            new_solution[i], new_solution[j] = base_solution[j], base_solution[i]\n            new_solution[k], new_solution[l] = base_solution[l], base_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 170,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: x[1][0] + x[1][1])\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search operator: a combination of node insertion and edge swapping\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    k = np.random.randint(0, n)\n\n    # Node insertion: remove node at i and insert it after k\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    new_solution = np.insert(new_solution, k, node)\n\n    # Edge swapping: swap edges between j and (j+1) mod n with edges between k and (k+1) mod n\n    if j < k:\n        a, b = j, k\n    else:\n        a, b = k, j\n\n    new_solution[a+1:b] = new_solution[a+1:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9375366908610329,
            2.3607019782066345
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: x[1][0] + x[1][1])\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search operator: a combination of node insertion and edge swapping\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    k = np.random.randint(0, n)\n\n    # Node insertion: remove node at i and insert it after k\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    new_solution = np.insert(new_solution, k, node)\n\n    # Edge swapping: swap edges between j and (j+1) mod n with edges between k and (k+1) mod n\n    if j < k:\n        a, b = j, k\n    else:\n        a, b = k, j\n\n    new_solution[a+1:b] = new_solution[a+1:b][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 171,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: edge exchange followed by segment relocation\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Edge exchange: swap two non-adjacent edges\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while abs(i - j) <= 1 or abs(i - j) == n - 1:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment relocation: move a random segment to a new position\n    seg_start = np.random.randint(0, n)\n    seg_length = np.random.randint(2, min(5, n // 2))  # Random segment length\n    seg_end = (seg_start + seg_length) % n\n\n    if seg_start < seg_end:\n        segment = new_solution[seg_start:seg_end]\n        remaining = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n    else:\n        segment = np.concatenate([new_solution[seg_start:], new_solution[:seg_end]])\n        remaining = new_solution[seg_end:seg_start]\n\n    insert_pos = np.random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7104652461378885,
            2.1796498894691467
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: edge exchange followed by segment relocation\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Edge exchange: swap two non-adjacent edges\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while abs(i - j) <= 1 or abs(i - j) == n - 1:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment relocation: move a random segment to a new position\n    seg_start = np.random.randint(0, n)\n    seg_length = np.random.randint(2, min(5, n // 2))  # Random segment length\n    seg_end = (seg_start + seg_length) % n\n\n    if seg_start < seg_end:\n        segment = new_solution[seg_start:seg_end]\n        remaining = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n    else:\n        segment = np.concatenate([new_solution[seg_start:], new_solution[:seg_end]])\n        remaining = new_solution[seg_end:seg_start]\n\n    insert_pos = np.random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 172,
        "algorithm": "{The heuristic function selects a promising solution from the archive by prioritizing those with lower combined objective values, then applies a hybrid local search combining edge swaps and segment reversals to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Generate a neighbor using a hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly swap two edges\n    if n > 2:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8294398318208767,
            2.176114022731781
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Generate a neighbor using a hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly swap two edges\n    if n > 2:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 173,
        "algorithm": "{A novel hybrid local search strategy that combines a biased random walk with a dynamic edge swap mechanism, prioritizing high-potential regions in the objective space to explore diverse neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligently select a solution with high potential for improvement\n    # Here, we prioritize solutions with lower costs in both objectives\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected = archive_sorted[0][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Step 1: Dynamic edge swap mechanism\n    for _ in range(3):  # Perform 3 swaps\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Biased random walk for diversification\n    for _ in range(2):  # Perform 2 biased swaps\n        # Find the edge with the highest combined distance in both objectives\n        max_dist = -1\n        best_i = 0\n        for i in range(n):\n            u, v = new_solution[i], new_solution[(i+1)%n]\n            dist = distance_matrix_1[u, v] + distance_matrix_2[u, v]\n            if dist > max_dist:\n                max_dist = dist\n                best_i = i\n        # Swap with a random neighbor\n        j = np.random.choice([(best_i-1)%n, (best_i+1)%n])\n        new_solution[best_i], new_solution[j] = new_solution[j], new_solution[best_i]\n\n    return new_solution\n\n",
        "score": [
            -0.734803603983316,
            2.764750838279724
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligently select a solution with high potential for improvement\n    # Here, we prioritize solutions with lower costs in both objectives\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected = archive_sorted[0][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Step 1: Dynamic edge swap mechanism\n    for _ in range(3):  # Perform 3 swaps\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Biased random walk for diversification\n    for _ in range(2):  # Perform 2 biased swaps\n        # Find the edge with the highest combined distance in both objectives\n        max_dist = -1\n        best_i = 0\n        for i in range(n):\n            u, v = new_solution[i], new_solution[(i+1)%n]\n            dist = distance_matrix_1[u, v] + distance_matrix_2[u, v]\n            if dist > max_dist:\n                max_dist = dist\n                best_i = i\n        # Swap with a random neighbor\n        j = np.random.choice([(best_i-1)%n, (best_i+1)%n])\n        new_solution[best_i], new_solution[j] = new_solution[j], new_solution[best_i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 174,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with better objective values, then applies a hybrid local search combining edge insertion and node reordering to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion and node reordering\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select segments to modify\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    # Reverse the segment (similar to 2-opt but more flexible)\n    reversed_segment = segment[::-1]\n\n    # Insert the reversed segment back\n    new_solution[a:b+1] = reversed_segment\n\n    # Apply node reordering within a random segment\n    c, d = sorted(random.sample(range(n), 2))\n    segment_to_reorder = new_solution[c:d+1]\n    random.shuffle(segment_to_reorder)\n    new_solution[c:d+1] = segment_to_reorder\n\n    return new_solution\n\n",
        "score": [
            -0.7991002416666303,
            2.1533591747283936
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion and node reordering\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select segments to modify\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    # Reverse the segment (similar to 2-opt but more flexible)\n    reversed_segment = segment[::-1]\n\n    # Insert the reversed segment back\n    new_solution[a:b+1] = reversed_segment\n\n    # Apply node reordering within a random segment\n    c, d = sorted(random.sample(range(n), 2))\n    segment_to_reorder = new_solution[c:d+1]\n    random.shuffle(segment_to_reorder)\n    new_solution[c:d+1] = segment_to_reorder\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 175,
        "algorithm": "{A novel hybrid local search method that combines a dynamic edge-swap strategy with a probabilistic edge-reversal mechanism to explore diverse neighborhoods while preserving feasibility, guided by Pareto-dominance and solution diversity metrics.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on Pareto dominance and diversity\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: dynamic edge-swap with probabilistic edge-reversal\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful changes\n\n    # Select a random segment to modify\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Dynamic edge-swap: reverse segment with probability based on segment cost\n    if np.random.random() < 0.7:  # Higher probability for larger segments\n        segment = segment[::-1]\n        new_solution[a:b+1] = segment\n\n    # Probabilistic edge-reversal: reverse edges with small probability\n    for i in range(n):\n        if np.random.random() < 0.05:\n            j = (i + 1) % n\n            if new_solution[i] != new_solution[j]:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates (should not happen due to TSP properties)\n    if len(np.unique(new_solution)) != n:\n        return base_solution  # Fallback to original if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.7940424542805922,
            2.5328598022460938
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on Pareto dominance and diversity\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: dynamic edge-swap with probabilistic edge-reversal\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful changes\n\n    # Select a random segment to modify\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Dynamic edge-swap: reverse segment with probability based on segment cost\n    if np.random.random() < 0.7:  # Higher probability for larger segments\n        segment = segment[::-1]\n        new_solution[a:b+1] = segment\n\n    # Probabilistic edge-reversal: reverse edges with small probability\n    for i in range(n):\n        if np.random.random() < 0.05:\n            j = (i + 1) % n\n            if new_solution[i] != new_solution[j]:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates (should not happen due to TSP properties)\n    if len(np.unique(new_solution)) != n:\n        return base_solution  # Fallback to original if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 176,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on its potential for local improvement, then applies a hybrid local search strategy combining edge swapping and path relinking to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge swapping and path relinking\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge swapping (randomly swap two edges)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Path relinking (improve by moving nodes to better positions)\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Evaluate potential improvement in both objectives\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n        # Try inserting segment in a different position\n        c = random.randint(0, n-1)\n        if c < a:\n            candidate = np.concatenate((new_solution[:c], segment, new_solution[c:a], new_solution[b+1:]))\n        else:\n            candidate = np.concatenate((new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]))\n\n        # Accept if improvement in at least one objective\n        new_cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7581334387731731,
            3.108926832675934
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge swapping and path relinking\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge swapping (randomly swap two edges)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Path relinking (improve by moving nodes to better positions)\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Evaluate potential improvement in both objectives\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n        # Try inserting segment in a different position\n        c = random.randint(0, n-1)\n        if c < a:\n            candidate = np.concatenate((new_solution[:c], segment, new_solution[c:a], new_solution[b+1:]))\n        else:\n            candidate = np.concatenate((new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]))\n\n        # Accept if improvement in at least one objective\n        new_cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 177,
        "algorithm": "{This algorithm selects a promising solution from the archive based on a hybrid of dominance and crowding distance, then applies a novel edge-swapping local search that considers both objectives' distance matrices to generate a high-quality neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on dominance and crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate dominance and crowding distance\n    dominated_by = [0] * len(archive)\n    crowding_distance = [0.0] * len(archive)\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            if (objectives[i][0] >= objectives[j][0] and objectives[i][1] >= objectives[j][1]) and \\\n               (objectives[i][0] > objectives[j][0] or objectives[i][1] > objectives[j][1]):\n                dominated_by[i] += 1\n\n    # Sort by non-dominated and crowding distance\n    non_dominated = [i for i in range(len(archive)) if dominated_by[i] == 0]\n    if not non_dominated:\n        non_dominated = range(len(archive))\n\n    # Select a random solution from non-dominated\n    selected_idx = np.random.choice(non_dominated)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using a novel edge-swapping strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select two random edges to swap\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while abs(i - j) <= 1:\n        j = np.random.randint(0, n)\n\n    # Ensure i < j for simplicity\n    if i > j:\n        i, j = j, i\n\n    # Calculate the change in both objectives\n    old_edges = [\n        (new_solution[i-1], new_solution[i]),\n        (new_solution[j-1], new_solution[j])\n    ]\n    new_edges = [\n        (new_solution[i-1], new_solution[j]),\n        (new_solution[i], new_solution[j-1])\n    ]\n\n    # Calculate the delta for both objectives\n    delta_obj1 = (distance_matrix_1[new_edges[0][0], new_edges[0][1]] + distance_matrix_1[new_edges[1][0], new_edges[1][1]]) - \\\n                 (distance_matrix_1[old_edges[0][0], old_edges[0][1]] + distance_matrix_1[old_edges[1][0], old_edges[1][1]])\n    delta_obj2 = (distance_matrix_2[new_edges[0][0], new_edges[0][1]] + distance_matrix_2[new_edges[1][0], new_edges[1][1]]) - \\\n                 (distance_matrix_2[old_edges[0][0], old_edges[0][1]] + distance_matrix_2[old_edges[1][0], old_edges[1][1]])\n\n    # Only perform the swap if it improves at least one objective\n    if delta_obj1 < 0 or delta_obj2 < 0:\n        # Perform the swap\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7792020827726258,
            3.570629894733429
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on dominance and crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate dominance and crowding distance\n    dominated_by = [0] * len(archive)\n    crowding_distance = [0.0] * len(archive)\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            if (objectives[i][0] >= objectives[j][0] and objectives[i][1] >= objectives[j][1]) and \\\n               (objectives[i][0] > objectives[j][0] or objectives[i][1] > objectives[j][1]):\n                dominated_by[i] += 1\n\n    # Sort by non-dominated and crowding distance\n    non_dominated = [i for i in range(len(archive)) if dominated_by[i] == 0]\n    if not non_dominated:\n        non_dominated = range(len(archive))\n\n    # Select a random solution from non-dominated\n    selected_idx = np.random.choice(non_dominated)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using a novel edge-swapping strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select two random edges to swap\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while abs(i - j) <= 1:\n        j = np.random.randint(0, n)\n\n    # Ensure i < j for simplicity\n    if i > j:\n        i, j = j, i\n\n    # Calculate the change in both objectives\n    old_edges = [\n        (new_solution[i-1], new_solution[i]),\n        (new_solution[j-1], new_solution[j])\n    ]\n    new_edges = [\n        (new_solution[i-1], new_solution[j]),\n        (new_solution[i], new_solution[j-1])\n    ]\n\n    # Calculate the delta for both objectives\n    delta_obj1 = (distance_matrix_1[new_edges[0][0], new_edges[0][1]] + distance_matrix_1[new_edges[1][0], new_edges[1][1]]) - \\\n                 (distance_matrix_1[old_edges[0][0], old_edges[0][1]] + distance_matrix_1[old_edges[1][0], old_edges[1][1]])\n    delta_obj2 = (distance_matrix_2[new_edges[0][0], new_edges[0][1]] + distance_matrix_2[new_edges[1][0], new_edges[1][1]]) - \\\n                 (distance_matrix_2[old_edges[0][0], old_edges[0][1]] + distance_matrix_2[old_edges[1][0], old_edges[1][1]])\n\n    # Only perform the swap if it improves at least one objective\n    if delta_obj1 < 0 or delta_obj2 < 0:\n        # Perform the swap\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 178,
        "algorithm": "{This heuristic function selects a solution from the archive based on a combined objective metric, then applies a hybrid local search that combines 2-opt with a novel 3-opt-like move to explore non-adjacent edge swaps while maintaining feasibility, ensuring the generated neighbor solution remains a valid TSP tour.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate a combined score (e.g., sum of normalized objectives)\n    scores = [sum(obj) for (_, obj) in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two non-adjacent edges to swap (3-opt-like move)\n    a, b = sorted(random.sample(range(n), 2))\n    while b - a < 2:  # Ensure edges are not adjacent\n        a, b = sorted(random.sample(range(n), 2))\n\n    # Perform the swap\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        raise ValueError(\"Invalid tour generated\")\n\n    return new_solution\n\n",
        "score": [
            -0.7669021866902667,
            2.082359731197357
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate a combined score (e.g., sum of normalized objectives)\n    scores = [sum(obj) for (_, obj) in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two non-adjacent edges to swap (3-opt-like move)\n    a, b = sorted(random.sample(range(n), 2))\n    while b - a < 2:  # Ensure edges are not adjacent\n        a, b = sorted(random.sample(range(n), 2))\n\n    # Perform the swap\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        raise ValueError(\"Invalid tour generated\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 179,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a solution from the archive based on its Pareto dominance and objective diversity, then applies a combination of edge insertion and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choice(range(len(archive)))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly choose a segment to reverse\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 1)\n    segment = new_solution[start:end+1]\n\n    # Reverse the segment\n    reversed_segment = segment[::-1]\n    new_solution[start:end+1] = reversed_segment\n\n    # Optionally insert a random edge\n    if random.random() < 0.5:\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates and missing nodes\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8281197660244558,
            1.3306224942207336
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choice(range(len(archive)))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly choose a segment to reverse\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 1)\n    segment = new_solution[start:end+1]\n\n    # Reverse the segment\n    reversed_segment = segment[::-1]\n    new_solution[start:end+1] = reversed_segment\n\n    # Optionally insert a random edge\n    if random.random() < 0.5:\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates and missing nodes\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 180,
        "algorithm": "{This heuristic function selects a promising solution from the archive based on a weighted combination of its objectives, applies a hybrid local search operator that combines edge-swapping and path-relinking to generate a neighbor solution, and ensures feasibility by maintaining a valid TSP tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-front solutions or those with low dominance)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Hybrid local search: combine edge-swapping and path-relinking\n    new_solution = base_solution.copy()\n\n    # Step 1: Edge-swapping for diversification\n    for _ in range(2):  # Perform a few edge swaps\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Path-relinking for intensification\n    # Select a random segment to relink\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = base_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], segment, new_solution[b+1:]])\n\n    # Ensure feasibility by repairing if necessary\n    # This is a simplified check; a full repair mechanism would be needed in practice\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or not all(count == 1 for count in counts):\n        # Fallback to a simple 2-opt if repair fails\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6818414465522983,
            0.8261313438415527
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-front solutions or those with low dominance)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Hybrid local search: combine edge-swapping and path-relinking\n    new_solution = base_solution.copy()\n\n    # Step 1: Edge-swapping for diversification\n    for _ in range(2):  # Perform a few edge swaps\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Path-relinking for intensification\n    # Select a random segment to relink\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = base_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], segment, new_solution[b+1:]])\n\n    # Ensure feasibility by repairing if necessary\n    # This is a simplified check; a full repair mechanism would be needed in practice\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or not all(count == 1 for count in counts):\n        # Fallback to a simple 2-opt if repair fails\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 181,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Combine 2-opt with a novel segment reversal and insertion\n    n = len(base_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Segment reversal (like 2-opt but with a larger segment)\n    segment = new_solution[i:j+1]\n    new_solution[i:j+1] = segment[::-1]\n\n    # Novel segment insertion: Move a random segment to a new position\n    k = np.random.randint(n)\n    segment_size = np.random.randint(1, min(5, n))\n    segment_start = np.random.randint(n - segment_size)\n    segment = new_solution[segment_start:segment_start + segment_size]\n    new_solution = np.concatenate([new_solution[:segment_start], new_solution[segment_start + segment_size:]])\n    insert_pos = np.random.randint(len(new_solution) - segment_size + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8920305533984296,
            1.3866034746170044
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Combine 2-opt with a novel segment reversal and insertion\n    n = len(base_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Segment reversal (like 2-opt but with a larger segment)\n    segment = new_solution[i:j+1]\n    new_solution[i:j+1] = segment[::-1]\n\n    # Novel segment insertion: Move a random segment to a new position\n    k = np.random.randint(n)\n    segment_size = np.random.randint(1, min(5, n))\n    segment_start = np.random.randint(n - segment_size)\n    segment = new_solution[segment_start:segment_start + segment_size]\n    new_solution = np.concatenate([new_solution[:segment_start], new_solution[segment_start + segment_size:]])\n    insert_pos = np.random.randint(len(new_solution) - segment_size + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 182,
        "algorithm": "{A novel hybrid local search strategy combines edge exchange with a variable-length segment relocation, guided by a Pareto-dominance-based selection of promising solutions from the archive, ensuring feasibility and diversity in the neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = None\n    for sol, _ in archive:\n        dominated = False\n        for _, (cost1, cost2) in archive:\n            if (cost1 < sol[0] and cost2 <= sol[1]) or (cost1 <= sol[0] and cost2 < sol[1]):\n                dominated = True\n                break\n        if not dominated:\n            selected_solution = sol.copy()\n            break\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: variable-length segment relocation with edge exchange\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment of variable length\n    start = np.random.randint(0, n)\n    length = np.random.randint(2, min(5, n - 1))\n    end = (start + length) % n\n\n    # Extract the segment\n    segment = new_solution[start:end]\n    remaining = np.setdiff1d(new_solution, segment)\n\n    # Insert the segment at a new random position\n    insert_pos = np.random.randint(0, len(remaining) + 1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Edge exchange: swap two edges if it improves both objectives\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Calculate current and new edge costs\n    current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n    new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n    current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n    new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n    # Apply edge exchange if beneficial\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n       (new_cost1 <= current_cost1 and new_cost2 < current_cost2) or \\\n       (new_cost1 < current_cost1 and new_cost2 <= current_cost2):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8697071605048033,
            1.5978636145591736
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = None\n    for sol, _ in archive:\n        dominated = False\n        for _, (cost1, cost2) in archive:\n            if (cost1 < sol[0] and cost2 <= sol[1]) or (cost1 <= sol[0] and cost2 < sol[1]):\n                dominated = True\n                break\n        if not dominated:\n            selected_solution = sol.copy()\n            break\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: variable-length segment relocation with edge exchange\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment of variable length\n    start = np.random.randint(0, n)\n    length = np.random.randint(2, min(5, n - 1))\n    end = (start + length) % n\n\n    # Extract the segment\n    segment = new_solution[start:end]\n    remaining = np.setdiff1d(new_solution, segment)\n\n    # Insert the segment at a new random position\n    insert_pos = np.random.randint(0, len(remaining) + 1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Edge exchange: swap two edges if it improves both objectives\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Calculate current and new edge costs\n    current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n    new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n    current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n    new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n    # Apply edge exchange if beneficial\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n       (new_cost1 <= current_cost1 and new_cost2 < current_cost2) or \\\n       (new_cost1 < current_cost1 and new_cost2 <= current_cost2):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 183,
        "algorithm": "{A novel adaptive local search heuristic that combines diversified edge swaps with dynamic segment reordering to explore high-quality regions of the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Create a copy of the selected solution\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive local search operator: hybrid of edge swaps and segment reordering\n    if random.random() < 0.7:  # 70% chance for edge swaps\n        # Perform multiple random edge swaps\n        for _ in range(random.randint(2, 5)):\n            a, b = sorted(random.sample(range(n), 2))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:  # Segment reordering\n        # Split the tour into 3 segments and reorder them\n        split_points = sorted(random.sample(range(1, n-1), 2))\n        seg1 = new_solution[:split_points[0]]\n        seg2 = new_solution[split_points[0]:split_points[1]]\n        seg3 = new_solution[split_points[1]:]\n        # Randomly permute the segments\n        segments = [seg1, seg2, seg3]\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n    # Ensure the solution remains a valid tour (no duplicates, complete)\n    assert len(np.unique(new_solution)) == n, \"Invalid tour generated\"\n    return new_solution\n\n",
        "score": [
            -0.8868460371035205,
            2.3125486969947815
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Create a copy of the selected solution\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive local search operator: hybrid of edge swaps and segment reordering\n    if random.random() < 0.7:  # 70% chance for edge swaps\n        # Perform multiple random edge swaps\n        for _ in range(random.randint(2, 5)):\n            a, b = sorted(random.sample(range(n), 2))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:  # Segment reordering\n        # Split the tour into 3 segments and reorder them\n        split_points = sorted(random.sample(range(1, n-1), 2))\n        seg1 = new_solution[:split_points[0]]\n        seg2 = new_solution[split_points[0]:split_points[1]]\n        seg3 = new_solution[split_points[1]:]\n        # Randomly permute the segments\n        segments = [seg1, seg2, seg3]\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n    # Ensure the solution remains a valid tour (no duplicates, complete)\n    assert len(np.unique(new_solution)) == n, \"Invalid tour generated\"\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 184,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on objective diversity and applies a hybrid local search combining edge insertion and segment reversal, ensuring feasibility by validating the tour after each modification.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select a segment to reverse or insert\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Apply segment reversal or edge insertion based on a random choice\n    if np.random.rand() < 0.5:\n        # Segment reversal\n        new_solution[a:b+1] = segment[::-1]\n    else:\n        # Edge insertion: remove segment and reinsert at a different position\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = np.random.randint(0, len(new_solution) + 1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure the solution remains a valid tour\n    if len(new_solution) != n:\n        # Fallback to a simple swap if the above operations fail\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8065041734105574,
            1.9028048515319824
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select a segment to reverse or insert\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Apply segment reversal or edge insertion based on a random choice\n    if np.random.rand() < 0.5:\n        # Segment reversal\n        new_solution[a:b+1] = segment[::-1]\n    else:\n        # Edge insertion: remove segment and reinsert at a different position\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = np.random.randint(0, len(new_solution) + 1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure the solution remains a valid tour\n    if len(new_solution) != n:\n        # Fallback to a simple swap if the above operations fail\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 185,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive edge exchange with multi-objective path relinking, prioritizing solutions with high dominance potential and leveraging both distance matrices to guide the exploration of Pareto-optimal regions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution, selected_objective = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: adaptive edge exchange with multi-objective guidance\n    n = len(new_solution)\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    # Determine the better edge to replace based on both objectives\n    a, b = new_solution[i], new_solution[(i + 1) % n]\n    c, d = new_solution[j], new_solution[(j + 1) % n]\n\n    # Calculate costs for both objectives\n    cost1_before = distance_matrix_1[a, b] + distance_matrix_1[c, d]\n    cost1_after = distance_matrix_1[a, c] + distance_matrix_1[b, d]\n    cost2_before = distance_matrix_2[a, b] + distance_matrix_2[c, d]\n    cost2_after = distance_matrix_2[a, c] + distance_matrix_2[b, d]\n\n    # Multi-objective improvement check\n    if (cost1_after < cost1_before and cost2_after <= cost2_before) or \\\n       (cost1_after <= cost1_before and cost2_after < cost2_before):\n        # Perform the edge exchange\n        if j > i:\n            new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n        else:\n            new_solution[j+1:i+1] = np.flip(new_solution[j+1:i+1])\n\n    # Additional path relinking step\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    while k == l:\n        l = random.randint(0, n - 1)\n\n    # Check if path relinking improves both objectives\n    if k < l:\n        segment = new_solution[k:l+1]\n        cost1_segment = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        cost2_segment = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n        reversed_segment = segment[::-1]\n        cost1_reversed = sum(distance_matrix_1[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n        cost2_reversed = sum(distance_matrix_2[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n\n        if (cost1_reversed < cost1_segment and cost2_reversed <= cost2_segment) or \\\n           (cost1_reversed <= cost1_segment and cost2_reversed < cost2_segment):\n            new_solution[k:l+1] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            -0.7405426578640479,
            2.554143488407135
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution, selected_objective = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: adaptive edge exchange with multi-objective guidance\n    n = len(new_solution)\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while i == j:\n        j = random.randint(0, n - 1)\n\n    # Determine the better edge to replace based on both objectives\n    a, b = new_solution[i], new_solution[(i + 1) % n]\n    c, d = new_solution[j], new_solution[(j + 1) % n]\n\n    # Calculate costs for both objectives\n    cost1_before = distance_matrix_1[a, b] + distance_matrix_1[c, d]\n    cost1_after = distance_matrix_1[a, c] + distance_matrix_1[b, d]\n    cost2_before = distance_matrix_2[a, b] + distance_matrix_2[c, d]\n    cost2_after = distance_matrix_2[a, c] + distance_matrix_2[b, d]\n\n    # Multi-objective improvement check\n    if (cost1_after < cost1_before and cost2_after <= cost2_before) or \\\n       (cost1_after <= cost1_before and cost2_after < cost2_before):\n        # Perform the edge exchange\n        if j > i:\n            new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n        else:\n            new_solution[j+1:i+1] = np.flip(new_solution[j+1:i+1])\n\n    # Additional path relinking step\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    while k == l:\n        l = random.randint(0, n - 1)\n\n    # Check if path relinking improves both objectives\n    if k < l:\n        segment = new_solution[k:l+1]\n        cost1_segment = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        cost2_segment = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n        reversed_segment = segment[::-1]\n        cost1_reversed = sum(distance_matrix_1[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n        cost2_reversed = sum(distance_matrix_2[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n\n        if (cost1_reversed < cost1_segment and cost2_reversed <= cost2_segment) or \\\n           (cost1_reversed <= cost1_segment and cost2_reversed < cost2_segment):\n            new_solution[k:l+1] = reversed_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 186,
        "algorithm": "{This algorithm selects a promising solution from the archive based on a hybrid of Pareto dominance and non-dominated sorting, then applies a novel edge-swapping and segment-reversing local search operator to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high chance to be non-dominated or have potential for improvement\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (i + 1) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search operator: Hybrid Edge-Swapping and Segment-Reversing\n    n = len(new_solution)\n    for _ in range(10):  # Limit the number of attempts for efficiency\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Try to insert the reversed segment elsewhere\n        c, d = sorted(random.sample(range(n), 2))\n        if c > d:\n            c, d = d, c\n\n        # Create a new candidate solution\n        candidate = np.concatenate([new_solution[:c], reversed_segment, new_solution[d+1:]])\n        if len(candidate) == n and len(np.unique(candidate)) == n:  # Ensure feasibility\n            # Evaluate the candidate's objectives\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n\n            # Accept the candidate if it improves at least one objective\n            if (cost1 < archive[selected_idx][1][0]) or (cost2 < archive[selected_idx][1][1]):\n                new_solution = candidate\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.8115875385401569,
            8.38838255405426
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high chance to be non-dominated or have potential for improvement\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (i + 1) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search operator: Hybrid Edge-Swapping and Segment-Reversing\n    n = len(new_solution)\n    for _ in range(10):  # Limit the number of attempts for efficiency\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Try to insert the reversed segment elsewhere\n        c, d = sorted(random.sample(range(n), 2))\n        if c > d:\n            c, d = d, c\n\n        # Create a new candidate solution\n        candidate = np.concatenate([new_solution[:c], reversed_segment, new_solution[d+1:]])\n        if len(candidate) == n and len(np.unique(candidate)) == n:  # Ensure feasibility\n            # Evaluate the candidate's objectives\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n\n            # Accept the candidate if it improves at least one objective\n            if (cost1 < archive[selected_idx][1][0]) or (cost2 < archive[selected_idx][1][1]):\n                new_solution = candidate\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 187,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)  # Select based on average cost\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge-swapping strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment and reverse it (2-opt-like)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Novel edge-swapping: swap edges that improve both objectives\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        a, b, c, d = random.sample(range(n), 4)\n        # Check if swapping edges (a->b and c->d) to (a->c and b->d) improves both objectives\n        old_cost1 = distance_matrix_1[base_solution[a], base_solution[b]] + distance_matrix_1[base_solution[c], base_solution[d]]\n        new_cost1 = distance_matrix_1[base_solution[a], base_solution[c]] + distance_matrix_1[base_solution[b], base_solution[d]]\n        old_cost2 = distance_matrix_2[base_solution[a], base_solution[b]] + distance_matrix_2[base_solution[c], base_solution[d]]\n        new_cost2 = distance_matrix_2[base_solution[a], base_solution[c]] + distance_matrix_2[base_solution[b], base_solution[d]]\n\n        if (new_cost1 < old_cost1) and (new_cost2 < old_cost2):\n            # Apply the swap\n            new_solution[a], new_solution[b], new_solution[c], new_solution[d] = new_solution[c], new_solution[d], new_solution[a], new_solution[b]\n            break  # Only apply one swap per iteration\n\n    return new_solution\n\n",
        "score": [
            -0.9930560834727069,
            2.3339802622795105
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)  # Select based on average cost\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge-swapping strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment and reverse it (2-opt-like)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Novel edge-swapping: swap edges that improve both objectives\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        a, b, c, d = random.sample(range(n), 4)\n        # Check if swapping edges (a->b and c->d) to (a->c and b->d) improves both objectives\n        old_cost1 = distance_matrix_1[base_solution[a], base_solution[b]] + distance_matrix_1[base_solution[c], base_solution[d]]\n        new_cost1 = distance_matrix_1[base_solution[a], base_solution[c]] + distance_matrix_1[base_solution[b], base_solution[d]]\n        old_cost2 = distance_matrix_2[base_solution[a], base_solution[b]] + distance_matrix_2[base_solution[c], base_solution[d]]\n        new_cost2 = distance_matrix_2[base_solution[a], base_solution[c]] + distance_matrix_2[base_solution[b], base_solution[d]]\n\n        if (new_cost1 < old_cost1) and (new_cost2 < old_cost2):\n            # Apply the swap\n            new_solution[a], new_solution[b], new_solution[c], new_solution[d] = new_solution[c], new_solution[d], new_solution[a], new_solution[b]\n            break  # Only apply one swap per iteration\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 188,
        "algorithm": "{A novel hybrid local search operator that combines edge swapping with a dynamic segment inversion strategy, guided by Pareto dominance and objective-space diversity, to explore high-quality regions in the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1]))[0].copy()\n\n    # Hybrid local search: dynamic segment inversion with edge swapping\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Randomly select segment to invert\n    start, end = np.random.choice(n, 2, replace=False)\n    if start > end:\n        start, end = end, start\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Edge swapping with diversity consideration\n    for _ in range(3):  # Perform 3 edge swaps\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        if j - i > 1:  # Ensure valid segment\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if inversion causes duplicates\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6838538607312983,
            1.7361661195755005
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1]))[0].copy()\n\n    # Hybrid local search: dynamic segment inversion with edge swapping\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Randomly select segment to invert\n    start, end = np.random.choice(n, 2, replace=False)\n    if start > end:\n        start, end = end, start\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Edge swapping with diversity consideration\n    for _ in range(3):  # Perform 3 edge swaps\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        if j - i > 1:  # Ensure valid segment\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if inversion causes duplicates\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 189,
        "algorithm": "{The algorithm selects a promising solution from the archive using a combination of dominance-based filtering and crowding distance, then applies a hybrid local search operator that combines 2-opt with a novel segment reinsertion strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def is_dominated(a, b):\n        return a[0] <= b[0] and a[1] <= b[1] and (a[0] < b[0] or a[1] < b[1])\n\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if is_dominated(obj, other_obj):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Compute crowding distance\n    def crowding_distance(pop):\n        distances = [0] * len(pop)\n        for m in range(2):\n            sorted_idx = np.argsort([obj[m] for _, obj in pop])\n            distances[sorted_idx[0]] = distances[sorted_idx[-1]] = float('inf')\n            for i in range(1, len(pop)-1):\n                if pop[sorted_idx[-1]][1][m] == pop[sorted_idx[0]][1][m]:\n                    continue\n                distances[sorted_idx[i]] += (pop[sorted_idx[i+1]][1][m] - pop[sorted_idx[i-1]][1][m]) / (pop[sorted_idx[-1]][1][m] - pop[sorted_idx[0]][1][m])\n        return distances\n\n    distances = crowding_distance(non_dominated)\n    selected_idx = np.argmax(distances)\n    base_solution = non_dominated[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search operator\n    def hybrid_local_search(solution):\n        n = len(solution)\n        new_sol = solution.copy()\n\n        # Randomly select two segments\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n\n        # Ensure segments are distinct and valid\n        if a == c and b == d:\n            return new_sol\n\n        # Reinsert segment [c,d] after position b\n        segment = new_sol[c:d+1]\n        remaining = np.concatenate([new_sol[:c], new_sol[d+1:]])\n        new_sol = np.concatenate([remaining[:b+1], segment, remaining[b+1:]])\n\n        # Check if the new solution is valid (no duplicates)\n        if len(np.unique(new_sol)) == n:\n            return new_sol\n        else:\n            return solution\n\n    new_solution = hybrid_local_search(base_solution)\n\n    # Ensure the solution is a valid tour\n    if len(np.unique(new_solution)) != len(instance):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9636288941380431,
            3.1243348121643066
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def is_dominated(a, b):\n        return a[0] <= b[0] and a[1] <= b[1] and (a[0] < b[0] or a[1] < b[1])\n\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if is_dominated(obj, other_obj):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Compute crowding distance\n    def crowding_distance(pop):\n        distances = [0] * len(pop)\n        for m in range(2):\n            sorted_idx = np.argsort([obj[m] for _, obj in pop])\n            distances[sorted_idx[0]] = distances[sorted_idx[-1]] = float('inf')\n            for i in range(1, len(pop)-1):\n                if pop[sorted_idx[-1]][1][m] == pop[sorted_idx[0]][1][m]:\n                    continue\n                distances[sorted_idx[i]] += (pop[sorted_idx[i+1]][1][m] - pop[sorted_idx[i-1]][1][m]) / (pop[sorted_idx[-1]][1][m] - pop[sorted_idx[0]][1][m])\n        return distances\n\n    distances = crowding_distance(non_dominated)\n    selected_idx = np.argmax(distances)\n    base_solution = non_dominated[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search operator\n    def hybrid_local_search(solution):\n        n = len(solution)\n        new_sol = solution.copy()\n\n        # Randomly select two segments\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n\n        # Ensure segments are distinct and valid\n        if a == c and b == d:\n            return new_sol\n\n        # Reinsert segment [c,d] after position b\n        segment = new_sol[c:d+1]\n        remaining = np.concatenate([new_sol[:c], new_sol[d+1:]])\n        new_sol = np.concatenate([remaining[:b+1], segment, remaining[b+1:]])\n\n        # Check if the new solution is valid (no duplicates)\n        if len(np.unique(new_sol)) == n:\n            return new_sol\n        else:\n            return solution\n\n    new_solution = hybrid_local_search(base_solution)\n\n    # Ensure the solution is a valid tour\n    if len(np.unique(new_solution)) != len(instance):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 190,
        "algorithm": "{The heuristic function selects a promising solution from the archive based on a combination of objective values and solution quality, then applies a hybrid local search operator that combines edge exchange and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Choose the solution with the best combined objective value\n    best_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    base_solution = best_solution.copy()\n\n    # Hybrid local search operator: combine edge exchange and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Ensure segments are distinct and non-overlapping\n    if a == c and b == d:\n        c, d = (c + 1) % n, (d + 1) % n\n\n    # Reverse the segments\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Ensure the solution remains a valid tour (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6782535670884169,
            3.1094414591789246
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Choose the solution with the best combined objective value\n    best_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    base_solution = best_solution.copy()\n\n    # Hybrid local search operator: combine edge exchange and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Ensure segments are distinct and non-overlapping\n    if a == c and b == d:\n        c, d = (c + 1) % n, (d + 1) % n\n\n    # Reverse the segments\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Ensure the solution remains a valid tour (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 191,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n\n    # Hybrid Local Search: Combine 3-opt with a custom move that considers both distance matrices\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to modify\n    a, b, c = sorted(random.sample(range(n), 3))\n    i, j, k = new_solution[a], new_solution[b], new_solution[c]\n\n    # Apply a custom 3-opt-like move that considers both objectives\n    if random.random() < 0.5:\n        # Option 1: Reverse segment between a and b, then reconnect\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[b+1:] = np.roll(new_solution[b+1:], -(k - new_solution[b+1]))\n    else:\n        # Option 2: Rotate segments to balance both objectives\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], (j - i) % (b - a + 1))\n\n    # Ensure the solution remains valid (no duplicates and all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.33186696375527436,
            3.1888617873191833
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n\n    # Hybrid Local Search: Combine 3-opt with a custom move that considers both distance matrices\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to modify\n    a, b, c = sorted(random.sample(range(n), 3))\n    i, j, k = new_solution[a], new_solution[b], new_solution[c]\n\n    # Apply a custom 3-opt-like move that considers both objectives\n    if random.random() < 0.5:\n        # Option 1: Reverse segment between a and b, then reconnect\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[b+1:] = np.roll(new_solution[b+1:], -(k - new_solution[b+1]))\n    else:\n        # Option 2: Rotate segments to balance both objectives\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], (j - i) % (b - a + 1))\n\n    # Ensure the solution remains valid (no duplicates and all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 192,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge insertion heuristic\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select 4 distinct edges to modify\n    indices = np.random.choice(n, size=4, replace=False)\n    a, b, c, d = sorted(indices)\n\n    # Apply a novel 4-opt-like move: reconnect edges in a non-standard way\n    if np.random.rand() < 0.5:\n        # Case 1: Cross edges to create a more diverse structure\n        new_solution[a:b] = selected_solution[a:b][::-1]\n        new_solution[c:d] = selected_solution[c:d][::-1]\n    else:\n        # Case 2: Shift segments to explore new neighborhoods\n        segment = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b], new_solution[c:]])\n\n    # Ensure feasibility by checking for duplicates and fixing if necessary\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        # If duplicates exist, revert to a simple swap as fallback\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8904377014357736,
            1.8188572525978088
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge insertion heuristic\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select 4 distinct edges to modify\n    indices = np.random.choice(n, size=4, replace=False)\n    a, b, c, d = sorted(indices)\n\n    # Apply a novel 4-opt-like move: reconnect edges in a non-standard way\n    if np.random.rand() < 0.5:\n        # Case 1: Cross edges to create a more diverse structure\n        new_solution[a:b] = selected_solution[a:b][::-1]\n        new_solution[c:d] = selected_solution[c:d][::-1]\n    else:\n        # Case 2: Shift segments to explore new neighborhoods\n        segment = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b], new_solution[c:]])\n\n    # Ensure feasibility by checking for duplicates and fixing if necessary\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        # If duplicates exist, revert to a simple swap as fallback\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 193,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n\n    # Hybrid local search: combine 3-opt with a novel edge swap based on distance matrices\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to modify\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply a novel edge swap: reorder nodes between a and b, then between b and c\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Ensure feasibility by checking for duplicates and repairing if needed\n    unique, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique[counts > 1]\n\n    if len(duplicates) > 0:\n        # Repair by swapping duplicate nodes with missing ones\n        missing = np.setdiff1d(np.arange(n), new_solution)\n        for dup in duplicates:\n            if len(missing) > 0:\n                idx = np.where(new_solution == dup)[0]\n                new_solution[idx[1:]] = np.random.choice(missing, len(idx[1:]), replace=False)\n                missing = np.setdiff1d(missing, new_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.36127156874355165,
            1.7306789755821228
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n\n    # Hybrid local search: combine 3-opt with a novel edge swap based on distance matrices\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to modify\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply a novel edge swap: reorder nodes between a and b, then between b and c\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Ensure feasibility by checking for duplicates and repairing if needed\n    unique, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique[counts > 1]\n\n    if len(duplicates) > 0:\n        # Repair by swapping duplicate nodes with missing ones\n        missing = np.setdiff1d(np.arange(n), new_solution)\n        for dup in duplicates:\n            if len(missing) > 0:\n                idx = np.where(new_solution == dup)[0]\n                new_solution[idx[1:]] = np.random.choice(missing, len(idx[1:]), replace=False)\n                missing = np.setdiff1d(missing, new_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 194,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with high normalized objective values)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_obj[:, 0] * 0.7 + normalized_obj[:, 1] * 0.3  # Weighted sum\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive node insertion and segment reversal\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Step 1: Identify critical segments based on objective trade-offs\n    segment_length = max(2, n // 10)\n    critical_segments = []\n    for i in range(0, n, segment_length):\n        segment = base_solution[i:i+segment_length]\n        cost1 = sum(distance_matrix_1[segment[j], segment[(j+1)%len(segment)]] for j in range(len(segment)))\n        cost2 = sum(distance_matrix_2[segment[j], segment[(j+1)%len(segment)]] for j in range(len(segment)))\n        critical_segments.append((i, cost1, cost2))\n\n    # Step 2: Select segment with highest combined cost (potential for improvement)\n    critical_segments.sort(key=lambda x: -(x[1] * 0.6 + x[2] * 0.4))\n    start_idx = critical_segments[0][0]\n    segment_size = min(segment_length, n - start_idx)\n\n    # Step 3: Perform adaptive operation (node insertion or segment reversal)\n    if random.random() < 0.5:  # 50% chance for node insertion\n        # Node insertion: remove a node from the segment and reinsert it elsewhere\n        if segment_size > 2:\n            remove_pos = random.randint(start_idx, start_idx + segment_size - 1)\n            node = new_solution[remove_pos]\n            new_solution = np.concatenate([new_solution[:remove_pos], new_solution[remove_pos+1:]])\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n    else:  # Segment reversal\n        # Reverse the segment to potentially reduce both objectives\n        if segment_size > 1:\n            segment = new_solution[start_idx:start_idx+segment_size]\n            new_solution[start_idx:start_idx+segment_size] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9308846090701244,
            2.100978672504425
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with high normalized objective values)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_obj[:, 0] * 0.7 + normalized_obj[:, 1] * 0.3  # Weighted sum\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive node insertion and segment reversal\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Step 1: Identify critical segments based on objective trade-offs\n    segment_length = max(2, n // 10)\n    critical_segments = []\n    for i in range(0, n, segment_length):\n        segment = base_solution[i:i+segment_length]\n        cost1 = sum(distance_matrix_1[segment[j], segment[(j+1)%len(segment)]] for j in range(len(segment)))\n        cost2 = sum(distance_matrix_2[segment[j], segment[(j+1)%len(segment)]] for j in range(len(segment)))\n        critical_segments.append((i, cost1, cost2))\n\n    # Step 2: Select segment with highest combined cost (potential for improvement)\n    critical_segments.sort(key=lambda x: -(x[1] * 0.6 + x[2] * 0.4))\n    start_idx = critical_segments[0][0]\n    segment_size = min(segment_length, n - start_idx)\n\n    # Step 3: Perform adaptive operation (node insertion or segment reversal)\n    if random.random() < 0.5:  # 50% chance for node insertion\n        # Node insertion: remove a node from the segment and reinsert it elsewhere\n        if segment_size > 2:\n            remove_pos = random.randint(start_idx, start_idx + segment_size - 1)\n            node = new_solution[remove_pos]\n            new_solution = np.concatenate([new_solution[:remove_pos], new_solution[remove_pos+1:]])\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n    else:  # Segment reversal\n        # Reverse the segment to potentially reduce both objectives\n        if segment_size > 1:\n            segment = new_solution[start_idx:start_idx+segment_size]\n            new_solution[start_idx:start_idx+segment_size] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 195,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Combine edge insertion and node relocation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to relocate\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Remove the segment [i, j]\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n    # Find the best insertion point for the segment\n    best_pos = 0\n    best_cost = float('inf')\n    for pos in range(len(new_solution)):\n        candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n        cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(len(candidate)-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(len(candidate)-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        total_cost = cost1 + cost2\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n\n    # Insert the segment at the best position\n    new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8983196930922085,
            6.71889340877533
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Combine edge insertion and node relocation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to relocate\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Remove the segment [i, j]\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n    # Find the best insertion point for the segment\n    best_pos = 0\n    best_cost = float('inf')\n    for pos in range(len(new_solution)):\n        candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n        cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(len(candidate)-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(len(candidate)-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        total_cost = cost1 + cost2\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n\n    # Insert the segment at the best position\n    new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 196,
        "algorithm": "{A novel hybrid local search algorithm that combines edge exchange with a dynamic neighborhood selection strategy to balance exploration and exploitation in multi-objective TSP, prioritizing high-potential solutions from the archive while ensuring feasibility through constrained operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    ranks = [i for i in range(len(archive))]\n    selected_idx = random.choices(ranks, weights=[len(archive) - i for i in ranks], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Select a random segment (dynamic size)\n    segment_size = random.randint(2, max(2, n // 3))\n    start = random.randint(0, n - segment_size)\n    segment = new_solution[start:start + segment_size]\n\n    # Step 2: Reverse the segment (like 2-opt but with variable segment size)\n    reversed_segment = segment[::-1]\n    new_solution[start:start + segment_size] = reversed_segment\n\n    # Step 3: Apply a dynamic edge exchange based on distance matrices\n    # Select two random edges from the segment and the rest of the tour\n    if segment_size > 2:\n        # Choose two edges within the segment\n        i = random.randint(0, segment_size - 2)\n        j = random.randint(i + 1, segment_size - 1)\n\n        # Choose two edges from the rest of the tour\n        k = random.randint(0, n - 2)\n        while k in range(start, start + segment_size):\n            k = random.randint(0, n - 2)\n        l = (k + 1) % n\n\n        # Calculate the cost difference in both objectives\n        # Original edges: (k, l), (new_solution[k], new_solution[l])\n        # New edges: (k, new_solution[i]), (new_solution[j], l)\n        cost1_diff = (distance_matrix_1[new_solution[k], new_solution[i]] +\n                      distance_matrix_1[new_solution[j], new_solution[l]]) - \\\n                     (distance_matrix_1[new_solution[k], new_solution[l]] +\n                      distance_matrix_1[new_solution[i], new_solution[j]])\n\n        cost2_diff = (distance_matrix_2[new_solution[k], new_solution[i]] +\n                      distance_matrix_2[new_solution[j], new_solution[l]]) - \\\n                     (distance_matrix_2[new_solution[k], new_solution[l]] +\n                      distance_matrix_2[new_solution[i], new_solution[j]])\n\n        # Accept if at least one objective improves\n        if cost1_diff < 0 or cost2_diff < 0:\n            # Swap the edges\n            new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n            new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n\n    return new_solution\n\n",
        "score": [
            -0.8582880217140388,
            1.815435767173767
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    ranks = [i for i in range(len(archive))]\n    selected_idx = random.choices(ranks, weights=[len(archive) - i for i in ranks], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Select a random segment (dynamic size)\n    segment_size = random.randint(2, max(2, n // 3))\n    start = random.randint(0, n - segment_size)\n    segment = new_solution[start:start + segment_size]\n\n    # Step 2: Reverse the segment (like 2-opt but with variable segment size)\n    reversed_segment = segment[::-1]\n    new_solution[start:start + segment_size] = reversed_segment\n\n    # Step 3: Apply a dynamic edge exchange based on distance matrices\n    # Select two random edges from the segment and the rest of the tour\n    if segment_size > 2:\n        # Choose two edges within the segment\n        i = random.randint(0, segment_size - 2)\n        j = random.randint(i + 1, segment_size - 1)\n\n        # Choose two edges from the rest of the tour\n        k = random.randint(0, n - 2)\n        while k in range(start, start + segment_size):\n            k = random.randint(0, n - 2)\n        l = (k + 1) % n\n\n        # Calculate the cost difference in both objectives\n        # Original edges: (k, l), (new_solution[k], new_solution[l])\n        # New edges: (k, new_solution[i]), (new_solution[j], l)\n        cost1_diff = (distance_matrix_1[new_solution[k], new_solution[i]] +\n                      distance_matrix_1[new_solution[j], new_solution[l]]) - \\\n                     (distance_matrix_1[new_solution[k], new_solution[l]] +\n                      distance_matrix_1[new_solution[i], new_solution[j]])\n\n        cost2_diff = (distance_matrix_2[new_solution[k], new_solution[i]] +\n                      distance_matrix_2[new_solution[j], new_solution[l]]) - \\\n                     (distance_matrix_2[new_solution[k], new_solution[l]] +\n                      distance_matrix_2[new_solution[i], new_solution[j]])\n\n        # Accept if at least one objective improves\n        if cost1_diff < 0 or cost2_diff < 0:\n            # Swap the edges\n            new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n            new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 197,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search: Segment-based perturbation followed by edge insertion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Step 1: Segment-based perturbation (novel approach)\n    segment_length = max(3, n // 5)  # Randomly select a segment\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start + segment_length]\n\n    # Reverse the segment to disrupt the tour\n    new_solution[start:start + segment_length] = segment[::-1]\n\n    # Step 2: Edge insertion (improves local structure)\n    for _ in range(2):  # Perform 2 insertions\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        if i != j:\n            # Remove node at i and reinsert at j\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            insert_pos = random.randint(0, n - 2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8528023992442076,
            1.463337779045105
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search: Segment-based perturbation followed by edge insertion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Step 1: Segment-based perturbation (novel approach)\n    segment_length = max(3, n // 5)  # Randomly select a segment\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start + segment_length]\n\n    # Reverse the segment to disrupt the tour\n    new_solution[start:start + segment_length] = segment[::-1]\n\n    # Step 2: Edge insertion (improves local structure)\n    for _ in range(2):  # Perform 2 insertions\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        if i != j:\n            # Remove node at i and reinsert at j\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            insert_pos = random.randint(0, n - 2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 198,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and node relocation\n    n = len(new_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    k = np.random.randint(0, n)\n\n    # Ensure all indices are distinct\n    while j == i or k == i or k == j:\n        j = np.random.randint(0, n)\n        k = np.random.randint(0, n)\n\n    # Perform a 3-opt move (insert node at position i between j and k)\n    if i < j < k:\n        new_solution = np.concatenate((new_solution[:i], new_solution[j:k], new_solution[i:j], new_solution[k:]))\n    elif i < k < j:\n        new_solution = np.concatenate((new_solution[:i], new_solution[k:j], new_solution[i:k], new_solution[j:]))\n    else:  # j < i < k\n        new_solution = np.concatenate((new_solution[:j], new_solution[i:k], new_solution[j:i], new_solution[k:]))\n\n    return new_solution\n\n",
        "score": [
            -0.8804199477363392,
            1.1926817893981934
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and node relocation\n    n = len(new_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    k = np.random.randint(0, n)\n\n    # Ensure all indices are distinct\n    while j == i or k == i or k == j:\n        j = np.random.randint(0, n)\n        k = np.random.randint(0, n)\n\n    # Perform a 3-opt move (insert node at position i between j and k)\n    if i < j < k:\n        new_solution = np.concatenate((new_solution[:i], new_solution[j:k], new_solution[i:j], new_solution[k:]))\n    elif i < k < j:\n        new_solution = np.concatenate((new_solution[:i], new_solution[k:j], new_solution[i:k], new_solution[j:]))\n    else:  # j < i < k\n        new_solution = np.concatenate((new_solution[:j], new_solution[i:k], new_solution[j:i], new_solution[k:]))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 199,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = random.randint(0, max(0, len(archive_sorted) // 5 - 1))\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: Edge Insertion + Path Relinking\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge Insertion - Remove a random edge and reinsert it in the best possible position\n    i = random.randint(0, n - 1)\n    j = (i + 1) % n\n\n    # Remove edge (i, j)\n    removed_node = new_solution[j]\n    new_solution = np.delete(new_solution, j)\n\n    # Find the best insertion position for the removed node\n    best_cost = float('inf')\n    best_pos = 0\n    for pos in range(len(new_solution)):\n        # Insert at position pos\n        candidate = np.insert(new_solution, pos, removed_node)\n        cost1 = sum(distance_matrix_1[candidate[k], candidate[(k + 1) % n]] for k in range(n))\n        cost2 = sum(distance_matrix_2[candidate[k], candidate[(k + 1) % n]] for k in range(n))\n        total_cost = cost1 + cost2\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n\n    new_solution = np.insert(new_solution, best_pos, removed_node)\n\n    # Step 2: Path Relinking - Swap edges to improve solution further\n    for _ in range(5):  # Perform 5 random swaps\n        a, b = random.sample(range(n), 2)\n        if a > b:\n            a, b = b, a\n        # Reverse the segment between a and b\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7442135909483188,
            14.65776777267456
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = random.randint(0, max(0, len(archive_sorted) // 5 - 1))\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: Edge Insertion + Path Relinking\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge Insertion - Remove a random edge and reinsert it in the best possible position\n    i = random.randint(0, n - 1)\n    j = (i + 1) % n\n\n    # Remove edge (i, j)\n    removed_node = new_solution[j]\n    new_solution = np.delete(new_solution, j)\n\n    # Find the best insertion position for the removed node\n    best_cost = float('inf')\n    best_pos = 0\n    for pos in range(len(new_solution)):\n        # Insert at position pos\n        candidate = np.insert(new_solution, pos, removed_node)\n        cost1 = sum(distance_matrix_1[candidate[k], candidate[(k + 1) % n]] for k in range(n))\n        cost2 = sum(distance_matrix_2[candidate[k], candidate[(k + 1) % n]] for k in range(n))\n        total_cost = cost1 + cost2\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n\n    new_solution = np.insert(new_solution, best_pos, removed_node)\n\n    # Step 2: Path Relinking - Swap edges to improve solution further\n    for _ in range(5):  # Perform 5 random swaps\n        a, b = random.sample(range(n), 2)\n        if a > b:\n            a, b = b, a\n        # Reverse the segment between a and b\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 200,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply double-bridge move: select 4 random edges and reconnect them in a novel pattern\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No enough nodes to perform the move\n\n    # Select 4 distinct indices\n    indices = np.random.choice(range(n), size=4, replace=False)\n    i, j, k, l = sorted(indices)\n\n    # Perform double-bridge move: reconnect edges in a star-like pattern\n    new_solution[i:j] = base_solution[i:j][::-1]  # Reverse first segment\n    new_solution[j:k] = base_solution[j:k][::-1]  # Reverse second segment\n    new_solution[k:l] = base_solution[k:l][::-1]  # Reverse third segment\n\n    # Ensure feasibility by checking for duplicates (though double-bridge preserves tour validity)\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()  # Fallback if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.4227495332821574,
            1.5707628726959229
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply double-bridge move: select 4 random edges and reconnect them in a novel pattern\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No enough nodes to perform the move\n\n    # Select 4 distinct indices\n    indices = np.random.choice(range(n), size=4, replace=False)\n    i, j, k, l = sorted(indices)\n\n    # Perform double-bridge move: reconnect edges in a star-like pattern\n    new_solution[i:j] = base_solution[i:j][::-1]  # Reverse first segment\n    new_solution[j:k] = base_solution[j:k][::-1]  # Reverse second segment\n    new_solution[k:l] = base_solution[k:l][::-1]  # Reverse third segment\n\n    # Ensure feasibility by checking for duplicates (though double-bridge preserves tour validity)\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()  # Fallback if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 201,
        "algorithm": "{The heuristic selects a solution from the archive by prioritizing those with the lowest combined objective values, then applies a novel hybrid local search that combines edge exchange with a probabilistic segment reversal to escape local optima while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (lowest combined objective)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(len(archive_sorted) // 4, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: probabilistic segment reversal + edge exchange\n    if random.random() < 0.7:  # 70% chance for segment reversal\n        # Select a random segment and reverse it\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # Edge exchange\n        # Select two random edges and swap their nodes\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8276916563299944,
            1.8962625861167908
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (lowest combined objective)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(len(archive_sorted) // 4, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: probabilistic segment reversal + edge exchange\n    if random.random() < 0.7:  # 70% chance for segment reversal\n        # Select a random segment and reverse it\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # Edge exchange\n        # Select two random edges and swap their nodes\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 202,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive based on dominance and diversity, then applies a hybrid local search combining edge exchange and segment reversal to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (non-dominated and diverse)\n    candidates = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if other_obj[0] < obj[0] and other_obj[1] <= obj[1] or other_obj[0] <= obj[0] and other_obj[1] < obj[1]:\n                dominated = True\n                break\n        if not dominated:\n            candidates.append(sol)\n\n    if not candidates:\n        candidates = [sol for sol, _ in archive]  # If all are dominated, pick any\n\n    base_solution = random.choice(candidates).copy()\n\n    # Hybrid local search: segment reversal + edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Random segment reversal\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Edge exchange (swap two random edges)\n    if n > 3:\n        i = random.randint(0, n-3)\n        j = random.randint(i+2, n-1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8629404683719254,
            1.470814287662506
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (non-dominated and diverse)\n    candidates = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if other_obj[0] < obj[0] and other_obj[1] <= obj[1] or other_obj[0] <= obj[0] and other_obj[1] < obj[1]:\n                dominated = True\n                break\n        if not dominated:\n            candidates.append(sol)\n\n    if not candidates:\n        candidates = [sol for sol, _ in archive]  # If all are dominated, pick any\n\n    base_solution = random.choice(candidates).copy()\n\n    # Hybrid local search: segment reversal + edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Random segment reversal\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Edge exchange (swap two random edges)\n    if n > 3:\n        i = random.randint(0, n-3)\n        j = random.randint(i+2, n-1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 203,
        "algorithm": "{A novel hybrid local search operator that combines a biased random walk with a multi-objective-aware segment inversion to explore promising regions in the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high combined objective value (promising for improvement)\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = weights / np.sum(weights)  # Normalize to probabilities\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: biased random walk + multi-objective segment inversion\n    if n > 3:\n        # Step 1: Biased random walk (move a segment to a better position)\n        segment_length = np.random.randint(2, min(5, n // 2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start + segment_length]\n\n        # Evaluate potential insertion points\n        best_insert = start\n        best_improvement = 0.0\n\n        for i in range(n - segment_length + 1):\n            if i == start:\n                continue\n\n            # Temporarily move segment to position i\n            temp_solution = np.concatenate([\n                new_solution[:i],\n                segment,\n                np.delete(new_solution, np.arange(start, start + segment_length))\n            ])\n\n            # Calculate improvement in both objectives\n            old_cost1 = distance_matrix_1[base_solution[start-1], base_solution[start]] + distance_matrix_1[base_solution[start + segment_length - 1], base_solution[start + segment_length]]\n            new_cost1 = distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[i + segment_length - 1], temp_solution[i + segment_length]]\n\n            old_cost2 = distance_matrix_2[base_solution[start-1], base_solution[start]] + distance_matrix_2[base_solution[start + segment_length - 1], base_solution[start + segment_length]]\n            new_cost2 = distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[i + segment_length - 1], temp_solution[i + segment_length]]\n\n            improvement = (old_cost1 - new_cost1) + (old_cost2 - new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_insert = i\n\n        # Apply the best move\n        if best_insert != start:\n            new_solution = np.concatenate([\n                new_solution[:best_insert],\n                segment,\n                np.delete(new_solution, np.arange(start, start + segment_length))\n            ])\n\n        # Step 2: Multi-objective segment inversion (if improvement found)\n        if best_improvement > 0:\n            # Randomly select a segment to invert\n            invert_start = np.random.randint(0, n - 2)\n            invert_end = np.random.randint(invert_start + 2, n)\n\n            # Calculate costs before inversion\n            old_cost1 = distance_matrix_1[new_solution[invert_start-1], new_solution[invert_start]] + distance_matrix_1[new_solution[invert_end-1], new_solution[invert_end]]\n            old_cost2 = distance_matrix_2[new_solution[invert_start-1], new_solution[invert_start]] + distance_matrix_2[new_solution[invert_end-1], new_solution[invert_end]]\n\n            # Invert the segment\n            new_solution[invert_start:invert_end] = new_solution[invert_start:invert_end][::-1]\n\n            # Calculate costs after inversion\n            new_cost1 = distance_matrix_1[new_solution[invert_start-1], new_solution[invert_start]] + distance_matrix_1[new_solution[invert_end-1], new_solution[invert_end]]\n            new_cost2 = distance_matrix_2[new_solution[invert_start-1], new_solution[invert_start]] + distance_matrix_2[new_solution[invert_end-1], new_solution[invert_end]]\n\n            # If inversion doesn't improve, revert\n            if (old_cost1 - new_cost1) + (old_cost2 - new_cost2) < 0:\n                new_solution[invert_start:invert_end] = new_solution[invert_start:invert_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7784705066333972,
            2.288114607334137
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high combined objective value (promising for improvement)\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = weights / np.sum(weights)  # Normalize to probabilities\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: biased random walk + multi-objective segment inversion\n    if n > 3:\n        # Step 1: Biased random walk (move a segment to a better position)\n        segment_length = np.random.randint(2, min(5, n // 2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start + segment_length]\n\n        # Evaluate potential insertion points\n        best_insert = start\n        best_improvement = 0.0\n\n        for i in range(n - segment_length + 1):\n            if i == start:\n                continue\n\n            # Temporarily move segment to position i\n            temp_solution = np.concatenate([\n                new_solution[:i],\n                segment,\n                np.delete(new_solution, np.arange(start, start + segment_length))\n            ])\n\n            # Calculate improvement in both objectives\n            old_cost1 = distance_matrix_1[base_solution[start-1], base_solution[start]] + distance_matrix_1[base_solution[start + segment_length - 1], base_solution[start + segment_length]]\n            new_cost1 = distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[i + segment_length - 1], temp_solution[i + segment_length]]\n\n            old_cost2 = distance_matrix_2[base_solution[start-1], base_solution[start]] + distance_matrix_2[base_solution[start + segment_length - 1], base_solution[start + segment_length]]\n            new_cost2 = distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[i + segment_length - 1], temp_solution[i + segment_length]]\n\n            improvement = (old_cost1 - new_cost1) + (old_cost2 - new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_insert = i\n\n        # Apply the best move\n        if best_insert != start:\n            new_solution = np.concatenate([\n                new_solution[:best_insert],\n                segment,\n                np.delete(new_solution, np.arange(start, start + segment_length))\n            ])\n\n        # Step 2: Multi-objective segment inversion (if improvement found)\n        if best_improvement > 0:\n            # Randomly select a segment to invert\n            invert_start = np.random.randint(0, n - 2)\n            invert_end = np.random.randint(invert_start + 2, n)\n\n            # Calculate costs before inversion\n            old_cost1 = distance_matrix_1[new_solution[invert_start-1], new_solution[invert_start]] + distance_matrix_1[new_solution[invert_end-1], new_solution[invert_end]]\n            old_cost2 = distance_matrix_2[new_solution[invert_start-1], new_solution[invert_start]] + distance_matrix_2[new_solution[invert_end-1], new_solution[invert_end]]\n\n            # Invert the segment\n            new_solution[invert_start:invert_end] = new_solution[invert_start:invert_end][::-1]\n\n            # Calculate costs after inversion\n            new_cost1 = distance_matrix_1[new_solution[invert_start-1], new_solution[invert_start]] + distance_matrix_1[new_solution[invert_end-1], new_solution[invert_end]]\n            new_cost2 = distance_matrix_2[new_solution[invert_start-1], new_solution[invert_start]] + distance_matrix_2[new_solution[invert_end-1], new_solution[invert_end]]\n\n            # If inversion doesn't improve, revert\n            if (old_cost1 - new_cost1) + (old_cost2 - new_cost2) < 0:\n                new_solution[invert_start:invert_end] = new_solution[invert_start:invert_end][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 204,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on potential improvement in both objectives, then applies a hybrid local search combining edge insertion and node swap operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_solutions = sorted_archive[:max(1, len(archive) // 3)]\n    selected_idx = random.randint(0, len(candidate_solutions) - 1)\n    base_solution = candidate_solutions[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of edge insertion and node swap\n    n = len(new_solution)\n    i, j = random.sample(range(n), 2)\n\n    # Edge insertion: remove a segment and reinsert it in a different order\n    if i > j:\n        i, j = j, i\n    segment = new_solution[i:j+1]\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Node swap: swap two nodes if it improves both objectives\n    a, b = random.sample(range(n), 2)\n    current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n    new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n    current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n    new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n    if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7342455277963058,
            1.7135604619979858
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_solutions = sorted_archive[:max(1, len(archive) // 3)]\n    selected_idx = random.randint(0, len(candidate_solutions) - 1)\n    base_solution = candidate_solutions[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of edge insertion and node swap\n    n = len(new_solution)\n    i, j = random.sample(range(n), 2)\n\n    # Edge insertion: remove a segment and reinsert it in a different order\n    if i > j:\n        i, j = j, i\n    segment = new_solution[i:j+1]\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Node swap: swap two nodes if it improves both objectives\n    a, b = random.sample(range(n), 2)\n    current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n    new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n    current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n    new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n    if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 205,
        "algorithm": "{The heuristic selects a solution from the archive with the highest combined improvement potential in both objectives, then applies a hybrid local search combining edge insertion and node swap operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: edge insertion + node swap\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Edge insertion\n    new_solution = np.concatenate((new_solution[:i], new_solution[i+1:j+1], new_solution[i:i+1], new_solution[j+1:]))\n\n    # Node swap for diversification\n    k, l = np.random.choice(n, 2, replace=False)\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If infeasible, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8616206676363533,
            1.9484860301017761
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: edge insertion + node swap\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Edge insertion\n    new_solution = np.concatenate((new_solution[:i], new_solution[i+1:j+1], new_solution[i:i+1], new_solution[j+1:]))\n\n    # Node swap for diversification\n    k, l = np.random.choice(n, 2, replace=False)\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If infeasible, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 206,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment inversion\n    n = len(selected)\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    new_solution = selected.copy()\n\n    # Perform 3-opt-like segment reversal\n    new_solution[a:b+1] = selected[a:b+1][::-1]\n    new_solution[b:c+1] = selected[b:c+1][::-1]\n    new_solution[c:d+1] = selected[c:d+1][::-1]\n\n    # Novel segment inversion: reverse a random segment with probability\n    if random.random() < 0.5:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9192265651298732,
            0.21707439422607422
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment inversion\n    n = len(selected)\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    new_solution = selected.copy()\n\n    # Perform 3-opt-like segment reversal\n    new_solution[a:b+1] = selected[a:b+1][::-1]\n    new_solution[b:c+1] = selected[b:c+1][::-1]\n    new_solution[c:d+1] = selected[c:d+1][::-1]\n\n    # Novel segment inversion: reverse a random segment with probability\n    if random.random() < 0.5:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 206,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment inversion\n    n = len(selected)\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    new_solution = selected.copy()\n\n    # Perform 3-opt-like segment reversal\n    new_solution[a:b+1] = selected[a:b+1][::-1]\n    new_solution[b:c+1] = selected[b:c+1][::-1]\n    new_solution[c:d+1] = selected[c:d+1][::-1]\n\n    # Novel segment inversion: reverse a random segment with probability\n    if random.random() < 0.5:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9192265651298732,
            0.21707439422607422
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment inversion\n    n = len(selected)\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    new_solution = selected.copy()\n\n    # Perform 3-opt-like segment reversal\n    new_solution[a:b+1] = selected[a:b+1][::-1]\n    new_solution[b:c+1] = selected[b:c+1][::-1]\n    new_solution[c:d+1] = selected[c:d+1][::-1]\n\n    # Novel segment inversion: reverse a random segment with probability\n    if random.random() < 0.5:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 207,
        "algorithm": "{This algorithm intelligently selects a solution from the archive with high potential for improvement by analyzing objective values and applies a hybrid local search combining edge swaps with a novel segment inversion strategy to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest potential for improvement (minimizing both objectives)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate a combined score for selection (e.g., sum of normalized objectives)\n    scores = np.array([sum(obj) for obj in archive_objectives])\n    selected_idx = np.argmin(scores)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge swaps with segment inversion\n    for _ in range(10):  # Perform multiple perturbations\n        # Randomly select a segment to invert\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[a:b+1][::-1]\n        new_solution[a:b+1] = segment\n\n        # Randomly swap two edges\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility: remove duplicates and ensure all nodes are visited\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    if len(missing_nodes) > 0:\n        # Insert missing nodes at random positions\n        for node in missing_nodes:\n            pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, pos, node)\n        # Trim to original length if needed\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.8776596208452154,
            2.746184766292572
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest potential for improvement (minimizing both objectives)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate a combined score for selection (e.g., sum of normalized objectives)\n    scores = np.array([sum(obj) for obj in archive_objectives])\n    selected_idx = np.argmin(scores)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge swaps with segment inversion\n    for _ in range(10):  # Perform multiple perturbations\n        # Randomly select a segment to invert\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[a:b+1][::-1]\n        new_solution[a:b+1] = segment\n\n        # Randomly swap two edges\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility: remove duplicates and ensure all nodes are visited\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    if len(missing_nodes) > 0:\n        # Insert missing nodes at random positions\n        for node in missing_nodes:\n            pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, pos, node)\n        # Trim to original length if needed\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 208,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with high objective diversity and applies a novel hybrid local search combining edge insertion and segment reversal to explore non-adjacent node interactions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the difference in objectives (promotes diversity)\n        archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]), reverse=True)\n        selected_idx = random.randint(0, min(2, len(archive_sorted) - 1))  # Select from top 3 diverse solutions\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select two non-adjacent segments\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        c, d = sorted(random.sample(range(1, n-1), 2))\n\n        # Reverse segment between a and b\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Insert segment between c and d\n        segment = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:c], segment, new_solution[d+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.4351486895912187,
            1.8819763660430908
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the difference in objectives (promotes diversity)\n        archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]), reverse=True)\n        selected_idx = random.randint(0, min(2, len(archive_sorted) - 1))  # Select from top 3 diverse solutions\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select two non-adjacent segments\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        c, d = sorted(random.sample(range(1, n-1), 2))\n\n        # Reverse segment between a and b\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Insert segment between c and d\n        segment = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:c], segment, new_solution[d+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 209,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge insertion strategy\n    n = len(best_solution)\n    new_solution = best_solution.copy()\n\n    # Randomly select a segment to perturb\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Apply 2-opt within the selected segment\n    segment = new_solution[i:j+1]\n    segment = segment[::-1]  # Reverse the segment\n    new_solution[i:j+1] = segment\n\n    # Novel edge insertion: try inserting a random edge from another part of the tour\n    if n > 3:\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if abs(k - l) > 1:\n            # Insert the edge (k, l) by reversing the path between them\n            if k > l:\n                k, l = l, k\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8301121929053464,
            1.5937823057174683
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge insertion strategy\n    n = len(best_solution)\n    new_solution = best_solution.copy()\n\n    # Randomly select a segment to perturb\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Apply 2-opt within the selected segment\n    segment = new_solution[i:j+1]\n    segment = segment[::-1]  # Reverse the segment\n    new_solution[i:j+1] = segment\n\n    # Novel edge insertion: try inserting a random edge from another part of the tour\n    if n > 3:\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if abs(k - l) > 1:\n            # Insert the edge (k, l) by reversing the path between them\n            if k > l:\n                k, l = l, k\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 210,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_objectives = [(sol[1][0] / distance_matrix_1.max(), sol[1][1] / distance_matrix_2.max()) for sol in archive]\n    scores = [sum(obj) for obj in normalized_objectives]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine edge insertion and node reordering\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment of the tour\n    start = np.random.randint(0, n - 2)\n    end = np.random.randint(start + 2, n)\n    segment = new_solution[start:end]\n\n    # Reverse the segment to create a new order\n    reversed_segment = segment[::-1]\n\n    # Insert the reversed segment at a random position\n    insert_pos = np.random.randint(0, n - len(reversed_segment))\n    new_solution = np.concatenate([new_solution[:insert_pos], reversed_segment, new_solution[insert_pos + len(reversed_segment):]])\n\n    # Ensure the solution remains valid by removing duplicates and adding missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([unique_nodes, missing_nodes])\n\n    return new_solution\n\n",
        "score": [
            -0.8347003311906385,
            3.0627259612083435
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_objectives = [(sol[1][0] / distance_matrix_1.max(), sol[1][1] / distance_matrix_2.max()) for sol in archive]\n    scores = [sum(obj) for obj in normalized_objectives]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine edge insertion and node reordering\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment of the tour\n    start = np.random.randint(0, n - 2)\n    end = np.random.randint(start + 2, n)\n    segment = new_solution[start:end]\n\n    # Reverse the segment to create a new order\n    reversed_segment = segment[::-1]\n\n    # Insert the reversed segment at a random position\n    insert_pos = np.random.randint(0, n - len(reversed_segment))\n    new_solution = np.concatenate([new_solution[:insert_pos], reversed_segment, new_solution[insert_pos + len(reversed_segment):]])\n\n    # Ensure the solution remains valid by removing duplicates and adding missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([unique_nodes, missing_nodes])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 211,
        "algorithm": "{A novel hybrid local search operator combines a randomized segment inversion with a multi-objective-aware edge swap, prioritizing solutions with high Pareto dominance and low dominance resistance, ensuring feasible TSP tours through careful edge validation and segment handling.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by dominance (lower cost in both objectives is better)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        # Select top 20% solutions\n        top_solutions = archive_sorted[:max(1, len(archive_sorted) // 5)]\n        # Randomly select one from top solutions\n        base_solution, _ = random.choice(top_solutions)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Random segment inversion (3-opt inspired)\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment = new_solution[a:b]\n    new_solution[a:b] = segment[::-1]\n\n    # Multi-objective-aware edge swap\n    for _ in range(2):  # Limit swaps to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j or i + 1 == j:\n            continue\n\n        # Calculate cost change in both objectives\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        # Accept if both objectives improve or at least one improves significantly\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or \\\n           (new_cost1 < old_cost1 * 0.95 or new_cost2 < old_cost2 * 0.95):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7731490701345493,
            1.2285063862800598
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by dominance (lower cost in both objectives is better)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        # Select top 20% solutions\n        top_solutions = archive_sorted[:max(1, len(archive_sorted) // 5)]\n        # Randomly select one from top solutions\n        base_solution, _ = random.choice(top_solutions)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Random segment inversion (3-opt inspired)\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment = new_solution[a:b]\n    new_solution[a:b] = segment[::-1]\n\n    # Multi-objective-aware edge swap\n    for _ in range(2):  # Limit swaps to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j or i + 1 == j:\n            continue\n\n        # Calculate cost change in both objectives\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        # Accept if both objectives improve or at least one improves significantly\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or \\\n           (new_cost1 < old_cost1 * 0.95 or new_cost2 < old_cost2 * 0.95):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 212,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([np.sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse (3-opt-like operation)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Randomly insert a node from another segment (edge insertion)\n    c = np.random.randint(0, n)\n    if c != a and c != b:\n        node = new_solution[c]\n        new_solution = np.delete(new_solution, c)\n        pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.8852922637064564,
            3.3664153814315796
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([np.sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse (3-opt-like operation)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Randomly insert a node from another segment (edge insertion)\n    c = np.random.randint(0, n)\n    if c != a and c != b:\n        node = new_solution[c]\n        new_solution = np.delete(new_solution, c)\n        pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 213,
        "algorithm": "{My novel local search algorithm combines a multi-objective aware edge exchange heuristic with a probabilistic segment inversion, dynamically balancing exploration of the Pareto front and exploitation of local optima to generate high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + np.sum(x[0] == archive[0][0])))  # Simple selection heuristic\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Multi-objective edge exchange with probabilistic segment inversion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operations\n\n    # Multi-objective edge exchange\n    for _ in range(2):  # Number of exchanges\n        i, j = sorted(random.sample(range(n), 2))\n        # Evaluate edge replacement in both objectives\n        old_edges = [(new_solution[i-1], new_solution[i]), (new_solution[j-1], new_solution[j])]\n        new_edges = [(new_solution[i-1], new_solution[j]), (new_solution[i], new_solution[j-1])]\n\n        # Calculate cost change\n        cost_change_1 = (distance_matrix_1[new_edges[0][0], new_edges[0][1]] + distance_matrix_1[new_edges[1][0], new_edges[1][1]] -\n                          (distance_matrix_1[old_edges[0][0], old_edges[0][1]] + distance_matrix_1[old_edges[1][0], old_edges[1][1]]))\n        cost_change_2 = (distance_matrix_2[new_edges[0][0], new_edges[0][1]] + distance_matrix_2[new_edges[1][0], new_edges[1][1]] -\n                        (distance_matrix_2[old_edges[0][0], old_edges[0][1]] + distance_matrix_2[old_edges[1][0], old_edges[1][1]]))\n\n        # Apply if beneficial for at least one objective\n        if cost_change_1 < 0 or cost_change_2 < 0:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Probabilistic segment inversion (biased toward better edges)\n    if random.random() < 0.3:  # 30% chance\n        i, j = sorted(random.sample(range(n), 2))\n        # Check if inversion improves at least one objective\n        old_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n        old_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n        new_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n\n        if not ((new_cost1 <= old_cost1 and new_cost2 <= old_cost2) and (new_cost1 < old_cost1 or new_cost2 < old_cost2)):\n            new_solution[i:j] = new_solution[i:j][::-1]  # Revert if not better in at least one objective\n\n    return new_solution\n\n",
        "score": [
            -0.958353661096387,
            2.6927186846733093
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + np.sum(x[0] == archive[0][0])))  # Simple selection heuristic\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Multi-objective edge exchange with probabilistic segment inversion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operations\n\n    # Multi-objective edge exchange\n    for _ in range(2):  # Number of exchanges\n        i, j = sorted(random.sample(range(n), 2))\n        # Evaluate edge replacement in both objectives\n        old_edges = [(new_solution[i-1], new_solution[i]), (new_solution[j-1], new_solution[j])]\n        new_edges = [(new_solution[i-1], new_solution[j]), (new_solution[i], new_solution[j-1])]\n\n        # Calculate cost change\n        cost_change_1 = (distance_matrix_1[new_edges[0][0], new_edges[0][1]] + distance_matrix_1[new_edges[1][0], new_edges[1][1]] -\n                          (distance_matrix_1[old_edges[0][0], old_edges[0][1]] + distance_matrix_1[old_edges[1][0], old_edges[1][1]]))\n        cost_change_2 = (distance_matrix_2[new_edges[0][0], new_edges[0][1]] + distance_matrix_2[new_edges[1][0], new_edges[1][1]] -\n                        (distance_matrix_2[old_edges[0][0], old_edges[0][1]] + distance_matrix_2[old_edges[1][0], old_edges[1][1]]))\n\n        # Apply if beneficial for at least one objective\n        if cost_change_1 < 0 or cost_change_2 < 0:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Probabilistic segment inversion (biased toward better edges)\n    if random.random() < 0.3:  # 30% chance\n        i, j = sorted(random.sample(range(n), 2))\n        # Check if inversion improves at least one objective\n        old_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n        old_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n        new_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n\n        if not ((new_cost1 <= old_cost1 and new_cost2 <= old_cost2) and (new_cost1 < old_cost1 or new_cost2 < old_cost2)):\n            new_solution[i:j] = new_solution[i:j][::-1]  # Revert if not better in at least one objective\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 214,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high total cost in either objective (indicating room for improvement)\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected_solution.copy()\n\n    # Hybrid local search: combine edge-swapping with segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 2: Randomly swap two non-adjacent edges\n    i, j = np.random.choice(n, size=2, replace=False)\n    if abs(i - j) > 1:  # Ensure non-adjacent\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Check for improvement in both objectives\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for i in range(len(sol)):\n            cost += dist_mat[sol[i-1], sol[i]]\n        return cost\n\n    original_cost1 = calculate_cost(base_solution, distance_matrix_1)\n    original_cost2 = calculate_cost(base_solution, distance_matrix_2)\n    new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # If no improvement in either objective, revert to base solution\n    if (new_cost1 >= original_cost1 and new_cost2 >= original_cost2):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9176921663986954,
            2.4785290956497192
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high total cost in either objective (indicating room for improvement)\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected_solution.copy()\n\n    # Hybrid local search: combine edge-swapping with segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 2: Randomly swap two non-adjacent edges\n    i, j = np.random.choice(n, size=2, replace=False)\n    if abs(i - j) > 1:  # Ensure non-adjacent\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Check for improvement in both objectives\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for i in range(len(sol)):\n            cost += dist_mat[sol[i-1], sol[i]]\n        return cost\n\n    original_cost1 = calculate_cost(base_solution, distance_matrix_1)\n    original_cost2 = calculate_cost(base_solution, distance_matrix_2)\n    new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # If no improvement in either objective, revert to base solution\n    if (new_cost1 >= original_cost1 and new_cost2 >= original_cost2):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 215,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high variance in objectives)\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    N = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Step 1: Randomly select three distinct edges to modify\n    a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n\n    # Step 2: Perform a 3-opt move (swap edges to reduce tour length)\n    if np.random.rand() < 0.5:\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n    else:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Novel edge-swap strategy: Swap a pair of edges based on bi-objective improvement\n    if np.random.rand() < 0.3:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check bi-objective improvement\n        old_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[i]] + distance_matrix_1[selected_solution[j-1], selected_solution[j]]\n        new_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[j]] + distance_matrix_1[selected_solution[i], selected_solution[j-1]]\n        old_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[i]] + distance_matrix_2[selected_solution[j-1], selected_solution[j]]\n        new_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[j]] + distance_matrix_2[selected_solution[i], selected_solution[j-1]]\n\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or np.random.rand() < 0.2:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7835654409728643,
            1.9704337120056152
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high variance in objectives)\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    N = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Step 1: Randomly select three distinct edges to modify\n    a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n\n    # Step 2: Perform a 3-opt move (swap edges to reduce tour length)\n    if np.random.rand() < 0.5:\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n    else:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Novel edge-swap strategy: Swap a pair of edges based on bi-objective improvement\n    if np.random.rand() < 0.3:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check bi-objective improvement\n        old_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[i]] + distance_matrix_1[selected_solution[j-1], selected_solution[j]]\n        new_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[j]] + distance_matrix_1[selected_solution[i], selected_solution[j-1]]\n        old_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[i]] + distance_matrix_2[selected_solution[j-1], selected_solution[j]]\n        new_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[j]] + distance_matrix_2[selected_solution[i], selected_solution[j-1]]\n\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or np.random.rand() < 0.2:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 216,
        "algorithm": "{The algorithm intelligently selects a non-dominated solution from the archive by prioritizing those with lower objective values, then applies a hybrid local search combining 3-opt with a novel edge-swapping heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a non-dominated solution with lower objective values\n    selected = min(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: 3-opt with edge-swapping\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to modify\n    a, b, c = sorted(random.sample(range(n), 3))\n    i, j, k = new_solution[a], new_solution[b], new_solution[c]\n\n    # Apply 3-opt move\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], 1)\n    new_solution[b:c+1] = np.roll(new_solution[b:c+1], -1)\n\n    # Edge-swapping heuristic: swap edges between i and k if beneficial\n    if random.random() < 0.5:  # 50% chance to apply edge-swapping\n        pos_i = np.where(new_solution == i)[0][0]\n        pos_k = np.where(new_solution == k)[0][0]\n        if pos_i < pos_k:\n            # Reverse the segment between i and k\n            new_solution[pos_i:pos_k+1] = new_solution[pos_i:pos_k+1][::-1]\n\n    # Ensure the solution remains feasible\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.75494122362995,
            1.6211899518966675
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a non-dominated solution with lower objective values\n    selected = min(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: 3-opt with edge-swapping\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to modify\n    a, b, c = sorted(random.sample(range(n), 3))\n    i, j, k = new_solution[a], new_solution[b], new_solution[c]\n\n    # Apply 3-opt move\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], 1)\n    new_solution[b:c+1] = np.roll(new_solution[b:c+1], -1)\n\n    # Edge-swapping heuristic: swap edges between i and k if beneficial\n    if random.random() < 0.5:  # 50% chance to apply edge-swapping\n        pos_i = np.where(new_solution == i)[0][0]\n        pos_k = np.where(new_solution == k)[0][0]\n        if pos_i < pos_k:\n            # Reverse the segment between i and k\n            new_solution[pos_i:pos_k+1] = new_solution[pos_i:pos_k+1][::-1]\n\n    # Ensure the solution remains feasible\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 217,
        "algorithm": "{A novel hybrid local search operator combines a biased random walk with a dynamic edge swap mechanism, prioritizing edges with high potential for multi-objective improvement while ensuring feasibility by maintaining a valid TSP tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    ranked_solutions = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_solution = random.choices(ranked_solutions, weights=[1/(i+1) for i in range(len(ranked_solutions))], k=1)[0][0]\n    base_solution = selected_solution.copy()\n\n    # Hybrid local search: dynamic edge swap with biased random walk\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify critical edges (high potential for improvement)\n    critical_edges = []\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i+1)%n]\n        cost1 = distance_matrix_1[u, v]\n        cost2 = distance_matrix_2[u, v]\n        if cost1 > np.mean(distance_matrix_1[u]) or cost2 > np.mean(distance_matrix_2[u]):\n            critical_edges.append((i, (i+1)%n))\n\n    if critical_edges:\n        # Perform a biased swap\n        i, j = random.choice(critical_edges)\n        k = random.randint(0, n-1)\n        while k == i or k == j or k == (i+1)%n or k == (j-1)%n:\n            k = random.randint(0, n-1)\n\n        # Perform a 3-opt move (ensuring feasibility)\n        new_solution[i], new_solution[k], new_solution[j] = new_solution[k], new_solution[j], new_solution[i]\n    else:\n        # Fallback to random 2-opt if no critical edges found\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.831042791416451,
            3.1195780634880066
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    ranked_solutions = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_solution = random.choices(ranked_solutions, weights=[1/(i+1) for i in range(len(ranked_solutions))], k=1)[0][0]\n    base_solution = selected_solution.copy()\n\n    # Hybrid local search: dynamic edge swap with biased random walk\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify critical edges (high potential for improvement)\n    critical_edges = []\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i+1)%n]\n        cost1 = distance_matrix_1[u, v]\n        cost2 = distance_matrix_2[u, v]\n        if cost1 > np.mean(distance_matrix_1[u]) or cost2 > np.mean(distance_matrix_2[u]):\n            critical_edges.append((i, (i+1)%n))\n\n    if critical_edges:\n        # Perform a biased swap\n        i, j = random.choice(critical_edges)\n        k = random.randint(0, n-1)\n        while k == i or k == j or k == (i+1)%n or k == (j-1)%n:\n            k = random.randint(0, n-1)\n\n        # Perform a 3-opt move (ensuring feasibility)\n        new_solution[i], new_solution[k], new_solution[j] = new_solution[k], new_solution[j], new_solution[i]\n    else:\n        # Fallback to random 2-opt if no critical edges found\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 218,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high Pareto frontier dominance, then applies a hybrid local search combining edge exchange and node reinsertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Apply hybrid local search: edge exchange and node reinsertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Edge exchange (swap two edges)\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains a valid tour\n        if i != j and abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Node reinsertion (remove a node and reinsert it elsewhere)\n    if n > 2:\n        k = random.randint(0, n - 1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8421132971741975,
            2.240696907043457
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Apply hybrid local search: edge exchange and node reinsertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Edge exchange (swap two edges)\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains a valid tour\n        if i != j and abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Node reinsertion (remove a node and reinsert it elsewhere)\n    if n > 2:\n        k = random.randint(0, n - 1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 219,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a hybrid of Pareto dominance and diversity, then applies a novel 3-opt* local search operator that intelligently combines segments from the solution and its reversed counterpart to explore high-quality neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (non-dominated and diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a reversed version of the solution\n    reversed_solution = base_solution[::-1]\n\n    # Hybrid 3-opt* operator: combine segments from base and reversed solutions\n    n = len(base_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    new_solution = np.concatenate([\n        base_solution[:a],\n        reversed_solution[a:b],\n        base_solution[b:c],\n        reversed_solution[c:]\n    ])\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8871397357622655,
            2.4336536526679993
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (non-dominated and diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a reversed version of the solution\n    reversed_solution = base_solution[::-1]\n\n    # Hybrid 3-opt* operator: combine segments from base and reversed solutions\n    n = len(base_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    new_solution = np.concatenate([\n        base_solution[:a],\n        reversed_solution[a:b],\n        base_solution[b:c],\n        reversed_solution[c:]\n    ])\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 220,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with high Pareto dominance or low objective values, then applies a hybrid local search combining edge exchange with node reinsertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential (e.g., low objective values or non-dominated)\n    selected_idx = np.argmin([sum(obj) for (_, obj) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge exchange with node reinsertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No feasible move for small instances\n\n    # Randomly select segments for edge exchange\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    c, d = sorted(np.random.choice(n, size=2, replace=False))\n\n    # Edge exchange\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Node reinsertion for diversification\n    if np.random.rand() < 0.3:  # 30% chance to apply reinsertion\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8525057869992057,
            2.401378631591797
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential (e.g., low objective values or non-dominated)\n    selected_idx = np.argmin([sum(obj) for (_, obj) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge exchange with node reinsertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No feasible move for small instances\n\n    # Randomly select segments for edge exchange\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    c, d = sorted(np.random.choice(n, size=2, replace=False))\n\n    # Edge exchange\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Node reinsertion for diversification\n    if np.random.rand() < 0.3:  # 30% chance to apply reinsertion\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 221,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high crowding distance)\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge insertion strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to modify\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Reverse the segment (2-opt like operation)\n    new_solution[a:b+1] = segment[::-1]\n\n    # Novel edge insertion: Insert a randomly chosen node from the segment elsewhere\n    if len(segment) > 1:\n        insert_node = np.random.choice(segment)\n        insert_pos = np.random.randint(0, n)\n        new_solution = np.insert(np.delete(new_solution, np.where(new_solution == insert_node)[0]), insert_pos, insert_node)\n\n    return new_solution\n\n",
        "score": [
            -0.9683645905992659,
            1.9464306831359863
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high crowding distance)\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge insertion strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to modify\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Reverse the segment (2-opt like operation)\n    new_solution[a:b+1] = segment[::-1]\n\n    # Novel edge insertion: Insert a randomly chosen node from the segment elsewhere\n    if len(segment) > 1:\n        insert_node = np.random.choice(segment)\n        insert_pos = np.random.randint(0, n)\n        new_solution = np.insert(np.delete(new_solution, np.where(new_solution == insert_node)[0]), insert_pos, insert_node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 222,
        "algorithm": "{This algorithm intelligently selects a high-potential solution from the archive based on Pareto dominance and diversity, then applies a hybrid local search combining edge reinsertion and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential (non-dominated and diverse)\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: edge reinsertion + segment reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomly select a segment to move\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end]\n\n    # Step 2: Remove the segment and reinsert it elsewhere\n    new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 3: Randomly reverse a segment to introduce diversity\n    if random.random() < 0.5:\n        rev_start = random.randint(0, len(new_solution) - 2)\n        rev_end = random.randint(rev_start + 1, len(new_solution) - 1)\n        new_solution[rev_start:rev_end] = new_solution[rev_start:rev_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8933336328027307,
            2.098551094532013
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential (non-dominated and diverse)\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: edge reinsertion + segment reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomly select a segment to move\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end]\n\n    # Step 2: Remove the segment and reinsert it elsewhere\n    new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 3: Randomly reverse a segment to introduce diversity\n    if random.random() < 0.5:\n        rev_start = random.randint(0, len(new_solution) - 2)\n        rev_end = random.randint(rev_start + 1, len(new_solution) - 1)\n        new_solution[rev_start:rev_end] = new_solution[rev_start:rev_end][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 223,
        "algorithm": "{The heuristic function selects a high-performing solution from the archive, then applies a novel hybrid local search combining edge swaps and node reinsertions, guided by a Pareto-dominance criterion to prioritize non-dominated edges while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: np.sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: edge swap + node reinsertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Edge swap (randomized)\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Step 2: Node reinsertion (guided by distance matrices)\n    node_to_move = random.choice(new_solution)\n    mask = new_solution != node_to_move\n    remaining_nodes = new_solution[mask]\n\n    # Find best insertion position in both objective spaces\n    best_cost = float('inf')\n    best_pos = 0\n\n    for i in range(len(remaining_nodes)):\n        # Create candidate solution\n        candidate = np.concatenate([remaining_nodes[:i], [node_to_move], remaining_nodes[i:]])\n        # Evaluate cost in both spaces\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = i\n\n    # Apply best insertion\n    new_solution = np.concatenate([remaining_nodes[:best_pos], [node_to_move], remaining_nodes[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8679139589206679,
            12.39779406785965
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: np.sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: edge swap + node reinsertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Edge swap (randomized)\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Step 2: Node reinsertion (guided by distance matrices)\n    node_to_move = random.choice(new_solution)\n    mask = new_solution != node_to_move\n    remaining_nodes = new_solution[mask]\n\n    # Find best insertion position in both objective spaces\n    best_cost = float('inf')\n    best_pos = 0\n\n    for i in range(len(remaining_nodes)):\n        # Create candidate solution\n        candidate = np.concatenate([remaining_nodes[:i], [node_to_move], remaining_nodes[i:]])\n        # Evaluate cost in both spaces\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = i\n\n    # Apply best insertion\n    new_solution = np.concatenate([remaining_nodes[:best_pos], [node_to_move], remaining_nodes[best_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 224,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining edge exchange with a novel segment relocation strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive (e.g., with good objective values and diversity)\n    selected_solution = None\n    min_objective_sum = float('inf')\n    for solution, objective in archive:\n        obj_sum = sum(objective)\n        if obj_sum < min_objective_sum:\n            min_objective_sum = obj_sum\n            selected_solution = solution.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge exchange + segment relocation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Edge exchange (2-opt-like but with a twist)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Segment relocation (novel part)\n    if n > 3:\n        k = np.random.randint(1, n-1)\n        segment = new_solution[k:k+np.random.randint(1, min(5, n-k))]\n        remaining = np.setdiff1d(new_solution, segment)\n        new_solution = np.concatenate([remaining[:k], segment, remaining[k:]])\n\n    # Ensure feasibility\n    assert len(set(new_solution)) == len(selected_solution), \"Invalid tour: nodes missing or duplicated\"\n    assert len(new_solution) == len(selected_solution), \"Invalid tour: length mismatch\"\n\n    return new_solution\n\n",
        "score": [
            -0.8695439412773369,
            2.720355451107025
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive (e.g., with good objective values and diversity)\n    selected_solution = None\n    min_objective_sum = float('inf')\n    for solution, objective in archive:\n        obj_sum = sum(objective)\n        if obj_sum < min_objective_sum:\n            min_objective_sum = obj_sum\n            selected_solution = solution.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge exchange + segment relocation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Edge exchange (2-opt-like but with a twist)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Segment relocation (novel part)\n    if n > 3:\n        k = np.random.randint(1, n-1)\n        segment = new_solution[k:k+np.random.randint(1, min(5, n-k))]\n        remaining = np.setdiff1d(new_solution, segment)\n        new_solution = np.concatenate([remaining[:k], segment, remaining[k:]])\n\n    # Ensure feasibility\n    assert len(set(new_solution)) == len(selected_solution), \"Invalid tour: nodes missing or duplicated\"\n    assert len(new_solution) == len(selected_solution), \"Invalid tour: length mismatch\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 225,
        "algorithm": "{The algorithm intelligently selects a solution from the archive with high objective variance, then applies a hybrid local search combining edge insertion and node relocation, guided by a Pareto-dominance criterion, to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective variance (promising for improvement)\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n    objective_variance = np.abs(objectives[:, 0] - objectives[:, 1])\n    selected_idx = np.argmax(objective_variance)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search: combination of edge insertion and node relocation\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Randomly select two distinct edges to modify\n    i, j = sorted(random.sample(range(n_nodes), 2))\n    k, l = sorted(random.sample(range(n_nodes), 2))\n\n    # Edge insertion: insert segment [j, k] between i and l\n    if i != j and j != k and k != l and i != l:\n        new_segment = new_solution[j:k+1]\n        new_solution = np.concatenate([new_solution[:i+1], new_segment, new_solution[l+1:]])\n\n        # Node relocation: move node at position i+1 to position l+1\n        if i+1 < len(new_solution) and l+1 < len(new_solution):\n            node = new_solution[i+1]\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:l+1], [node], new_solution[l+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n_nodes:\n        # Fallback to a simpler modification if invalid\n        new_solution = base_solution.copy()\n        a, b = random.sample(range(n_nodes), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6927736342852449,
            2.1116470098495483
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective variance (promising for improvement)\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n    objective_variance = np.abs(objectives[:, 0] - objectives[:, 1])\n    selected_idx = np.argmax(objective_variance)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search: combination of edge insertion and node relocation\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Randomly select two distinct edges to modify\n    i, j = sorted(random.sample(range(n_nodes), 2))\n    k, l = sorted(random.sample(range(n_nodes), 2))\n\n    # Edge insertion: insert segment [j, k] between i and l\n    if i != j and j != k and k != l and i != l:\n        new_segment = new_solution[j:k+1]\n        new_solution = np.concatenate([new_solution[:i+1], new_segment, new_solution[l+1:]])\n\n        # Node relocation: move node at position i+1 to position l+1\n        if i+1 < len(new_solution) and l+1 < len(new_solution):\n            node = new_solution[i+1]\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:l+1], [node], new_solution[l+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n_nodes:\n        # Fallback to a simpler modification if invalid\n        new_solution = base_solution.copy()\n        a, b = random.sample(range(n_nodes), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 226,
        "algorithm": "{This heuristic selects a promising solution from the archive by prioritizing those with the highest crowding distance (indicating less crowded regions in the Pareto front) and then applies a hybrid local search combining edge insertion and path relinking to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distance for each solution in the archive\n    objectives = np.array([obj for _, obj in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    objectives_sorted = objectives[sorted_indices]\n\n    crowding_distance = np.zeros(len(archive))\n    for i in range(2):  # For each objective\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distance[sorted_indices[0]] = np.inf\n        crowding_distance[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive) - 1):\n            crowding_distance[sorted_indices[j]] += (objectives_sorted[sorted_indices[j+1], i] - objectives_sorted[sorted_indices[j-1], i]) / (objectives_sorted[-1, i] - objectives_sorted[0, i])\n\n    # Select the solution with the highest crowding distance (most promising for improvement)\n    selected_idx = np.argmax(crowding_distance)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search to generate a neighbor\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge insertion with path relinking\n    for _ in range(10):  # Number of attempts\n        # Randomly select two distinct segments\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Extract the segment to relocate\n        segment = new_solution[a:b+1]\n\n        # Remove the segment from the solution\n        remaining = np.concatenate([new_solution[:a], new_solution[b+1:]])\n\n        # Insert the segment at a random position\n        insert_pos = np.random.randint(0, len(remaining) + 1)\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n        # Check feasibility (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Step 3: Apply path relinking with another solution from the archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice([i for i in range(len(archive)) if i != selected_idx])][0]\n        for i in range(n):\n            if np.random.rand() < 0.2:  # 20% chance to adopt a node from the other solution\n                node = other_solution[i]\n                if node not in new_solution[:i]:  # Ensure no duplicates\n                    # Find the position of the node in the current solution\n                    pos = np.where(new_solution == node)[0][0]\n                    # Swap the nodes\n                    new_solution[i], new_solution[pos] = new_solution[pos], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6955472663524336,
            2.0942842960357666
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distance for each solution in the archive\n    objectives = np.array([obj for _, obj in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    objectives_sorted = objectives[sorted_indices]\n\n    crowding_distance = np.zeros(len(archive))\n    for i in range(2):  # For each objective\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distance[sorted_indices[0]] = np.inf\n        crowding_distance[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive) - 1):\n            crowding_distance[sorted_indices[j]] += (objectives_sorted[sorted_indices[j+1], i] - objectives_sorted[sorted_indices[j-1], i]) / (objectives_sorted[-1, i] - objectives_sorted[0, i])\n\n    # Select the solution with the highest crowding distance (most promising for improvement)\n    selected_idx = np.argmax(crowding_distance)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search to generate a neighbor\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge insertion with path relinking\n    for _ in range(10):  # Number of attempts\n        # Randomly select two distinct segments\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Extract the segment to relocate\n        segment = new_solution[a:b+1]\n\n        # Remove the segment from the solution\n        remaining = np.concatenate([new_solution[:a], new_solution[b+1:]])\n\n        # Insert the segment at a random position\n        insert_pos = np.random.randint(0, len(remaining) + 1)\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n        # Check feasibility (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Step 3: Apply path relinking with another solution from the archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice([i for i in range(len(archive)) if i != selected_idx])][0]\n        for i in range(n):\n            if np.random.rand() < 0.2:  # 20% chance to adopt a node from the other solution\n                node = other_solution[i]\n                if node not in new_solution[:i]:  # Ensure no duplicates\n                    # Find the position of the node in the current solution\n                    pos = np.where(new_solution == node)[0][0]\n                    # Swap the nodes\n                    new_solution[i], new_solution[pos] = new_solution[pos], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 227,
        "algorithm": "{My algorithm selects a promising solution from the archive using a hybrid selection criterion (combining objective values and diversity) and applies a novel local search operator that combines edge insertion with a probabilistic swap mechanism to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    # Here, we use a hybrid selection: solutions with better objectives and higher diversity\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[(1 / (obj[0] + obj[1] + 1e-6)) * (1 + i / len(archive)) for i, (_, obj) in enumerate(archive)],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    # Step 1: Edge insertion with probabilistic swap\n    for _ in range(5):  # Number of attempts\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        if j - i > 1:  # Ensure there are nodes between i and j\n            # Extract the segment between i and j\n            segment = new_solution[i:j+1]\n            # Try inserting the segment in a different position\n            new_pos = random.randint(0, len(new_solution) - len(segment))\n            if new_pos != i:  # Ensure the position is different\n                # Remove the segment\n                new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n                # Insert the segment at new position\n                new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n                # Probabilistically swap two nodes in the segment\n                if len(segment) > 1 and random.random() < 0.3:\n                    swap_i, swap_j = random.sample(range(len(segment)), 2)\n                    segment[swap_i], segment[swap_j] = segment[swap_j], segment[swap_i]\n                    new_solution[new_pos:new_pos+len(segment)] = segment\n\n    # Ensure the solution remains feasible\n    assert len(new_solution) == len(base_solution), \"Generated solution is not feasible\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Generated solution is not feasible\"\n\n    return new_solution\n\n",
        "score": [
            -0.7541528244571236,
            1.6363754868507385
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    # Here, we use a hybrid selection: solutions with better objectives and higher diversity\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[(1 / (obj[0] + obj[1] + 1e-6)) * (1 + i / len(archive)) for i, (_, obj) in enumerate(archive)],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    # Step 1: Edge insertion with probabilistic swap\n    for _ in range(5):  # Number of attempts\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        if j - i > 1:  # Ensure there are nodes between i and j\n            # Extract the segment between i and j\n            segment = new_solution[i:j+1]\n            # Try inserting the segment in a different position\n            new_pos = random.randint(0, len(new_solution) - len(segment))\n            if new_pos != i:  # Ensure the position is different\n                # Remove the segment\n                new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n                # Insert the segment at new position\n                new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n                # Probabilistically swap two nodes in the segment\n                if len(segment) > 1 and random.random() < 0.3:\n                    swap_i, swap_j = random.sample(range(len(segment)), 2)\n                    segment[swap_i], segment[swap_j] = segment[swap_j], segment[swap_i]\n                    new_solution[new_pos:new_pos+len(segment)] = segment\n\n    # Ensure the solution remains feasible\n    assert len(new_solution) == len(base_solution), \"Generated solution is not feasible\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Generated solution is not feasible\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 228,
        "algorithm": "{A novel hybrid local search strategy combines a randomized edge exchange with a multi-objective path relinking heuristic, prioritizing solutions with high crowding distance in the archive to explore diverse neighborhoods while ensuring feasibility through careful edge swaps and path relinking operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or random if archive is small\n    if len(archive) < 5:\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        # Calculate crowding distances for all solutions\n        objectives = np.array([obj for _, obj in archive])\n        sorted_indices = np.argsort(objectives[:, 0])\n        crowding_distances = np.zeros(len(archive))\n\n        # Calculate crowding distance for each objective\n        for obj_idx in range(2):\n            sorted_obj = objectives[sorted_indices, obj_idx]\n            crowding_distances[sorted_indices[0]] = np.inf\n            crowding_distances[sorted_indices[-1]] = np.inf\n            for i in range(1, len(archive) - 1):\n                crowding_distances[sorted_indices[i]] += (sorted_obj[i+1] - sorted_obj[i-1]) / (sorted_obj[-1] - sorted_obj[0] + 1e-10)\n\n        # Select solution with highest crowding distance\n        selected_idx = np.argmax(crowding_distances)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: randomized edge exchange with path relinking\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select a segment to modify\n    a, b = sorted(random.sample(range(n), 2))\n    segment = base_solution[a:b+1]\n\n    # Reverse the segment (like 2-opt but more controlled)\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Path relinking: try to improve by inserting nodes from another solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        # Find a common segment between solutions\n        for i in range(n):\n            if new_solution[i] in other_solution:\n                j = np.where(other_solution == new_solution[i])[0][0]\n                for k in range(1, min(n - i, n - j)):\n                    if new_solution[i + k] == other_solution[j + k]:\n                        # Found a matching segment, try to improve\n                        if k > 1:\n                            # Swap segments to potentially improve\n                            new_segment = other_solution[j:j+k]\n                            new_solution[i:i+k] = new_segment\n                        break\n                break\n\n    # Ensure the solution is valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, fall back to a simple 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8034858122618604,
            1.570081353187561
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or random if archive is small\n    if len(archive) < 5:\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        # Calculate crowding distances for all solutions\n        objectives = np.array([obj for _, obj in archive])\n        sorted_indices = np.argsort(objectives[:, 0])\n        crowding_distances = np.zeros(len(archive))\n\n        # Calculate crowding distance for each objective\n        for obj_idx in range(2):\n            sorted_obj = objectives[sorted_indices, obj_idx]\n            crowding_distances[sorted_indices[0]] = np.inf\n            crowding_distances[sorted_indices[-1]] = np.inf\n            for i in range(1, len(archive) - 1):\n                crowding_distances[sorted_indices[i]] += (sorted_obj[i+1] - sorted_obj[i-1]) / (sorted_obj[-1] - sorted_obj[0] + 1e-10)\n\n        # Select solution with highest crowding distance\n        selected_idx = np.argmax(crowding_distances)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: randomized edge exchange with path relinking\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select a segment to modify\n    a, b = sorted(random.sample(range(n), 2))\n    segment = base_solution[a:b+1]\n\n    # Reverse the segment (like 2-opt but more controlled)\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Path relinking: try to improve by inserting nodes from another solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        # Find a common segment between solutions\n        for i in range(n):\n            if new_solution[i] in other_solution:\n                j = np.where(other_solution == new_solution[i])[0][0]\n                for k in range(1, min(n - i, n - j)):\n                    if new_solution[i + k] == other_solution[j + k]:\n                        # Found a matching segment, try to improve\n                        if k > 1:\n                            # Swap segments to potentially improve\n                            new_segment = other_solution[j:j+k]\n                            new_solution[i:i+k] = new_segment\n                        break\n                break\n\n    # Ensure the solution is valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, fall back to a simple 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 229,
        "algorithm": "{A novel local search strategy combining adaptive segment reversal with multi-objective segment selection, prioritizing high-potential segments based on their contribution to both objectives and using a hybrid of insertion and reversal moves to generate diverse, high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Determine the most promising segment to modify\n    n = len(new_solution)\n    segment_length = max(3, n // 10)\n\n    # Randomly select a segment\n    start = random.randint(0, n - segment_length - 1)\n    end = start + segment_length\n\n    # Decide between insertion or reversal based on segment quality\n    segment = new_solution[start:end]\n    if random.random() < 0.7:  # Higher probability for reversal\n        # Reverse the segment\n        new_solution[start:end] = segment[::-1]\n    else:\n        # Insert the segment elsewhere\n        new_solution = np.delete(new_solution, range(start, end))\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure the solution remains valid\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.9204884252238179,
            1.606895625591278
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Determine the most promising segment to modify\n    n = len(new_solution)\n    segment_length = max(3, n // 10)\n\n    # Randomly select a segment\n    start = random.randint(0, n - segment_length - 1)\n    end = start + segment_length\n\n    # Decide between insertion or reversal based on segment quality\n    segment = new_solution[start:end]\n    if random.random() < 0.7:  # Higher probability for reversal\n        # Reverse the segment\n        new_solution[start:end] = segment[::-1]\n    else:\n        # Insert the segment elsewhere\n        new_solution = np.delete(new_solution, range(start, end))\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure the solution remains valid\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 230,
        "algorithm": "{A novel adaptive local search operator that combines edge-swapping with dynamic segment reordering, guided by Pareto dominance and objective-space diversity to explore high-quality regions of the search space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Make a copy of the selected solution\n    new_solution = selected_solution.copy()\n\n    # Determine a segment to modify (adaptive segment selection)\n    n = len(new_solution)\n    segment_size = max(3, n // 5)\n    start = np.random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n\n    # Apply dynamic segment reordering (hybrid operator)\n    if np.random.rand() < 0.7:  # 70% chance to reorder\n        if np.random.rand() < 0.5:  # Reverse segment\n            segment = segment[::-1]\n        else:  # Rotate segment\n            shift = np.random.randint(1, len(segment))\n            segment = np.roll(segment, shift)\n\n    # Update the solution with the modified segment\n    new_solution[start:start+segment_size] = segment\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique[counts > 1]\n\n    for dup in duplicates:\n        missing = np.setdiff1d(np.arange(len(instance)), new_solution)\n        if len(missing) > 0:\n            idx = np.where(new_solution == dup)[0][1:]  # Skip first occurrence\n            for i in idx:\n                new_solution[i] = np.random.choice(missing)\n                missing = np.setdiff1d(missing, [new_solution[i]])\n\n    return new_solution\n\n",
        "score": [
            -0.8765136526310588,
            1.7933799028396606
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Make a copy of the selected solution\n    new_solution = selected_solution.copy()\n\n    # Determine a segment to modify (adaptive segment selection)\n    n = len(new_solution)\n    segment_size = max(3, n // 5)\n    start = np.random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n\n    # Apply dynamic segment reordering (hybrid operator)\n    if np.random.rand() < 0.7:  # 70% chance to reorder\n        if np.random.rand() < 0.5:  # Reverse segment\n            segment = segment[::-1]\n        else:  # Rotate segment\n            shift = np.random.randint(1, len(segment))\n            segment = np.roll(segment, shift)\n\n    # Update the solution with the modified segment\n    new_solution[start:start+segment_size] = segment\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique[counts > 1]\n\n    for dup in duplicates:\n        missing = np.setdiff1d(np.arange(len(instance)), new_solution)\n        if len(missing) > 0:\n            idx = np.where(new_solution == dup)[0][1:]  # Skip first occurrence\n            for i in idx:\n                new_solution[i] = np.random.choice(missing)\n                missing = np.setdiff1d(missing, [new_solution[i]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 231,
        "algorithm": "{A novel hybrid local search operator combines a biased random walk with a multi-objective diversification mechanism, alternating between edge swaps based on Pareto dominance and objective-space clustering to escape local optima while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = [sol for sol, _ in archive if len(sol) > 3]  # Ensure enough nodes for meaningful operations\n    if not candidates:\n        return archive[0][0].copy()\n\n    # Hybrid selection: prioritize non-dominated solutions, then diverse ones\n    dominated = set()\n    for i, (sol_i, _) in enumerate(archive):\n        for j, (sol_j, _) in enumerate(archive):\n            if i != j and all(archive[i][1][k] >= archive[j][1][k] for k in range(2)) and any(archive[i][1][k] > archive[j][1][k] for k in range(2)):\n                dominated.add(i)\n    non_dominated = [sol for i, (sol, _) in enumerate(archive) if i not in dominated]\n\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        # If no non-dominated, select a diverse solution (far from centroid)\n        centroid = np.mean([sol for sol, _ in archive], axis=0)\n        distances = [np.linalg.norm(sol - centroid) for sol in candidates]\n        base_solution = candidates[np.argmax(distances)].copy()\n\n    # Hybrid local search: alternate between edge swaps and cluster-based diversification\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Multi-objective edge swap (prioritize Pareto-improving moves)\n    for _ in range(min(5, n // 2)):\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j or (i + 1) % n == j:\n            continue  # Skip adjacent or same nodes\n\n        # Compute delta cost in both objectives\n        delta_1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                   distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                   distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                   distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta_2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                   distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                   distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                   distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if Pareto-improving or random walk with probability\n        if (delta_1 < 0 and delta_2 <= 0) or (delta_1 <= 0 and delta_2 < 0) or random.random() < 0.2:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Phase 2: Cluster-based diversification (swap nodes from different clusters)\n    if n > 4:\n        # Simple clustering (k-means with k=2)\n        coords = instance[new_solution, :2]  # Use first objective space for clustering\n        cluster_centers = np.array([coords.mean(axis=0), coords.max(axis=0)])\n        clusters = np.argmin(np.linalg.norm(coords[:, np.newaxis] - cluster_centers, axis=2), axis=1)\n\n        # Find nodes in different clusters\n        cluster0 = [i for i, c in enumerate(clusters) if c == 0]\n        cluster1 = [i for i, c in enumerate(clusters) if c == 1]\n\n        if len(cluster0) > 1 and len(cluster1) > 1:\n            a = random.choice(cluster0)\n            b = random.choice(cluster1)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8160515951298727,
            3.1839404106140137
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = [sol for sol, _ in archive if len(sol) > 3]  # Ensure enough nodes for meaningful operations\n    if not candidates:\n        return archive[0][0].copy()\n\n    # Hybrid selection: prioritize non-dominated solutions, then diverse ones\n    dominated = set()\n    for i, (sol_i, _) in enumerate(archive):\n        for j, (sol_j, _) in enumerate(archive):\n            if i != j and all(archive[i][1][k] >= archive[j][1][k] for k in range(2)) and any(archive[i][1][k] > archive[j][1][k] for k in range(2)):\n                dominated.add(i)\n    non_dominated = [sol for i, (sol, _) in enumerate(archive) if i not in dominated]\n\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        # If no non-dominated, select a diverse solution (far from centroid)\n        centroid = np.mean([sol for sol, _ in archive], axis=0)\n        distances = [np.linalg.norm(sol - centroid) for sol in candidates]\n        base_solution = candidates[np.argmax(distances)].copy()\n\n    # Hybrid local search: alternate between edge swaps and cluster-based diversification\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Multi-objective edge swap (prioritize Pareto-improving moves)\n    for _ in range(min(5, n // 2)):\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j or (i + 1) % n == j:\n            continue  # Skip adjacent or same nodes\n\n        # Compute delta cost in both objectives\n        delta_1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                   distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                   distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                   distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta_2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                   distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                   distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                   distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if Pareto-improving or random walk with probability\n        if (delta_1 < 0 and delta_2 <= 0) or (delta_1 <= 0 and delta_2 < 0) or random.random() < 0.2:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Phase 2: Cluster-based diversification (swap nodes from different clusters)\n    if n > 4:\n        # Simple clustering (k-means with k=2)\n        coords = instance[new_solution, :2]  # Use first objective space for clustering\n        cluster_centers = np.array([coords.mean(axis=0), coords.max(axis=0)])\n        clusters = np.argmin(np.linalg.norm(coords[:, np.newaxis] - cluster_centers, axis=2), axis=1)\n\n        # Find nodes in different clusters\n        cluster0 = [i for i, c in enumerate(clusters) if c == 0]\n        cluster1 = [i for i, c in enumerate(clusters) if c == 1]\n\n        if len(cluster0) > 1 and len(cluster1) > 1:\n            a = random.choice(cluster0)\n            b = random.choice(cluster1)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 232,
        "algorithm": "{This algorithm selects a promising solution from the archive by prioritizing those with lower combined objective values, then applies a hybrid local search operator that combines edge-swapping with a novel path-reversal mechanism to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower combined objective value\n    archive.sort(key=lambda x: sum(x[1]))\n    selected = archive[0][0].copy()\n\n    # Hybrid local search: edge-swapping + path-reversal\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Edge-swapping\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Path-reversal with objective-aware selection\n    for _ in range(2):  # Limit iterations to avoid excessive computation\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a > 2:  # Ensure meaningful reversal\n            segment = new_solution[a:b+1]\n            reversed_segment = segment[::-1]\n\n            # Calculate cost difference\n            original_cost = (distance_matrix_1[segment[-1], segment[0]] + distance_matrix_1[segment[0], segment[-1]] +\n                            distance_matrix_2[segment[-1], segment[0]] + distance_matrix_2[segment[0], segment[-1]])\n            new_cost = (distance_matrix_1[reversed_segment[-1], reversed_segment[0]] + distance_matrix_1[reversed_segment[0], reversed_segment[-1]] +\n                        distance_matrix_2[reversed_segment[-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[0], reversed_segment[-1]])\n\n            if new_cost < original_cost:\n                new_solution[a:b+1] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            -0.6533161542542839,
            1.8388464450836182
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower combined objective value\n    archive.sort(key=lambda x: sum(x[1]))\n    selected = archive[0][0].copy()\n\n    # Hybrid local search: edge-swapping + path-reversal\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Edge-swapping\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Path-reversal with objective-aware selection\n    for _ in range(2):  # Limit iterations to avoid excessive computation\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a > 2:  # Ensure meaningful reversal\n            segment = new_solution[a:b+1]\n            reversed_segment = segment[::-1]\n\n            # Calculate cost difference\n            original_cost = (distance_matrix_1[segment[-1], segment[0]] + distance_matrix_1[segment[0], segment[-1]] +\n                            distance_matrix_2[segment[-1], segment[0]] + distance_matrix_2[segment[0], segment[-1]])\n            new_cost = (distance_matrix_1[reversed_segment[-1], reversed_segment[0]] + distance_matrix_1[reversed_segment[0], reversed_segment[-1]] +\n                        distance_matrix_2[reversed_segment[-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[0], reversed_segment[-1]])\n\n            if new_cost < original_cost:\n                new_solution[a:b+1] = reversed_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 233,
        "algorithm": "{A novel hybrid local search operator combines a multi-parent crossover with a dynamic edge-swap mechanism, where segments from multiple solutions in the archive are intelligently merged while preserving feasibility, followed by a probabilistic edge-swap step that prioritizes improving both objectives based on their relative dominance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_solutions = []\n    for sol, _ in archive:\n        # Check if the solution is non-dominated or has high diversity\n        is_non_dominated = True\n        for _, obj in archive:\n            if obj[0] < archive[0][1][0] and obj[1] < archive[0][1][1]:\n                is_non_dominated = False\n                break\n        if is_non_dominated:\n            selected_solutions.append(sol)\n\n    if not selected_solutions:\n        selected_solutions = [sol for sol, _ in archive]\n\n    base_solution = random.choice(selected_solutions).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-parent crossover + dynamic edge-swap\n    num_parents = min(3, len(selected_solutions))\n    parents = random.sample(selected_solutions, num_parents)\n\n    # Multi-parent crossover: select segments from parents\n    segment_length = len(base_solution) // (num_parents + 1)\n    for i in range(num_parents):\n        start = i * segment_length\n        end = (i + 1) * segment_length\n        segment = parents[i][start:end]\n        # Insert segment into new_solution while maintaining feasibility\n        for node in segment:\n            if node not in new_solution[start:end]:\n                # Find a position to place the node\n                for j in range(len(new_solution)):\n                    if new_solution[j] not in segment:\n                        new_solution[j], new_solution[np.where(new_solution == node)[0][0]] = node, new_solution[j]\n                        break\n\n    # Dynamic edge-swap: prioritize edges that improve both objectives\n    for _ in range(5):  # Number of swaps\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        # Check if swapping improves both objectives\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or \\\n           (random.random() < 0.3 and (new_cost1 < original_cost1 or new_cost2 < original_cost2)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7312064025851368,
            3.125074088573456
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_solutions = []\n    for sol, _ in archive:\n        # Check if the solution is non-dominated or has high diversity\n        is_non_dominated = True\n        for _, obj in archive:\n            if obj[0] < archive[0][1][0] and obj[1] < archive[0][1][1]:\n                is_non_dominated = False\n                break\n        if is_non_dominated:\n            selected_solutions.append(sol)\n\n    if not selected_solutions:\n        selected_solutions = [sol for sol, _ in archive]\n\n    base_solution = random.choice(selected_solutions).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-parent crossover + dynamic edge-swap\n    num_parents = min(3, len(selected_solutions))\n    parents = random.sample(selected_solutions, num_parents)\n\n    # Multi-parent crossover: select segments from parents\n    segment_length = len(base_solution) // (num_parents + 1)\n    for i in range(num_parents):\n        start = i * segment_length\n        end = (i + 1) * segment_length\n        segment = parents[i][start:end]\n        # Insert segment into new_solution while maintaining feasibility\n        for node in segment:\n            if node not in new_solution[start:end]:\n                # Find a position to place the node\n                for j in range(len(new_solution)):\n                    if new_solution[j] not in segment:\n                        new_solution[j], new_solution[np.where(new_solution == node)[0][0]] = node, new_solution[j]\n                        break\n\n    # Dynamic edge-swap: prioritize edges that improve both objectives\n    for _ in range(5):  # Number of swaps\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        # Check if swapping improves both objectives\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or \\\n           (random.random() < 0.3 and (new_cost1 < original_cost1 or new_cost2 < original_cost2)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 234,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    base_solution = best_solution.copy()\n\n    # Perform a hybrid local search: combine 3-opt with a randomized edge swap\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select three distinct segments\n    i, j, k = sorted(np.random.choice(range(1, N), size=3, replace=False))\n\n    # Perform a 3-opt move\n    new_solution[i:j] = np.flip(new_solution[i:j])\n    new_solution[j:k] = np.flip(new_solution[j:k])\n\n    # Randomly swap two edges to increase diversity\n    a, b = np.random.choice(range(1, N), size=2, replace=False)\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) != N:\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.9014789249797452,
            1.6153644323349
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    base_solution = best_solution.copy()\n\n    # Perform a hybrid local search: combine 3-opt with a randomized edge swap\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select three distinct segments\n    i, j, k = sorted(np.random.choice(range(1, N), size=3, replace=False))\n\n    # Perform a 3-opt move\n    new_solution[i:j] = np.flip(new_solution[i:j])\n    new_solution[j:k] = np.flip(new_solution[j:k])\n\n    # Randomly swap two edges to increase diversity\n    a, b = np.random.choice(range(1, N), size=2, replace=False)\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) != N:\n        return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 235,
        "algorithm": "{A novel hybrid local search operator combines a randomized segment inversion with a multi-objective-aware edge swap, intelligently selecting segments based on their Pareto dominance and diversity in the archive to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select from non-dominated solutions if available\n        non_dominated = []\n        for i in range(len(archive)):\n            dominated = False\n            for j in range(len(archive)):\n                if i != j and archive[j][1][0] <= archive[i][1][0] and archive[j][1][1] <= archive[i][1][1] and (archive[j][1][0] < archive[i][1][0] or archive[j][1][1] < archive[i][1][1]):\n                    dominated = True\n                    break\n            if not dominated:\n                non_dominated.append(i)\n\n        if non_dominated:\n            selected_idx = random.choice(non_dominated)\n        else:\n            # Select from top 30% by combined cost\n            costs = [sum(obj) for _, obj in archive]\n            sorted_indices = np.argsort(costs)\n            top_30_percent = max(1, len(archive) // 3)\n            selected_idx = random.choice(sorted_indices[:top_30_percent])\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective-aware edge swap\n    n = len(base_solution)\n\n    # Randomized segment inversion\n    if n > 3:\n        seg_start = random.randint(0, n - 3)\n        seg_end = random.randint(seg_start + 1, min(seg_start + 2, n - 1))\n        new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Multi-objective-aware edge swap\n    if n > 4:\n        # Select two edges that are critical in either objective\n        for _ in range(2):\n            i = random.randint(0, n - 2)\n            j = random.randint(i + 1, n - 1)\n\n            # Calculate potential improvement in both objectives\n            a, b, c = base_solution[i-1], base_solution[i], base_solution[j]\n            d, e, f = base_solution[(i+1)%n], base_solution[(j+1)%n], base_solution[(j+2)%n]\n\n            # Calculate cost change in both objectives\n            delta_1 = (distance_matrix_1[b, e] + distance_matrix_1[c, d] -\n                      (distance_matrix_1[b, c] + distance_matrix_1[d, e]))\n            delta_2 = (distance_matrix_2[b, e] + distance_matrix_2[c, d] -\n                      (distance_matrix_2[b, c] + distance_matrix_2[d, e]))\n\n            # If improvement in at least one objective, perform swap\n            if delta_1 < 0 or delta_2 < 0:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8281839081668915,
            1.9514522552490234
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select from non-dominated solutions if available\n        non_dominated = []\n        for i in range(len(archive)):\n            dominated = False\n            for j in range(len(archive)):\n                if i != j and archive[j][1][0] <= archive[i][1][0] and archive[j][1][1] <= archive[i][1][1] and (archive[j][1][0] < archive[i][1][0] or archive[j][1][1] < archive[i][1][1]):\n                    dominated = True\n                    break\n            if not dominated:\n                non_dominated.append(i)\n\n        if non_dominated:\n            selected_idx = random.choice(non_dominated)\n        else:\n            # Select from top 30% by combined cost\n            costs = [sum(obj) for _, obj in archive]\n            sorted_indices = np.argsort(costs)\n            top_30_percent = max(1, len(archive) // 3)\n            selected_idx = random.choice(sorted_indices[:top_30_percent])\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective-aware edge swap\n    n = len(base_solution)\n\n    # Randomized segment inversion\n    if n > 3:\n        seg_start = random.randint(0, n - 3)\n        seg_end = random.randint(seg_start + 1, min(seg_start + 2, n - 1))\n        new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Multi-objective-aware edge swap\n    if n > 4:\n        # Select two edges that are critical in either objective\n        for _ in range(2):\n            i = random.randint(0, n - 2)\n            j = random.randint(i + 1, n - 1)\n\n            # Calculate potential improvement in both objectives\n            a, b, c = base_solution[i-1], base_solution[i], base_solution[j]\n            d, e, f = base_solution[(i+1)%n], base_solution[(j+1)%n], base_solution[(j+2)%n]\n\n            # Calculate cost change in both objectives\n            delta_1 = (distance_matrix_1[b, e] + distance_matrix_1[c, d] -\n                      (distance_matrix_1[b, c] + distance_matrix_1[d, e]))\n            delta_2 = (distance_matrix_2[b, e] + distance_matrix_2[c, d] -\n                      (distance_matrix_2[b, c] + distance_matrix_2[d, e]))\n\n            # If improvement in at least one objective, perform swap\n            if delta_1 < 0 or delta_2 < 0:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 236,
        "algorithm": "{This heuristic function selects a promising solution from the archive by prioritizing those with the highest combined objective improvement potential, then applies a hybrid local search combining edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_solution = archive[0][0].copy()\n\n    # Apply hybrid local search: segment reversal + edge insertion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments and reverse them\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select two edges and perform edge insertion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    if a != b:\n        temp = new_solution[b]\n        new_solution[b] = new_solution[a]\n        new_solution[a+1:b+1] = np.roll(new_solution[a+1:b+1], -1)\n        new_solution[a+1] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.8404053123140504,
            0.4494808316230774
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_solution = archive[0][0].copy()\n\n    # Apply hybrid local search: segment reversal + edge insertion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments and reverse them\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select two edges and perform edge insertion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    if a != b:\n        temp = new_solution[b]\n        new_solution[b] = new_solution[a]\n        new_solution[a+1:b+1] = np.roll(new_solution[a+1:b+1], -1)\n        new_solution[a+1] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 237,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on a hybrid objective score, then applies a novel 4-opt-like local search with adaptive segment selection and multi-objective edge swapping to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential improvement\n    total_score = sum((obj[0] + obj[1]) for _, obj in archive)\n    if total_score == 0:\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = random.choices(range(len(archive)), weights=[(obj[0] + obj[1]) / total_score for _, obj in archive])[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive 4-opt with multi-objective edge swapping\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Select 4 distinct positions\n    a, b, c, d = sorted(random.sample(range(n), 4))\n\n    # Calculate current and potential costs\n    def get_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n        return cost1, cost2\n\n    current_cost1, current_cost2 = get_cost(new_solution)\n\n    # Generate all possible 4-opt neighbors\n    neighbors = []\n    for i in range(4):\n        # Try different segment orderings\n        if i == 0:\n            temp = np.concatenate([new_solution[:a], new_solution[b:c+1], new_solution[a:b], new_solution[c+1:d+1], new_solution[d+1:]])\n        elif i == 1:\n            temp = np.concatenate([new_solution[:a], new_solution[c:d+1], new_solution[a:b], new_solution[b:c], new_solution[d+1:]])\n        elif i == 2:\n            temp = np.concatenate([new_solution[:a], new_solution[b:d+1][::-1], new_solution[a:b], new_solution[d+1:]])\n        else:\n            temp = np.concatenate([new_solution[:a], new_solution[b:c+1][::-1], new_solution[c+1:d+1], new_solution[a:b], new_solution[d+1:]])\n\n        if len(np.unique(temp)) == n:  # Ensure validity\n            cost1, cost2 = get_cost(temp)\n            neighbors.append((cost1, cost2, temp))\n\n    # Select the best neighbor that improves at least one objective\n    best_neighbor = None\n    best_improvement = -1\n    for cost1, cost2, neighbor in neighbors:\n        improvement = (current_cost1 - cost1) + (current_cost2 - cost2)\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_neighbor = neighbor\n\n    if best_neighbor is not None:\n        return best_neighbor\n    else:\n        return new_solution\n\n",
        "score": [
            -0.9159254072450914,
            3.026590645313263
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential improvement\n    total_score = sum((obj[0] + obj[1]) for _, obj in archive)\n    if total_score == 0:\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = random.choices(range(len(archive)), weights=[(obj[0] + obj[1]) / total_score for _, obj in archive])[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive 4-opt with multi-objective edge swapping\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Select 4 distinct positions\n    a, b, c, d = sorted(random.sample(range(n), 4))\n\n    # Calculate current and potential costs\n    def get_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n        return cost1, cost2\n\n    current_cost1, current_cost2 = get_cost(new_solution)\n\n    # Generate all possible 4-opt neighbors\n    neighbors = []\n    for i in range(4):\n        # Try different segment orderings\n        if i == 0:\n            temp = np.concatenate([new_solution[:a], new_solution[b:c+1], new_solution[a:b], new_solution[c+1:d+1], new_solution[d+1:]])\n        elif i == 1:\n            temp = np.concatenate([new_solution[:a], new_solution[c:d+1], new_solution[a:b], new_solution[b:c], new_solution[d+1:]])\n        elif i == 2:\n            temp = np.concatenate([new_solution[:a], new_solution[b:d+1][::-1], new_solution[a:b], new_solution[d+1:]])\n        else:\n            temp = np.concatenate([new_solution[:a], new_solution[b:c+1][::-1], new_solution[c+1:d+1], new_solution[a:b], new_solution[d+1:]])\n\n        if len(np.unique(temp)) == n:  # Ensure validity\n            cost1, cost2 = get_cost(temp)\n            neighbors.append((cost1, cost2, temp))\n\n    # Select the best neighbor that improves at least one objective\n    best_neighbor = None\n    best_improvement = -1\n    for cost1, cost2, neighbor in neighbors:\n        improvement = (current_cost1 - cost1) + (current_cost2 - cost2)\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_neighbor = neighbor\n\n    if best_neighbor is not None:\n        return best_neighbor\n    else:\n        return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 238,
        "algorithm": "{The heuristic selects a solution from the archive based on its objective values, then applies a hybrid local search combining edge insertion and segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def dominance_score(sol, obj):\n        better_in_1 = sum(1 for other_obj in [o for (s, o) in archive if s.tolist() != sol.tolist()]\n                         if other_obj[0] < obj[0] and other_obj[1] <= obj[1])\n        better_in_2 = sum(1 for other_obj in [o for (s, o) in archive if s.tolist() != sol.tolist()]\n                         if other_obj[1] < obj[1] and other_obj[0] <= obj[0])\n        return better_in_1 + better_in_2\n\n    candidates = [(sol, obj, dominance_score(sol, obj)) for sol, obj in archive]\n    candidates.sort(key=lambda x: x[2])\n    selected = random.choice(candidates[:max(1, len(candidates) // 3)])[0].copy()\n\n    # Hybrid local search: segment inversion + edge insertion\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment inversion\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Edge insertion\n    if n > 3:\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Ensure feasibility\n    _, indices = np.unique(new_solution, return_index=True)\n    if len(indices) < n:\n        missing = [i for i in range(n) if i not in new_solution]\n        for i in range(n):\n            if new_solution[i] not in new_solution[:i]:\n                continue\n            for m in missing:\n                if m not in new_solution[:i]:\n                    new_solution[i] = m\n                    missing.remove(m)\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7418742268669818,
            3.5217655897140503
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def dominance_score(sol, obj):\n        better_in_1 = sum(1 for other_obj in [o for (s, o) in archive if s.tolist() != sol.tolist()]\n                         if other_obj[0] < obj[0] and other_obj[1] <= obj[1])\n        better_in_2 = sum(1 for other_obj in [o for (s, o) in archive if s.tolist() != sol.tolist()]\n                         if other_obj[1] < obj[1] and other_obj[0] <= obj[0])\n        return better_in_1 + better_in_2\n\n    candidates = [(sol, obj, dominance_score(sol, obj)) for sol, obj in archive]\n    candidates.sort(key=lambda x: x[2])\n    selected = random.choice(candidates[:max(1, len(candidates) // 3)])[0].copy()\n\n    # Hybrid local search: segment inversion + edge insertion\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment inversion\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Edge insertion\n    if n > 3:\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Ensure feasibility\n    _, indices = np.unique(new_solution, return_index=True)\n    if len(indices) < n:\n        missing = [i for i in range(n) if i not in new_solution]\n        for i in range(n):\n            if new_solution[i] not in new_solution[:i]:\n                continue\n            for m in missing:\n                if m not in new_solution[:i]:\n                    new_solution[i] = m\n                    missing.remove(m)\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 239,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its potential for improvement by combining dominance-based selection with a novel hybrid local search that dynamically balances edge swaps and segment reversals to escape local optima while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Combine edge swaps and segment reversals\n    n = len(new_solution)\n    a, b = np.random.choice(n, size=2, replace=False)\n    c, d = np.random.choice(n, size=2, replace=False)\n\n    # Ensure a < b and c < d for proper segment reversal\n    if a > b:\n        a, b = b, a\n    if c > d:\n        c, d = d, c\n\n    # Perform segment reversal between a and b, then between c and d\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to edge swap if reversal causes duplicates\n        new_solution = base_solution.copy()\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8112149642697459,
            2.27060204744339
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Combine edge swaps and segment reversals\n    n = len(new_solution)\n    a, b = np.random.choice(n, size=2, replace=False)\n    c, d = np.random.choice(n, size=2, replace=False)\n\n    # Ensure a < b and c < d for proper segment reversal\n    if a > b:\n        a, b = b, a\n    if c > d:\n        c, d = d, c\n\n    # Perform segment reversal between a and b, then between c and d\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to edge swap if reversal causes duplicates\n        new_solution = base_solution.copy()\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 240,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: min(x[1]))[0].copy()\n\n    # Hybrid 3-opt with adaptive segment selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Select three random segments\n    a, b, c = sorted(random.sample(range(1, n), 3))\n\n    # Determine the best segment to reverse based on both objectives\n    def segment_cost(solution, i, j):\n        cost1 = distance_matrix_1[solution[i-1], solution[i]] + distance_matrix_1[solution[j-1], solution[j]]\n        cost2 = distance_matrix_2[solution[i-1], solution[i]] + distance_matrix_2[solution[j-1], solution[j]]\n        return (cost1, cost2)\n\n    # Calculate potential improvements for each segment\n    segments = [(a, b), (b, c), (a, c)]\n    improvements = []\n    for i, j in segments:\n        original_cost = segment_cost(selected_solution, i, j)\n        reversed_solution = selected_solution.copy()\n        reversed_solution[i:j] = reversed_solution[i:j]\n        new_cost = segment_cost(reversed_solution, i, j)\n        improvement = (original_cost[0] - new_cost[0], original_cost[1] - new_cost[1])\n        improvements.append((improvement, i, j))\n\n    # Select the segment with the best combined improvement\n    best_improvement = max(improvements, key=lambda x: sum(x[0]))\n    _, i, j = best_improvement\n\n    # Apply the best improvement\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Further optimize by considering both objectives\n    for _ in range(2):  # Limit iterations for efficiency\n        i, j = sorted(random.sample(range(1, n), 2))\n        if random.random() < 0.5:  # Randomly choose between 2-opt or insertion\n            # 2-opt style move\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Insertion move\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    return new_solution\n\n",
        "score": [
            -0.4058464341544029,
            2.116389274597168
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: min(x[1]))[0].copy()\n\n    # Hybrid 3-opt with adaptive segment selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Select three random segments\n    a, b, c = sorted(random.sample(range(1, n), 3))\n\n    # Determine the best segment to reverse based on both objectives\n    def segment_cost(solution, i, j):\n        cost1 = distance_matrix_1[solution[i-1], solution[i]] + distance_matrix_1[solution[j-1], solution[j]]\n        cost2 = distance_matrix_2[solution[i-1], solution[i]] + distance_matrix_2[solution[j-1], solution[j]]\n        return (cost1, cost2)\n\n    # Calculate potential improvements for each segment\n    segments = [(a, b), (b, c), (a, c)]\n    improvements = []\n    for i, j in segments:\n        original_cost = segment_cost(selected_solution, i, j)\n        reversed_solution = selected_solution.copy()\n        reversed_solution[i:j] = reversed_solution[i:j]\n        new_cost = segment_cost(reversed_solution, i, j)\n        improvement = (original_cost[0] - new_cost[0], original_cost[1] - new_cost[1])\n        improvements.append((improvement, i, j))\n\n    # Select the segment with the best combined improvement\n    best_improvement = max(improvements, key=lambda x: sum(x[0]))\n    _, i, j = best_improvement\n\n    # Apply the best improvement\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Further optimize by considering both objectives\n    for _ in range(2):  # Limit iterations for efficiency\n        i, j = sorted(random.sample(range(1, n), 2))\n        if random.random() < 0.5:  # Randomly choose between 2-opt or insertion\n            # 2-opt style move\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Insertion move\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 241,
        "algorithm": "{A hybrid local search strategy that combines a probabilistic node reinsertion with a variable-length segment relocation, guided by a multi-objective fitness criterion to balance exploration and exploitation in the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]))  # Example: select solution with highest combined cost\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: probabilistic node reinsertion + variable-length segment relocation\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Step 1: Probabilistic node reinsertion\n    for _ in range(min(3, n // 2)):  # Limit to avoid excessive changes\n        i = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = np.random.randint(1, n-1)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Step 2: Variable-length segment relocation\n    seg_length = np.random.randint(2, min(5, n // 2))  # Random segment length\n    start = np.random.randint(1, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    new_solution = np.delete(new_solution, np.arange(start, start+seg_length))\n    insert_pos = np.random.randint(1, n - seg_length + 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            -0.8196265957680957,
            1.980879783630371
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]))  # Example: select solution with highest combined cost\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: probabilistic node reinsertion + variable-length segment relocation\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Step 1: Probabilistic node reinsertion\n    for _ in range(min(3, n // 2)):  # Limit to avoid excessive changes\n        i = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = np.random.randint(1, n-1)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Step 2: Variable-length segment relocation\n    seg_length = np.random.randint(2, min(5, n // 2))  # Random segment length\n    start = np.random.randint(1, n - seg_length)\n    segment = new_solution[start:start+seg_length]\n    new_solution = np.delete(new_solution, np.arange(start, start+seg_length))\n    insert_pos = np.random.randint(1, n - seg_length + 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 242,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        max_variance_idx = np.argmax(np.var(objectives, axis=0))\n        base_solution = archive[max_variance_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations for efficiency\n        # Randomly select a segment to reverse\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1][::-1]\n\n        # Randomly select an edge to insert the segment\n        k = np.random.randint(0, n)\n        if k < i or k >= j:\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n            new_solution = new_solution[:n]  # Ensure correct length\n\n    # Ensure solution is valid (no duplicates)\n    if len(set(new_solution)) != n:\n        # If invalid, fall back to a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8446761942557428,
            1.0551203489303589
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        max_variance_idx = np.argmax(np.var(objectives, axis=0))\n        base_solution = archive[max_variance_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations for efficiency\n        # Randomly select a segment to reverse\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1][::-1]\n\n        # Randomly select an edge to insert the segment\n        k = np.random.randint(0, n)\n        if k < i or k >= j:\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n            new_solution = new_solution[:n]  # Ensure correct length\n\n    # Ensure solution is valid (no duplicates)\n    if len(set(new_solution)) != n:\n        # If invalid, fall back to a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 243,
        "algorithm": "{A novel hybrid local search operator combines a probabilistic 3-opt move with a dynamic segment inversion, guided by a weighted Pareto dominance criterion to explore trade-offs between objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by non-dominated rank (simplified for this example)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        base_solution = random.choice(sorted_archive[:max(1, len(archive)//2)])[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search operator\n    if N >= 4:\n        # Probabilistic 3-opt move\n        if random.random() < 0.7:\n            a, b, c = sorted(random.sample(range(N), 3))\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[b:c]\n            new_solution[a:c] = np.concatenate([segment2, segment1])\n\n        # Dynamic segment inversion\n        else:\n            k = random.randint(2, min(5, N//2))\n            start = random.randint(0, N - k)\n            new_solution[start:start+k] = new_solution[start:start+k][::-1]\n\n    # Ensure feasibility\n    if not np.array_equal(np.unique(new_solution), np.arange(N)):\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(N), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7893154496653708,
            2.022042155265808
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by non-dominated rank (simplified for this example)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        base_solution = random.choice(sorted_archive[:max(1, len(archive)//2)])[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search operator\n    if N >= 4:\n        # Probabilistic 3-opt move\n        if random.random() < 0.7:\n            a, b, c = sorted(random.sample(range(N), 3))\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[b:c]\n            new_solution[a:c] = np.concatenate([segment2, segment1])\n\n        # Dynamic segment inversion\n        else:\n            k = random.randint(2, min(5, N//2))\n            start = random.randint(0, N - k)\n            new_solution[start:start+k] = new_solution[start:start+k][::-1]\n\n    # Ensure feasibility\n    if not np.array_equal(np.unique(new_solution), np.arange(N)):\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(N), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 244,
        "algorithm": "{The heuristic function selects a solution from the archive with high potential for improvement by evaluating both objective values and their spread, then applies a hybrid local search combining edge swaps and segment rotations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps and segment rotations\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to apply operators\n\n    # Randomly choose between edge swap or segment rotation\n    if np.random.rand() < 0.5:\n        # Edge swap (2-opt variant)\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:\n        # Segment rotation (rotate a segment of nodes)\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = np.roll(segment, c - a)\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution: duplicate nodes\"\n    assert set(new_solution) == set(base_solution), \"Invalid solution: missing nodes\"\n\n    return new_solution\n\n",
        "score": [
            -0.8211096729589179,
            1.7339463233947754
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps and segment rotations\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to apply operators\n\n    # Randomly choose between edge swap or segment rotation\n    if np.random.rand() < 0.5:\n        # Edge swap (2-opt variant)\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:\n        # Segment rotation (rotate a segment of nodes)\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = np.roll(segment, c - a)\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution: duplicate nodes\"\n    assert set(new_solution) == set(base_solution), \"Invalid solution: missing nodes\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 245,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined objective (sum of both objectives)\n    selected = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected.copy()\n\n    # Perform a novel hybrid local search: combine 2-opt with a greedy edge swap\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to ensure efficiency\n        # Randomly select two edges to break\n        i, j = sorted(random.sample(range(1, n), 2))\n\n        # Try reversing the segment between i and j (2-opt-like move)\n        candidate = new_solution.copy()\n        candidate[i:j] = candidate[i:j][::-1]\n\n        # Evaluate the candidate in both objective spaces\n        cost1 = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(n))\n        cost2 = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(n))\n\n        # If the candidate is better in at least one objective, accept it\n        if (cost1 < sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))) or \\\n           (cost2 < sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))):\n            new_solution = candidate\n\n        # Additionally, perform a greedy edge swap if the above didn't improve\n        else:\n            # Find the worst edge in the current solution\n            worst_edge = max(\n                [(k, (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                      distance_matrix_2[new_solution[k-1], new_solution[k]]))\n                 for k in range(n)],\n                key=lambda x: x[1]\n            )[0]\n\n            # Try swapping the worst edge with a random edge\n            k = random.randint(0, n-1)\n            if k != worst_edge and k != (worst_edge + 1) % n:\n                candidate = new_solution.copy()\n                candidate[worst_edge], candidate[k] = candidate[k], candidate[worst_edge]\n                cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n                cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n\n                if (cost1 < sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))) or \\\n                   (cost2 < sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))):\n                    new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8634127371516178,
            8.871429443359375
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined objective (sum of both objectives)\n    selected = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected.copy()\n\n    # Perform a novel hybrid local search: combine 2-opt with a greedy edge swap\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to ensure efficiency\n        # Randomly select two edges to break\n        i, j = sorted(random.sample(range(1, n), 2))\n\n        # Try reversing the segment between i and j (2-opt-like move)\n        candidate = new_solution.copy()\n        candidate[i:j] = candidate[i:j][::-1]\n\n        # Evaluate the candidate in both objective spaces\n        cost1 = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(n))\n        cost2 = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(n))\n\n        # If the candidate is better in at least one objective, accept it\n        if (cost1 < sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))) or \\\n           (cost2 < sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))):\n            new_solution = candidate\n\n        # Additionally, perform a greedy edge swap if the above didn't improve\n        else:\n            # Find the worst edge in the current solution\n            worst_edge = max(\n                [(k, (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                      distance_matrix_2[new_solution[k-1], new_solution[k]]))\n                 for k in range(n)],\n                key=lambda x: x[1]\n            )[0]\n\n            # Try swapping the worst edge with a random edge\n            k = random.randint(0, n-1)\n            if k != worst_edge and k != (worst_edge + 1) % n:\n                candidate = new_solution.copy()\n                candidate[worst_edge], candidate[k] = candidate[k], candidate[worst_edge]\n                cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n                cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n\n                if (cost1 < sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))) or \\\n                   (cost2 < sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))):\n                    new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 246,
        "algorithm": "{A novel hybrid local search operator combines a variable-length edge exchange with a dynamic objective-weighted path relocation, selecting solutions from the archive based on non-dominated sorting and crowding distance to prioritize high-potential regions, while ensuring feasibility through constrained edge swaps and path reinsertions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution from the archive based on non-dominated sorting and crowding distance\n    def non_dominated_sort(objectives):\n        fronts = [[]]\n        S = [[] for _ in range(len(objectives))]\n        n = [0] * len(objectives)\n        rank = [0] * len(objectives)\n\n        for p in range(len(objectives)):\n            S[p] = []\n            n[p] = 0\n            for q in range(len(objectives)):\n                if objectives[p][0] < objectives[q][0] and objectives[p][1] < objectives[q][1]:\n                    if q not in S[p]:\n                        S[p].append(q)\n                elif objectives[q][0] < objectives[p][0] and objectives[q][1] < objectives[p][1]:\n                    n[p] += 1\n            if n[p] == 0:\n                rank[p] = 0\n                if p not in fronts[0]:\n                    fronts[0].append(p)\n\n        i = 0\n        while fronts[i]:\n            Q = []\n            for p in fronts[i]:\n                for q in S[p]:\n                    n[q] -= 1\n                    if n[q] == 0:\n                        rank[q] = i + 1\n                        if q not in Q:\n                            Q.append(q)\n            i += 1\n            fronts.append(Q)\n\n        del fronts[-1]\n        return fronts, rank\n\n    def crowding_distance(front, objectives):\n        distance = [0] * len(front)\n        for obj in range(2):\n            sorted_front = sorted(front, key=lambda x: objectives[x][obj])\n            distance[0] = distance[-1] = float('inf')\n            for i in range(1, len(front) - 1):\n                distance[i] += (objectives[sorted_front[i + 1]][obj] - objectives[sorted_front[i - 1]][obj]) / (objectives[sorted_front[-1]][obj] - objectives[sorted_front[0]][obj] + 1e-10)\n        return distance\n\n    objectives = [obj for _, obj in archive]\n    fronts, _ = non_dominated_sort(objectives)\n    selected_front = fronts[0] if fronts else [i for i in range(len(archive))]\n    crowding_distances = crowding_distance(selected_front, objectives)\n    selected_idx = selected_front[np.argmax(crowding_distances)]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment length and positions\n    seg_length = random.randint(2, max(2, N // 3))\n    start = random.randint(0, N - seg_length)\n    end = start + seg_length\n\n    # Extract the segment\n    segment = new_solution[start:end]\n\n    # Randomly select a new position for the segment\n    new_pos = random.randint(0, N - seg_length)\n    if new_pos > start:\n        new_pos += seg_length\n\n    # Remove the segment and insert it at the new position\n    new_solution = np.concatenate([\n        new_solution[:start],\n        new_solution[end:new_pos],\n        segment,\n        new_solution[new_pos:]\n    ])\n\n    # Step 3: Apply dynamic objective-weighted path relocation\n    def compute_weighted_cost(solution, alpha=0.5):\n        cost1 = sum(distance_matrix_1[solution[i], solution[i + 1]] for i in range(len(solution) - 1))\n        cost1 += distance_matrix_1[solution[-1], solution[0]]\n        cost2 = sum(distance_matrix_2[solution[i], solution[i + 1]] for i in range(len(solution) - 1))\n        cost2 += distance_matrix_2[solution[-1], solution[0]]\n        return alpha * cost1 + (1 - alpha) * cost2\n\n    alpha = random.random()\n    current_cost = compute_weighted_cost(new_solution, alpha)\n\n    # Try to improve by relocating a random path\n    for _ in range(10):\n        i = random.randint(0, N - 1)\n        j = random.randint(0, N - 1)\n        if i == j:\n            continue\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n        temp_cost = compute_weighted_cost(temp_solution, alpha)\n\n        if temp_cost < current_cost:\n            new_solution = temp_solution\n            current_cost = temp_cost\n\n    return new_solution\n\n",
        "score": [
            -0.8644327121566597,
            3.0134140849113464
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution from the archive based on non-dominated sorting and crowding distance\n    def non_dominated_sort(objectives):\n        fronts = [[]]\n        S = [[] for _ in range(len(objectives))]\n        n = [0] * len(objectives)\n        rank = [0] * len(objectives)\n\n        for p in range(len(objectives)):\n            S[p] = []\n            n[p] = 0\n            for q in range(len(objectives)):\n                if objectives[p][0] < objectives[q][0] and objectives[p][1] < objectives[q][1]:\n                    if q not in S[p]:\n                        S[p].append(q)\n                elif objectives[q][0] < objectives[p][0] and objectives[q][1] < objectives[p][1]:\n                    n[p] += 1\n            if n[p] == 0:\n                rank[p] = 0\n                if p not in fronts[0]:\n                    fronts[0].append(p)\n\n        i = 0\n        while fronts[i]:\n            Q = []\n            for p in fronts[i]:\n                for q in S[p]:\n                    n[q] -= 1\n                    if n[q] == 0:\n                        rank[q] = i + 1\n                        if q not in Q:\n                            Q.append(q)\n            i += 1\n            fronts.append(Q)\n\n        del fronts[-1]\n        return fronts, rank\n\n    def crowding_distance(front, objectives):\n        distance = [0] * len(front)\n        for obj in range(2):\n            sorted_front = sorted(front, key=lambda x: objectives[x][obj])\n            distance[0] = distance[-1] = float('inf')\n            for i in range(1, len(front) - 1):\n                distance[i] += (objectives[sorted_front[i + 1]][obj] - objectives[sorted_front[i - 1]][obj]) / (objectives[sorted_front[-1]][obj] - objectives[sorted_front[0]][obj] + 1e-10)\n        return distance\n\n    objectives = [obj for _, obj in archive]\n    fronts, _ = non_dominated_sort(objectives)\n    selected_front = fronts[0] if fronts else [i for i in range(len(archive))]\n    crowding_distances = crowding_distance(selected_front, objectives)\n    selected_idx = selected_front[np.argmax(crowding_distances)]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment length and positions\n    seg_length = random.randint(2, max(2, N // 3))\n    start = random.randint(0, N - seg_length)\n    end = start + seg_length\n\n    # Extract the segment\n    segment = new_solution[start:end]\n\n    # Randomly select a new position for the segment\n    new_pos = random.randint(0, N - seg_length)\n    if new_pos > start:\n        new_pos += seg_length\n\n    # Remove the segment and insert it at the new position\n    new_solution = np.concatenate([\n        new_solution[:start],\n        new_solution[end:new_pos],\n        segment,\n        new_solution[new_pos:]\n    ])\n\n    # Step 3: Apply dynamic objective-weighted path relocation\n    def compute_weighted_cost(solution, alpha=0.5):\n        cost1 = sum(distance_matrix_1[solution[i], solution[i + 1]] for i in range(len(solution) - 1))\n        cost1 += distance_matrix_1[solution[-1], solution[0]]\n        cost2 = sum(distance_matrix_2[solution[i], solution[i + 1]] for i in range(len(solution) - 1))\n        cost2 += distance_matrix_2[solution[-1], solution[0]]\n        return alpha * cost1 + (1 - alpha) * cost2\n\n    alpha = random.random()\n    current_cost = compute_weighted_cost(new_solution, alpha)\n\n    # Try to improve by relocating a random path\n    for _ in range(10):\n        i = random.randint(0, N - 1)\n        j = random.randint(0, N - 1)\n        if i == j:\n            continue\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n        temp_cost = compute_weighted_cost(temp_solution, alpha)\n\n        if temp_cost < current_cost:\n            new_solution = temp_solution\n            current_cost = temp_cost\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 247,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on Pareto dominance and diversity, then applies a combination of edge insertion and segment reversal to explore high-quality regions of the search space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Prioritize non-dominated solutions\n        dominated = np.zeros(len(archive), dtype=bool)\n        for i in range(len(archive)):\n            for j in range(len(archive)):\n                if i != j and archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1] and (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                    dominated[i] = True\n                    break\n        non_dominated_indices = np.where(~dominated)[0]\n        if len(non_dominated_indices) > 0:\n            selected_idx = np.random.choice(non_dominated_indices)\n        else:\n            selected_idx = np.random.randint(len(archive))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal + edge insertion\n    n = len(new_solution)\n    if n > 3:\n        # Select a random segment to reverse\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Select a random edge to insert elsewhere\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8458878248065475,
            1.113240897655487
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Prioritize non-dominated solutions\n        dominated = np.zeros(len(archive), dtype=bool)\n        for i in range(len(archive)):\n            for j in range(len(archive)):\n                if i != j and archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1] and (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                    dominated[i] = True\n                    break\n        non_dominated_indices = np.where(~dominated)[0]\n        if len(non_dominated_indices) > 0:\n            selected_idx = np.random.choice(non_dominated_indices)\n        else:\n            selected_idx = np.random.randint(len(archive))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal + edge insertion\n    n = len(new_solution)\n    if n > 3:\n        # Select a random segment to reverse\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Select a random edge to insert elsewhere\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 248,
        "algorithm": "{A novel hybrid local search operator combines a multi-segment 2-opt with a node insertion heuristic, where segments are dynamically selected based on their contribution to Pareto dominance, and node insertions are guided by both distance matrices to balance objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Multi-segment 2-opt with guided node insertion\n    n = len(base_solution)\n    if n < 4:\n        # Simple swap if too small\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Step 1: Select segments with high improvement potential\n    segment_length = max(2, n // 5)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = base_solution[start:end]\n\n    # Step 2: Evaluate segment quality using both distance matrices\n    segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n    segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n    # Step 3: Reverse the segment if it improves at least one objective\n    reversed_segment = segment[::-1]\n    reversed_cost1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n    reversed_cost2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n    if (reversed_cost1 < segment_cost1) or (reversed_cost2 < segment_cost2):\n        new_solution[start:end] = reversed_segment\n\n    # Step 4: Guided node insertion\n    candidate_nodes = [node for node in base_solution if node not in segment]\n    if not candidate_nodes:\n        return new_solution\n\n    # Select a node to reinsert with balanced objectives\n    node = np.random.choice(candidate_nodes)\n    pos = np.random.randint(0, n)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility by removing duplicates\n    unique_nodes, counts = np.unique(new_solution, return_counts=True)\n    for node in unique_nodes[counts > 1]:\n        indices = np.where(new_solution == node)[0]\n        for i in indices[1:]:\n            new_solution[i] = -1\n    new_solution = new_solution[new_solution != -1]\n\n    return new_solution\n\n",
        "score": [
            -0.8001931094349457,
            3.1135576963424683
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Multi-segment 2-opt with guided node insertion\n    n = len(base_solution)\n    if n < 4:\n        # Simple swap if too small\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Step 1: Select segments with high improvement potential\n    segment_length = max(2, n // 5)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = base_solution[start:end]\n\n    # Step 2: Evaluate segment quality using both distance matrices\n    segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n    segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n    # Step 3: Reverse the segment if it improves at least one objective\n    reversed_segment = segment[::-1]\n    reversed_cost1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n    reversed_cost2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n    if (reversed_cost1 < segment_cost1) or (reversed_cost2 < segment_cost2):\n        new_solution[start:end] = reversed_segment\n\n    # Step 4: Guided node insertion\n    candidate_nodes = [node for node in base_solution if node not in segment]\n    if not candidate_nodes:\n        return new_solution\n\n    # Select a node to reinsert with balanced objectives\n    node = np.random.choice(candidate_nodes)\n    pos = np.random.randint(0, n)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility by removing duplicates\n    unique_nodes, counts = np.unique(new_solution, return_counts=True)\n    for node in unique_nodes[counts > 1]:\n        indices = np.where(new_solution == node)[0]\n        for i in indices[1:]:\n            new_solution[i] = -1\n    new_solution = new_solution[new_solution != -1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 249,
        "algorithm": "{The algorithm selects a diverse solution from the archive with high potential for improvement by combining a crowding distance metric with objective dominance, then applies a hybrid local search that combines a novel edge-swap strategy with a randomized segment reversal to escape local optima while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with high potential for improvement\n    # Calculate crowding distance for each solution\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    for i in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i])\n\n    # Select solution with highest crowding distance (diverse and potentially improvable)\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel edge-swap strategy\n    for _ in range(2):  # Perform 2 edge swaps\n        i, j = np.random.choice(n, 2, replace=False)\n        if abs(i - j) > 1:  # Ensure non-adjacent edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Randomized segment reversal\n    if np.random.rand() < 0.5:  # 50% chance to apply\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.679211618730622,
            2.1156176328659058
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with high potential for improvement\n    # Calculate crowding distance for each solution\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    for i in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i])\n\n    # Select solution with highest crowding distance (diverse and potentially improvable)\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel edge-swap strategy\n    for _ in range(2):  # Perform 2 edge swaps\n        i, j = np.random.choice(n, 2, replace=False)\n        if abs(i - j) > 1:  # Ensure non-adjacent edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Randomized segment reversal\n    if np.random.rand() < 0.5:  # 50% chance to apply\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 250,
        "algorithm": "{The heuristic function selects a promising solution from the archive based on a weighted combination of objective values, then applies a hybrid local search operator combining edge exchange and segment relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (could be based on Pareto front or other criteria)\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search: combine edge exchange and segment relocation\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Ensure segments are of reasonable size\n    segment_size = min(3, (b - a + 1) // 2, (d - c + 1) // 2)\n    if segment_size < 1:\n        segment_size = 1\n\n    # Extract segments\n    segment1 = new_solution[a:a+segment_size]\n    segment2 = new_solution[c:c+segment_size]\n\n    # Swap segments\n    new_solution[a:a+segment_size] = segment2\n    new_solution[c:c+segment_size] = segment1\n\n    # Ensure the solution remains a valid tour\n    # Check for duplicates and fix if necessary\n    unique, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique[counts > 1]\n    for dup in duplicates:\n        # Find all occurrences of the duplicate\n        indices = np.where(new_solution == dup)[0]\n        for i in range(1, len(indices)):\n            # Replace with a missing node\n            missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n            if len(missing_nodes) > 0:\n                new_solution[indices[i]] = missing_nodes[0]\n\n    return new_solution\n\n",
        "score": [
            -0.9049307037015162,
            2.7469048500061035
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (could be based on Pareto front or other criteria)\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search: combine edge exchange and segment relocation\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Ensure segments are of reasonable size\n    segment_size = min(3, (b - a + 1) // 2, (d - c + 1) // 2)\n    if segment_size < 1:\n        segment_size = 1\n\n    # Extract segments\n    segment1 = new_solution[a:a+segment_size]\n    segment2 = new_solution[c:c+segment_size]\n\n    # Swap segments\n    new_solution[a:a+segment_size] = segment2\n    new_solution[c:c+segment_size] = segment1\n\n    # Ensure the solution remains a valid tour\n    # Check for duplicates and fix if necessary\n    unique, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique[counts > 1]\n    for dup in duplicates:\n        # Find all occurrences of the duplicate\n        indices = np.where(new_solution == dup)[0]\n        for i in range(1, len(indices)):\n            # Replace with a missing node\n            missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n            if len(missing_nodes) > 0:\n                new_solution[indices[i]] = missing_nodes[0]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 251,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a solution from the archive based on Pareto dominance and non-dominated sorting, then applies a combination of edge insertion and segment reversal with adaptive neighborhood exploration to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with promising potential (non-dominated or with high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Edge insertion + adaptive segment reversal\n    N = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Step 1: Edge insertion\n    i, j = sorted(random.sample(range(N), 2))\n    if j - i > 1:\n        segment = new_solution[i+1:j]\n        new_solution = np.concatenate([new_solution[:i+1], segment[::-1], new_solution[j:]])\n\n    # Step 2: Adaptive segment reversal\n    segment_size = min(4, N // 4)  # Adaptive segment size\n    start = random.randint(0, N - segment_size)\n    new_solution[start:start+segment_size] = new_solution[start:start+segment_size][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    assert len(np.unique(new_solution)) == N, \"Generated solution is invalid.\"\n\n    return new_solution\n\n",
        "score": [
            -0.8059954301362542,
            1.429137647151947
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with promising potential (non-dominated or with high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Edge insertion + adaptive segment reversal\n    N = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Step 1: Edge insertion\n    i, j = sorted(random.sample(range(N), 2))\n    if j - i > 1:\n        segment = new_solution[i+1:j]\n        new_solution = np.concatenate([new_solution[:i+1], segment[::-1], new_solution[j:]])\n\n    # Step 2: Adaptive segment reversal\n    segment_size = min(4, N // 4)  # Adaptive segment size\n    start = random.randint(0, N - segment_size)\n    new_solution[start:start+segment_size] = new_solution[start:start+segment_size][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    assert len(np.unique(new_solution)) == N, \"Generated solution is invalid.\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 252,
        "algorithm": "{The algorithm intelligently selects a solution from the archive with high potential for local improvement, then applies a hybrid local search operator combining edge insertion and segment reversal to explore the solution space more effectively while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal and edge insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a segment to reverse\n        start = np.random.randint(0, n - 3)\n        end = np.random.randint(start + 2, n - 1)\n        segment = new_solution[start:end+1]\n        new_solution[start:end+1] = segment[::-1]\n\n        # Insert a random node at a new position\n        node = np.random.choice(new_solution)\n        idx = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(0, n)\n        if new_pos != idx:\n            new_solution = np.delete(new_solution, idx)\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8153182988416905,
            1.7428495287895203
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal and edge insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a segment to reverse\n        start = np.random.randint(0, n - 3)\n        end = np.random.randint(start + 2, n - 1)\n        segment = new_solution[start:end+1]\n        new_solution[start:end+1] = segment[::-1]\n\n        # Insert a random node at a new position\n        node = np.random.choice(new_solution)\n        idx = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(0, n)\n        if new_pos != idx:\n            new_solution = np.delete(new_solution, idx)\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 253,
        "algorithm": "{A novel adaptive multi-objective local search operator dynamically combines 3-opt and Or-opt moves, guided by Pareto dominance and objective-space diversity, to explore high-quality regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = random.choice(archive)\n    current_solution, (cost1, cost2) = selected\n    new_solution = current_solution.copy()\n\n    # Adaptive local search: combine 3-opt and Or-opt with probability based on solution quality\n    if random.random() < 0.7:  # Higher probability for 3-opt in promising regions\n        # 3-opt move (select 3 random edges and reconnect)\n        a, b, c = sorted(random.sample(range(len(new_solution)), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution[a:c] = np.concatenate([segment2, segment1])\n    else:\n        # Or-opt move (relocate a random segment of 2-4 nodes)\n        l = random.randint(2, 4)\n        pos = random.randint(0, len(new_solution) - l)\n        segment = new_solution[pos:pos+l]\n        new_solution = np.concatenate([new_solution[:pos], new_solution[pos+l:]])\n        insert_pos = random.randint(0, len(new_solution) - l)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to 2-opt if feasibility is violated\n        a, b = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8274353788903255,
            1.927040934562683
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = random.choice(archive)\n    current_solution, (cost1, cost2) = selected\n    new_solution = current_solution.copy()\n\n    # Adaptive local search: combine 3-opt and Or-opt with probability based on solution quality\n    if random.random() < 0.7:  # Higher probability for 3-opt in promising regions\n        # 3-opt move (select 3 random edges and reconnect)\n        a, b, c = sorted(random.sample(range(len(new_solution)), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution[a:c] = np.concatenate([segment2, segment1])\n    else:\n        # Or-opt move (relocate a random segment of 2-4 nodes)\n        l = random.randint(2, 4)\n        pos = random.randint(0, len(new_solution) - l)\n        segment = new_solution[pos:pos+l]\n        new_solution = np.concatenate([new_solution[:pos], new_solution[pos+l:]])\n        insert_pos = random.randint(0, len(new_solution) - l)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to 2-opt if feasibility is violated\n        a, b = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 254,
        "algorithm": "{A novel heuristic function that selects a promising solution from the archive based on dominance and diversity, then applies a hybrid local search combining edge insertion and segment reversal to explore non-dominated regions while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., dominated solutions)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Edge Insertion + Segment Reversal\n    N = len(new_solution)\n\n    # Edge Insertion: Randomly select two edges and reconnect\n    a, b, c, d = np.random.choice(N, size=4, replace=False)\n    i, j = min(a, b), max(a, b)\n    k, l = min(c, d), max(c, d)\n\n    if i < k:\n        # Insert segment [i+1, k] after j\n        segment = new_solution[i+1:k+1]\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[k+1:j+1], segment, new_solution[j+1:]])\n    else:\n        # Insert segment [k+1, i] after l\n        segment = new_solution[k+1:i+1]\n        new_solution = np.concatenate([new_solution[:k+1], new_solution[i+1:l+1], segment, new_solution[l+1:]])\n\n    # Segment Reversal: Randomly reverse a segment\n    start, end = np.random.choice(N, size=2, replace=False)\n    start, end = min(start, end), max(start, end)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        # Fallback to a simple swap if invalid\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8710323155149775,
            1.4698072671890259
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., dominated solutions)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Edge Insertion + Segment Reversal\n    N = len(new_solution)\n\n    # Edge Insertion: Randomly select two edges and reconnect\n    a, b, c, d = np.random.choice(N, size=4, replace=False)\n    i, j = min(a, b), max(a, b)\n    k, l = min(c, d), max(c, d)\n\n    if i < k:\n        # Insert segment [i+1, k] after j\n        segment = new_solution[i+1:k+1]\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[k+1:j+1], segment, new_solution[j+1:]])\n    else:\n        # Insert segment [k+1, i] after l\n        segment = new_solution[k+1:i+1]\n        new_solution = np.concatenate([new_solution[:k+1], new_solution[i+1:l+1], segment, new_solution[l+1:]])\n\n    # Segment Reversal: Randomly reverse a segment\n    start, end = np.random.choice(N, size=2, replace=False)\n    start, end = min(start, end), max(start, end)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        # Fallback to a simple swap if invalid\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 255,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on dominance and diversity, then applies a hybrid local search combining edge insertion with a novel segment reversal operator to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on dominance and diversity\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n\n    # Insert the reversed segment at a different position\n    new_solution = np.concatenate([new_solution[:a], reversed_segment, new_solution[b+1:]])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if segment reversal causes duplicates\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7602087628696456,
            2.2481406331062317
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on dominance and diversity\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n\n    # Insert the reversed segment at a different position\n    new_solution = np.concatenate([new_solution[:a], reversed_segment, new_solution[b+1:]])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if segment reversal causes duplicates\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 256,
        "algorithm": "{A novel hybrid local search operator combines edge insertion with a dynamic neighborhood exploration strategy, guided by Pareto dominance and objective-space diversity, to generate high-quality neighbors by intelligently reinserting segments of the tour while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution based on objective diversity\n    def objective_diversity(solution, obj):\n        return obj[0] + obj[1]  # Simple sum for diversity\n\n    archive_with_diversity = [(s, o, objective_diversity(s, o)) for s, o in archive]\n    archive_with_diversity.sort(key=lambda x: x[2], reverse=True)\n    selected = archive_with_diversity[0][0].copy()\n\n    # Hybrid local search: Dynamic segment insertion with edge swapping\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reinsert\n    segment_start = random.randint(0, n - 2)\n    segment_end = random.randint(segment_start + 1, min(segment_start + 3, n - 1))  # Small segment for diversity\n    segment = new_solution[segment_start:segment_end + 1]\n\n    # Remove the segment\n    new_solution = np.concatenate([new_solution[:segment_start], new_solution[segment_end + 1:]])\n\n    # Reinsert the segment at a new position\n    insert_pos = random.randint(0, n - len(segment) - 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Edge swapping to improve objectives\n    for _ in range(3):  # Limit swaps for efficiency\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        # Check if swapping improves at least one objective\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8851207189648758,
            2.224055767059326
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution based on objective diversity\n    def objective_diversity(solution, obj):\n        return obj[0] + obj[1]  # Simple sum for diversity\n\n    archive_with_diversity = [(s, o, objective_diversity(s, o)) for s, o in archive]\n    archive_with_diversity.sort(key=lambda x: x[2], reverse=True)\n    selected = archive_with_diversity[0][0].copy()\n\n    # Hybrid local search: Dynamic segment insertion with edge swapping\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reinsert\n    segment_start = random.randint(0, n - 2)\n    segment_end = random.randint(segment_start + 1, min(segment_start + 3, n - 1))  # Small segment for diversity\n    segment = new_solution[segment_start:segment_end + 1]\n\n    # Remove the segment\n    new_solution = np.concatenate([new_solution[:segment_start], new_solution[segment_end + 1:]])\n\n    # Reinsert the segment at a new position\n    insert_pos = random.randint(0, n - len(segment) - 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Edge swapping to improve objectives\n    for _ in range(3):  # Limit swaps for efficiency\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        # Check if swapping improves at least one objective\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 257,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel path relinking strategy\n    n = len(base_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt to the selected segment\n    segment = base_solution[i:j+1]\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    # Path relinking: blend with another solution's segment\n    other_idx = np.random.choice([x for x in range(len(archive)) if x != selected_idx])\n    other_solution = archive[other_idx][0]\n    l, m = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[l:m+1] = other_solution[l:m+1]\n\n    # Ensure feasibility by fixing any duplicates\n    unique, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique[counts > 1]\n    for dup in duplicates:\n        missing = np.setdiff1d(np.arange(n), new_solution)\n        if len(missing) > 0:\n            replace_idx = np.where(new_solution == dup)[0][1]\n            new_solution[replace_idx] = missing[0]\n\n    return new_solution\n\n",
        "score": [
            -0.6697510029441238,
            3.995799422264099
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel path relinking strategy\n    n = len(base_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt to the selected segment\n    segment = base_solution[i:j+1]\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    # Path relinking: blend with another solution's segment\n    other_idx = np.random.choice([x for x in range(len(archive)) if x != selected_idx])\n    other_solution = archive[other_idx][0]\n    l, m = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[l:m+1] = other_solution[l:m+1]\n\n    # Ensure feasibility by fixing any duplicates\n    unique, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique[counts > 1]\n    for dup in duplicates:\n        missing = np.setdiff1d(np.arange(n), new_solution)\n        if len(missing) > 0:\n            replace_idx = np.where(new_solution == dup)[0][1]\n            new_solution[replace_idx] = missing[0]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 258,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search operator that combines edge insertion with a novel node-sequence relocation strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected = archive[0][0].copy()\n    for sol, _ in archive:\n        if np.random.rand() < 0.3:  # 30% chance to pick a random solution to encourage diversity\n            selected = sol.copy()\n            break\n\n    new_solution = selected.copy()\n\n    # Hybrid local search: edge insertion + node-sequence relocation\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Edge insertion (remove a random edge and reinsert it)\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i == j:\n        j = (j + 1) % n\n\n    # Remove edge between i and (i+1)\n    a, b = new_solution[i], new_solution[(i+1)%n]\n    # Remove edge between j and (j+1)\n    c, d = new_solution[j], new_solution[(j+1)%n]\n\n    # Reinsert a and b between j and (j+1)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([new_solution[:(j+1)%n], [a, b], new_solution[(j+1)%n:]])\n    else:\n        new_solution = np.concatenate([new_solution[:(j+1)%n], [b, a], new_solution[(j+1)%n:]])\n\n    # Step 2: Node-sequence relocation (move a sequence of nodes to a new position)\n    k = random.randint(2, min(4, n//2))  # Sequence length between 2 and 4\n    start = random.randint(0, n - k - 1)\n    sequence = new_solution[start:start + k]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start + k:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], sequence, new_solution[insert_pos:]])\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or not np.all(counts == 1):\n        # Fallback: revert to original if invalid\n        return selected\n\n    return new_solution\n\n",
        "score": [
            -0.832253702364191,
            3.9022212624549866
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected = archive[0][0].copy()\n    for sol, _ in archive:\n        if np.random.rand() < 0.3:  # 30% chance to pick a random solution to encourage diversity\n            selected = sol.copy()\n            break\n\n    new_solution = selected.copy()\n\n    # Hybrid local search: edge insertion + node-sequence relocation\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Edge insertion (remove a random edge and reinsert it)\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i == j:\n        j = (j + 1) % n\n\n    # Remove edge between i and (i+1)\n    a, b = new_solution[i], new_solution[(i+1)%n]\n    # Remove edge between j and (j+1)\n    c, d = new_solution[j], new_solution[(j+1)%n]\n\n    # Reinsert a and b between j and (j+1)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([new_solution[:(j+1)%n], [a, b], new_solution[(j+1)%n:]])\n    else:\n        new_solution = np.concatenate([new_solution[:(j+1)%n], [b, a], new_solution[(j+1)%n:]])\n\n    # Step 2: Node-sequence relocation (move a sequence of nodes to a new position)\n    k = random.randint(2, min(4, n//2))  # Sequence length between 2 and 4\n    start = random.randint(0, n - k - 1)\n    sequence = new_solution[start:start + k]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start + k:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], sequence, new_solution[insert_pos:]])\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or not np.all(counts == 1):\n        # Fallback: revert to original if invalid\n        return selected\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 259,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        # Normalize objectives for diversity selection\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        diversity_scores = np.linalg.norm(normalized - normalized.mean(axis=0), axis=1)\n        selected_idx = np.argmax(diversity_scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Adaptive Segment Relinking with Edge Insertion\n    n = len(new_solution)\n    # Select a random segment length between 3 and n//2\n    segment_length = random.randint(3, max(3, n // 2))\n    # Select a random starting position for the segment\n    start_pos = random.randint(0, n - segment_length)\n\n    # Extract the segment\n    segment = new_solution[start_pos:start_pos + segment_length]\n\n    # Remove the segment from the solution\n    remaining = np.concatenate([new_solution[:start_pos], new_solution[start_pos + segment_length:]])\n\n    # Insert the segment back at a new position with edge insertion heuristic\n    best_insert_pos = 0\n    best_insert_cost = float('inf')\n\n    # Evaluate insertion positions\n    for i in range(len(remaining) + 1):\n        # Insert segment at position i\n        candidate = np.concatenate([remaining[:i], segment, remaining[i:]])\n\n        # Calculate total cost in both objective spaces\n        cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n))\n        cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n))\n\n        # Use a weighted sum of costs as the evaluation metric\n        weight = random.random()  # Random weight to balance objectives\n        total_cost = weight * cost1 + (1 - weight) * cost2\n\n        if total_cost < best_insert_cost:\n            best_insert_cost = total_cost\n            best_insert_pos = i\n\n    # Insert the segment at the best position\n    new_solution = np.concatenate([remaining[:best_insert_pos], segment, remaining[best_insert_pos:]])\n\n    # Additional perturbation: Reverse a random segment to escape local optima\n    if random.random() < 0.3:  # 30% chance to reverse\n        rev_start = random.randint(0, n - 2)\n        rev_end = random.randint(rev_start + 1, n - 1)\n        new_solution[rev_start:rev_end + 1] = new_solution[rev_start:rev_end + 1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.44702857143675234,
            9.520353496074677
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        # Normalize objectives for diversity selection\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        diversity_scores = np.linalg.norm(normalized - normalized.mean(axis=0), axis=1)\n        selected_idx = np.argmax(diversity_scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Adaptive Segment Relinking with Edge Insertion\n    n = len(new_solution)\n    # Select a random segment length between 3 and n//2\n    segment_length = random.randint(3, max(3, n // 2))\n    # Select a random starting position for the segment\n    start_pos = random.randint(0, n - segment_length)\n\n    # Extract the segment\n    segment = new_solution[start_pos:start_pos + segment_length]\n\n    # Remove the segment from the solution\n    remaining = np.concatenate([new_solution[:start_pos], new_solution[start_pos + segment_length:]])\n\n    # Insert the segment back at a new position with edge insertion heuristic\n    best_insert_pos = 0\n    best_insert_cost = float('inf')\n\n    # Evaluate insertion positions\n    for i in range(len(remaining) + 1):\n        # Insert segment at position i\n        candidate = np.concatenate([remaining[:i], segment, remaining[i:]])\n\n        # Calculate total cost in both objective spaces\n        cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n))\n        cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n))\n\n        # Use a weighted sum of costs as the evaluation metric\n        weight = random.random()  # Random weight to balance objectives\n        total_cost = weight * cost1 + (1 - weight) * cost2\n\n        if total_cost < best_insert_cost:\n            best_insert_cost = total_cost\n            best_insert_pos = i\n\n    # Insert the segment at the best position\n    new_solution = np.concatenate([remaining[:best_insert_pos], segment, remaining[best_insert_pos:]])\n\n    # Additional perturbation: Reverse a random segment to escape local optima\n    if random.random() < 0.3:  # 30% chance to reverse\n        rev_start = random.randint(0, n - 2)\n        rev_end = random.randint(rev_start + 1, n - 1)\n        new_solution[rev_start:rev_end + 1] = new_solution[rev_start:rev_end + 1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 260,
        "algorithm": "{A novel hybrid local search operator combines a randomized edge-swap strategy with a multi-objective-aware segment inversion to explore the solution space, balancing exploration and exploitation by dynamically adjusting the search focus based on the relative improvement potential of each objective.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by the sum of normalized objectives (higher sum indicates more potential)\n        archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1], reverse=True)\n        # Select top 30% of solutions\n        top_solutions = archive_sorted[:max(1, int(0.3 * len(archive)))]\n        # Randomly select from top solutions\n        selected = random.choice(top_solutions)[0].copy()\n    else:\n        selected = archive[0][0].copy()\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if random.random() < 0.7:  # 70% chance for edge-swap strategy\n        # Select two non-adjacent edges to swap\n        i = random.randint(0, n-4)\n        j = random.randint(i+2, n-2)\n        # Swap edges (i,i+1) and (j,j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n    else:  # 30% chance for multi-objective segment inversion\n        # Select a segment to invert based on objective improvement potential\n        segment_size = min(5, n // 3)\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        # Calculate potential improvement for both objectives\n        def calculate_improvement(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            return cost1, cost2\n\n        original_cost1, original_cost2 = calculate_improvement(new_solution)\n        inverted_segment = new_solution[start:end][::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[start:end] = inverted_segment\n        new_cost1, new_cost2 = calculate_improvement(temp_solution)\n\n        # Accept if at least one objective improves\n        if new_cost1 < original_cost1 or new_cost2 < original_cost2:\n            new_solution[start:end] = inverted_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9831684074910731,
            1.56109219789505
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by the sum of normalized objectives (higher sum indicates more potential)\n        archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1], reverse=True)\n        # Select top 30% of solutions\n        top_solutions = archive_sorted[:max(1, int(0.3 * len(archive)))]\n        # Randomly select from top solutions\n        selected = random.choice(top_solutions)[0].copy()\n    else:\n        selected = archive[0][0].copy()\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if random.random() < 0.7:  # 70% chance for edge-swap strategy\n        # Select two non-adjacent edges to swap\n        i = random.randint(0, n-4)\n        j = random.randint(i+2, n-2)\n        # Swap edges (i,i+1) and (j,j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n    else:  # 30% chance for multi-objective segment inversion\n        # Select a segment to invert based on objective improvement potential\n        segment_size = min(5, n // 3)\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        # Calculate potential improvement for both objectives\n        def calculate_improvement(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            return cost1, cost2\n\n        original_cost1, original_cost2 = calculate_improvement(new_solution)\n        inverted_segment = new_solution[start:end][::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[start:end] = inverted_segment\n        new_cost1, new_cost2 = calculate_improvement(temp_solution)\n\n        # Accept if at least one objective improves\n        if new_cost1 < original_cost1 or new_cost2 < original_cost2:\n            new_solution[start:end] = inverted_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 261,
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Edge insertion + segment reversal\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to reverse\n    i = np.random.randint(0, n)\n    j = np.random.randint(i, n)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly insert a node elsewhere\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8308141094213491,
            1.7639894485473633
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Edge insertion + segment reversal\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to reverse\n    i = np.random.randint(0, n)\n    j = np.random.randint(i, n)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly insert a node elsewhere\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 262,
        "algorithm": "{The algorithm selects a promising solution from the archive using a dominance-based heuristic, then applies a hybrid local search combining edge exchange and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    combined_costs = [sum(obj) for _, obj in archive]\n    best_idx = np.argmin(combined_costs)\n    base_solution = archive[best_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Hybrid operator: Edge exchange + Node insertion\n    # Randomly select two distinct edges to exchange\n    i, j = np.random.choice(n_nodes, size=2, replace=False)\n    k, l = np.random.choice(n_nodes, size=2, replace=False)\n\n    # Ensure i < j and k < l for simplicity\n    if i > j:\n        i, j = j, i\n    if k > l:\n        k, l = l, k\n\n    # Perform edge exchange\n    if i < k < j < l:\n        # Case 1: Non-overlapping edges\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n    else:\n        # Case 2: Overlapping edges (use node insertion for more complex changes)\n        # Randomly select a node and insert it elsewhere\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        insert_pos = np.random.randint(0, len(new_solution) + 1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    assert len(new_solution) == n_nodes and len(np.unique(new_solution)) == n_nodes\n\n    return new_solution\n\n",
        "score": [
            -0.7727027262136368,
            2.0192610025405884
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    combined_costs = [sum(obj) for _, obj in archive]\n    best_idx = np.argmin(combined_costs)\n    base_solution = archive[best_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Hybrid operator: Edge exchange + Node insertion\n    # Randomly select two distinct edges to exchange\n    i, j = np.random.choice(n_nodes, size=2, replace=False)\n    k, l = np.random.choice(n_nodes, size=2, replace=False)\n\n    # Ensure i < j and k < l for simplicity\n    if i > j:\n        i, j = j, i\n    if k > l:\n        k, l = l, k\n\n    # Perform edge exchange\n    if i < k < j < l:\n        # Case 1: Non-overlapping edges\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n    else:\n        # Case 2: Overlapping edges (use node insertion for more complex changes)\n        # Randomly select a node and insert it elsewhere\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        insert_pos = np.random.randint(0, len(new_solution) + 1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    assert len(new_solution) == n_nodes and len(np.unique(new_solution)) == n_nodes\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 263,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining edge insertion and node relocation with a probabilistic acceptance criterion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = objectives / (objectives.sum(axis=0) + 1e-10)\n    weights = 1 - normalized.mean(axis=1)  # Prefer solutions with better combined objectives\n    weights = weights / weights.sum()\n    base_solution = random.choices(archive, weights=weights, k=1)[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge insertion and node relocation\n    for _ in range(2):  # Number of perturbations\n        # Randomly select two distinct edges to modify\n        i, j = sorted(random.sample(range(1, n), 2))\n        k, l = sorted(random.sample(range(1, n), 2))\n\n        # Edge insertion: insert node at j after node at l\n        if i != l and j != k:\n            new_solution = np.concatenate([\n                new_solution[:i],\n                new_solution[i:j],\n                new_solution[j:l+1],\n                new_solution[i:j],\n                new_solution[l+1:]\n            ])\n            # Ensure no duplicates and all nodes are visited\n            unique_nodes = np.unique(new_solution)\n            if len(unique_nodes) == n:\n                # Accept if the change improves both objectives or with some probability\n                if (random.random() < 0.3 or\n                    (np.sum(distance_matrix_1[new_solution[:-1], new_solution[1:]]) < np.sum(distance_matrix_1[base_solution[:-1], base_solution[1:]]) and\n                     np.sum(distance_matrix_2[new_solution[:-1], new_solution[1:]]) < np.sum(distance_matrix_2[base_solution[:-1], base_solution[1:]]))):\n                    base_solution = new_solution.copy()\n                else:\n                    new_solution = base_solution.copy()\n            else:\n                new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6534229127052043,
            3.3537164330482483
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = objectives / (objectives.sum(axis=0) + 1e-10)\n    weights = 1 - normalized.mean(axis=1)  # Prefer solutions with better combined objectives\n    weights = weights / weights.sum()\n    base_solution = random.choices(archive, weights=weights, k=1)[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge insertion and node relocation\n    for _ in range(2):  # Number of perturbations\n        # Randomly select two distinct edges to modify\n        i, j = sorted(random.sample(range(1, n), 2))\n        k, l = sorted(random.sample(range(1, n), 2))\n\n        # Edge insertion: insert node at j after node at l\n        if i != l and j != k:\n            new_solution = np.concatenate([\n                new_solution[:i],\n                new_solution[i:j],\n                new_solution[j:l+1],\n                new_solution[i:j],\n                new_solution[l+1:]\n            ])\n            # Ensure no duplicates and all nodes are visited\n            unique_nodes = np.unique(new_solution)\n            if len(unique_nodes) == n:\n                # Accept if the change improves both objectives or with some probability\n                if (random.random() < 0.3 or\n                    (np.sum(distance_matrix_1[new_solution[:-1], new_solution[1:]]) < np.sum(distance_matrix_1[base_solution[:-1], base_solution[1:]]) and\n                     np.sum(distance_matrix_2[new_solution[:-1], new_solution[1:]]) < np.sum(distance_matrix_2[base_solution[:-1], base_solution[1:]]))):\n                    base_solution = new_solution.copy()\n                else:\n                    new_solution = base_solution.copy()\n            else:\n                new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 264,
        "algorithm": "{This algorithm selects a solution from the archive using a weighted random selection based on normalized objective values, then applies a hybrid local search combining edge exchange and segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with weighted randomness based on normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    weights = 1 / (1 + normalized.sum(axis=1))\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: edge exchange + segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge exchange\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment inversion with probability\n    if random.random() < 0.5:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility (no duplicates and all nodes present)\n    if len(set(new_solution)) != n:\n        # Fallback to simple swap if inversion causes duplicates\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8821378235180994,
            2.7687289714813232
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with weighted randomness based on normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    weights = 1 / (1 + normalized.sum(axis=1))\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: edge exchange + segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge exchange\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment inversion with probability\n    if random.random() < 0.5:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility (no duplicates and all nodes present)\n    if len(set(new_solution)) != n:\n        # Fallback to simple swap if inversion causes duplicates\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 265,
        "algorithm": "{This algorithm selects a promising solution from the archive based on a combination of non-dominated sorting and crowding distance to prioritize solutions with high potential for improvement, then applies a hybrid local search operator combining edge exchange with path relinking to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Use non-dominated sorting and crowding distance to prioritize solutions\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Non-dominated sorting\n    fronts = []\n    dominated_count = np.zeros(len(solutions))\n    dominates_set = [[] for _ in range(len(solutions))]\n\n    for i in range(len(solutions)):\n        for j in range(len(solutions)):\n            if i == j:\n                continue\n            if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] < objectives[j, 1]) or \\\n               (objectives[i, 0] < objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]):\n                dominates_set[i].append(j)\n            elif (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] < objectives[i, 1]) or \\\n                 (objectives[j, 0] < objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]):\n                dominated_count[i] += 1\n\n    current_front = []\n    for i in range(len(solutions)):\n        if dominated_count[i] == 0:\n            current_front.append(i)\n\n    fronts.append(current_front)\n    while len(current_front) > 0:\n        next_front = []\n        for i in current_front:\n            for j in dominates_set[i]:\n                dominated_count[j] -= 1\n                if dominated_count[j] == 0:\n                    next_front.append(j)\n        current_front = next_front\n        if len(current_front) > 0:\n            fronts.append(current_front)\n\n    # Select the best front and then the most crowded solution\n    selected_idx = 0\n    for front in fronts:\n        if len(front) == 1:\n            selected_idx = front[0]\n            break\n        # Calculate crowding distance for the front\n        crowding_dist = np.zeros(len(front))\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[front, m])\n            crowding_dist[sorted_idx[0]] = np.inf\n            crowding_dist[sorted_idx[-1]] = np.inf\n            for i in range(1, len(front)-1):\n                crowding_dist[sorted_idx[i]] += (objectives[front[sorted_idx[i+1]], m] - objectives[front[sorted_idx[i-1]], m]) / (objectives[front[sorted_idx[-1]], m] - objectives[front[sorted_idx[0]], m])\n\n        selected_idx = front[np.argmax(crowding_dist)]\n        break\n\n    base_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: Edge exchange with path relinking\n    # First, perform a random edge exchange\n    i, j = np.random.choice(n, 2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Then, perform path relinking with a random solution from the archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0]\n        # Find common edges and difference\n        base_edges = set(zip(base_solution, np.roll(base_solution, -1)))\n        other_edges = set(zip(other_solution, np.roll(other_solution, -1)))\n        common_edges = base_edges & other_edges\n\n        # Apply path relinking by flipping edges\n        for edge in common_edges:\n            if edge in base_edges and edge in other_edges:\n                continue\n            # Find positions in new_solution\n            idx1 = np.where(new_solution == edge[0])[0][0]\n            idx2 = np.where(new_solution == edge[1])[0][0]\n            if (idx2 - idx1) % n == 1 or (idx1 - idx2) % n == 1:\n                # Consecutive, flip to introduce new edge\n                new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    return new_solution\n\n",
        "score": [
            -0.7177602269364152,
            6.629664063453674
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Use non-dominated sorting and crowding distance to prioritize solutions\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Non-dominated sorting\n    fronts = []\n    dominated_count = np.zeros(len(solutions))\n    dominates_set = [[] for _ in range(len(solutions))]\n\n    for i in range(len(solutions)):\n        for j in range(len(solutions)):\n            if i == j:\n                continue\n            if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] < objectives[j, 1]) or \\\n               (objectives[i, 0] < objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]):\n                dominates_set[i].append(j)\n            elif (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] < objectives[i, 1]) or \\\n                 (objectives[j, 0] < objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]):\n                dominated_count[i] += 1\n\n    current_front = []\n    for i in range(len(solutions)):\n        if dominated_count[i] == 0:\n            current_front.append(i)\n\n    fronts.append(current_front)\n    while len(current_front) > 0:\n        next_front = []\n        for i in current_front:\n            for j in dominates_set[i]:\n                dominated_count[j] -= 1\n                if dominated_count[j] == 0:\n                    next_front.append(j)\n        current_front = next_front\n        if len(current_front) > 0:\n            fronts.append(current_front)\n\n    # Select the best front and then the most crowded solution\n    selected_idx = 0\n    for front in fronts:\n        if len(front) == 1:\n            selected_idx = front[0]\n            break\n        # Calculate crowding distance for the front\n        crowding_dist = np.zeros(len(front))\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[front, m])\n            crowding_dist[sorted_idx[0]] = np.inf\n            crowding_dist[sorted_idx[-1]] = np.inf\n            for i in range(1, len(front)-1):\n                crowding_dist[sorted_idx[i]] += (objectives[front[sorted_idx[i+1]], m] - objectives[front[sorted_idx[i-1]], m]) / (objectives[front[sorted_idx[-1]], m] - objectives[front[sorted_idx[0]], m])\n\n        selected_idx = front[np.argmax(crowding_dist)]\n        break\n\n    base_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: Edge exchange with path relinking\n    # First, perform a random edge exchange\n    i, j = np.random.choice(n, 2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Then, perform path relinking with a random solution from the archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.choice(len(archive))][0]\n        # Find common edges and difference\n        base_edges = set(zip(base_solution, np.roll(base_solution, -1)))\n        other_edges = set(zip(other_solution, np.roll(other_solution, -1)))\n        common_edges = base_edges & other_edges\n\n        # Apply path relinking by flipping edges\n        for edge in common_edges:\n            if edge in base_edges and edge in other_edges:\n                continue\n            # Find positions in new_solution\n            idx1 = np.where(new_solution == edge[0])[0][0]\n            idx2 = np.where(new_solution == edge[1])[0][0]\n            if (idx2 - idx1) % n == 1 or (idx1 - idx2) % n == 1:\n                # Consecutive, flip to introduce new edge\n                new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 266,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0]\n    new_solution = best_solution.copy()\n\n    # Hybrid 3-opt and edge insertion\n    n = len(new_solution)\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # 3-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Edge insertion: randomly select a segment and insert it elsewhere\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing_nodes])\n\n    return new_solution\n\n",
        "score": [
            -0.8063923116327886,
            2.5499680638313293
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0]\n    new_solution = best_solution.copy()\n\n    # Hybrid 3-opt and edge insertion\n    n = len(new_solution)\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # 3-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Edge insertion: randomly select a segment and insert it elsewhere\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([new_solution, missing_nodes])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 267,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search: 3-opt with biased randomness\n    n = len(best_solution)\n    new_solution = best_solution.copy()\n\n    # Randomly select 3 distinct edges to modify\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Create a new segment by reversing the middle part\n    new_segment = np.concatenate([best_solution[a:b], best_solution[b:c][::-1]])\n\n    # Insert the new segment back into the solution\n    new_solution = np.concatenate([best_solution[:a], new_segment, best_solution[c:]])\n\n    # Ensure the solution is a valid tour (no duplicates, all nodes included)\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        # Fallback to a simple 2-opt if 3-opt fails\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution = best_solution.copy()\n        new_solution[i:j] = new_solution[i:j][::-1]\n        return new_solution\n\n",
        "score": [
            -0.7040995409637986,
            1.532874047756195
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search: 3-opt with biased randomness\n    n = len(best_solution)\n    new_solution = best_solution.copy()\n\n    # Randomly select 3 distinct edges to modify\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Create a new segment by reversing the middle part\n    new_segment = np.concatenate([best_solution[a:b], best_solution[b:c][::-1]])\n\n    # Insert the new segment back into the solution\n    new_solution = np.concatenate([best_solution[:a], new_segment, best_solution[c:]])\n\n    # Ensure the solution is a valid tour (no duplicates, all nodes included)\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        # Fallback to a simple 2-opt if 3-opt fails\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution = best_solution.copy()\n        new_solution[i:j] = new_solution[i:j][::-1]\n        return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 268,
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted random choice favoring solutions with lower total distance in both objective spaces, then applies a novel hybrid local search combining edge swaps and segment reversals to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1.0 / (1 + obj[0] + obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swap + segment reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly choose two distinct edges to swap\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Edge swap\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Segment reversal\n    k = random.randint(1, n-2)\n    l = random.randint(1, n-2)\n    if k > l:\n        k, l = l, k\n    new_solution[k:l] = np.flip(new_solution[k:l])\n\n    return new_solution\n\n",
        "score": [
            -0.9207417909592912,
            2.2136955857276917
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1.0 / (1 + obj[0] + obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swap + segment reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly choose two distinct edges to swap\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Edge swap\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Segment reversal\n    k = random.randint(1, n-2)\n    l = random.randint(1, n-2)\n    if k > l:\n        k, l = l, k\n    new_solution[k:l] = np.flip(new_solution[k:l])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 269,
        "algorithm": "{A novel hybrid local search operator combines 3-opt with a variable-length segment relocation strategy, dynamically selecting segments based on their contribution to the Pareto front and using a probabilistic acceptance criterion to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probabilistic bias towards non-dominated ones\n    weights = np.array([1.0 / (i + 1) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: variable-length segment relocation with 3-opt\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment length (2-4 nodes)\n    segment_length = random.randint(2, min(4, n // 2))\n\n    # Randomly select a starting point for the segment\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start + segment_length]\n\n    # Remove the segment\n    new_solution = np.concatenate([new_solution[:start], new_solution[start + segment_length:]])\n\n    # Find insertion points that minimize both objectives\n    best_pos = -1\n    best_cost = (float('inf'), float('inf'))\n\n    for i in range(len(new_solution) - segment_length + 1):\n        # Try inserting the segment before position i\n        candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n\n        # Calculate costs\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n        # Use weighted sum to balance objectives\n        weight = random.random()\n        total_cost = weight * cost1 + (1 - weight) * cost2\n\n        if total_cost < sum(best_cost):\n            best_cost = (cost1, cost2)\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Apply 3-opt to further improve\n    i, j, k = sorted(random.sample(range(n), 3))\n    if random.random() < 0.5:\n        # Try different 3-opt configurations\n        options = [\n            np.concatenate([new_solution[:i], new_solution[i:j][::-1], new_solution[j:k][::-1], new_solution[k:]]),\n            np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j], new_solution[k:]]),\n            np.concatenate([new_solution[:i], new_solution[j:k][::-1], new_solution[i:j], new_solution[k:]])\n        ]\n    else:\n        options = [\n            np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j][::-1], new_solution[k:]]),\n            np.concatenate([new_solution[:i], new_solution[i:j][::-1], new_solution[j:k], new_solution[k:]]),\n            np.concatenate([new_solution[:i], new_solution[j:k][::-1], new_solution[i:j], new_solution[k:]])\n        ]\n\n    # Evaluate all options and keep the best\n    best_option = new_solution\n    best_cost = (float('inf'), float('inf'))\n\n    for option in options:\n        cost1 = sum(distance_matrix_1[option[i], option[i+1]] for i in range(n-1)) + distance_matrix_1[option[-1], option[0]]\n        cost2 = sum(distance_matrix_2[option[i], option[i+1]] for i in range(n-1)) + distance_matrix_2[option[-1], option[0]]\n\n        weight = random.random()\n        total_cost = weight * cost1 + (1 - weight) * cost2\n\n        if total_cost < sum(best_cost):\n            best_cost = (cost1, cost2)\n            best_option = option\n\n    return best_option\n\n",
        "score": [
            -0.7975931638143543,
            12.883319556713104
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probabilistic bias towards non-dominated ones\n    weights = np.array([1.0 / (i + 1) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: variable-length segment relocation with 3-opt\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment length (2-4 nodes)\n    segment_length = random.randint(2, min(4, n // 2))\n\n    # Randomly select a starting point for the segment\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start + segment_length]\n\n    # Remove the segment\n    new_solution = np.concatenate([new_solution[:start], new_solution[start + segment_length:]])\n\n    # Find insertion points that minimize both objectives\n    best_pos = -1\n    best_cost = (float('inf'), float('inf'))\n\n    for i in range(len(new_solution) - segment_length + 1):\n        # Try inserting the segment before position i\n        candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n\n        # Calculate costs\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n        # Use weighted sum to balance objectives\n        weight = random.random()\n        total_cost = weight * cost1 + (1 - weight) * cost2\n\n        if total_cost < sum(best_cost):\n            best_cost = (cost1, cost2)\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Apply 3-opt to further improve\n    i, j, k = sorted(random.sample(range(n), 3))\n    if random.random() < 0.5:\n        # Try different 3-opt configurations\n        options = [\n            np.concatenate([new_solution[:i], new_solution[i:j][::-1], new_solution[j:k][::-1], new_solution[k:]]),\n            np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j], new_solution[k:]]),\n            np.concatenate([new_solution[:i], new_solution[j:k][::-1], new_solution[i:j], new_solution[k:]])\n        ]\n    else:\n        options = [\n            np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j][::-1], new_solution[k:]]),\n            np.concatenate([new_solution[:i], new_solution[i:j][::-1], new_solution[j:k], new_solution[k:]]),\n            np.concatenate([new_solution[:i], new_solution[j:k][::-1], new_solution[i:j], new_solution[k:]])\n        ]\n\n    # Evaluate all options and keep the best\n    best_option = new_solution\n    best_cost = (float('inf'), float('inf'))\n\n    for option in options:\n        cost1 = sum(distance_matrix_1[option[i], option[i+1]] for i in range(n-1)) + distance_matrix_1[option[-1], option[0]]\n        cost2 = sum(distance_matrix_2[option[i], option[i+1]] for i in range(n-1)) + distance_matrix_2[option[-1], option[0]]\n\n        weight = random.random()\n        total_cost = weight * cost1 + (1 - weight) * cost2\n\n        if total_cost < sum(best_cost):\n            best_cost = (cost1, cost2)\n            best_option = option\n\n    return best_option\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 270,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive based on dominance and diversity, then applies a hybrid local search combining edge insertion with adaptive segment swapping to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive segment swapping with edge insertion\n    n = len(new_solution)\n    segment_length = max(3, min(10, n // 4))\n\n    # Randomly select a segment to swap\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = new_solution[start:end]\n\n    # Find the best insertion point for the segment\n    best_insert_pos = -1\n    best_improvement = 0\n\n    for i in range(n - segment_length + 1):\n        if i == start:\n            continue  # Skip the original position\n\n        # Calculate the change in both objectives\n        delta_obj1 = 0\n        delta_obj2 = 0\n\n        # Remove the segment\n        if i < start:\n            # Segment is moved left\n            prev_node = new_solution[i - 1] if i > 0 else new_solution[-1]\n            next_node = new_solution[start] if start < n - 1 else new_solution[0]\n            delta_obj1 -= distance_matrix_1[prev_node, new_solution[start]]\n            delta_obj1 += distance_matrix_1[prev_node, next_node]\n            delta_obj2 -= distance_matrix_2[prev_node, new_solution[start]]\n            delta_obj2 += distance_matrix_2[prev_node, next_node]\n\n            # Add the segment\n            prev_node = new_solution[i + segment_length - 1]\n            next_node = new_solution[i + segment_length] if i + segment_length < n else new_solution[0]\n            delta_obj1 -= distance_matrix_1[prev_node, next_node]\n            delta_obj1 += distance_matrix_1[prev_node, segment[0]]\n            for j in range(1, len(segment)):\n                delta_obj1 += distance_matrix_1[segment[j-1], segment[j]]\n            delta_obj1 += distance_matrix_1[segment[-1], next_node]\n\n            delta_obj2 -= distance_matrix_2[prev_node, next_node]\n            delta_obj2 += distance_matrix_2[prev_node, segment[0]]\n            for j in range(1, len(segment)):\n                delta_obj2 += distance_matrix_2[segment[j-1], segment[j]]\n            delta_obj2 += distance_matrix_2[segment[-1], next_node]\n        else:\n            # Segment is moved right\n            prev_node = new_solution[start - 1] if start > 0 else new_solution[-1]\n            next_node = new_solution[end] if end < n else new_solution[0]\n            delta_obj1 -= distance_matrix_1[prev_node, new_solution[start]]\n            delta_obj1 += distance_matrix_1[prev_node, next_node]\n            delta_obj2 -= distance_matrix_2[prev_node, new_solution[start]]\n            delta_obj2 += distance_matrix_2[prev_node, next_node]\n\n            # Add the segment\n            prev_node = new_solution[i - 1] if i > 0 else new_solution[-1]\n            next_node = new_solution[i] if i < n else new_solution[0]\n            delta_obj1 -= distance_matrix_1[prev_node, next_node]\n            delta_obj1 += distance_matrix_1[prev_node, segment[0]]\n            for j in range(1, len(segment)):\n                delta_obj1 += distance_matrix_1[segment[j-1], segment[j]]\n            delta_obj1 += distance_matrix_1[segment[-1], next_node]\n\n            delta_obj2 -= distance_matrix_2[prev_node, next_node]\n            delta_obj2 += distance_matrix_2[prev_node, segment[0]]\n            for j in range(1, len(segment)):\n                delta_obj2 += distance_matrix_2[segment[j-1], segment[j]]\n            delta_obj2 += distance_matrix_2[segment[-1], next_node]\n\n        # Combine both objectives with equal weight\n        total_improvement = delta_obj1 + delta_obj2\n\n        if total_improvement < best_improvement:\n            best_improvement = total_improvement\n            best_insert_pos = i\n\n    if best_insert_pos != -1:\n        # Apply the best move\n        if best_insert_pos < start:\n            # Move segment left\n            new_solution = np.concatenate([\n                new_solution[:best_insert_pos],\n                segment,\n                new_solution[best_insert_pos:start],\n                new_solution[end:]\n            ])\n        else:\n            # Move segment right\n            new_solution = np.concatenate([\n                new_solution[:start],\n                new_solution[end:best_insert_pos],\n                segment,\n                new_solution[best_insert_pos:]\n            ])\n\n    # Additional edge insertion for fine-tuning\n    for _ in range(2):\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) <= 1:\n            continue\n\n        # Calculate the change in both objectives\n        delta_obj1 = (\n            -distance_matrix_1[new_solution[i-1], new_solution[i]]\n            -distance_matrix_1[new_solution[j-1], new_solution[j]]\n            +distance_matrix_1[new_solution[i-1], new_solution[j-1]]\n            +distance_matrix_1[new_solution[i], new_solution[j]]\n        )\n\n        delta_obj2 = (\n            -distance_matrix_2[new_solution[i-1], new_solution[i]]\n            -distance_matrix_2[new_solution[j-1], new_solution[j]]\n            +distance_matrix_2[new_solution[i-1], new_solution[j-1]]\n            +distance_matrix_2[new_solution[i], new_solution[j]]\n        )\n\n        if delta_obj1 + delta_obj2 < 0:\n            # Apply the edge swap\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n            else:\n                new_solution[j:i] = new_solution[j:i][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7188560397678085,
            4.120917737483978
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive segment swapping with edge insertion\n    n = len(new_solution)\n    segment_length = max(3, min(10, n // 4))\n\n    # Randomly select a segment to swap\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = new_solution[start:end]\n\n    # Find the best insertion point for the segment\n    best_insert_pos = -1\n    best_improvement = 0\n\n    for i in range(n - segment_length + 1):\n        if i == start:\n            continue  # Skip the original position\n\n        # Calculate the change in both objectives\n        delta_obj1 = 0\n        delta_obj2 = 0\n\n        # Remove the segment\n        if i < start:\n            # Segment is moved left\n            prev_node = new_solution[i - 1] if i > 0 else new_solution[-1]\n            next_node = new_solution[start] if start < n - 1 else new_solution[0]\n            delta_obj1 -= distance_matrix_1[prev_node, new_solution[start]]\n            delta_obj1 += distance_matrix_1[prev_node, next_node]\n            delta_obj2 -= distance_matrix_2[prev_node, new_solution[start]]\n            delta_obj2 += distance_matrix_2[prev_node, next_node]\n\n            # Add the segment\n            prev_node = new_solution[i + segment_length - 1]\n            next_node = new_solution[i + segment_length] if i + segment_length < n else new_solution[0]\n            delta_obj1 -= distance_matrix_1[prev_node, next_node]\n            delta_obj1 += distance_matrix_1[prev_node, segment[0]]\n            for j in range(1, len(segment)):\n                delta_obj1 += distance_matrix_1[segment[j-1], segment[j]]\n            delta_obj1 += distance_matrix_1[segment[-1], next_node]\n\n            delta_obj2 -= distance_matrix_2[prev_node, next_node]\n            delta_obj2 += distance_matrix_2[prev_node, segment[0]]\n            for j in range(1, len(segment)):\n                delta_obj2 += distance_matrix_2[segment[j-1], segment[j]]\n            delta_obj2 += distance_matrix_2[segment[-1], next_node]\n        else:\n            # Segment is moved right\n            prev_node = new_solution[start - 1] if start > 0 else new_solution[-1]\n            next_node = new_solution[end] if end < n else new_solution[0]\n            delta_obj1 -= distance_matrix_1[prev_node, new_solution[start]]\n            delta_obj1 += distance_matrix_1[prev_node, next_node]\n            delta_obj2 -= distance_matrix_2[prev_node, new_solution[start]]\n            delta_obj2 += distance_matrix_2[prev_node, next_node]\n\n            # Add the segment\n            prev_node = new_solution[i - 1] if i > 0 else new_solution[-1]\n            next_node = new_solution[i] if i < n else new_solution[0]\n            delta_obj1 -= distance_matrix_1[prev_node, next_node]\n            delta_obj1 += distance_matrix_1[prev_node, segment[0]]\n            for j in range(1, len(segment)):\n                delta_obj1 += distance_matrix_1[segment[j-1], segment[j]]\n            delta_obj1 += distance_matrix_1[segment[-1], next_node]\n\n            delta_obj2 -= distance_matrix_2[prev_node, next_node]\n            delta_obj2 += distance_matrix_2[prev_node, segment[0]]\n            for j in range(1, len(segment)):\n                delta_obj2 += distance_matrix_2[segment[j-1], segment[j]]\n            delta_obj2 += distance_matrix_2[segment[-1], next_node]\n\n        # Combine both objectives with equal weight\n        total_improvement = delta_obj1 + delta_obj2\n\n        if total_improvement < best_improvement:\n            best_improvement = total_improvement\n            best_insert_pos = i\n\n    if best_insert_pos != -1:\n        # Apply the best move\n        if best_insert_pos < start:\n            # Move segment left\n            new_solution = np.concatenate([\n                new_solution[:best_insert_pos],\n                segment,\n                new_solution[best_insert_pos:start],\n                new_solution[end:]\n            ])\n        else:\n            # Move segment right\n            new_solution = np.concatenate([\n                new_solution[:start],\n                new_solution[end:best_insert_pos],\n                segment,\n                new_solution[best_insert_pos:]\n            ])\n\n    # Additional edge insertion for fine-tuning\n    for _ in range(2):\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) <= 1:\n            continue\n\n        # Calculate the change in both objectives\n        delta_obj1 = (\n            -distance_matrix_1[new_solution[i-1], new_solution[i]]\n            -distance_matrix_1[new_solution[j-1], new_solution[j]]\n            +distance_matrix_1[new_solution[i-1], new_solution[j-1]]\n            +distance_matrix_1[new_solution[i], new_solution[j]]\n        )\n\n        delta_obj2 = (\n            -distance_matrix_2[new_solution[i-1], new_solution[i]]\n            -distance_matrix_2[new_solution[j-1], new_solution[j]]\n            +distance_matrix_2[new_solution[i-1], new_solution[j-1]]\n            +distance_matrix_2[new_solution[i], new_solution[j]]\n        )\n\n        if delta_obj1 + delta_obj2 < 0:\n            # Apply the edge swap\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n            else:\n                new_solution[j:i] = new_solution[j:i][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 271,
        "algorithm": "{A hybrid local search operator that combines a novel edge-recombination strategy with adaptive neighborhood exploration, guided by Pareto dominance and objective-space diversity, to generate high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto front solutions)\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Hybrid local search: Edge recombination with adaptive neighborhood\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge recombination - select a subset of edges and rebuild the tour\n    edge_set = set()\n    for i in range(n):\n        u, v = new_solution[i], new_solution[(i + 1) % n]\n        edge_set.add((min(u, v), max(u, v)))\n\n    # Step 2: Adaptive neighborhood exploration - modify the tour based on edge diversity\n    for _ in range(2):  # Perform multiple small perturbations\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Check if the edge exists in the original solution\n        if (i, j) in edge_set:\n            continue  # Skip if edge is part of the original structure\n\n        # Perform a 3-opt move to ensure feasibility\n        if j - i > 2:\n            k = np.random.randint(i + 1, j)\n            new_solution[i:j] = np.concatenate([new_solution[i:k], new_solution[k:j][::-1]])\n\n    return new_solution\n\n",
        "score": [
            -0.9573441590754067,
            1.9198067784309387
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto front solutions)\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Hybrid local search: Edge recombination with adaptive neighborhood\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge recombination - select a subset of edges and rebuild the tour\n    edge_set = set()\n    for i in range(n):\n        u, v = new_solution[i], new_solution[(i + 1) % n]\n        edge_set.add((min(u, v), max(u, v)))\n\n    # Step 2: Adaptive neighborhood exploration - modify the tour based on edge diversity\n    for _ in range(2):  # Perform multiple small perturbations\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Check if the edge exists in the original solution\n        if (i, j) in edge_set:\n            continue  # Skip if edge is part of the original structure\n\n        # Perform a 3-opt move to ensure feasibility\n        if j - i > 2:\n            k = np.random.randint(i + 1, j)\n            new_solution[i:j] = np.concatenate([new_solution[i:k], new_solution[k:j][::-1]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 272,
        "algorithm": "{The algorithm selects a promising solution from the archive using a hybrid local search strategy that combines a biased random selection based on objective values with a novel edge-swap operator that considers both objective spaces, ensuring feasibility by preserving the tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    weights = 1 / (1 + normalized_obj.sum(axis=1))\n    weights /= weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: edge-swap with multi-objective consideration\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to swap (avoiding adjacent edges to ensure diversity)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while abs(i - j) <= 1:\n        j = np.random.randint(0, n)\n\n    # Perform the swap\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility: check if the swap creates a valid tour\n    if not np.all(np.unique(new_solution) == np.arange(n)):\n        # If invalid, revert to a simple 2-opt move as fallback\n        i, j = sorted([i, j])\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7364433757143456,
            2.4119566082954407
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    weights = 1 / (1 + normalized_obj.sum(axis=1))\n    weights /= weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: edge-swap with multi-objective consideration\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to swap (avoiding adjacent edges to ensure diversity)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while abs(i - j) <= 1:\n        j = np.random.randint(0, n)\n\n    # Perform the swap\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility: check if the swap creates a valid tour\n    if not np.all(np.unique(new_solution) == np.arange(n)):\n        # If invalid, revert to a simple 2-opt move as fallback\n        i, j = sorted([i, j])\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 273,
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on a weighted combination of objectives\n    weights = np.random.uniform(0.3, 0.7, size=len(archive))\n    objectives = np.array([obj for _, obj in archive])\n    scores = np.sum(weights[:, np.newaxis] * objectives, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n\n    # Apply edge insertion with segment reversal\n    if b - a > 1:\n        # Reverse the segment with probability 0.5\n        if np.random.rand() < 0.5:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        else:\n            # Insert the segment elsewhere\n            c = np.random.randint(0, n)\n            segment = new_solution[a:b+1]\n            new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n    else:\n        # Standard swap for small segments\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7181703132809296,
            1.7797994017601013
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on a weighted combination of objectives\n    weights = np.random.uniform(0.3, 0.7, size=len(archive))\n    objectives = np.array([obj for _, obj in archive])\n    scores = np.sum(weights[:, np.newaxis] * objectives, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n\n    # Apply edge insertion with segment reversal\n    if b - a > 1:\n        # Reverse the segment with probability 0.5\n        if np.random.rand() < 0.5:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        else:\n            # Insert the segment elsewhere\n            c = np.random.randint(0, n)\n            segment = new_solution[a:b+1]\n            new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n    else:\n        # Standard swap for small segments\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 274,
        "algorithm": "{A hybrid local search operator that intelligently combines edge-swapping with a novel multi-objective path relinking mechanism to explore diverse neighborhoods while balancing the two objectives, selecting solutions with high potential for improvement based on both objective values and structural diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return instance[:, 0].astype(int)  # Return a default tour if archive is empty\n    sorted_solutions = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_solution = random.choice(sorted_solutions[:max(1, len(sorted_solutions) // 2)])[0].copy()\n\n    # Hybrid local search: combine edge-swapping with multi-objective path relinking\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Random edge-swapping (like 2-opt but more flexible)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Multi-objective path relinking (select edges from another solution)\n    if len(archive) > 1:\n        other_solution = random.choice([s for s in archive if not np.array_equal(s[0], selected_solution)])[0]\n        # Identify common edges between solutions\n        selected_edges = set(zip(selected_solution, np.roll(selected_solution, -1)))\n        other_edges = set(zip(other_solution, np.roll(other_solution, -1)))\n        common_edges = selected_edges & other_edges\n\n        # If common edges exist, try to preserve them\n        if common_edges:\n            edge = random.choice(list(common_edges))\n            # Ensure the edge is not already present in the new solution\n            if edge not in zip(new_solution, np.roll(new_solution, -1)):\n                # Find positions to insert the edge\n                a, b = edge\n                pos_a = np.where(new_solution == a)[0][0]\n                pos_b = np.where(new_solution == b)[0][0]\n                if abs(pos_a - pos_b) > 1:\n                    # Reverse the segment between a and b to insert the edge\n                    start, end = sorted([pos_a, pos_b])\n                    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure the solution is valid (no duplicates and visits all nodes)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution: duplicate nodes\"\n    assert set(new_solution) == set(selected_solution), \"Invalid solution: missing nodes\"\n\n    return new_solution\n\n",
        "score": [
            -0.9796656893324451,
            3.3085691332817078
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return instance[:, 0].astype(int)  # Return a default tour if archive is empty\n    sorted_solutions = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_solution = random.choice(sorted_solutions[:max(1, len(sorted_solutions) // 2)])[0].copy()\n\n    # Hybrid local search: combine edge-swapping with multi-objective path relinking\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Random edge-swapping (like 2-opt but more flexible)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Multi-objective path relinking (select edges from another solution)\n    if len(archive) > 1:\n        other_solution = random.choice([s for s in archive if not np.array_equal(s[0], selected_solution)])[0]\n        # Identify common edges between solutions\n        selected_edges = set(zip(selected_solution, np.roll(selected_solution, -1)))\n        other_edges = set(zip(other_solution, np.roll(other_solution, -1)))\n        common_edges = selected_edges & other_edges\n\n        # If common edges exist, try to preserve them\n        if common_edges:\n            edge = random.choice(list(common_edges))\n            # Ensure the edge is not already present in the new solution\n            if edge not in zip(new_solution, np.roll(new_solution, -1)):\n                # Find positions to insert the edge\n                a, b = edge\n                pos_a = np.where(new_solution == a)[0][0]\n                pos_b = np.where(new_solution == b)[0][0]\n                if abs(pos_a - pos_b) > 1:\n                    # Reverse the segment between a and b to insert the edge\n                    start, end = sorted([pos_a, pos_b])\n                    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure the solution is valid (no duplicates and visits all nodes)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution: duplicate nodes\"\n    assert set(new_solution) == set(selected_solution), \"Invalid solution: missing nodes\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 275,
        "algorithm": "{A novel local search heuristic that combines adaptive segment reversal with multi-objective aware swaps to explore diverse neighborhoods while balancing the two objectives, ensuring feasibility through intelligent node selection and validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(1, 0.1, len(archive)) / np.linspace(1, 0.1, len(archive)).sum())\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive segment reversal + multi-objective aware swaps\n    n = len(new_solution)\n    segment_size = max(2, min(5, int(np.sqrt(n))))  # Adaptive segment size\n\n    # Phase 1: Segment reversal with multi-objective awareness\n    for _ in range(3):  # Number of attempts\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[i:j+1]\n\n        # Evaluate segment reversal in both objectives\n        original_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)) + sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        original_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)) + sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        reversed_segment = segment[::-1]\n        temp_solution = np.concatenate([new_solution[:i], reversed_segment, new_solution[j+1:]])\n        new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n)) + sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n)) + sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n        # Accept if both objectives improve or one improves significantly\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or \\\n           (new_cost1 < original_cost1 * 0.95 or new_cost2 < original_cost2 * 0.95):\n            new_solution = temp_solution\n\n    # Phase 2: Multi-objective aware swaps\n    for _ in range(2):\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        # Try swapping nodes a and b\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n        new_cost1 = distance_matrix_1[temp_solution[a-1], temp_solution[a]] + distance_matrix_1[temp_solution[b-1], temp_solution[b]]\n        new_cost2 = distance_matrix_2[temp_solution[a-1], temp_solution[a]] + distance_matrix_2[temp_solution[b-1], temp_solution[b]]\n\n        # Accept if both objectives improve or one improves significantly\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or \\\n           (new_cost1 < original_cost1 * 0.95 or new_cost2 < original_cost2 * 0.95):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.9051026201071051,
            3.8895865082740784
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(1, 0.1, len(archive)) / np.linspace(1, 0.1, len(archive)).sum())\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive segment reversal + multi-objective aware swaps\n    n = len(new_solution)\n    segment_size = max(2, min(5, int(np.sqrt(n))))  # Adaptive segment size\n\n    # Phase 1: Segment reversal with multi-objective awareness\n    for _ in range(3):  # Number of attempts\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[i:j+1]\n\n        # Evaluate segment reversal in both objectives\n        original_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)) + sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        original_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)) + sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        reversed_segment = segment[::-1]\n        temp_solution = np.concatenate([new_solution[:i], reversed_segment, new_solution[j+1:]])\n        new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n)) + sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n)) + sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n        # Accept if both objectives improve or one improves significantly\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or \\\n           (new_cost1 < original_cost1 * 0.95 or new_cost2 < original_cost2 * 0.95):\n            new_solution = temp_solution\n\n    # Phase 2: Multi-objective aware swaps\n    for _ in range(2):\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        # Try swapping nodes a and b\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n        new_cost1 = distance_matrix_1[temp_solution[a-1], temp_solution[a]] + distance_matrix_1[temp_solution[b-1], temp_solution[b]]\n        new_cost2 = distance_matrix_2[temp_solution[a-1], temp_solution[a]] + distance_matrix_2[temp_solution[b-1], temp_solution[b]]\n\n        # Accept if both objectives improve or one improves significantly\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or \\\n           (new_cost1 < original_cost1 * 0.95 or new_cost2 < original_cost2 * 0.95):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 276,
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: segment relocation combined with edge insertion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to relocate\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Randomly select a new position for the segment\n    c = np.random.randint(0, n - (b - a))\n    if c >= a:\n        c += (b - a + 1)\n\n    # Relocate the segment\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Apply edge insertion to further improve the solution\n    for _ in range(2):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        if j - i > 1:\n            # Remove edge (i, i+1) and (j, j+1), insert (i, j) and (i+1, j+1)\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[j:j+1], new_solution[i+1:j], new_solution[i:i+1], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8991751895205587,
            0.33300071954727173
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: segment relocation combined with edge insertion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to relocate\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Randomly select a new position for the segment\n    c = np.random.randint(0, n - (b - a))\n    if c >= a:\n        c += (b - a + 1)\n\n    # Relocate the segment\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Apply edge insertion to further improve the solution\n    for _ in range(2):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        if j - i > 1:\n            # Remove edge (i, i+1) and (j, j+1), insert (i, j) and (i+1, j+1)\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[j:j+1], new_solution[i+1:j], new_solution[i:i+1], new_solution[j+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 277,
        "algorithm": "{A novel hybrid local search operator combines a randomized segment inversion with an adaptive edge swapping mechanism, prioritizing solutions with high potential for improvement by selecting those with the highest objective values and applying the operator to the most critical segments of the tour.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Random segment inversion followed by adaptive edge swapping\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Random segment inversion\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j+1]\n    new_solution[i:j+1] = segment[::-1]\n\n    # Step 2: Adaptive edge swapping\n    # Identify the most critical edges (highest distance in either objective)\n    critical_edges = []\n    for k in range(n):\n        u, v = new_solution[k], new_solution[(k+1)%n]\n        dist1 = distance_matrix_1[u, v]\n        dist2 = distance_matrix_2[u, v]\n        if dist1 > np.mean(distance_matrix_1) or dist2 > np.mean(distance_matrix_2):\n            critical_edges.append(k)\n\n    if critical_edges:\n        # Swap two random critical edges\n        a, b = random.sample(critical_edges, 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9063404499701668,
            3.4276223182678223
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Random segment inversion followed by adaptive edge swapping\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Random segment inversion\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j+1]\n    new_solution[i:j+1] = segment[::-1]\n\n    # Step 2: Adaptive edge swapping\n    # Identify the most critical edges (highest distance in either objective)\n    critical_edges = []\n    for k in range(n):\n        u, v = new_solution[k], new_solution[(k+1)%n]\n        dist1 = distance_matrix_1[u, v]\n        dist2 = distance_matrix_2[u, v]\n        if dist1 > np.mean(distance_matrix_1) or dist2 > np.mean(distance_matrix_2):\n            critical_edges.append(k)\n\n    if critical_edges:\n        # Swap two random critical edges\n        a, b = random.sample(critical_edges, 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 278,
        "algorithm": "{This heuristic selects a solution from the archive based on the highest sum of normalized objectives, then applies a hybrid local search combining edge insertion with a novel segment-based perturbation to generate a neighbor solution while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    if objectives.shape[0] > 1:\n        normalized = (objectives - objectives.mean(axis=0)) / (objectives.std(axis=0) + 1e-8)\n        scores = normalized.sum(axis=1)\n        selected_idx = np.argmax(scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment-based perturbation with edge insertion\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a random segment to perturb\n        segment_size = max(2, min(4, n // 3))\n        start = np.random.randint(0, n - segment_size + 1)\n        segment = new_solution[start:start+segment_size]\n\n        # Remove the segment and insert it elsewhere\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_size:]])\n        insert_pos = np.random.randint(0, len(new_solution) - segment_size + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Further improve with edge insertion\n        for _ in range(2):\n            i, j = np.random.choice(n, 2, replace=False)\n            if i < j:\n                new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.9008128192141095,
            2.169119656085968
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    if objectives.shape[0] > 1:\n        normalized = (objectives - objectives.mean(axis=0)) / (objectives.std(axis=0) + 1e-8)\n        scores = normalized.sum(axis=1)\n        selected_idx = np.argmax(scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment-based perturbation with edge insertion\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a random segment to perturb\n        segment_size = max(2, min(4, n // 3))\n        start = np.random.randint(0, n - segment_size + 1)\n        segment = new_solution[start:start+segment_size]\n\n        # Remove the segment and insert it elsewhere\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_size:]])\n        insert_pos = np.random.randint(0, len(new_solution) - segment_size + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Further improve with edge insertion\n        for _ in range(2):\n            i, j = np.random.choice(n, 2, replace=False)\n            if i < j:\n                new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 279,
        "algorithm": "{A hybrid local search operator that combines a novel edge-swap strategy with a biased random selection of solutions from the archive, prioritizing those with diverse or high-quality edges, to generate improved neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = None\n    max_diversity = -1\n    for sol, (cost1, cost2) in archive:\n        diversity = abs(cost1 - cost2)\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: combine edge-swap with biased random selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to perturb\n    segment_start = random.randint(0, n - 3)\n    segment_length = random.randint(2, min(5, n - segment_start - 1))\n\n    # Reverse the segment (similar to 3-opt but more flexible)\n    segment = new_solution[segment_start:segment_start + segment_length]\n    new_solution[segment_start:segment_start + segment_length] = segment[::-1]\n\n    # Randomly swap two edges to introduce diversity\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.42160461366676905,
            2.221987307071686
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = None\n    max_diversity = -1\n    for sol, (cost1, cost2) in archive:\n        diversity = abs(cost1 - cost2)\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: combine edge-swap with biased random selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to perturb\n    segment_start = random.randint(0, n - 3)\n    segment_length = random.randint(2, min(5, n - segment_start - 1))\n\n    # Reverse the segment (similar to 3-opt but more flexible)\n    segment = new_solution[segment_start:segment_start + segment_length]\n    new_solution[segment_start:segment_start + segment_length] = segment[::-1]\n\n    # Randomly swap two edges to introduce diversity\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 280,
        "algorithm": "{The algorithm selects a solution from the archive based on a combination of non-dominated sorting and crowding distance to prioritize solutions with high potential for improvement, then applies a hybrid local search operator combining edge exchange and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Use non-dominated sorting to identify Pareto front\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    pareto_front = []\n\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1] and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        # If no Pareto front, select randomly\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose a random segment to reverse\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n\n    # Reverse the segment\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly swap two edges (edge exchange)\n    c = np.random.randint(0, n)\n    d = np.random.randint(0, n)\n    if c != d:\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7830695045874871,
            1.6525130867958069
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Use non-dominated sorting to identify Pareto front\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    pareto_front = []\n\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1] and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        # If no Pareto front, select randomly\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose a random segment to reverse\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n\n    # Reverse the segment\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly swap two edges (edge exchange)\n    c = np.random.randint(0, n)\n    d = np.random.randint(0, n)\n    if c != d:\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 281,
        "algorithm": "{A novel hybrid local search heuristic selects a solution from the archive based on non-dominated objectives, then applies a dynamic 3-opt with adaptive segment swapping and multi-objective aware edge selection to generate high-quality neighbors while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        base_solution = archive[0][0].copy()\n    else:\n        # Select a random non-dominated solution\n        selected_idx = np.random.randint(0, len(non_dominated))\n        base_solution = non_dominated[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: Dynamic 3-opt with adaptive segment swapping\n    for _ in range(10):  # Number of attempts\n        # Randomly select three distinct segments\n        a, b, c = sorted(np.random.choice(range(1, n-1), 3, replace=False))\n\n        # Create three possible new solutions\n        candidates = [\n            np.concatenate([new_solution[:a], new_solution[b:c], new_solution[a:b], new_solution[c:]]),\n            np.concatenate([new_solution[:a], new_solution[c:], new_solution[b:c], new_solution[a:b]]),\n            np.concatenate([new_solution[:b], new_solution[a:b], new_solution[c:], new_solution[b:c]])\n        ]\n\n        # Evaluate candidates based on both objectives\n        best_candidate = None\n        best_score = float('inf')\n\n        for candidate in candidates:\n            # Calculate total distance for both objectives\n            total_dist1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1))\n            total_dist1 += distance_matrix_1[candidate[-1], candidate[0]]  # Return to start\n\n            total_dist2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1))\n            total_dist2 += distance_matrix_2[candidate[-1], candidate[0]]  # Return to start\n\n            # Combined score with adaptive weighting\n            score = 0.5 * total_dist1 + 0.5 * total_dist2\n\n            if score < best_score:\n                best_score = score\n                best_candidate = candidate\n\n        if best_candidate is not None:\n            new_solution = best_candidate.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6786499747411017,
            7.126109778881073
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        base_solution = archive[0][0].copy()\n    else:\n        # Select a random non-dominated solution\n        selected_idx = np.random.randint(0, len(non_dominated))\n        base_solution = non_dominated[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: Dynamic 3-opt with adaptive segment swapping\n    for _ in range(10):  # Number of attempts\n        # Randomly select three distinct segments\n        a, b, c = sorted(np.random.choice(range(1, n-1), 3, replace=False))\n\n        # Create three possible new solutions\n        candidates = [\n            np.concatenate([new_solution[:a], new_solution[b:c], new_solution[a:b], new_solution[c:]]),\n            np.concatenate([new_solution[:a], new_solution[c:], new_solution[b:c], new_solution[a:b]]),\n            np.concatenate([new_solution[:b], new_solution[a:b], new_solution[c:], new_solution[b:c]])\n        ]\n\n        # Evaluate candidates based on both objectives\n        best_candidate = None\n        best_score = float('inf')\n\n        for candidate in candidates:\n            # Calculate total distance for both objectives\n            total_dist1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1))\n            total_dist1 += distance_matrix_1[candidate[-1], candidate[0]]  # Return to start\n\n            total_dist2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1))\n            total_dist2 += distance_matrix_2[candidate[-1], candidate[0]]  # Return to start\n\n            # Combined score with adaptive weighting\n            score = 0.5 * total_dist1 + 0.5 * total_dist2\n\n            if score < best_score:\n                best_score = score\n                best_candidate = candidate\n\n        if best_candidate is not None:\n            new_solution = best_candidate.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 282,
        "algorithm": "{The heuristic function selects a solution from the archive by prioritizing those with the highest potential for improvement, then applies a novel hybrid local search combining edge exchange and segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_idx = min(len(archive_sorted) // 2, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge exchange and segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge exchange (swap two edges)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment inversion (reverse a random segment)\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to basic swap if inversion causes duplicates\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7525287442909724,
            1.3624373078346252
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_idx = min(len(archive_sorted) // 2, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge exchange and segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge exchange (swap two edges)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment inversion (reverse a random segment)\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to basic swap if inversion causes duplicates\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 283,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    import numpy as np\n\n    # Select a random solution from the archive with preference to those with lower costs\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine edge exchange with segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Reverse segments (segment reversal)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Edge exchange: swap two edges if it improves both objectives\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Calculate current and new costs\n    def calculate_cost(sol, dm1, dm2):\n        cost1 = sum(dm1[sol[i], sol[(i+1)%n]] for i in range(n))\n        cost2 = sum(dm2[sol[i], sol[(i+1)%n]] for i in range(n))\n        return cost1, cost2\n\n    current_cost1, current_cost2 = calculate_cost(new_solution, distance_matrix_1, distance_matrix_2)\n\n    # Propose new solution by swapping edges\n    temp_solution = new_solution.copy()\n    temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n    temp_solution[c], temp_solution[d] = temp_solution[d], temp_solution[c]\n\n    new_cost1, new_cost2 = calculate_cost(temp_solution, distance_matrix_1, distance_matrix_2)\n\n    # Accept if both objectives improve or at least one improves\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n       (new_cost1 < current_cost1 or new_cost2 < current_cost2):\n        new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8706980666798435,
            2.1515997648239136
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    import numpy as np\n\n    # Select a random solution from the archive with preference to those with lower costs\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine edge exchange with segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Reverse segments (segment reversal)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Edge exchange: swap two edges if it improves both objectives\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Calculate current and new costs\n    def calculate_cost(sol, dm1, dm2):\n        cost1 = sum(dm1[sol[i], sol[(i+1)%n]] for i in range(n))\n        cost2 = sum(dm2[sol[i], sol[(i+1)%n]] for i in range(n))\n        return cost1, cost2\n\n    current_cost1, current_cost2 = calculate_cost(new_solution, distance_matrix_1, distance_matrix_2)\n\n    # Propose new solution by swapping edges\n    temp_solution = new_solution.copy()\n    temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n    temp_solution[c], temp_solution[d] = temp_solution[d], temp_solution[c]\n\n    new_cost1, new_cost2 = calculate_cost(temp_solution, distance_matrix_1, distance_matrix_2)\n\n    # Accept if both objectives improve or at least one improves\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n       (new_cost1 < current_cost1 or new_cost2 < current_cost2):\n        new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 284,
        "algorithm": "{This heuristic selects a solution from the archive with the highest combined objective improvement potential, then applies a hybrid local search combining edge exchange and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge exchange + segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two segments to exchange or reverse\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    k = random.randint(j + 1, n - 1)\n\n    # Choose between edge exchange or segment reversal\n    if random.random() < 0.5:\n        # Edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal\n        segment = new_solution[i:j+1]\n        new_solution[i:j+1] = segment[::-1]\n\n    # Ensure feasibility by fixing any invalid edges\n    for idx in range(n - 1):\n        if new_solution[idx] == new_solution[idx + 1]:\n            # Swap with a random node to fix duplicate\n            swap_idx = random.choice([i for i in range(n) if i != idx and i != idx + 1])\n            new_solution[idx + 1], new_solution[swap_idx] = new_solution[swap_idx], new_solution[idx + 1]\n\n    return new_solution\n\n",
        "score": [
            -0.832423809980983,
            2.1624380350112915
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge exchange + segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two segments to exchange or reverse\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    k = random.randint(j + 1, n - 1)\n\n    # Choose between edge exchange or segment reversal\n    if random.random() < 0.5:\n        # Edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal\n        segment = new_solution[i:j+1]\n        new_solution[i:j+1] = segment[::-1]\n\n    # Ensure feasibility by fixing any invalid edges\n    for idx in range(n - 1):\n        if new_solution[idx] == new_solution[idx + 1]:\n            # Swap with a random node to fix duplicate\n            swap_idx = random.choice([i for i in range(n) if i != idx and i != idx + 1])\n            new_solution[idx + 1], new_solution[swap_idx] = new_solution[swap_idx], new_solution[idx + 1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 285,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1.0 / (1.0 + obj[0] + obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive segment exchange and node relocation\n    n = len(base_solution)\n    segment_length = max(2, min(5, n // 10))  # Adaptive segment length\n\n    # Randomly select a segment to exchange or relocate\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = base_solution[start:end]\n\n    # Decide between exchange or relocation\n    if random.random() < 0.7:  # Higher probability for exchange\n        # Exchange the segment with another segment of the same length\n        other_start = random.randint(0, n - segment_length)\n        other_end = other_start + segment_length\n        other_segment = base_solution[other_start:other_end]\n\n        # Swap segments\n        new_solution[start:end] = other_segment\n        new_solution[other_start:other_end] = segment\n    else:\n        # Relocate the segment to a new position\n        new_pos = random.randint(0, n - segment_length)\n        new_solution = np.concatenate([\n            base_solution[:new_pos],\n            segment,\n            base_solution[new_pos:start],\n            base_solution[end:]\n        ])\n\n    # Ensure the solution is valid (no duplicates, all nodes present)\n    if len(set(new_solution)) != n:\n        # Fallback to swap if relocation causes duplicates\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8570212276209151,
            1.4386605024337769
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1.0 / (1.0 + obj[0] + obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive segment exchange and node relocation\n    n = len(base_solution)\n    segment_length = max(2, min(5, n // 10))  # Adaptive segment length\n\n    # Randomly select a segment to exchange or relocate\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = base_solution[start:end]\n\n    # Decide between exchange or relocation\n    if random.random() < 0.7:  # Higher probability for exchange\n        # Exchange the segment with another segment of the same length\n        other_start = random.randint(0, n - segment_length)\n        other_end = other_start + segment_length\n        other_segment = base_solution[other_start:other_end]\n\n        # Swap segments\n        new_solution[start:end] = other_segment\n        new_solution[other_start:other_end] = segment\n    else:\n        # Relocate the segment to a new position\n        new_pos = random.randint(0, n - segment_length)\n        new_solution = np.concatenate([\n            base_solution[:new_pos],\n            segment,\n            base_solution[new_pos:start],\n            base_solution[end:]\n        ])\n\n    # Ensure the solution is valid (no duplicates, all nodes present)\n    if len(set(new_solution)) != n:\n        # Fallback to swap if relocation causes duplicates\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 286,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment inversion\n    n = len(base_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment inversion to a random sub-segment\n    k, l = np.random.choice(n, size=2, replace=False)\n    if k > l:\n        k, l = l, k\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7865889326499382,
            1.867939293384552
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment inversion\n    n = len(base_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment inversion to a random sub-segment\n    k, l = np.random.choice(n, size=2, replace=False)\n    if k > l:\n        k, l = l, k\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 287,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with lower objective values, then applies a hybrid local search combining edge exchange and node insertion to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = np.array([0.5, 0.5])\n    objectives = np.array([obj for _, obj in archive])\n    scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge exchange and node insertion\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    k, l = np.random.choice(n, 2, replace=False)\n\n    # Edge exchange (2-opt-like but with two edges)\n    if i > j:\n        i, j = j, i\n    if k > l:\n        k, l = l, k\n\n    # Ensure valid exchange\n    if i < k < j < l or k < i < l < j:\n        # Perform edge exchange\n        new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n        new_solution[k:l+1] = np.flip(new_solution[k:l+1])\n    else:\n        # Perform node insertion\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7641786587477202,
            1.7215926051139832
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = np.array([0.5, 0.5])\n    objectives = np.array([obj for _, obj in archive])\n    scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge exchange and node insertion\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    k, l = np.random.choice(n, 2, replace=False)\n\n    # Edge exchange (2-opt-like but with two edges)\n    if i > j:\n        i, j = j, i\n    if k > l:\n        k, l = l, k\n\n    # Ensure valid exchange\n    if i < k < j < l or k < i < l < j:\n        # Perform edge exchange\n        new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n        new_solution[k:l+1] = np.flip(new_solution[k:l+1])\n    else:\n        # Perform node insertion\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 288,
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search operator that combines 3-opt with a novel edge-swapping strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto front solutions)\n    selected_idx = np.argmax([np.sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with edge-swapping\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(1, n), 3, replace=False))\n\n    # Apply 3-opt move\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n\n    # Reverse segments to explore different configurations\n    if np.random.rand() < 0.5:\n        segment1 = segment1[::-1]\n    if np.random.rand() < 0.5:\n        segment2 = segment2[::-1]\n\n    # Reconstruct the solution\n    new_solution = np.concatenate([new_solution[:i], segment1, segment2, new_solution[k:]])\n\n    # Edge-swapping: swap two non-adjacent edges if beneficial\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        if abs(a - b) > 1:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.972539772843827,
            4.328244626522064
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto front solutions)\n    selected_idx = np.argmax([np.sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with edge-swapping\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(1, n), 3, replace=False))\n\n    # Apply 3-opt move\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n\n    # Reverse segments to explore different configurations\n    if np.random.rand() < 0.5:\n        segment1 = segment1[::-1]\n    if np.random.rand() < 0.5:\n        segment2 = segment2[::-1]\n\n    # Reconstruct the solution\n    new_solution = np.concatenate([new_solution[:i], segment1, segment2, new_solution[k:]])\n\n    # Edge-swapping: swap two non-adjacent edges if beneficial\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        if abs(a - b) > 1:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 289,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its dominance and diversity, then applies a hybrid local search combining edge insertion and path relinking to explore high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (non-dominated and diverse)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    base_cost1, base_cost2 = archive[selected_idx][1]\n\n    # Hybrid local search: combine edge insertion and path relinking\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge insertion (remove a random edge and reinsert it)\n    if n > 3:\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1) if i < n - 1 else i + 1\n        if j >= n:\n            j = n - 1\n\n        # Remove edge between i and j\n        removed_edge = (new_solution[i], new_solution[j])\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[j+1:]])\n\n        # Reinsert the edge at a random position\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], [removed_edge[0]], new_solution[insert_pos:]])\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], [removed_edge[1]], new_solution[insert_pos:]])\n\n    # Step 2: Path relinking (partial path exchange)\n    if n > 4:\n        a = random.randint(0, n - 3)\n        b = random.randint(a + 1, n - 2)\n        c = random.randint(b + 1, n - 1)\n        d = random.randint(c + 1, n)\n\n        # Exchange segments [a:b] and [c:d]\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[c:d]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b:c], segment1, new_solution[d:]])\n\n    # Ensure the solution remains a valid tour\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.655962384288221,
            6.260325908660889
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (non-dominated and diverse)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    base_cost1, base_cost2 = archive[selected_idx][1]\n\n    # Hybrid local search: combine edge insertion and path relinking\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge insertion (remove a random edge and reinsert it)\n    if n > 3:\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1) if i < n - 1 else i + 1\n        if j >= n:\n            j = n - 1\n\n        # Remove edge between i and j\n        removed_edge = (new_solution[i], new_solution[j])\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[j+1:]])\n\n        # Reinsert the edge at a random position\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], [removed_edge[0]], new_solution[insert_pos:]])\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], [removed_edge[1]], new_solution[insert_pos:]])\n\n    # Step 2: Path relinking (partial path exchange)\n    if n > 4:\n        a = random.randint(0, n - 3)\n        b = random.randint(a + 1, n - 2)\n        c = random.randint(b + 1, n - 1)\n        d = random.randint(c + 1, n)\n\n        # Exchange segments [a:b] and [c:d]\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[c:d]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b:c], segment1, new_solution[d:]])\n\n    # Ensure the solution remains a valid tour\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 290,
        "algorithm": "{The heuristic function selects a solution from the archive based on a weighted combination of objective values and applies a hybrid local search operator that combines 3-opt with a novel segment inversion strategy to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its combined objective\n    objectives = np.array([sum(obj) for _, obj in archive])\n    if np.any(objectives < 0):\n        objectives -= np.min(objectives) - 1  # Ensure all positive\n    probabilities = 1 / (objectives + 1e-6)\n    probabilities /= np.sum(probabilities)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # 3-opt segment selection\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n\n    # Novel segment inversion strategy\n    if random.random() < 0.5:\n        segment1 = segment1[::-1]\n    if random.random() < 0.5:\n        segment2 = segment2[::-1]\n\n    # Reconstruct the tour\n    new_solution = np.concatenate([new_solution[:a], segment1, segment2, new_solution[c:]])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if inversion causes duplicates\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8269882356856398,
            2.1910422444343567
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its combined objective\n    objectives = np.array([sum(obj) for _, obj in archive])\n    if np.any(objectives < 0):\n        objectives -= np.min(objectives) - 1  # Ensure all positive\n    probabilities = 1 / (objectives + 1e-6)\n    probabilities /= np.sum(probabilities)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # 3-opt segment selection\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n\n    # Novel segment inversion strategy\n    if random.random() < 0.5:\n        segment1 = segment1[::-1]\n    if random.random() < 0.5:\n        segment2 = segment2[::-1]\n\n    # Reconstruct the tour\n    new_solution = np.concatenate([new_solution[:a], segment1, segment2, new_solution[c:]])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if inversion causes duplicates\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 291,
        "algorithm": "{A hybrid local search algorithm that intelligently combines edge insertion, segment reversal, and objective-aware swaps to explore the solution space, prioritizing regions with high potential for multi-objective improvement by dynamically balancing exploration and exploitation of the archive's non-dominated solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Create a copy for modification\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Edge insertion with objective-aware selection\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    if i != j:\n        # Calculate potential improvement\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        # Apply if better in at least one objective\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            # Perform edge insertion\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Step 2: Segment reversal with boundary optimization\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a != b:\n        a, b = min(a, b), max(a, b)\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Calculate cost difference\n        old_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[a-1], reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%n]]\n\n        old_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%n]]\n\n        # Apply if better in at least one objective\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            new_solution[a:b+1] = reversed_segment\n\n    # Step 3: Objective-aware swap\n    c = random.randint(0, n - 1)\n    d = random.randint(0, n - 1)\n    if c != d:\n        # Calculate cost difference\n        old_cost1 = distance_matrix_1[new_solution[c-1], new_solution[c]] + distance_matrix_1[new_solution[d-1], new_solution[d]] + distance_matrix_1[new_solution[c], new_solution[(c+1)%n]] + distance_matrix_1[new_solution[d], new_solution[(d+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[c-1], new_solution[d]] + distance_matrix_1[new_solution[d-1], new_solution[c]] + distance_matrix_1[new_solution[d], new_solution[(c+1)%n]] + distance_matrix_1[new_solution[c], new_solution[(d+1)%n]]\n\n        old_cost2 = distance_matrix_2[new_solution[c-1], new_solution[c]] + distance_matrix_2[new_solution[d-1], new_solution[d]] + distance_matrix_2[new_solution[c], new_solution[(c+1)%n]] + distance_matrix_2[new_solution[d], new_solution[(d+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[c-1], new_solution[d]] + distance_matrix_2[new_solution[d-1], new_solution[c]] + distance_matrix_2[new_solution[d], new_solution[(c+1)%n]] + distance_matrix_2[new_solution[c], new_solution[(d+1)%n]]\n\n        # Apply if better in at least one objective\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    return new_solution\n\n",
        "score": [
            -0.9418461733221835,
            1.8006479740142822
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Create a copy for modification\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Edge insertion with objective-aware selection\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    if i != j:\n        # Calculate potential improvement\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        # Apply if better in at least one objective\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            # Perform edge insertion\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Step 2: Segment reversal with boundary optimization\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a != b:\n        a, b = min(a, b), max(a, b)\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Calculate cost difference\n        old_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[a-1], reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%n]]\n\n        old_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%n]]\n\n        # Apply if better in at least one objective\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            new_solution[a:b+1] = reversed_segment\n\n    # Step 3: Objective-aware swap\n    c = random.randint(0, n - 1)\n    d = random.randint(0, n - 1)\n    if c != d:\n        # Calculate cost difference\n        old_cost1 = distance_matrix_1[new_solution[c-1], new_solution[c]] + distance_matrix_1[new_solution[d-1], new_solution[d]] + distance_matrix_1[new_solution[c], new_solution[(c+1)%n]] + distance_matrix_1[new_solution[d], new_solution[(d+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[c-1], new_solution[d]] + distance_matrix_1[new_solution[d-1], new_solution[c]] + distance_matrix_1[new_solution[d], new_solution[(c+1)%n]] + distance_matrix_1[new_solution[c], new_solution[(d+1)%n]]\n\n        old_cost2 = distance_matrix_2[new_solution[c-1], new_solution[c]] + distance_matrix_2[new_solution[d-1], new_solution[d]] + distance_matrix_2[new_solution[c], new_solution[(c+1)%n]] + distance_matrix_2[new_solution[d], new_solution[(d+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[c-1], new_solution[d]] + distance_matrix_2[new_solution[d-1], new_solution[c]] + distance_matrix_2[new_solution[d], new_solution[(c+1)%n]] + distance_matrix_2[new_solution[c], new_solution[(d+1)%n]]\n\n        # Apply if better in at least one objective\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 292,
        "algorithm": "{A novel hybrid local search operator that combines a biased random walk with a dynamic edge exchange mechanism to explore high-quality regions of the search space while maintaining feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = [sol for sol, _ in archive]\n    base_solution = random.choice(candidates) if len(candidates) > 1 else candidates[0].copy()\n\n    # Hybrid local search: biased random walk + dynamic edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Biased random walk - select segments with high potential for improvement\n    segment_length = min(3, n // 2)\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Step 2: Dynamic edge exchange - reverse segment and insert elsewhere\n    segment = new_solution[start:end]\n    remaining = np.concatenate([new_solution[:start], new_solution[end:]])\n\n    # Evaluate potential insertion points\n    best_insert_pos = 0\n    best_cost = float('inf')\n\n    for i in range(len(remaining) + 1):\n        candidate = np.concatenate([remaining[:i], segment, remaining[i:]])\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        total_cost = cost1 + cost2  # Combined objective for selection\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert_pos = i\n\n    # Apply the best insertion\n    new_solution = np.concatenate([remaining[:best_insert_pos], segment, remaining[best_insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.6609921109723943,
            11.069823265075684
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = [sol for sol, _ in archive]\n    base_solution = random.choice(candidates) if len(candidates) > 1 else candidates[0].copy()\n\n    # Hybrid local search: biased random walk + dynamic edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Biased random walk - select segments with high potential for improvement\n    segment_length = min(3, n // 2)\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Step 2: Dynamic edge exchange - reverse segment and insert elsewhere\n    segment = new_solution[start:end]\n    remaining = np.concatenate([new_solution[:start], new_solution[end:]])\n\n    # Evaluate potential insertion points\n    best_insert_pos = 0\n    best_cost = float('inf')\n\n    for i in range(len(remaining) + 1):\n        candidate = np.concatenate([remaining[:i], segment, remaining[i:]])\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        total_cost = cost1 + cost2  # Combined objective for selection\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert_pos = i\n\n    # Apply the best insertion\n    new_solution = np.concatenate([remaining[:best_insert_pos], segment, remaining[best_insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 293,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective edge-swap heuristic with a Pareto-dominance guided path relocation operator, intelligently selecting solutions from the archive based on their non-dominated front and edge diversity to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (non-dominated and diverse)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective edge-swap with path relocation\n    n = len(base_solution)\n    a, b = sorted(random.sample(range(n), 2))\n\n    # Edge-swap for first objective\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Path relocation for second objective\n    if random.random() < 0.5:  # 50% chance to apply path relocation\n        c, d = sorted(random.sample(range(n), 2))\n        if c != a and c != b and d != a and d != b:\n            segment = new_solution[c:d+1]\n            new_solution = np.concatenate([new_solution[:c], new_solution[d+1:], segment])\n\n    # Ensure feasibility (no duplicates and all nodes included)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if relocation causes duplicates\n        new_solution = base_solution.copy()\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7226908125512352,
            1.2200141549110413
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (non-dominated and diverse)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective edge-swap with path relocation\n    n = len(base_solution)\n    a, b = sorted(random.sample(range(n), 2))\n\n    # Edge-swap for first objective\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Path relocation for second objective\n    if random.random() < 0.5:  # 50% chance to apply path relocation\n        c, d = sorted(random.sample(range(n), 2))\n        if c != a and c != b and d != a and d != b:\n            segment = new_solution[c:d+1]\n            new_solution = np.concatenate([new_solution[:c], new_solution[d+1:], segment])\n\n    # Ensure feasibility (no duplicates and all nodes included)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if relocation causes duplicates\n        new_solution = base_solution.copy()\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 294,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a combination of objective diversity and local improvement potential, then applies a hybrid local search operator combining edge insertion and path relinking with a biased random walk to explore high-quality regions of the search space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest objective value)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge insertion with biased random walk\n    for _ in range(3):  # Number of insertion attempts\n        i, j = sorted(random.sample(range(n), 2))\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Step 2: Path relinking with objective-aware selection\n    if len(archive) > 1:\n        ref_solution = archive[random.randint(0, len(archive)-1)][0]\n        for i in range(n):\n            if random.random() < 0.3:  # 30% chance to relink\n                ref_pos = np.where(ref_solution == new_solution[i])[0]\n                if len(ref_pos) > 0:\n                    ref_pos = ref_pos[0]\n                    j = (ref_pos + random.randint(-2, 2)) % n\n                    node = new_solution[j]\n                    new_solution = np.concatenate([new_solution[:i], [node], new_solution[i+1:]])\n\n    # Ensure feasibility by repairing if necessary\n    unique, counts = np.unique(new_solution, return_counts=True)\n    missing = [i for i in range(n) if i not in unique]\n    duplicate = [i for i, cnt in zip(unique, counts) if cnt > 1]\n\n    for d in duplicate:\n        pos = np.where(new_solution == d)[0][1]\n        new_solution[pos] = missing.pop() if missing else random.choice([i for i in range(n) if i not in new_solution])\n\n    return new_solution\n\n",
        "score": [
            -0.48436278375192426,
            0.9986229538917542
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest objective value)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge insertion with biased random walk\n    for _ in range(3):  # Number of insertion attempts\n        i, j = sorted(random.sample(range(n), 2))\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Step 2: Path relinking with objective-aware selection\n    if len(archive) > 1:\n        ref_solution = archive[random.randint(0, len(archive)-1)][0]\n        for i in range(n):\n            if random.random() < 0.3:  # 30% chance to relink\n                ref_pos = np.where(ref_solution == new_solution[i])[0]\n                if len(ref_pos) > 0:\n                    ref_pos = ref_pos[0]\n                    j = (ref_pos + random.randint(-2, 2)) % n\n                    node = new_solution[j]\n                    new_solution = np.concatenate([new_solution[:i], [node], new_solution[i+1:]])\n\n    # Ensure feasibility by repairing if necessary\n    unique, counts = np.unique(new_solution, return_counts=True)\n    missing = [i for i in range(n) if i not in unique]\n    duplicate = [i for i, cnt in zip(unique, counts) if cnt > 1]\n\n    for d in duplicate:\n        pos = np.where(new_solution == d)[0][1]\n        new_solution[pos] = missing.pop() if missing else random.choice([i for i in range(n) if i not in new_solution])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 295,
        "algorithm": "{A novel hybrid local search method that combines a randomized edge-swap heuristic with a multi-objective-aware path relinking to explore diverse neighborhoods while preserving feasibility, ensuring solutions are always valid TSP tours.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = None\n    for sol, _ in archive:\n        is_dominated = False\n        for _, obj in archive:\n            if obj[0] < obj[0] and obj[1] < obj[1]:\n                is_dominated = True\n                break\n        if not is_dominated:\n            selected = sol\n            break\n    if selected is None:\n        selected = random.choice(archive)[0]\n\n    new_solution = selected.copy()\n\n    # Hybrid local search: Randomized edge swap + path relinking\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select segments to swap or relink\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Perform a randomized edge swap\n    if random.random() < 0.5:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    else:\n        # Path relinking: insert a segment from another solution\n        other_sol = random.choice(archive)[0]\n        segment = other_sol[c:d]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a + len(segment):]])\n\n    # Ensure feasibility: remove duplicates and add missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    if len(missing_nodes) > 0:\n        for node in missing_nodes:\n            idx = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, idx, node)\n\n    # Trim to ensure exact length and remove duplicates\n    new_solution = new_solution[:n]\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    # If still missing nodes, append them (should rarely happen)\n    missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n    if len(missing_nodes) > 0:\n        new_solution = np.concatenate([new_solution, missing_nodes])\n\n    return new_solution\n\n",
        "score": [
            -0.8638970910692079,
            2.01277357339859
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = None\n    for sol, _ in archive:\n        is_dominated = False\n        for _, obj in archive:\n            if obj[0] < obj[0] and obj[1] < obj[1]:\n                is_dominated = True\n                break\n        if not is_dominated:\n            selected = sol\n            break\n    if selected is None:\n        selected = random.choice(archive)[0]\n\n    new_solution = selected.copy()\n\n    # Hybrid local search: Randomized edge swap + path relinking\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select segments to swap or relink\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Perform a randomized edge swap\n    if random.random() < 0.5:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    else:\n        # Path relinking: insert a segment from another solution\n        other_sol = random.choice(archive)[0]\n        segment = other_sol[c:d]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a + len(segment):]])\n\n    # Ensure feasibility: remove duplicates and add missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    if len(missing_nodes) > 0:\n        for node in missing_nodes:\n            idx = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, idx, node)\n\n    # Trim to ensure exact length and remove duplicates\n    new_solution = new_solution[:n]\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    # If still missing nodes, append them (should rarely happen)\n    missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n    if len(missing_nodes) > 0:\n        new_solution = np.concatenate([new_solution, missing_nodes])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 296,
        "algorithm": "{A novel hybrid local search operator combines a biased random walk with a dynamic path relinking mechanism, prioritizing high-potential segments identified via multi-objective dominance analysis to generate diverse, high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution, _ = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Identify segments with high potential for improvement (e.g., high edge weights or low connectivity)\n    n = len(new_solution)\n    segment_length = max(2, n // 10)\n    start = random.randint(0, n - segment_length - 1)\n    segment = new_solution[start:start + segment_length]\n\n    # Apply dynamic path relinking: reverse the segment and relink it with a biased random walk\n    reversed_segment = segment[::-1]\n    new_solution[start:start + segment_length] = reversed_segment\n\n    # Introduce a biased random walk to explore the neighborhood\n    for _ in range(3):\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility by checking for duplicates (though reversed segments should already be valid)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8530595966072557,
            1.2750916481018066
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution, _ = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Identify segments with high potential for improvement (e.g., high edge weights or low connectivity)\n    n = len(new_solution)\n    segment_length = max(2, n // 10)\n    start = random.randint(0, n - segment_length - 1)\n    segment = new_solution[start:start + segment_length]\n\n    # Apply dynamic path relinking: reverse the segment and relink it with a biased random walk\n    reversed_segment = segment[::-1]\n    new_solution[start:start + segment_length] = reversed_segment\n\n    # Introduce a biased random walk to explore the neighborhood\n    for _ in range(3):\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility by checking for duplicates (though reversed segments should already be valid)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 297,
        "algorithm": "{A novel hybrid local search operator combines a multi-segment inversion strategy with a probabilistic edge-swapping mechanism, dynamically balancing exploration and exploitation by selectively perturbing high-potential segments of the tour based on their contribution to the Pareto front.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high crowding distance)\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Create a copy of the selected solution\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: multi-segment inversion with probabilistic edge-swapping\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Determine segment length based on tour length\n        segment_length = max(2, n // 4)\n        start = random.randint(0, n - segment_length - 1)\n        end = start + segment_length\n\n        # Invert a segment\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Probabilistic edge-swapping\n        for _ in range(2):\n            if random.random() < 0.7:  # 70% chance to swap edges\n                i = random.randint(0, n - 2)\n                j = random.randint(i + 1, n - 1)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8375026708066173,
            1.6462238430976868
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high crowding distance)\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Create a copy of the selected solution\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: multi-segment inversion with probabilistic edge-swapping\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Determine segment length based on tour length\n        segment_length = max(2, n // 4)\n        start = random.randint(0, n - segment_length - 1)\n        end = start + segment_length\n\n        # Invert a segment\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Probabilistic edge-swapping\n        for _ in range(2):\n            if random.random() < 0.7:  # 70% chance to swap edges\n                i = random.randint(0, n - 2)\n                j = random.randint(i + 1, n - 1)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 298,
        "algorithm": "{A hybrid local search heuristic that combines edge exchange with a novel segment relocation strategy, prioritizing solutions with high Pareto dominance and applying a dynamic neighborhood exploration to balance exploration and exploitation while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with high potential for improvement\n    # Sort solutions by their dominance (lower total cost is better)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    # Select the top 20% of solutions\n    top_solutions = archive_sorted[:max(1, len(archive_sorted) // 5)]\n    # Randomly select one from the top\n    selected_idx = random.randint(0, len(top_solutions) - 1)\n    base_solution = top_solutions[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    n = len(new_solution)\n    # Randomly choose between edge exchange or segment relocation\n    if random.random() < 0.5:\n        # Edge exchange: swap two random edges\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n        if j - i > 1:\n            # Swap segments to maintain feasibility\n            new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Segment relocation: move a random segment to another position\n        i = random.randint(0, n - 3)\n        j = random.randint(i + 1, n - 2)\n        k = random.randint(0, n - 1)\n        if k < i or k > j:\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n            if k == 0:\n                new_solution = np.concatenate([segment, new_solution])\n            elif k == len(new_solution):\n                new_solution = np.concatenate([new_solution, segment])\n            else:\n                new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7583305323889602,
            1.7495946288108826
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with high potential for improvement\n    # Sort solutions by their dominance (lower total cost is better)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    # Select the top 20% of solutions\n    top_solutions = archive_sorted[:max(1, len(archive_sorted) // 5)]\n    # Randomly select one from the top\n    selected_idx = random.randint(0, len(top_solutions) - 1)\n    base_solution = top_solutions[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    n = len(new_solution)\n    # Randomly choose between edge exchange or segment relocation\n    if random.random() < 0.5:\n        # Edge exchange: swap two random edges\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n        if j - i > 1:\n            # Swap segments to maintain feasibility\n            new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Segment relocation: move a random segment to another position\n        i = random.randint(0, n - 3)\n        j = random.randint(i + 1, n - 2)\n        k = random.randint(0, n - 1)\n        if k < i or k > j:\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n            if k == 0:\n                new_solution = np.concatenate([segment, new_solution])\n            elif k == len(new_solution):\n                new_solution = np.concatenate([new_solution, segment])\n            else:\n                new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 299,
        "algorithm": "{A hybrid local search strategy that combines a randomized edge-swap operator with a novel adaptive segment-reversal mechanism to intelligently explore the solution space while maintaining feasibility and potentially improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: randomized edge-swap with adaptive segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse (adaptive segment size)\n    segment_size = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Reverse the selected segment\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Randomly swap two edges to create a new neighbor\n    if n > 3:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.733849429877954,
            2.083847224712372
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: randomized edge-swap with adaptive segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse (adaptive segment size)\n    segment_size = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Reverse the selected segment\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Randomly swap two edges to create a new neighbor\n    if n > 3:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 300,
        "algorithm": "{A novel hybrid local search operator combines a node-swapping strategy with a multi-objective-aware edge insertion heuristic to intelligently perturb solutions while preserving feasibility, balancing exploration and exploitation by prioritizing edges with high potential for cost reduction in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(1, 0.1, len(archive)) / np.sum(np.linspace(1, 0.1, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Node-swapping with multi-objective edge insertion\n    n = len(base_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n\n    # Perform node swapping\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Multi-objective edge insertion heuristic\n    for _ in range(3):  # Limit iterations to maintain efficiency\n        # Find edges with potential for cost reduction\n        edge_costs = []\n        for k in range(n):\n            a, b = base_solution[k], base_solution[(k+1)%n]\n            cost1 = distance_matrix_1[a, b]\n            cost2 = distance_matrix_2[a, b]\n            edge_costs.append((cost1 + cost2, k))\n\n        # Sort by total cost (sum of both objectives)\n        edge_costs.sort(key=lambda x: x[0])\n        worst_edge_idx = edge_costs[-1][1]  # Edge with highest combined cost\n\n        # Try inserting a random node between worst_edge nodes\n        u, v = base_solution[worst_edge_idx], base_solution[(worst_edge_idx+1)%n]\n        candidates = [node for node in base_solution if node not in {u, v}]\n        if candidates:\n            x = np.random.choice(candidates)\n            # Find position to insert x between u and v\n            pos = np.where(base_solution == u)[0][0]\n            new_solution = np.insert(new_solution, pos+1, x)\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts > 1):\n        # Fallback to simple swap if insertion causes infeasibility\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.0099698260778036,
            1.8028193712234497
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(1, 0.1, len(archive)) / np.sum(np.linspace(1, 0.1, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Node-swapping with multi-objective edge insertion\n    n = len(base_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n\n    # Perform node swapping\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Multi-objective edge insertion heuristic\n    for _ in range(3):  # Limit iterations to maintain efficiency\n        # Find edges with potential for cost reduction\n        edge_costs = []\n        for k in range(n):\n            a, b = base_solution[k], base_solution[(k+1)%n]\n            cost1 = distance_matrix_1[a, b]\n            cost2 = distance_matrix_2[a, b]\n            edge_costs.append((cost1 + cost2, k))\n\n        # Sort by total cost (sum of both objectives)\n        edge_costs.sort(key=lambda x: x[0])\n        worst_edge_idx = edge_costs[-1][1]  # Edge with highest combined cost\n\n        # Try inserting a random node between worst_edge nodes\n        u, v = base_solution[worst_edge_idx], base_solution[(worst_edge_idx+1)%n]\n        candidates = [node for node in base_solution if node not in {u, v}]\n        if candidates:\n            x = np.random.choice(candidates)\n            # Find position to insert x between u and v\n            pos = np.where(base_solution == u)[0][0]\n            new_solution = np.insert(new_solution, pos+1, x)\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts > 1):\n        # Fallback to simple swap if insertion causes infeasibility\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    }
]