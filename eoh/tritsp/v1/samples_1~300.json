[
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = min(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    start = np.random.randint(0, n)\n    end = np.random.randint(start, n)\n\n    # Apply 2-opt within the selected segment\n    i = start\n    j = end\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply node insertion to further improve the solution\n    for _ in range(2):  # Perform a few insertion attempts\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            node = new_solution[a]\n            new_solution = np.delete(new_solution, a)\n            new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7151564700650572,
            1.3487423181533813
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = min(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    start = np.random.randint(0, n)\n    end = np.random.randint(start, n)\n\n    # Apply 2-opt within the selected segment\n    i = start\n    j = end\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply node insertion to further improve the solution\n    for _ in range(2):  # Perform a few insertion attempts\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            node = new_solution[a]\n            new_solution = np.delete(new_solution, a)\n            new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = min(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    start = np.random.randint(0, n)\n    end = np.random.randint(start, n)\n\n    # Apply 2-opt within the selected segment\n    i = start\n    j = end\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply node insertion to further improve the solution\n    for _ in range(2):  # Perform a few insertion attempts\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            node = new_solution[a]\n            new_solution = np.delete(new_solution, a)\n            new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7151564700650572,
            1.3487423181533813
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = min(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    start = np.random.randint(0, n)\n    end = np.random.randint(start, n)\n\n    # Apply 2-opt within the selected segment\n    i = start\n    j = end\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply node insertion to further improve the solution\n    for _ in range(2):  # Perform a few insertion attempts\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            node = new_solution[a]\n            new_solution = np.delete(new_solution, a)\n            new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = min(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    start = np.random.randint(0, n)\n    end = np.random.randint(start, n)\n\n    # Apply 2-opt within the selected segment\n    i = start\n    j = end\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply node insertion to further improve the solution\n    for _ in range(2):  # Perform a few insertion attempts\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            node = new_solution[a]\n            new_solution = np.delete(new_solution, a)\n            new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7151564700650572,
            1.3487423181533813
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = min(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    start = np.random.randint(0, n)\n    end = np.random.randint(start, n)\n\n    # Apply 2-opt within the selected segment\n    i = start\n    j = end\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply node insertion to further improve the solution\n    for _ in range(2):  # Perform a few insertion attempts\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            node = new_solution[a]\n            new_solution = np.delete(new_solution, a)\n            new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Perform a hybrid local search: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    for i in range(n):\n        for j in range(i + 2, n):\n            # Calculate the change in objectives for the 2-opt move\n            a, b = new_solution[i], new_solution[i+1]\n            c, d = new_solution[j], new_solution[(j+1)%n]\n\n            delta1 = (distance_matrix_1[a, d] + distance_matrix_1[c, b]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n            delta2 = (distance_matrix_2[a, d] + distance_matrix_2[c, b]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n            delta3 = (distance_matrix_3[a, d] + distance_matrix_3[c, b]) - (distance_matrix_3[a, b] + distance_matrix_3[c, d])\n\n            # If the move improves at least one objective\n            if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                # Reverse the segment between i+1 and j\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7620547279216787,
            1.8092256784439087
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Perform a hybrid local search: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    for i in range(n):\n        for j in range(i + 2, n):\n            # Calculate the change in objectives for the 2-opt move\n            a, b = new_solution[i], new_solution[i+1]\n            c, d = new_solution[j], new_solution[(j+1)%n]\n\n            delta1 = (distance_matrix_1[a, d] + distance_matrix_1[c, b]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n            delta2 = (distance_matrix_2[a, d] + distance_matrix_2[c, b]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n            delta3 = (distance_matrix_3[a, d] + distance_matrix_3[c, b]) - (distance_matrix_3[a, b] + distance_matrix_3[c, d])\n\n            # If the move improves at least one objective\n            if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                # Reverse the segment between i+1 and j\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Perform a hybrid local search: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    for i in range(n):\n        for j in range(i + 2, n):\n            # Calculate the change in objectives for the 2-opt move\n            a, b = new_solution[i], new_solution[i+1]\n            c, d = new_solution[j], new_solution[(j+1)%n]\n\n            delta1 = (distance_matrix_1[a, d] + distance_matrix_1[c, b]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n            delta2 = (distance_matrix_2[a, d] + distance_matrix_2[c, b]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n            delta3 = (distance_matrix_3[a, d] + distance_matrix_3[c, b]) - (distance_matrix_3[a, b] + distance_matrix_3[c, d])\n\n            # If the move improves at least one objective\n            if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                # Reverse the segment between i+1 and j\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7620547279216787,
            1.8092256784439087
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Perform a hybrid local search: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    for i in range(n):\n        for j in range(i + 2, n):\n            # Calculate the change in objectives for the 2-opt move\n            a, b = new_solution[i], new_solution[i+1]\n            c, d = new_solution[j], new_solution[(j+1)%n]\n\n            delta1 = (distance_matrix_1[a, d] + distance_matrix_1[c, b]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n            delta2 = (distance_matrix_2[a, d] + distance_matrix_2[c, b]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n            delta3 = (distance_matrix_3[a, d] + distance_matrix_3[c, b]) - (distance_matrix_3[a, b] + distance_matrix_3[c, d])\n\n            # If the move improves at least one objective\n            if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                # Reverse the segment between i+1 and j\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: Apply a combination of 2-opt and node insertion\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Randomly select two distinct edges to swap (2-opt)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select a node and insert it in a new position (node insertion)\n    node = new_solution[np.random.randint(n)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node))\n    pos = np.random.randint(n-1)\n    new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.758094793127672,
            1.5458695054054261
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: Apply a combination of 2-opt and node insertion\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Randomly select two distinct edges to swap (2-opt)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select a node and insert it in a new position (node insertion)\n    node = new_solution[np.random.randint(n)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node))\n    pos = np.random.randint(n-1)\n    new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0]\n\n    # Apply a hybrid local search: 2-opt with objective-aware perturbations\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct positions to apply 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply objective-aware perturbation: swap segments based on objective differences\n    if random.random() < 0.5:\n        # Identify segments with high objective differences\n        segment_length = random.randint(2, min(5, n//3))\n        k = random.randint(0, n - segment_length)\n        l = random.randint(0, n - segment_length)\n\n        # Swap segments if it improves the objectives\n        temp_solution = new_solution.copy()\n        temp_solution[k:k+segment_length], temp_solution[l:l+segment_length] = temp_solution[l:l+segment_length], temp_solution[k:k+segment_length]\n\n        # Calculate new objectives\n        def calculate_objectives(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        original_costs = calculate_objectives(new_solution)\n        temp_costs = calculate_objectives(temp_solution)\n\n        # Accept if at least one objective improves\n        if any(temp_costs[i] < original_costs[i] for i in range(3)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.6459065449857456,
            0.9749270081520081
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0]\n\n    # Apply a hybrid local search: 2-opt with objective-aware perturbations\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct positions to apply 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply objective-aware perturbation: swap segments based on objective differences\n    if random.random() < 0.5:\n        # Identify segments with high objective differences\n        segment_length = random.randint(2, min(5, n//3))\n        k = random.randint(0, n - segment_length)\n        l = random.randint(0, n - segment_length)\n\n        # Swap segments if it improves the objectives\n        temp_solution = new_solution.copy()\n        temp_solution[k:k+segment_length], temp_solution[l:l+segment_length] = temp_solution[l:l+segment_length], temp_solution[k:k+segment_length]\n\n        # Calculate new objectives\n        def calculate_objectives(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        original_costs = calculate_objectives(new_solution)\n        temp_costs = calculate_objectives(temp_solution)\n\n        # Accept if at least one objective improves\n        if any(temp_costs[i] < original_costs[i] for i in range(3)):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0]\n\n    # Apply a hybrid local search: 2-opt with objective-aware perturbations\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct positions to apply 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply objective-aware perturbation: swap segments based on objective differences\n    if random.random() < 0.5:\n        # Identify segments with high objective differences\n        segment_length = random.randint(2, min(5, n//3))\n        k = random.randint(0, n - segment_length)\n        l = random.randint(0, n - segment_length)\n\n        # Swap segments if it improves the objectives\n        temp_solution = new_solution.copy()\n        temp_solution[k:k+segment_length], temp_solution[l:l+segment_length] = temp_solution[l:l+segment_length], temp_solution[k:k+segment_length]\n\n        # Calculate new objectives\n        def calculate_objectives(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        original_costs = calculate_objectives(new_solution)\n        temp_costs = calculate_objectives(temp_solution)\n\n        # Accept if at least one objective improves\n        if any(temp_costs[i] < original_costs[i] for i in range(3)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.6459065449857456,
            0.9749270081520081
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0]\n\n    # Apply a hybrid local search: 2-opt with objective-aware perturbations\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct positions to apply 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply objective-aware perturbation: swap segments based on objective differences\n    if random.random() < 0.5:\n        # Identify segments with high objective differences\n        segment_length = random.randint(2, min(5, n//3))\n        k = random.randint(0, n - segment_length)\n        l = random.randint(0, n - segment_length)\n\n        # Swap segments if it improves the objectives\n        temp_solution = new_solution.copy()\n        temp_solution[k:k+segment_length], temp_solution[l:l+segment_length] = temp_solution[l:l+segment_length], temp_solution[k:k+segment_length]\n\n        # Calculate new objectives\n        def calculate_objectives(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        original_costs = calculate_objectives(new_solution)\n        temp_costs = calculate_objectives(temp_solution)\n\n        # Accept if at least one objective improves\n        if any(temp_costs[i] < original_costs[i] for i in range(3)):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = None\n    max_diversity = -1\n\n    for sol, obj in archive:\n        # Calculate diversity as the sum of normalized differences between objectives\n        diversity = abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    # Apply hybrid 3-objective local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and reverse them (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply 3-objective aware 2-opt swap\n    for _ in range(5):  # Limited iterations for efficiency\n        a, b = sorted(random.sample(range(n), 2))\n        if a == b:\n            continue\n\n        # Calculate current and potential new costs for all three objectives\n        current_cost = (\n            distance_matrix_1[new_solution[a-1], new_solution[a]] +\n            distance_matrix_1[new_solution[b-1], new_solution[b]] +\n            distance_matrix_2[new_solution[a-1], new_solution[a]] +\n            distance_matrix_2[new_solution[b-1], new_solution[b]] +\n            distance_matrix_3[new_solution[a-1], new_solution[a]] +\n            distance_matrix_3[new_solution[b-1], new_solution[b]]\n        )\n\n        potential_cost = (\n            distance_matrix_1[new_solution[a-1], new_solution[b]] +\n            distance_matrix_1[new_solution[b-1], new_solution[a]] +\n            distance_matrix_2[new_solution[a-1], new_solution[b]] +\n            distance_matrix_2[new_solution[b-1], new_solution[a]] +\n            distance_matrix_3[new_solution[a-1], new_solution[b]] +\n            distance_matrix_3[new_solution[b-1], new_solution[a]]\n        )\n\n        # Accept if at least one objective improves\n        if potential_cost < current_cost:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.49727628096616366,
            1.6390827775001526
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = None\n    max_diversity = -1\n\n    for sol, obj in archive:\n        # Calculate diversity as the sum of normalized differences between objectives\n        diversity = abs(obj[0] - obj[1]) + abs(obj[1] - obj[2]) + abs(obj[2] - obj[0])\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    # Apply hybrid 3-objective local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and reverse them (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply 3-objective aware 2-opt swap\n    for _ in range(5):  # Limited iterations for efficiency\n        a, b = sorted(random.sample(range(n), 2))\n        if a == b:\n            continue\n\n        # Calculate current and potential new costs for all three objectives\n        current_cost = (\n            distance_matrix_1[new_solution[a-1], new_solution[a]] +\n            distance_matrix_1[new_solution[b-1], new_solution[b]] +\n            distance_matrix_2[new_solution[a-1], new_solution[a]] +\n            distance_matrix_2[new_solution[b-1], new_solution[b]] +\n            distance_matrix_3[new_solution[a-1], new_solution[a]] +\n            distance_matrix_3[new_solution[b-1], new_solution[b]]\n        )\n\n        potential_cost = (\n            distance_matrix_1[new_solution[a-1], new_solution[b]] +\n            distance_matrix_1[new_solution[b-1], new_solution[a]] +\n            distance_matrix_2[new_solution[a-1], new_solution[b]] +\n            distance_matrix_2[new_solution[b-1], new_solution[a]] +\n            distance_matrix_3[new_solution[a-1], new_solution[b]] +\n            distance_matrix_3[new_solution[b-1], new_solution[a]]\n        )\n\n        # Accept if at least one objective improves\n        if potential_cost < current_cost:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a promising solution from the archive and applies a multi-objective-aware 2-opt* operator, combined with a biased random walk to explore trade-offs across the three objectives, ensuring feasibility and high-quality neighbors by prioritizing segments with high potential for improvement in at least one of the objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive (intelligent random selection)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(1, 0.1, len(archive)) / np.sum(np.linspace(1, 0.1, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Hybrid local search: 2-opt* with multi-objective bias\n    for _ in range(10):  # Number of attempts\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate potential improvement across objectives\n        def compute_savings(a, b, c, d):\n            # 2-opt* move: reverse segment [a:b] and [c:d]\n            new_sol = base_solution.copy()\n            new_sol[a:b] = base_solution[a:b][::-1]\n            new_sol[c:d] = base_solution[c:d][::-1]\n            # Evaluate the new solution\n            cost1 = sum(distance_matrix_1[new_sol[i], new_sol[i+1]] for i in range(n-1)) + distance_matrix_1[new_sol[-1], new_sol[0]]\n            cost2 = sum(distance_matrix_2[new_sol[i], new_sol[i+1]] for i in range(n-1)) + distance_matrix_2[new_sol[-1], new_sol[0]]\n            cost3 = sum(distance_matrix_3[new_sol[i], new_sol[i+1]] for i in range(n-1)) + distance_matrix_3[new_sol[-1], new_sol[0]]\n            return (cost1, cost2, cost3)\n\n        old_costs = archive[selected_idx][1]\n        new_costs = compute_savings(i, j, k, l)\n\n        # Accept if at least one objective improves\n        if any(new_cost < old_cost for new_cost, old_cost in zip(new_costs, old_costs)):\n            new_solution = base_solution.copy()\n            new_solution[i:j] = base_solution[i:j][::-1]\n            new_solution[k:l] = base_solution[k:l][::-1]\n            return new_solution\n\n    # If no improvement found, perform a biased random walk\n    new_solution = base_solution.copy()\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7712418724359896,
            1.285500705242157
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive (intelligent random selection)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(1, 0.1, len(archive)) / np.sum(np.linspace(1, 0.1, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Hybrid local search: 2-opt* with multi-objective bias\n    for _ in range(10):  # Number of attempts\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate potential improvement across objectives\n        def compute_savings(a, b, c, d):\n            # 2-opt* move: reverse segment [a:b] and [c:d]\n            new_sol = base_solution.copy()\n            new_sol[a:b] = base_solution[a:b][::-1]\n            new_sol[c:d] = base_solution[c:d][::-1]\n            # Evaluate the new solution\n            cost1 = sum(distance_matrix_1[new_sol[i], new_sol[i+1]] for i in range(n-1)) + distance_matrix_1[new_sol[-1], new_sol[0]]\n            cost2 = sum(distance_matrix_2[new_sol[i], new_sol[i+1]] for i in range(n-1)) + distance_matrix_2[new_sol[-1], new_sol[0]]\n            cost3 = sum(distance_matrix_3[new_sol[i], new_sol[i+1]] for i in range(n-1)) + distance_matrix_3[new_sol[-1], new_sol[0]]\n            return (cost1, cost2, cost3)\n\n        old_costs = archive[selected_idx][1]\n        new_costs = compute_savings(i, j, k, l)\n\n        # Accept if at least one objective improves\n        if any(new_cost < old_cost for new_cost, old_cost in zip(new_costs, old_costs)):\n            new_solution = base_solution.copy()\n            new_solution[i:j] = base_solution[i:j][::-1]\n            new_solution[k:l] = base_solution[k:l][::-1]\n            return new_solution\n\n    # If no improvement found, perform a biased random walk\n    new_solution = base_solution.copy()\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a promising solution from the archive and applies a multi-objective-aware 2-opt* operator, combined with a biased random walk to explore trade-offs across the three objectives, ensuring feasibility and high-quality neighbors by prioritizing segments with high potential for improvement in at least one of the objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive (intelligent random selection)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(1, 0.1, len(archive)) / np.sum(np.linspace(1, 0.1, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Hybrid local search: 2-opt* with multi-objective bias\n    for _ in range(10):  # Number of attempts\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate potential improvement across objectives\n        def compute_savings(a, b, c, d):\n            # 2-opt* move: reverse segment [a:b] and [c:d]\n            new_sol = base_solution.copy()\n            new_sol[a:b] = base_solution[a:b][::-1]\n            new_sol[c:d] = base_solution[c:d][::-1]\n            # Evaluate the new solution\n            cost1 = sum(distance_matrix_1[new_sol[i], new_sol[i+1]] for i in range(n-1)) + distance_matrix_1[new_sol[-1], new_sol[0]]\n            cost2 = sum(distance_matrix_2[new_sol[i], new_sol[i+1]] for i in range(n-1)) + distance_matrix_2[new_sol[-1], new_sol[0]]\n            cost3 = sum(distance_matrix_3[new_sol[i], new_sol[i+1]] for i in range(n-1)) + distance_matrix_3[new_sol[-1], new_sol[0]]\n            return (cost1, cost2, cost3)\n\n        old_costs = archive[selected_idx][1]\n        new_costs = compute_savings(i, j, k, l)\n\n        # Accept if at least one objective improves\n        if any(new_cost < old_cost for new_cost, old_cost in zip(new_costs, old_costs)):\n            new_solution = base_solution.copy()\n            new_solution[i:j] = base_solution[i:j][::-1]\n            new_solution[k:l] = base_solution[k:l][::-1]\n            return new_solution\n\n    # If no improvement found, perform a biased random walk\n    new_solution = base_solution.copy()\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7712418724359896,
            1.285500705242157
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive (intelligent random selection)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(1, 0.1, len(archive)) / np.sum(np.linspace(1, 0.1, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Hybrid local search: 2-opt* with multi-objective bias\n    for _ in range(10):  # Number of attempts\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate potential improvement across objectives\n        def compute_savings(a, b, c, d):\n            # 2-opt* move: reverse segment [a:b] and [c:d]\n            new_sol = base_solution.copy()\n            new_sol[a:b] = base_solution[a:b][::-1]\n            new_sol[c:d] = base_solution[c:d][::-1]\n            # Evaluate the new solution\n            cost1 = sum(distance_matrix_1[new_sol[i], new_sol[i+1]] for i in range(n-1)) + distance_matrix_1[new_sol[-1], new_sol[0]]\n            cost2 = sum(distance_matrix_2[new_sol[i], new_sol[i+1]] for i in range(n-1)) + distance_matrix_2[new_sol[-1], new_sol[0]]\n            cost3 = sum(distance_matrix_3[new_sol[i], new_sol[i+1]] for i in range(n-1)) + distance_matrix_3[new_sol[-1], new_sol[0]]\n            return (cost1, cost2, cost3)\n\n        old_costs = archive[selected_idx][1]\n        new_costs = compute_savings(i, j, k, l)\n\n        # Accept if at least one objective improves\n        if any(new_cost < old_cost for new_cost, old_cost in zip(new_costs, old_costs)):\n            new_solution = base_solution.copy()\n            new_solution[i:j] = base_solution[i:j][::-1]\n            new_solution[k:l] = base_solution[k:l][::-1]\n            return new_solution\n\n    # If no improvement found, perform a biased random walk\n    new_solution = base_solution.copy()\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{The algorithm selects a promising solution from the archive by evaluating its potential for local improvement across all three objectives, then applies a hybrid 2-opt and 3-opt local search operator with adaptive step sizes to generate a neighbor solution, ensuring feasibility by validating the tour structure and distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive (simplified heuristic: pick the one with the best combined objective)\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply hybrid local search: 2-opt and 3-opt with adaptive step sizes\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Perform 2-opt\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        if i == 0 and j == n - 1:\n            continue  # Avoid invalid tour\n\n        # Reverse the segment between i and j\n        new_segment = new_solution[i:j+1][::-1]\n        new_solution[i:j+1] = new_segment\n\n        # Check feasibility (no duplicate nodes)\n        if len(np.unique(new_solution)) == n:\n            selected_solution = new_solution.copy()\n\n    # Perform 3-opt (simplified version)\n    for _ in range(5):\n        a, b, c = np.random.choice(n, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Try different 3-opt configurations\n        for config in [\n            (a, b, c),\n            (a, c, b),\n            (b, a, c),\n            (b, c, a),\n            (c, a, b),\n            (c, b, a)\n        ]:\n            temp_solution = new_solution.copy()\n            temp_solution[a:b+1] = temp_solution[a:b+1][::-1]\n            temp_solution[b:c+1] = temp_solution[b:c+1][::-1]\n\n            # Check feasibility\n            if len(np.unique(temp_solution)) == n:\n                new_solution = temp_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7458425110626937,
            3.48055682182312
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive (simplified heuristic: pick the one with the best combined objective)\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply hybrid local search: 2-opt and 3-opt with adaptive step sizes\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Perform 2-opt\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        if i == 0 and j == n - 1:\n            continue  # Avoid invalid tour\n\n        # Reverse the segment between i and j\n        new_segment = new_solution[i:j+1][::-1]\n        new_solution[i:j+1] = new_segment\n\n        # Check feasibility (no duplicate nodes)\n        if len(np.unique(new_solution)) == n:\n            selected_solution = new_solution.copy()\n\n    # Perform 3-opt (simplified version)\n    for _ in range(5):\n        a, b, c = np.random.choice(n, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Try different 3-opt configurations\n        for config in [\n            (a, b, c),\n            (a, c, b),\n            (b, a, c),\n            (b, c, a),\n            (c, a, b),\n            (c, b, a)\n        ]:\n            temp_solution = new_solution.copy()\n            temp_solution[a:b+1] = temp_solution[a:b+1][::-1]\n            temp_solution[b:c+1] = temp_solution[b:c+1][::-1]\n\n            # Check feasibility\n            if len(np.unique(temp_solution)) == n:\n                new_solution = temp_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Generate a neighbor by performing a hybrid local search: 2-opt with random segment reversal\n    n = len(selected_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution = selected_solution.copy()\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse a random segment\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        new_solution = selected_solution.copy()\n        idx1, idx2 = random.sample(range(n), 2)\n        new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    return new_solution\n\n",
        "score": [
            -0.7202072742467446,
            1.323708748817444
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Generate a neighbor by performing a hybrid local search: 2-opt with random segment reversal\n    n = len(selected_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution = selected_solution.copy()\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse a random segment\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        new_solution = selected_solution.copy()\n        idx1, idx2 = random.sample(range(n), 2)\n        new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for sol, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: apply a combination of 2-opt and objective-aware edge swaps\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # 2-opt swap to improve tour structure\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware edge swap: prioritize edges with high distance in the worst-performing objective\n    worst_obj = np.argmax(archive[selected_idx][1])\n    distance_matrices = [distance_matrix_1, distance_matrix_2, distance_matrix_3]\n    current_obj = archive[selected_idx][1][worst_obj]\n\n    for _ in range(5):  # Limited attempts to find beneficial swaps\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        if k != l:\n            # Calculate potential improvement\n            old_edges = [(new_solution[k-1], new_solution[k]), (new_solution[l-1], new_solution[l])]\n            new_edges = [(new_solution[k-1], new_solution[l]), (new_solution[l-1], new_solution[k])]\n            improvement = sum(distance_matrices[worst_obj][a][b] for a, b in old_edges) - \\\n                          sum(distance_matrices[worst_obj][a][b] for a, b in new_edges)\n\n            if improvement > 0:\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.5727001704783985,
            2.2575618267059325
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for sol, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: apply a combination of 2-opt and objective-aware edge swaps\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # 2-opt swap to improve tour structure\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware edge swap: prioritize edges with high distance in the worst-performing objective\n    worst_obj = np.argmax(archive[selected_idx][1])\n    distance_matrices = [distance_matrix_1, distance_matrix_2, distance_matrix_3]\n    current_obj = archive[selected_idx][1][worst_obj]\n\n    for _ in range(5):  # Limited attempts to find beneficial swaps\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        if k != l:\n            # Calculate potential improvement\n            old_edges = [(new_solution[k-1], new_solution[k]), (new_solution[l-1], new_solution[l])]\n            new_edges = [(new_solution[k-1], new_solution[l]), (new_solution[l-1], new_solution[k])]\n            improvement = sum(distance_matrices[worst_obj][a][b] for a, b in old_edges) - \\\n                          sum(distance_matrices[worst_obj][a][b] for a, b in new_edges)\n\n            if improvement > 0:\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, base_objectives = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify critical edges (high cost in any objective)\n    critical_edges = []\n    for i in range(n):\n        j = (i + 1) % n\n        edge_costs = (\n            distance_matrix_1[new_solution[i], new_solution[j]],\n            distance_matrix_2[new_solution[i], new_solution[j]],\n            distance_matrix_3[new_solution[i], new_solution[j]]\n        )\n        if any(c > 0.7 * np.max(edge_costs) for c in edge_costs):\n            critical_edges.append(i)\n\n    if critical_edges:\n        # Perform 2-opt on a randomly selected critical edge\n        idx = np.random.choice(critical_edges)\n        j = (idx + 1) % n\n        # Find the best possible swap that minimizes the sum of objectives\n        best_swap = None\n        best_improvement = 0\n        for k in range(n):\n            if k == idx or k == j or (k + 1) % n == idx or (k + 1) % n == j:\n                continue\n            # Calculate the improvement from swapping edges\n            old_cost = (\n                distance_matrix_1[new_solution[idx], new_solution[j]] +\n                distance_matrix_2[new_solution[idx], new_solution[j]] +\n                distance_matrix_3[new_solution[idx], new_solution[j]]\n            )\n            new_cost = (\n                distance_matrix_1[new_solution[idx], new_solution[k]] +\n                distance_matrix_2[new_solution[idx], new_solution[k]] +\n                distance_matrix_3[new_solution[idx], new_solution[k]] +\n                distance_matrix_1[new_solution[j], new_solution[(k + 1) % n]] +\n                distance_matrix_2[new_solution[j], new_solution[(k + 1) % n]] +\n                distance_matrix_3[new_solution[j], new_solution[(k + 1) % n]]\n            )\n            improvement = old_cost - new_cost\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_swap = k\n\n        if best_swap is not None:\n            # Perform the swap\n            k = best_swap\n            new_solution[idx + 1:k + 1] = np.flip(new_solution[idx + 1:k + 1])\n\n    return new_solution\n\n",
        "score": [
            -0.6843478942663955,
            2.892498290538788
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, base_objectives = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify critical edges (high cost in any objective)\n    critical_edges = []\n    for i in range(n):\n        j = (i + 1) % n\n        edge_costs = (\n            distance_matrix_1[new_solution[i], new_solution[j]],\n            distance_matrix_2[new_solution[i], new_solution[j]],\n            distance_matrix_3[new_solution[i], new_solution[j]]\n        )\n        if any(c > 0.7 * np.max(edge_costs) for c in edge_costs):\n            critical_edges.append(i)\n\n    if critical_edges:\n        # Perform 2-opt on a randomly selected critical edge\n        idx = np.random.choice(critical_edges)\n        j = (idx + 1) % n\n        # Find the best possible swap that minimizes the sum of objectives\n        best_swap = None\n        best_improvement = 0\n        for k in range(n):\n            if k == idx or k == j or (k + 1) % n == idx or (k + 1) % n == j:\n                continue\n            # Calculate the improvement from swapping edges\n            old_cost = (\n                distance_matrix_1[new_solution[idx], new_solution[j]] +\n                distance_matrix_2[new_solution[idx], new_solution[j]] +\n                distance_matrix_3[new_solution[idx], new_solution[j]]\n            )\n            new_cost = (\n                distance_matrix_1[new_solution[idx], new_solution[k]] +\n                distance_matrix_2[new_solution[idx], new_solution[k]] +\n                distance_matrix_3[new_solution[idx], new_solution[k]] +\n                distance_matrix_1[new_solution[j], new_solution[(k + 1) % n]] +\n                distance_matrix_2[new_solution[j], new_solution[(k + 1) % n]] +\n                distance_matrix_3[new_solution[j], new_solution[(k + 1) % n]]\n            )\n            improvement = old_cost - new_cost\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_swap = k\n\n        if best_swap is not None:\n            # Perform the swap\n            k = best_swap\n            new_solution[idx + 1:k + 1] = np.flip(new_solution[idx + 1:k + 1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: combine 2-opt and edge insertion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct edges to perform 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Perform 2-opt\n    if i == 0 and j == n-1:\n        new_solution = new_solution[::-1]\n    else:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply edge insertion for further improvement\n    for _ in range(2):  # Limit the number of insertions for efficiency\n        a, b = sorted(random.sample(range(n), 2))\n        if a == 0 and b == n-1:\n            continue\n        node = new_solution[b]\n        new_solution = np.concatenate([new_solution[:b], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.5267715337256534,
            1.666912031173706
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: combine 2-opt and edge insertion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct edges to perform 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Perform 2-opt\n    if i == 0 and j == n-1:\n        new_solution = new_solution[::-1]\n    else:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply edge insertion for further improvement\n    for _ in range(2):  # Limit the number of insertions for efficiency\n        a, b = sorted(random.sample(range(n), 2))\n        if a == 0 and b == n-1:\n            continue\n        node = new_solution[b]\n        new_solution = np.concatenate([new_solution[:b], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the variance of each objective across the archive\n    objectives = np.array([obj for _, obj in archive])\n    obj_variance = np.var(objectives, axis=0)\n\n    # Select the solution with the highest objective variance (most potential for improvement)\n    selected_idx = np.argmax(np.sum(obj_variance[np.newaxis, :] * objectives, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform 2-opt to improve one objective\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            # Swap edges (i, i+1) and (j, j+1) with (i, j) and (i+1, j+1)\n            temp = new_solution[i+1:j+1].copy()\n            new_solution[i+1:j+1] = temp[::-1]\n\n            # Evaluate the new solution's objectives\n            obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n            obj3 = sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n\n            # Check if the new solution dominates the original in at least one objective\n            original_obj = archive[selected_idx][1]\n            if (obj1 < original_obj[0]) or (obj2 < original_obj[1]) or (obj3 < original_obj[2]):\n                # Accept the move if it improves at least one objective\n                break\n            else:\n                # Revert if no improvement\n                new_solution = base_solution.copy()\n\n    # Step 3: Apply multi-objective edge swap operator\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Swap two edges in a way that preserves feasibility\n        temp = new_solution[i:j+1].copy()\n        new_solution[i:j+1] = temp[::-1]\n\n        # Evaluate the new solution's objectives\n        obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        obj3 = sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n\n        # Accept the move if it improves at least one objective\n        original_obj = archive[selected_idx][1]\n        if (obj1 < original_obj[0]) or (obj2 < original_obj[1]) or (obj3 < original_obj[2]):\n            break\n        else:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6539287637610494,
            4.247673153877258
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the variance of each objective across the archive\n    objectives = np.array([obj for _, obj in archive])\n    obj_variance = np.var(objectives, axis=0)\n\n    # Select the solution with the highest objective variance (most potential for improvement)\n    selected_idx = np.argmax(np.sum(obj_variance[np.newaxis, :] * objectives, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform 2-opt to improve one objective\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            # Swap edges (i, i+1) and (j, j+1) with (i, j) and (i+1, j+1)\n            temp = new_solution[i+1:j+1].copy()\n            new_solution[i+1:j+1] = temp[::-1]\n\n            # Evaluate the new solution's objectives\n            obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n            obj3 = sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n\n            # Check if the new solution dominates the original in at least one objective\n            original_obj = archive[selected_idx][1]\n            if (obj1 < original_obj[0]) or (obj2 < original_obj[1]) or (obj3 < original_obj[2]):\n                # Accept the move if it improves at least one objective\n                break\n            else:\n                # Revert if no improvement\n                new_solution = base_solution.copy()\n\n    # Step 3: Apply multi-objective edge swap operator\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Swap two edges in a way that preserves feasibility\n        temp = new_solution[i:j+1].copy()\n        new_solution[i:j+1] = temp[::-1]\n\n        # Evaluate the new solution's objectives\n        obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        obj3 = sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n\n        # Accept the move if it improves at least one objective\n        original_obj = archive[selected_idx][1]\n        if (obj1 < original_obj[0]) or (obj2 < original_obj[1]) or (obj3 < original_obj[2]):\n            break\n        else:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 13,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (prioritize solutions with higher potential)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select a random solution from the top 30% of the archive\n        selection_pool = sorted_archive[:max(1, len(archive) // 3)]\n        selected_idx = random.randint(0, len(selection_pool) - 1)\n        base_solution = selection_pool[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive 2-opt with multi-objective edge selection\n    for _ in range(10):  # Perform multiple iterations\n        # Identify edges with potential for improvement across all objectives\n        edge_scores = []\n        for i in range(n):\n            a = new_solution[i]\n            b = new_solution[(i + 1) % n]\n            c = new_solution[(i + 2) % n]\n\n            # Calculate the potential improvement for each objective\n            current_cost1 = distance_matrix_1[a, b] + distance_matrix_1[b, c]\n            current_cost2 = distance_matrix_2[a, b] + distance_matrix_2[b, c]\n            current_cost3 = distance_matrix_3[a, b] + distance_matrix_3[b, c]\n\n            # Try reversing the edge\n            new_cost1 = distance_matrix_1[a, c] + distance_matrix_1[c, b]\n            new_cost2 = distance_matrix_2[a, c] + distance_matrix_2[c, b]\n            new_cost3 = distance_matrix_3[a, c] + distance_matrix_3[c, b]\n\n            # Calculate the improvement score (weighted by objective importance)\n            improvement1 = current_cost1 - new_cost1\n            improvement2 = current_cost2 - new_cost2\n            improvement3 = current_cost3 - new_cost3\n\n            # Simple weighted sum (could be replaced with more sophisticated weighting)\n            total_improvement = improvement1 + improvement2 + improvement3\n            edge_scores.append((total_improvement, i))\n\n        # Sort edges by improvement potential\n        edge_scores.sort(reverse=True, key=lambda x: x[0])\n\n        # Select the top edge for reversal\n        if edge_scores and edge_scores[0][0] > 0:\n            best_edge = edge_scores[0][1]\n            i = best_edge\n            j = (i + 1) % n\n\n            # Perform 2-opt move\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6107473845593567,
            3.8903276562690734
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (prioritize solutions with higher potential)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select a random solution from the top 30% of the archive\n        selection_pool = sorted_archive[:max(1, len(archive) // 3)]\n        selected_idx = random.randint(0, len(selection_pool) - 1)\n        base_solution = selection_pool[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive 2-opt with multi-objective edge selection\n    for _ in range(10):  # Perform multiple iterations\n        # Identify edges with potential for improvement across all objectives\n        edge_scores = []\n        for i in range(n):\n            a = new_solution[i]\n            b = new_solution[(i + 1) % n]\n            c = new_solution[(i + 2) % n]\n\n            # Calculate the potential improvement for each objective\n            current_cost1 = distance_matrix_1[a, b] + distance_matrix_1[b, c]\n            current_cost2 = distance_matrix_2[a, b] + distance_matrix_2[b, c]\n            current_cost3 = distance_matrix_3[a, b] + distance_matrix_3[b, c]\n\n            # Try reversing the edge\n            new_cost1 = distance_matrix_1[a, c] + distance_matrix_1[c, b]\n            new_cost2 = distance_matrix_2[a, c] + distance_matrix_2[c, b]\n            new_cost3 = distance_matrix_3[a, c] + distance_matrix_3[c, b]\n\n            # Calculate the improvement score (weighted by objective importance)\n            improvement1 = current_cost1 - new_cost1\n            improvement2 = current_cost2 - new_cost2\n            improvement3 = current_cost3 - new_cost3\n\n            # Simple weighted sum (could be replaced with more sophisticated weighting)\n            total_improvement = improvement1 + improvement2 + improvement3\n            edge_scores.append((total_improvement, i))\n\n        # Sort edges by improvement potential\n        edge_scores.sort(reverse=True, key=lambda x: x[0])\n\n        # Select the top edge for reversal\n        if edge_scores and edge_scores[0][0] > 0:\n            best_edge = edge_scores[0][1]\n            i = best_edge\n            j = (i + 1) % n\n\n            # Perform 2-opt move\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 14,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Check if reversing this segment improves at least one objective\n        original_costs = [\n            sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n        ]\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n        new_costs = [\n            sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(n)),\n            sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(n)),\n            sum(distance_matrix_3[candidate[k-1], candidate[k]] for k in range(n))\n        ]\n        if any(new_costs[k] < original_costs[k] for k in range(3)):\n            new_solution = candidate\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.6993334684885839,
            1.5521645903587342
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Check if reversing this segment improves at least one objective\n        original_costs = [\n            sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n        ]\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n        new_costs = [\n            sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(n)),\n            sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(n)),\n            sum(distance_matrix_3[candidate[k-1], candidate[k]] for k in range(n))\n        ]\n        if any(new_costs[k] < original_costs[k] for k in range(3)):\n            new_solution = candidate\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 15,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest average objective value)\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt to improve connectivity\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: identify worst edges in any objective and try to improve\n    def calculate_total_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        cost3 = sum(distance_matrix_3[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_3[solution[-1], solution[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_total_cost(new_solution)\n\n    for _ in range(5):  # Limited attempts to find better swaps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n        temp_cost = calculate_total_cost(temp_solution)\n\n        # Accept if at least one objective improves\n        if any(temp_cost[k] < current_cost[k] for k in range(3)):\n            new_solution = temp_solution\n            current_cost = temp_cost\n\n    return new_solution\n\n",
        "score": [
            -0.8169082013181483,
            2.5842435717582704
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest average objective value)\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt to improve connectivity\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: identify worst edges in any objective and try to improve\n    def calculate_total_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        cost3 = sum(distance_matrix_3[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_3[solution[-1], solution[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_total_cost(new_solution)\n\n    for _ in range(5):  # Limited attempts to find better swaps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n        temp_cost = calculate_total_cost(temp_solution)\n\n        # Accept if at least one objective improves\n        if any(temp_cost[k] < current_cost[k] for k in range(3)):\n            new_solution = temp_solution\n            current_cost = temp_cost\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 15,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest average objective value)\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt to improve connectivity\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: identify worst edges in any objective and try to improve\n    def calculate_total_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        cost3 = sum(distance_matrix_3[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_3[solution[-1], solution[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_total_cost(new_solution)\n\n    for _ in range(5):  # Limited attempts to find better swaps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n        temp_cost = calculate_total_cost(temp_solution)\n\n        # Accept if at least one objective improves\n        if any(temp_cost[k] < current_cost[k] for k in range(3)):\n            new_solution = temp_solution\n            current_cost = temp_cost\n\n    return new_solution\n\n",
        "score": [
            -0.8169082013181483,
            2.5842435717582704
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest average objective value)\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt to improve connectivity\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: identify worst edges in any objective and try to improve\n    def calculate_total_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        cost3 = sum(distance_matrix_3[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_3[solution[-1], solution[0]]\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_total_cost(new_solution)\n\n    for _ in range(5):  # Limited attempts to find better swaps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n        temp_cost = calculate_total_cost(temp_solution)\n\n        # Accept if at least one objective improves\n        if any(temp_cost[k] < current_cost[k] for k in range(3)):\n            new_solution = temp_solution\n            current_cost = temp_cost\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 16,
        "algorithm": "{A novel heuristic function that intelligently selects a non-dominated solution from the archive, applies a hybrid local search combining 2-opt and k-opt moves tailored for tri-objective optimization, and ensures feasibility by validating the tour after each modification.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a random solution from the archive with preference for those with lower objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.max(axis=0) + 1e-10)\n    weights = 1.0 / (1.0 + np.sum(normalized_objectives, axis=1))\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: 2-opt for two objectives, k-opt for the third\n    n = len(base_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Randomly choose a segment to modify\n        k = np.random.randint(2, min(5, n//2))  # k-opt size\n        i = np.random.randint(0, n - k)\n        j = np.random.randint(i + 1, min(i + k + 1, n))\n\n        # Reverse the segment (2-opt)\n        new_solution[i:j] = base_solution[i:j][::-1]\n\n        # Check feasibility and objective improvement\n        if not np.all(np.unique(new_solution) == np.arange(n)):\n            new_solution = base_solution.copy()\n            continue\n\n        # Calculate new objectives\n        obj1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        obj2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        obj3 = sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        # Accept if better in at least one objective\n        if (obj1 < archive[selected_idx][1][0] or\n            obj2 < archive[selected_idx][1][1] or\n            obj3 < archive[selected_idx][1][2]):\n            base_solution = new_solution.copy()\n        else:\n            new_solution = base_solution.copy()\n\n    return base_solution\n\n",
        "score": [
            -0.7682007088257807,
            4.391886115074158
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a random solution from the archive with preference for those with lower objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.max(axis=0) + 1e-10)\n    weights = 1.0 / (1.0 + np.sum(normalized_objectives, axis=1))\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: 2-opt for two objectives, k-opt for the third\n    n = len(base_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Randomly choose a segment to modify\n        k = np.random.randint(2, min(5, n//2))  # k-opt size\n        i = np.random.randint(0, n - k)\n        j = np.random.randint(i + 1, min(i + k + 1, n))\n\n        # Reverse the segment (2-opt)\n        new_solution[i:j] = base_solution[i:j][::-1]\n\n        # Check feasibility and objective improvement\n        if not np.all(np.unique(new_solution) == np.arange(n)):\n            new_solution = base_solution.copy()\n            continue\n\n        # Calculate new objectives\n        obj1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        obj2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        obj3 = sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        # Accept if better in at least one objective\n        if (obj1 < archive[selected_idx][1][0] or\n            obj2 < archive[selected_idx][1][1] or\n            obj3 < archive[selected_idx][1][2]):\n            base_solution = new_solution.copy()\n        else:\n            new_solution = base_solution.copy()\n\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 17,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        variances = [max(obj) - min(obj) for _, obj in archive]\n        selected_idx = np.argmax(variances)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 2-opt for structure + insertion for fine-tuning\n    for _ in range(10):  # Limited iterations for efficiency\n        # 2-opt move (structure improvement)\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i + 1 < j:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n        # Insertion move (fine-tuning)\n        if n > 3:\n            k = np.random.randint(0, n)\n            l = np.random.randint(0, n)\n            if k != l:\n                node = new_solution[k]\n                new_solution = np.delete(new_solution, k)\n                new_solution = np.insert(new_solution, l, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6846146153593696,
            3.1583372950553894
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        variances = [max(obj) - min(obj) for _, obj in archive]\n        selected_idx = np.argmax(variances)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 2-opt for structure + insertion for fine-tuning\n    for _ in range(10):  # Limited iterations for efficiency\n        # 2-opt move (structure improvement)\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i + 1 < j:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n        # Insertion move (fine-tuning)\n        if n > 3:\n            k = np.random.randint(0, n)\n            l = np.random.randint(0, n)\n            if k != l:\n                node = new_solution[k]\n                new_solution = np.delete(new_solution, k)\n                new_solution = np.insert(new_solution, l, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 18,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n\n    # Step 1: Apply 2-opt to reduce total distance in one objective\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        # Randomly select an objective to optimize\n        obj_choice = random.choice([distance_matrix_1, distance_matrix_2, distance_matrix_3])\n        current_dist = (obj_choice[new_solution[i-1], new_solution[i]] +\n                        obj_choice[new_solution[j-1], new_solution[j]])\n        new_dist = (obj_choice[new_solution[i-1], new_solution[j-1]] +\n                    obj_choice[new_solution[i], new_solution[j]])\n        if new_dist < current_dist:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Apply node insertion to improve another objective\n    for _ in range(5):\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        # Remove node and try to reinsert elsewhere\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        # Evaluate insertion points based on a different objective\n        obj_choice = random.choice([distance_matrix_1, distance_matrix_2, distance_matrix_3])\n        best_pos = 0\n        best_cost = float('inf')\n        for pos in range(n-1):\n            cost = (obj_choice[new_solution[pos-1], node] +\n                    obj_choice[node, new_solution[pos]] -\n                    obj_choice[new_solution[pos-1], new_solution[pos]])\n            if cost < best_cost:\n                best_cost = cost\n                best_pos = pos\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Step 3: Apply objective-weighted swaps to balance objectives\n    for _ in range(5):\n        i, j = random.sample(range(n), 2)\n        # Calculate current and potential costs for all objectives\n        current_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]],\n            distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]],\n            distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]\n        ]\n        # Weighted improvement calculation\n        improvement = sum((current - new) * w for current, new, w in zip(current_costs, new_costs, [0.3, 0.3, 0.4]))\n        if improvement > 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7952939675274235,
            2.767560303211212
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj)/3 for obj in objectives]\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n\n    # Step 1: Apply 2-opt to reduce total distance in one objective\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        # Randomly select an objective to optimize\n        obj_choice = random.choice([distance_matrix_1, distance_matrix_2, distance_matrix_3])\n        current_dist = (obj_choice[new_solution[i-1], new_solution[i]] +\n                        obj_choice[new_solution[j-1], new_solution[j]])\n        new_dist = (obj_choice[new_solution[i-1], new_solution[j-1]] +\n                    obj_choice[new_solution[i], new_solution[j]])\n        if new_dist < current_dist:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Apply node insertion to improve another objective\n    for _ in range(5):\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        # Remove node and try to reinsert elsewhere\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        # Evaluate insertion points based on a different objective\n        obj_choice = random.choice([distance_matrix_1, distance_matrix_2, distance_matrix_3])\n        best_pos = 0\n        best_cost = float('inf')\n        for pos in range(n-1):\n            cost = (obj_choice[new_solution[pos-1], node] +\n                    obj_choice[node, new_solution[pos]] -\n                    obj_choice[new_solution[pos-1], new_solution[pos]])\n            if cost < best_cost:\n                best_cost = cost\n                best_pos = pos\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Step 3: Apply objective-weighted swaps to balance objectives\n    for _ in range(5):\n        i, j = random.sample(range(n), 2)\n        # Calculate current and potential costs for all objectives\n        current_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]],\n            distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]],\n            distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]\n        ]\n        # Weighted improvement calculation\n        improvement = sum((current - new) * w for current, new, w in zip(current_costs, new_costs, [0.3, 0.3, 0.4]))\n        if improvement > 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 19,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct positions to swap\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Perform the swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Further refine by considering objective-aware edge swaps\n    if np.random.rand() < 0.5:  # 50% chance to apply objective-aware refinement\n        # Select two edges based on their contribution to the worst objective\n        obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        obj3 = sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n\n        worst_obj = max(obj1, obj2, obj3)\n        if worst_obj == obj1:\n            # Find the edge with the highest contribution to obj1\n            max_edge = max(range(n), key=lambda k: distance_matrix_1[new_solution[k], new_solution[(k+1)%n]])\n        elif worst_obj == obj2:\n            max_edge = max(range(n), key=lambda k: distance_matrix_2[new_solution[k], new_solution[(k+1)%n]])\n        else:\n            max_edge = max(range(n), key=lambda k: distance_matrix_3[new_solution[k], new_solution[(k+1)%n]])\n\n        # Swap the nodes at the selected edge\n        new_solution[max_edge], new_solution[(max_edge+1)%n] = new_solution[(max_edge+1)%n], new_solution[max_edge]\n\n    return new_solution\n\n",
        "score": [
            -0.686629763054653,
            1.4375426530838014
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct positions to swap\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Perform the swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Further refine by considering objective-aware edge swaps\n    if np.random.rand() < 0.5:  # 50% chance to apply objective-aware refinement\n        # Select two edges based on their contribution to the worst objective\n        obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        obj3 = sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n\n        worst_obj = max(obj1, obj2, obj3)\n        if worst_obj == obj1:\n            # Find the edge with the highest contribution to obj1\n            max_edge = max(range(n), key=lambda k: distance_matrix_1[new_solution[k], new_solution[(k+1)%n]])\n        elif worst_obj == obj2:\n            max_edge = max(range(n), key=lambda k: distance_matrix_2[new_solution[k], new_solution[(k+1)%n]])\n        else:\n            max_edge = max(range(n), key=lambda k: distance_matrix_3[new_solution[k], new_solution[(k+1)%n]])\n\n        # Swap the nodes at the selected edge\n        new_solution[max_edge], new_solution[(max_edge+1)%n] = new_solution[(max_edge+1)%n], new_solution[max_edge]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 20,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    worst_obj_index = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[worst_obj_index][0].copy()\n    new_solution = base_solution.copy()\n\n    # Determine which objective to prioritize for improvement\n    obj_values = archive[worst_obj_index][1]\n    worst_obj = np.argmax(obj_values)\n\n    # Hybrid local search: 2-opt for the worst objective, followed by edge insertion\n    n = len(new_solution)\n    improved = False\n\n    # 2-opt step: Find the worst edge in the worst objective and try to improve it\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            # Swap edges (i, i+1) and (j, j+1)\n            candidate = new_solution.copy()\n            candidate[i+1:j+1] = candidate[i+1:j+1][::-1]\n\n            # Calculate the change in the worst objective\n            old_cost = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            new_cost = distance_matrix_1[candidate[i], candidate[i+1]] + distance_matrix_1[candidate[j], candidate[(j+1)%n]]\n\n            if worst_obj == 1:\n                old_cost = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n                new_cost = distance_matrix_2[candidate[i], candidate[i+1]] + distance_matrix_2[candidate[j], candidate[(j+1)%n]]\n            elif worst_obj == 2:\n                old_cost = distance_matrix_3[new_solution[i], new_solution[i+1]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n                new_cost = distance_matrix_3[candidate[i], candidate[i+1]] + distance_matrix_3[candidate[j], candidate[(j+1)%n]]\n\n            if new_cost < old_cost:\n                new_solution = candidate\n                improved = True\n                break\n        if improved:\n            break\n\n    # Edge insertion step: Try to improve the solution by relocating edges\n    if not improved:\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    candidate = new_solution.copy()\n                    node = candidate[i]\n                    candidate = np.delete(candidate, i)\n                    candidate = np.insert(candidate, j, node)\n\n                    # Check if this improves the worst objective\n                    old_cost = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n                    new_cost = distance_matrix_1[candidate[j-1], candidate[j]] + distance_matrix_1[candidate[j], candidate[(j+1)%n]]\n\n                    if worst_obj == 1:\n                        old_cost = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n                        new_cost = distance_matrix_2[candidate[j-1], candidate[j]] + distance_matrix_2[candidate[j], candidate[(j+1)%n]]\n                    elif worst_obj == 2:\n                        old_cost = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n                        new_cost = distance_matrix_3[candidate[j-1], candidate[j]] + distance_matrix_3[candidate[j], candidate[(j+1)%n]]\n\n                    if new_cost < old_cost:\n                        new_solution = candidate\n                        improved = True\n                        break\n            if improved:\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.6745649183990582,
            2.1275495529174804
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    worst_obj_index = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[worst_obj_index][0].copy()\n    new_solution = base_solution.copy()\n\n    # Determine which objective to prioritize for improvement\n    obj_values = archive[worst_obj_index][1]\n    worst_obj = np.argmax(obj_values)\n\n    # Hybrid local search: 2-opt for the worst objective, followed by edge insertion\n    n = len(new_solution)\n    improved = False\n\n    # 2-opt step: Find the worst edge in the worst objective and try to improve it\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            # Swap edges (i, i+1) and (j, j+1)\n            candidate = new_solution.copy()\n            candidate[i+1:j+1] = candidate[i+1:j+1][::-1]\n\n            # Calculate the change in the worst objective\n            old_cost = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            new_cost = distance_matrix_1[candidate[i], candidate[i+1]] + distance_matrix_1[candidate[j], candidate[(j+1)%n]]\n\n            if worst_obj == 1:\n                old_cost = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n                new_cost = distance_matrix_2[candidate[i], candidate[i+1]] + distance_matrix_2[candidate[j], candidate[(j+1)%n]]\n            elif worst_obj == 2:\n                old_cost = distance_matrix_3[new_solution[i], new_solution[i+1]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n                new_cost = distance_matrix_3[candidate[i], candidate[i+1]] + distance_matrix_3[candidate[j], candidate[(j+1)%n]]\n\n            if new_cost < old_cost:\n                new_solution = candidate\n                improved = True\n                break\n        if improved:\n            break\n\n    # Edge insertion step: Try to improve the solution by relocating edges\n    if not improved:\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    candidate = new_solution.copy()\n                    node = candidate[i]\n                    candidate = np.delete(candidate, i)\n                    candidate = np.insert(candidate, j, node)\n\n                    # Check if this improves the worst objective\n                    old_cost = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n                    new_cost = distance_matrix_1[candidate[j-1], candidate[j]] + distance_matrix_1[candidate[j], candidate[(j+1)%n]]\n\n                    if worst_obj == 1:\n                        old_cost = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n                        new_cost = distance_matrix_2[candidate[j-1], candidate[j]] + distance_matrix_2[candidate[j], candidate[(j+1)%n]]\n                    elif worst_obj == 2:\n                        old_cost = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n                        new_cost = distance_matrix_3[candidate[j-1], candidate[j]] + distance_matrix_3[candidate[j], candidate[(j+1)%n]]\n\n                    if new_cost < old_cost:\n                        new_solution = candidate\n                        improved = True\n                        break\n            if improved:\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 21,
        "algorithm": "{A heuristic function that intelligently selects a promising solution from an archive, applies a novel hybrid local search operator combining edge swaps, 2-opt moves, and objective-aware segment reversals to generate a neighbor solution while ensuring feasibility, and prioritizes solutions with higher potential for multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search\n    n = len(new_solution)\n\n    # Step 1: Random edge swap\n    if n > 2:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: 2-opt move for one objective\n    if n > 3:\n        obj = np.random.randint(0, 3)\n        if obj == 0:\n            dist_matrix = distance_matrix_1\n        elif obj == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n\n        current_cost = dist_matrix[new_solution[i-1], new_solution[i]] + dist_matrix[new_solution[j], new_solution[(j+1)%n]]\n        new_cost = dist_matrix[new_solution[i-1], reversed_segment[0]] + dist_matrix[reversed_segment[-1], new_solution[(j+1)%n]]\n\n        if new_cost < current_cost:\n            new_solution[i:j+1] = reversed_segment\n\n    # Step 3: Objective-aware segment reversal\n    if n > 4:\n        obj_weights = np.array([1.0, 1.0, 1.0])  # Equal weights for all objectives\n        obj_improvement = np.zeros(3)\n\n        # Calculate potential improvement for each objective\n        for obj in range(3):\n            if obj == 0:\n                dist_matrix = distance_matrix_1\n            elif obj == 1:\n                dist_matrix = distance_matrix_2\n            else:\n                dist_matrix = distance_matrix_3\n\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            segment = new_solution[i:j+1]\n            reversed_segment = segment[::-1]\n\n            current_cost = dist_matrix[new_solution[i-1], new_solution[i]] + dist_matrix[new_solution[j], new_solution[(j+1)%n]]\n            new_cost = dist_matrix[new_solution[i-1], reversed_segment[0]] + dist_matrix[reversed_segment[-1], new_solution[(j+1)%n]]\n\n            obj_improvement[obj] = current_cost - new_cost\n\n        # Select objective with highest potential improvement\n        selected_obj = np.argmax(obj_weights * obj_improvement)\n\n        # Apply reversal for selected objective\n        if selected_obj == 0:\n            dist_matrix = distance_matrix_1\n        elif selected_obj == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n\n        current_cost = dist_matrix[new_solution[i-1], new_solution[i]] + dist_matrix[new_solution[j], new_solution[(j+1)%n]]\n        new_cost = dist_matrix[new_solution[i-1], reversed_segment[0]] + dist_matrix[reversed_segment[-1], new_solution[(j+1)%n]]\n\n        if new_cost < current_cost:\n            new_solution[i:j+1] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8032957031342456,
            2.469921863079071
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search\n    n = len(new_solution)\n\n    # Step 1: Random edge swap\n    if n > 2:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: 2-opt move for one objective\n    if n > 3:\n        obj = np.random.randint(0, 3)\n        if obj == 0:\n            dist_matrix = distance_matrix_1\n        elif obj == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n\n        current_cost = dist_matrix[new_solution[i-1], new_solution[i]] + dist_matrix[new_solution[j], new_solution[(j+1)%n]]\n        new_cost = dist_matrix[new_solution[i-1], reversed_segment[0]] + dist_matrix[reversed_segment[-1], new_solution[(j+1)%n]]\n\n        if new_cost < current_cost:\n            new_solution[i:j+1] = reversed_segment\n\n    # Step 3: Objective-aware segment reversal\n    if n > 4:\n        obj_weights = np.array([1.0, 1.0, 1.0])  # Equal weights for all objectives\n        obj_improvement = np.zeros(3)\n\n        # Calculate potential improvement for each objective\n        for obj in range(3):\n            if obj == 0:\n                dist_matrix = distance_matrix_1\n            elif obj == 1:\n                dist_matrix = distance_matrix_2\n            else:\n                dist_matrix = distance_matrix_3\n\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            segment = new_solution[i:j+1]\n            reversed_segment = segment[::-1]\n\n            current_cost = dist_matrix[new_solution[i-1], new_solution[i]] + dist_matrix[new_solution[j], new_solution[(j+1)%n]]\n            new_cost = dist_matrix[new_solution[i-1], reversed_segment[0]] + dist_matrix[reversed_segment[-1], new_solution[(j+1)%n]]\n\n            obj_improvement[obj] = current_cost - new_cost\n\n        # Select objective with highest potential improvement\n        selected_obj = np.argmax(obj_weights * obj_improvement)\n\n        # Apply reversal for selected objective\n        if selected_obj == 0:\n            dist_matrix = distance_matrix_1\n        elif selected_obj == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n\n        current_cost = dist_matrix[new_solution[i-1], new_solution[i]] + dist_matrix[new_solution[j], new_solution[(j+1)%n]]\n        new_cost = dist_matrix[new_solution[i-1], reversed_segment[0]] + dist_matrix[reversed_segment[-1], new_solution[(j+1)%n]]\n\n        if new_cost < current_cost:\n            new_solution[i:j+1] = reversed_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 22,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    N = len(best_solution)\n    new_solution = best_solution.copy()\n\n    # Randomly select two distinct edges to swap (2-opt)\n    i, j = sorted(random.sample(range(N), 2))\n\n    # Ensure the swap maintains a valid tour\n    if i != 0 and j != N-1:\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Further refine by considering the most critical edge in each objective space\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        # Find the worst edge in this objective space\n        worst_edge = None\n        max_dist = -1\n        for k in range(N):\n            u = best_solution[k]\n            v = best_solution[(k+1)%N]\n            dist = distance_matrix[u, v]\n            if dist > max_dist:\n                max_dist = dist\n                worst_edge = k\n\n        # If the worst edge is in the selected segment, swap it with a better edge\n        if worst_edge is not None and worst_edge >= i and worst_edge < j:\n            # Find the best possible replacement edge\n            best_replacement = None\n            min_dist = float('inf')\n            for k in range(N):\n                if k == worst_edge or k == (worst_edge+1)%N:\n                    continue\n                u = best_solution[k]\n                v = best_solution[(k+1)%N]\n                dist = distance_matrix[u, v]\n                if dist < min_dist:\n                    min_dist = dist\n                    best_replacement = k\n\n            if best_replacement is not None:\n                # Perform the swap\n                new_solution[worst_edge], new_solution[best_replacement] = new_solution[best_replacement], new_solution[worst_edge]\n\n    return new_solution\n\n",
        "score": [
            -0.748534155399615,
            1.355953848361969
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    N = len(best_solution)\n    new_solution = best_solution.copy()\n\n    # Randomly select two distinct edges to swap (2-opt)\n    i, j = sorted(random.sample(range(N), 2))\n\n    # Ensure the swap maintains a valid tour\n    if i != 0 and j != N-1:\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Further refine by considering the most critical edge in each objective space\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        # Find the worst edge in this objective space\n        worst_edge = None\n        max_dist = -1\n        for k in range(N):\n            u = best_solution[k]\n            v = best_solution[(k+1)%N]\n            dist = distance_matrix[u, v]\n            if dist > max_dist:\n                max_dist = dist\n                worst_edge = k\n\n        # If the worst edge is in the selected segment, swap it with a better edge\n        if worst_edge is not None and worst_edge >= i and worst_edge < j:\n            # Find the best possible replacement edge\n            best_replacement = None\n            min_dist = float('inf')\n            for k in range(N):\n                if k == worst_edge or k == (worst_edge+1)%N:\n                    continue\n                u = best_solution[k]\n                v = best_solution[(k+1)%N]\n                dist = distance_matrix[u, v]\n                if dist < min_dist:\n                    min_dist = dist\n                    best_replacement = k\n\n            if best_replacement is not None:\n                # Perform the swap\n                new_solution[worst_edge], new_solution[best_replacement] = new_solution[best_replacement], new_solution[worst_edge]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 23,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with objective-aware selection\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Evaluate the current and reversed segment in all three objectives\n    def evaluate_segment(sol, start, end):\n        cost1 = distance_matrix_1[sol[start], sol[(start + 1) % n]]\n        cost2 = distance_matrix_2[sol[start], sol[(start + 1) % n]]\n        cost3 = distance_matrix_3[sol[start], sol[(start + 1) % n]]\n        for k in range(start + 1, end):\n            cost1 += distance_matrix_1[sol[k], sol[(k + 1) % n]]\n            cost2 += distance_matrix_2[sol[k], sol[(k + 1) % n]]\n            cost3 += distance_matrix_3[sol[k], sol[(k + 1) % n]]\n        return (cost1, cost2, cost3)\n\n    current_cost = evaluate_segment(new_solution, i, j)\n    reversed_segment = new_solution[i:j+1][::-1]\n    new_solution[i:j+1] = reversed_segment\n    new_cost = evaluate_segment(new_solution, i, j)\n\n    # If the reversed segment improves at least one objective, keep it; otherwise revert\n    if any(nc < cc for nc, cc in zip(new_cost, current_cost)):\n        return new_solution\n    else:\n        new_solution[i:j+1] = reversed_segment[::-1]  # Revert\n        return new_solution\n\n",
        "score": [
            -0.7764229707446951,
            1.7386518716812134
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with objective-aware selection\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Evaluate the current and reversed segment in all three objectives\n    def evaluate_segment(sol, start, end):\n        cost1 = distance_matrix_1[sol[start], sol[(start + 1) % n]]\n        cost2 = distance_matrix_2[sol[start], sol[(start + 1) % n]]\n        cost3 = distance_matrix_3[sol[start], sol[(start + 1) % n]]\n        for k in range(start + 1, end):\n            cost1 += distance_matrix_1[sol[k], sol[(k + 1) % n]]\n            cost2 += distance_matrix_2[sol[k], sol[(k + 1) % n]]\n            cost3 += distance_matrix_3[sol[k], sol[(k + 1) % n]]\n        return (cost1, cost2, cost3)\n\n    current_cost = evaluate_segment(new_solution, i, j)\n    reversed_segment = new_solution[i:j+1][::-1]\n    new_solution[i:j+1] = reversed_segment\n    new_cost = evaluate_segment(new_solution, i, j)\n\n    # If the reversed segment improves at least one objective, keep it; otherwise revert\n    if any(nc < cc for nc, cc in zip(new_cost, current_cost)):\n        return new_solution\n    else:\n        new_solution[i:j+1] = reversed_segment[::-1]  # Revert\n        return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 24,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Step 2: Identify critical segments in the tour that contribute most to the total cost\n    # Calculate the cost of each edge in the tour for each objective\n    n = len(selected_solution)\n    edge_costs_1 = [distance_matrix_1[selected_solution[i], selected_solution[(i+1)%n]] for i in range(n)]\n    edge_costs_2 = [distance_matrix_2[selected_solution[i], selected_solution[(i+1)%n]] for i in range(n)]\n    edge_costs_3 = [distance_matrix_3[selected_solution[i], selected_solution[(i+1)%n]] for i in range(n)]\n\n    # Step 3: Apply a hybrid local search operator\n    # Combine 2-opt with a novel objective-aware edge selection strategy\n    improved = False\n    for _ in range(10):  # Limit iterations to balance exploration and exploitation\n        # Select a random segment to consider for improvement\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the total cost of the current segment\n        current_cost = sum(edge_costs_1[i:j+1]) + sum(edge_costs_2[i:j+1]) + sum(edge_costs_3[i:j+1])\n\n        # Generate a candidate solution by reversing the segment\n        candidate = selected_solution.copy()\n        candidate[i:j+1] = np.flip(candidate[i:j+1])\n\n        # Calculate the new cost of the reversed segment\n        new_edge_costs_1 = [distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n)]\n        new_edge_costs_2 = [distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n)]\n        new_edge_costs_3 = [distance_matrix_3[candidate[k], candidate[(k+1)%n]] for k in range(n)]\n        new_cost = sum(new_edge_costs_1[i:j+1]) + sum(new_edge_costs_2[i:j+1]) + sum(new_edge_costs_3[i:j+1])\n\n        # If the new cost is better, accept the move\n        if new_cost < current_cost:\n            selected_solution = candidate\n            edge_costs_1 = new_edge_costs_1\n            edge_costs_2 = new_edge_costs_2\n            edge_costs_3 = new_edge_costs_3\n            improved = True\n\n    # If no improvement was found, apply a random swap to maintain diversity\n    if not improved:\n        i, j = np.random.choice(n, 2, replace=False)\n        selected_solution[i], selected_solution[j] = selected_solution[j], selected_solution[i]\n\n    return selected_solution\n\n",
        "score": [
            -0.6934166556800967,
            3.2122700452804565
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Step 2: Identify critical segments in the tour that contribute most to the total cost\n    # Calculate the cost of each edge in the tour for each objective\n    n = len(selected_solution)\n    edge_costs_1 = [distance_matrix_1[selected_solution[i], selected_solution[(i+1)%n]] for i in range(n)]\n    edge_costs_2 = [distance_matrix_2[selected_solution[i], selected_solution[(i+1)%n]] for i in range(n)]\n    edge_costs_3 = [distance_matrix_3[selected_solution[i], selected_solution[(i+1)%n]] for i in range(n)]\n\n    # Step 3: Apply a hybrid local search operator\n    # Combine 2-opt with a novel objective-aware edge selection strategy\n    improved = False\n    for _ in range(10):  # Limit iterations to balance exploration and exploitation\n        # Select a random segment to consider for improvement\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the total cost of the current segment\n        current_cost = sum(edge_costs_1[i:j+1]) + sum(edge_costs_2[i:j+1]) + sum(edge_costs_3[i:j+1])\n\n        # Generate a candidate solution by reversing the segment\n        candidate = selected_solution.copy()\n        candidate[i:j+1] = np.flip(candidate[i:j+1])\n\n        # Calculate the new cost of the reversed segment\n        new_edge_costs_1 = [distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n)]\n        new_edge_costs_2 = [distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n)]\n        new_edge_costs_3 = [distance_matrix_3[candidate[k], candidate[(k+1)%n]] for k in range(n)]\n        new_cost = sum(new_edge_costs_1[i:j+1]) + sum(new_edge_costs_2[i:j+1]) + sum(new_edge_costs_3[i:j+1])\n\n        # If the new cost is better, accept the move\n        if new_cost < current_cost:\n            selected_solution = candidate\n            edge_costs_1 = new_edge_costs_1\n            edge_costs_2 = new_edge_costs_2\n            edge_costs_3 = new_edge_costs_3\n            improved = True\n\n    # If no improvement was found, apply a random swap to maintain diversity\n    if not improved:\n        i, j = np.random.choice(n, 2, replace=False)\n        selected_solution[i], selected_solution[j] = selected_solution[j], selected_solution[i]\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 25,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: apply a combination of 2-opt and objective-specific perturbations\n    n = len(new_solution)\n    if n < 2:\n        return new_solution\n\n    # Randomly decide whether to use 2-opt or objective-specific perturbation\n    if random.random() < 0.5:\n        # 2-opt local search: swap two random segments\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Objective-specific perturbation: identify the worst objective and improve it\n        objectives = archive[selected_idx][1]\n        worst_obj = np.argmax(objectives)\n\n        if worst_obj == 0:\n            # Improve first objective: find the longest edge in the first space and reverse it\n            max_dist = -1\n            max_i = 0\n            for i in range(n):\n                dist = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n                if dist > max_dist:\n                    max_dist = dist\n                    max_i = i\n            new_solution[max_i], new_solution[(max_i+1)%n] = new_solution[(max_i+1)%n], new_solution[max_i]\n        elif worst_obj == 1:\n            # Improve second objective: find the longest edge in the second space and reverse it\n            max_dist = -1\n            max_i = 0\n            for i in range(n):\n                dist = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n                if dist > max_dist:\n                    max_dist = dist\n                    max_i = i\n            new_solution[max_i], new_solution[(max_i+1)%n] = new_solution[(max_i+1)%n], new_solution[max_i]\n        else:\n            # Improve third objective: find the longest edge in the third space and reverse it\n            max_dist = -1\n            max_i = 0\n            for i in range(n):\n                dist = distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n                if dist > max_dist:\n                    max_dist = dist\n                    max_i = i\n            new_solution[max_i], new_solution[(max_i+1)%n] = new_solution[(max_i+1)%n], new_solution[max_i]\n\n    return new_solution\n\n",
        "score": [
            -0.7660327703526266,
            1.4985243916511535
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: apply a combination of 2-opt and objective-specific perturbations\n    n = len(new_solution)\n    if n < 2:\n        return new_solution\n\n    # Randomly decide whether to use 2-opt or objective-specific perturbation\n    if random.random() < 0.5:\n        # 2-opt local search: swap two random segments\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Objective-specific perturbation: identify the worst objective and improve it\n        objectives = archive[selected_idx][1]\n        worst_obj = np.argmax(objectives)\n\n        if worst_obj == 0:\n            # Improve first objective: find the longest edge in the first space and reverse it\n            max_dist = -1\n            max_i = 0\n            for i in range(n):\n                dist = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n                if dist > max_dist:\n                    max_dist = dist\n                    max_i = i\n            new_solution[max_i], new_solution[(max_i+1)%n] = new_solution[(max_i+1)%n], new_solution[max_i]\n        elif worst_obj == 1:\n            # Improve second objective: find the longest edge in the second space and reverse it\n            max_dist = -1\n            max_i = 0\n            for i in range(n):\n                dist = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n                if dist > max_dist:\n                    max_dist = dist\n                    max_i = i\n            new_solution[max_i], new_solution[(max_i+1)%n] = new_solution[(max_i+1)%n], new_solution[max_i]\n        else:\n            # Improve third objective: find the longest edge in the third space and reverse it\n            max_dist = -1\n            max_i = 0\n            for i in range(n):\n                dist = distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n                if dist > max_dist:\n                    max_dist = dist\n                    max_i = i\n            new_solution[max_i], new_solution[(max_i+1)%n] = new_solution[(max_i+1)%n], new_solution[max_i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 26,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate crowding distances for each objective\n        objectives = np.array([obj for _, obj in archive])\n        crowding_distances = np.zeros(len(archive))\n\n        for m in range(3):\n            sorted_idx = np.argsort(objectives[:, m])\n            sorted_obj = objectives[sorted_idx, m]\n            crowding_distances[sorted_idx[0]] = np.inf\n            crowding_distances[sorted_idx[-1]] = np.inf\n            for i in range(1, len(archive) - 1):\n                crowding_distances[sorted_idx[i]] += (sorted_obj[i + 1] - sorted_obj[i - 1]) / (sorted_obj[-1] - sorted_obj[0] + 1e-10)\n\n        # Select the solution with the highest crowding distance\n        selected_idx = np.argmax(crowding_distances)\n        base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges based on their potential to improve objectives\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while i == j or (i + 1) % n == j or (j + 1) % n == i:\n        j = np.random.randint(0, n)\n\n    # Determine the edges to swap\n    a, b = sorted([i, j])\n    c, d = (a + 1) % n, (b + 1) % n\n\n    # Calculate the change in objectives for the swap\n    def calculate_delta(a, b, c, d):\n        delta1 = (distance_matrix_1[new_solution[a], new_solution[d]] +\n                 distance_matrix_1[new_solution[b], new_solution[c]]) - \\\n                (distance_matrix_1[new_solution[a], new_solution[b]] +\n                 distance_matrix_1[new_solution[c], new_solution[d]])\n        delta2 = (distance_matrix_2[new_solution[a], new_solution[d]] +\n                 distance_matrix_2[new_solution[b], new_solution[c]]) - \\\n                (distance_matrix_2[new_solution[a], new_solution[b]] +\n                 distance_matrix_2[new_solution[c], new_solution[d]])\n        delta3 = (distance_matrix_3[new_solution[a], new_solution[d]] +\n                 distance_matrix_3[new_solution[b], new_solution[c]]) - \\\n                (distance_matrix_3[new_solution[a], new_solution[b]] +\n                 distance_matrix_3[new_solution[c], new_solution[d]])\n        return delta1, delta2, delta3\n\n    delta1, delta2, delta3 = calculate_delta(a, b, c, d)\n\n    # If the swap improves at least one objective, apply it\n    if delta1 < 0 or delta2 < 0 or delta3 < 0:\n        new_solution[a+1:b+1] = new_solution[a+1:b+1][::-1]\n\n    # Apply a second 2-opt with a different edge selection strategy\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while i == j or (i + 1) % n == j or (j + 1) % n == i:\n        j = np.random.randint(0, n)\n\n    a, b = sorted([i, j])\n    c, d = (a + 1) % n, (b + 1) % n\n\n    delta1, delta2, delta3 = calculate_delta(a, b, c, d)\n\n    if delta1 < 0 or delta2 < 0 or delta3 < 0:\n        new_solution[a+1:b+1] = new_solution[a+1:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5586125024147812,
            2.8870884776115417
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate crowding distances for each objective\n        objectives = np.array([obj for _, obj in archive])\n        crowding_distances = np.zeros(len(archive))\n\n        for m in range(3):\n            sorted_idx = np.argsort(objectives[:, m])\n            sorted_obj = objectives[sorted_idx, m]\n            crowding_distances[sorted_idx[0]] = np.inf\n            crowding_distances[sorted_idx[-1]] = np.inf\n            for i in range(1, len(archive) - 1):\n                crowding_distances[sorted_idx[i]] += (sorted_obj[i + 1] - sorted_obj[i - 1]) / (sorted_obj[-1] - sorted_obj[0] + 1e-10)\n\n        # Select the solution with the highest crowding distance\n        selected_idx = np.argmax(crowding_distances)\n        base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges based on their potential to improve objectives\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while i == j or (i + 1) % n == j or (j + 1) % n == i:\n        j = np.random.randint(0, n)\n\n    # Determine the edges to swap\n    a, b = sorted([i, j])\n    c, d = (a + 1) % n, (b + 1) % n\n\n    # Calculate the change in objectives for the swap\n    def calculate_delta(a, b, c, d):\n        delta1 = (distance_matrix_1[new_solution[a], new_solution[d]] +\n                 distance_matrix_1[new_solution[b], new_solution[c]]) - \\\n                (distance_matrix_1[new_solution[a], new_solution[b]] +\n                 distance_matrix_1[new_solution[c], new_solution[d]])\n        delta2 = (distance_matrix_2[new_solution[a], new_solution[d]] +\n                 distance_matrix_2[new_solution[b], new_solution[c]]) - \\\n                (distance_matrix_2[new_solution[a], new_solution[b]] +\n                 distance_matrix_2[new_solution[c], new_solution[d]])\n        delta3 = (distance_matrix_3[new_solution[a], new_solution[d]] +\n                 distance_matrix_3[new_solution[b], new_solution[c]]) - \\\n                (distance_matrix_3[new_solution[a], new_solution[b]] +\n                 distance_matrix_3[new_solution[c], new_solution[d]])\n        return delta1, delta2, delta3\n\n    delta1, delta2, delta3 = calculate_delta(a, b, c, d)\n\n    # If the swap improves at least one objective, apply it\n    if delta1 < 0 or delta2 < 0 or delta3 < 0:\n        new_solution[a+1:b+1] = new_solution[a+1:b+1][::-1]\n\n    # Apply a second 2-opt with a different edge selection strategy\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while i == j or (i + 1) % n == j or (j + 1) % n == i:\n        j = np.random.randint(0, n)\n\n    a, b = sorted([i, j])\n    c, d = (a + 1) % n, (b + 1) % n\n\n    delta1, delta2, delta3 = calculate_delta(a, b, c, d)\n\n    if delta1 < 0 or delta2 < 0 or delta3 < 0:\n        new_solution[a+1:b+1] = new_solution[a+1:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 27,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / 3)\n    base_solution = base_solution.copy()\n\n    # Select a random segment of the tour to perturb\n    n = len(base_solution)\n    start = np.random.randint(0, n)\n    length = np.random.randint(2, min(5, n // 2))\n    end = (start + length) % n\n\n    # Extract the segment\n    if start < end:\n        segment = base_solution[start:end]\n    else:\n        segment = np.concatenate([base_solution[start:], base_solution[:end]])\n\n    # Reverse the segment to create a new solution\n    new_segment = segment[::-1]\n    new_solution = base_solution.copy()\n\n    # Replace the segment in the new solution\n    if start < end:\n        new_solution[start:end] = new_segment\n    else:\n        new_solution[start:] = new_segment[:n-start]\n        new_solution[:end] = new_segment[n-start:]\n\n    return new_solution\n\n",
        "score": [
            -0.7372620252539154,
            2.36218546628952
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]) / 3)\n    base_solution = base_solution.copy()\n\n    # Select a random segment of the tour to perturb\n    n = len(base_solution)\n    start = np.random.randint(0, n)\n    length = np.random.randint(2, min(5, n // 2))\n    end = (start + length) % n\n\n    # Extract the segment\n    if start < end:\n        segment = base_solution[start:end]\n    else:\n        segment = np.concatenate([base_solution[start:], base_solution[:end]])\n\n    # Reverse the segment to create a new solution\n    new_segment = segment[::-1]\n    new_solution = base_solution.copy()\n\n    # Replace the segment in the new solution\n    if start < end:\n        new_solution[start:end] = new_segment\n    else:\n        new_solution[start:] = new_segment[:n-start]\n        new_solution[:end] = new_segment[n-start:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 28,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to break and reconnect\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Ensure the reconnection is feasible\n    if i != k and j != l:\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # Swap the segments between k and l\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.7168256410781572,
            1.2065644025802613
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to break and reconnect\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Ensure the reconnection is feasible\n    if i != k and j != l:\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # Swap the segments between k and l\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 29,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with the lowest combined objective values, then applies a hybrid local search operator that combines 2-opt with a novel multi-objective edge swap strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the lowest combined objective value\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Apply hybrid local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to apply 2-opt\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    # Apply 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply multi-objective edge swap\n    for _ in range(2):  # Perform a few swaps\n        a, b = sorted(random.sample(range(n), 2))\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] -\n                  distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                  distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] -\n                  distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                  distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_3[new_solution[b], new_solution[(a+1)%n]] -\n                  distance_matrix_3[new_solution[a-1], new_solution[a]] -\n                  distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7279396866848229,
            0.955235481262207
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the lowest combined objective value\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Apply hybrid local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to apply 2-opt\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    # Apply 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply multi-objective edge swap\n    for _ in range(2):  # Perform a few swaps\n        a, b = sorted(random.sample(range(n), 2))\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] -\n                  distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                  distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] -\n                  distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                  distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_3[new_solution[b], new_solution[(a+1)%n]] -\n                  distance_matrix_3[new_solution[a-1], new_solution[a]] -\n                  distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 29,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with the lowest combined objective values, then applies a hybrid local search operator that combines 2-opt with a novel multi-objective edge swap strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the lowest combined objective value\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Apply hybrid local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to apply 2-opt\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    # Apply 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply multi-objective edge swap\n    for _ in range(2):  # Perform a few swaps\n        a, b = sorted(random.sample(range(n), 2))\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] -\n                  distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                  distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] -\n                  distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                  distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_3[new_solution[b], new_solution[(a+1)%n]] -\n                  distance_matrix_3[new_solution[a-1], new_solution[a]] -\n                  distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7279396866848229,
            0.955235481262207
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the lowest combined objective value\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Apply hybrid local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to apply 2-opt\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    # Apply 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply multi-objective edge swap\n    for _ in range(2):  # Perform a few swaps\n        a, b = sorted(random.sample(range(n), 2))\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] -\n                  distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                  distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] -\n                  distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                  distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_3[new_solution[b], new_solution[(a+1)%n]] -\n                  distance_matrix_3[new_solution[a-1], new_solution[a]] -\n                  distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 30,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def weighted_sum(objective, weights=(1, 1, 1)):\n        return sum(w * o for w, o in zip(weights, objective))\n\n    # Normalize objectives to avoid bias\n    objectives = [obj for _, obj in archive]\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_obj = [(obj - min_obj) / (max_obj - min_obj + 1e-10) for obj in objectives]\n\n    # Select the solution with the best normalized weighted sum\n    best_idx = np.argmin([weighted_sum(normalized_obj[i]) for i in range(len(archive))])\n    base_solution = archive[best_idx][0].copy()\n\n    # Apply a novel hybrid local search operator: 3-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three edges to break and reconnect\n    i, j, k = sorted(np.random.choice(range(n), size=3, replace=False))\n\n    # Determine the best reconnection based on the combined distance improvement\n    def calculate_improvement(a, b, c, d):\n        # Calculate the change in total distance across all three objectives\n        delta = (distance_matrix_1[a, b] + distance_matrix_1[c, d] - distance_matrix_1[a, c] - distance_matrix_1[b, d] +\n                 distance_matrix_2[a, b] + distance_matrix_2[c, d] - distance_matrix_2[a, c] - distance_matrix_2[b, d] +\n                 distance_matrix_3[a, b] + distance_matrix_3[c, d] - distance_matrix_3[a, c] - distance_matrix_3[b, d])\n        return delta\n\n    # Try all possible reconnections and select the best one\n    best_delta = float('inf')\n    best_reconnection = None\n\n    # Try reconnecting edges in all possible ways\n    for a, b, c in [(i, j, k), (i, k, j), (j, i, k), (j, k, i), (k, i, j), (k, j, i)]:\n        delta = calculate_improvement(new_solution[a], new_solution[b], new_solution[c], new_solution[(a+1)%n])\n        if delta < best_delta:\n            best_delta = delta\n            best_reconnection = (a, b, c)\n\n    if best_reconnection is not None:\n        a, b, c = best_reconnection\n        # Perform the reconnection\n        new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.609666656828707,
            2.141381859779358
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def weighted_sum(objective, weights=(1, 1, 1)):\n        return sum(w * o for w, o in zip(weights, objective))\n\n    # Normalize objectives to avoid bias\n    objectives = [obj for _, obj in archive]\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_obj = [(obj - min_obj) / (max_obj - min_obj + 1e-10) for obj in objectives]\n\n    # Select the solution with the best normalized weighted sum\n    best_idx = np.argmin([weighted_sum(normalized_obj[i]) for i in range(len(archive))])\n    base_solution = archive[best_idx][0].copy()\n\n    # Apply a novel hybrid local search operator: 3-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three edges to break and reconnect\n    i, j, k = sorted(np.random.choice(range(n), size=3, replace=False))\n\n    # Determine the best reconnection based on the combined distance improvement\n    def calculate_improvement(a, b, c, d):\n        # Calculate the change in total distance across all three objectives\n        delta = (distance_matrix_1[a, b] + distance_matrix_1[c, d] - distance_matrix_1[a, c] - distance_matrix_1[b, d] +\n                 distance_matrix_2[a, b] + distance_matrix_2[c, d] - distance_matrix_2[a, c] - distance_matrix_2[b, d] +\n                 distance_matrix_3[a, b] + distance_matrix_3[c, d] - distance_matrix_3[a, c] - distance_matrix_3[b, d])\n        return delta\n\n    # Try all possible reconnections and select the best one\n    best_delta = float('inf')\n    best_reconnection = None\n\n    # Try reconnecting edges in all possible ways\n    for a, b, c in [(i, j, k), (i, k, j), (j, i, k), (j, k, i), (k, i, j), (k, j, i)]:\n        delta = calculate_improvement(new_solution[a], new_solution[b], new_solution[c], new_solution[(a+1)%n])\n        if delta < best_delta:\n            best_delta = delta\n            best_reconnection = (a, b, c)\n\n    if best_reconnection is not None:\n        a, b, c = best_reconnection\n        # Perform the reconnection\n        new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 31,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high variance in objectives (indicating potential for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    obj_std = np.std(objectives, axis=0)\n    weighted_scores = np.sum(obj_std * objectives, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to potentially swap\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Calculate the change in objectives for the 2-opt move\n    def calculate_delta(a, b, c, d):\n        delta1 = (distance_matrix_1[a, b] + distance_matrix_1[c, d]) - (distance_matrix_1[a, c] + distance_matrix_1[b, d])\n        delta2 = (distance_matrix_2[a, b] + distance_matrix_2[c, d]) - (distance_matrix_2[a, c] + distance_matrix_2[b, d])\n        delta3 = (distance_matrix_3[a, b] + distance_matrix_3[c, d]) - (distance_matrix_3[a, c] + distance_matrix_3[b, d])\n        return delta1, delta2, delta3\n\n    delta = calculate_delta(new_solution[i], new_solution[j], new_solution[k], new_solution[l])\n\n    # Apply the move if it improves at least one objective\n    if any(d < 0 for d in delta):\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Additional objective-aware perturbation\n    if np.random.random() < 0.3:  # 30% chance to apply perturbation\n        worst_obj = np.argmax(archive[selected_idx][1])\n        if worst_obj == 0:\n            # Perturb for first objective\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        elif worst_obj == 1:\n            # Perturb for second objective\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Perturb for third objective\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6295214131480387,
            1.9490790367126465
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high variance in objectives (indicating potential for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    obj_std = np.std(objectives, axis=0)\n    weighted_scores = np.sum(obj_std * objectives, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to potentially swap\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Calculate the change in objectives for the 2-opt move\n    def calculate_delta(a, b, c, d):\n        delta1 = (distance_matrix_1[a, b] + distance_matrix_1[c, d]) - (distance_matrix_1[a, c] + distance_matrix_1[b, d])\n        delta2 = (distance_matrix_2[a, b] + distance_matrix_2[c, d]) - (distance_matrix_2[a, c] + distance_matrix_2[b, d])\n        delta3 = (distance_matrix_3[a, b] + distance_matrix_3[c, d]) - (distance_matrix_3[a, c] + distance_matrix_3[b, d])\n        return delta1, delta2, delta3\n\n    delta = calculate_delta(new_solution[i], new_solution[j], new_solution[k], new_solution[l])\n\n    # Apply the move if it improves at least one objective\n    if any(d < 0 for d in delta):\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Additional objective-aware perturbation\n    if np.random.random() < 0.3:  # 30% chance to apply perturbation\n        worst_obj = np.argmax(archive[selected_idx][1])\n        if worst_obj == 0:\n            # Perturb for first objective\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        elif worst_obj == 1:\n            # Perturb for second objective\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Perturb for third objective\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 32,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate diversity scores (variance across objectives)\n        diversity_scores = []\n        for sol, obj in archive:\n            diversity = (max(obj) - min(obj)) / (sum(obj) + 1e-8)  # Normalize by sum to avoid large values\n            diversity_scores.append(diversity)\n\n        # Select the solution with the highest diversity\n        selected_idx = np.argmax(diversity_scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of 2-opt and edge insertion\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Randomly select two distinct edges to modify\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # Apply 2-opt to reverse a segment\n        segment = new_solution[i:j+1]\n        new_solution[i:j+1] = segment[::-1]\n\n        # Check feasibility (no duplicates and all nodes visited)\n        if len(np.unique(new_solution)) == n:\n            break  # Valid neighbor found\n\n    # If 2-opt didn't work, try edge insertion\n    if len(np.unique(new_solution)) != n:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.4309065162712515,
            2.1673324346542358
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate diversity scores (variance across objectives)\n        diversity_scores = []\n        for sol, obj in archive:\n            diversity = (max(obj) - min(obj)) / (sum(obj) + 1e-8)  # Normalize by sum to avoid large values\n            diversity_scores.append(diversity)\n\n        # Select the solution with the highest diversity\n        selected_idx = np.argmax(diversity_scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of 2-opt and edge insertion\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Randomly select two distinct edges to modify\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # Apply 2-opt to reverse a segment\n        segment = new_solution[i:j+1]\n        new_solution[i:j+1] = segment[::-1]\n\n        # Check feasibility (no duplicates and all nodes visited)\n        if len(np.unique(new_solution)) == n:\n            break  # Valid neighbor found\n\n    # If 2-opt didn't work, try edge insertion\n    if len(np.unique(new_solution)) != n:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 33,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the lowest sum of objectives (promising for improvement)\n    selected = min(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to break and reconnect, prioritizing edges with high potential for improvement\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Ensure the new edges are valid and improve at least one objective\n    def is_valid_and_improving(a, b, c, d):\n        # Check if the new edges (a->b and c->d) improve at least one objective\n        old_costs = [\n            distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n            distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n            distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n            distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n            distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] +\n            distance_matrix_3[new_solution[b], new_solution[(b+1)%n]]\n        ]\n\n        new_costs = [\n            distance_matrix_1[new_solution[a], new_solution[b]] +\n            distance_matrix_1[new_solution[c], new_solution[d]],\n            distance_matrix_2[new_solution[a], new_solution[b]] +\n            distance_matrix_2[new_solution[c], new_solution[d]],\n            distance_matrix_3[new_solution[a], new_solution[b]] +\n            distance_matrix_3[new_solution[c], new_solution[d]]\n        ]\n\n        return any(new_cost < old_cost for new_cost, old_cost in zip(new_costs, old_costs))\n\n    # If the swap improves at least one objective, apply it\n    if is_valid_and_improving(i, j, k, l):\n        # Perform the 2-opt swap\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6910498153692248,
            3.0354370951652525
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the lowest sum of objectives (promising for improvement)\n    selected = min(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to break and reconnect, prioritizing edges with high potential for improvement\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Ensure the new edges are valid and improve at least one objective\n    def is_valid_and_improving(a, b, c, d):\n        # Check if the new edges (a->b and c->d) improve at least one objective\n        old_costs = [\n            distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n            distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n            distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n            distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n            distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] +\n            distance_matrix_3[new_solution[b], new_solution[(b+1)%n]]\n        ]\n\n        new_costs = [\n            distance_matrix_1[new_solution[a], new_solution[b]] +\n            distance_matrix_1[new_solution[c], new_solution[d]],\n            distance_matrix_2[new_solution[a], new_solution[b]] +\n            distance_matrix_2[new_solution[c], new_solution[d]],\n            distance_matrix_3[new_solution[a], new_solution[b]] +\n            distance_matrix_3[new_solution[c], new_solution[d]]\n        ]\n\n        return any(new_cost < old_cost for new_cost, old_cost in zip(new_costs, old_costs))\n\n    # If the swap improves at least one objective, apply it\n    if is_valid_and_improving(i, j, k, l):\n        # Perform the 2-opt swap\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 34,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator combining 2-opt and edge insertion\n    n = len(new_solution)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform 2-opt between a and b\n    if a != b:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Perform edge insertion between c and d\n    if c != d:\n        node_to_move = new_solution[d]\n        new_solution = np.delete(new_solution, d)\n        new_solution = np.insert(new_solution, c, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.69186039263432,
            1.7276339292526246
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator combining 2-opt and edge insertion\n    n = len(new_solution)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform 2-opt between a and b\n    if a != b:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Perform edge insertion between c and d\n    if c != d:\n        node_to_move = new_solution[d]\n        new_solution = np.delete(new_solution, d)\n        new_solution = np.insert(new_solution, c, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 35,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1 / (1 + sum(obj)) for _, obj in archive], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: 2-opt with objective-aware node selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    # Determine the most promising node to swap based on all three objectives\n    best_node = -1\n    best_improvement = 0\n\n    for k in range(i, j + 1):\n        # Evaluate the impact of swapping node k with its neighbors\n        for l in range(k + 1, j + 1):\n            # Calculate the change in all three objectives\n            delta1 = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                      distance_matrix_1[new_solution[l], new_solution[(k+1)%n]] +\n                      distance_matrix_1[new_solution[l-1], new_solution[k]] +\n                      distance_matrix_1[new_solution[k], new_solution[(l+1)%n]]) - \\\n                     (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                      distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] +\n                      distance_matrix_1[new_solution[l-1], new_solution[l]] +\n                      distance_matrix_1[new_solution[l], new_solution[(l+1)%n]])\n\n            delta2 = (distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                      distance_matrix_2[new_solution[l], new_solution[(k+1)%n]] +\n                      distance_matrix_2[new_solution[l-1], new_solution[k]] +\n                      distance_matrix_2[new_solution[k], new_solution[(l+1)%n]]) - \\\n                     (distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                      distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] +\n                      distance_matrix_2[new_solution[l-1], new_solution[l]] +\n                      distance_matrix_2[new_solution[l], new_solution[(l+1)%n]])\n\n            delta3 = (distance_matrix_3[new_solution[k-1], new_solution[l]] +\n                      distance_matrix_3[new_solution[l], new_solution[(k+1)%n]] +\n                      distance_matrix_3[new_solution[l-1], new_solution[k]] +\n                      distance_matrix_3[new_solution[k], new_solution[(l+1)%n]]) - \\\n                     (distance_matrix_3[new_solution[k-1], new_solution[k]] +\n                      distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] +\n                      distance_matrix_3[new_solution[l-1], new_solution[l]] +\n                      distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n            # Combine improvements across all objectives\n            total_improvement = -delta1 - delta2 - delta3\n\n            if total_improvement > best_improvement:\n                best_improvement = total_improvement\n                best_node = (k, l)\n\n    if best_node != -1:\n        k, l = best_node\n        # Perform the swap\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.6812895159533844,
            3.773575687408447
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1 / (1 + sum(obj)) for _, obj in archive], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: 2-opt with objective-aware node selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    # Determine the most promising node to swap based on all three objectives\n    best_node = -1\n    best_improvement = 0\n\n    for k in range(i, j + 1):\n        # Evaluate the impact of swapping node k with its neighbors\n        for l in range(k + 1, j + 1):\n            # Calculate the change in all three objectives\n            delta1 = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                      distance_matrix_1[new_solution[l], new_solution[(k+1)%n]] +\n                      distance_matrix_1[new_solution[l-1], new_solution[k]] +\n                      distance_matrix_1[new_solution[k], new_solution[(l+1)%n]]) - \\\n                     (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                      distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] +\n                      distance_matrix_1[new_solution[l-1], new_solution[l]] +\n                      distance_matrix_1[new_solution[l], new_solution[(l+1)%n]])\n\n            delta2 = (distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                      distance_matrix_2[new_solution[l], new_solution[(k+1)%n]] +\n                      distance_matrix_2[new_solution[l-1], new_solution[k]] +\n                      distance_matrix_2[new_solution[k], new_solution[(l+1)%n]]) - \\\n                     (distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                      distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] +\n                      distance_matrix_2[new_solution[l-1], new_solution[l]] +\n                      distance_matrix_2[new_solution[l], new_solution[(l+1)%n]])\n\n            delta3 = (distance_matrix_3[new_solution[k-1], new_solution[l]] +\n                      distance_matrix_3[new_solution[l], new_solution[(k+1)%n]] +\n                      distance_matrix_3[new_solution[l-1], new_solution[k]] +\n                      distance_matrix_3[new_solution[k], new_solution[(l+1)%n]]) - \\\n                     (distance_matrix_3[new_solution[k-1], new_solution[k]] +\n                      distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] +\n                      distance_matrix_3[new_solution[l-1], new_solution[l]] +\n                      distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n            # Combine improvements across all objectives\n            total_improvement = -delta1 - delta2 - delta3\n\n            if total_improvement > best_improvement:\n                best_improvement = total_improvement\n                best_node = (k, l)\n\n    if best_node != -1:\n        k, l = best_node\n        # Perform the swap\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 36,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n\n    # Apply a hybrid 2-opt and 3-opt local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment for 2-opt or 3-opt\n    if np.random.rand() < 0.5:\n        # 2-opt: Reverse a random segment\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # 3-opt: Randomly permute a segment of 3 nodes\n        i = np.random.randint(0, n - 2)\n        new_solution[i:i+3] = np.random.permutation(new_solution[i:i+3])\n\n    # Ensure the solution remains a valid tour\n    assert len(set(new_solution)) == n, \"Invalid tour: duplicate nodes\"\n    assert all(node in base_solution for node in new_solution), \"Invalid tour: unknown nodes\"\n\n    return new_solution\n\n",
        "score": [
            -0.6008907291452052,
            1.8520859003067016
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n\n    # Apply a hybrid 2-opt and 3-opt local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment for 2-opt or 3-opt\n    if np.random.rand() < 0.5:\n        # 2-opt: Reverse a random segment\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # 3-opt: Randomly permute a segment of 3 nodes\n        i = np.random.randint(0, n - 2)\n        new_solution[i:i+3] = np.random.permutation(new_solution[i:i+3])\n\n    # Ensure the solution remains a valid tour\n    assert len(set(new_solution)) == n, \"Invalid tour: duplicate nodes\"\n    assert all(node in base_solution for node in new_solution), \"Invalid tour: unknown nodes\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 37,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort archive by average objective value (ascending)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]) / 3)\n    selected = archive_sorted[0][0].copy()\n\n    # Apply hybrid local search\n    new_solution = selected.copy()\n\n    # Randomly choose between 2-opt, 3-opt, or objective-aware edge swap\n    operator_choice = random.random()\n\n    if operator_choice < 0.3:\n        # 2-opt: Randomly select two edges and reverse the segment between them\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    elif operator_choice < 0.6:\n        # 3-opt: Randomly select three edges and reconnect them in a new way\n        i, j, k = sorted(random.sample(range(len(new_solution)), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n    else:\n        # Objective-aware edge swap: Identify edges that contribute most to worst objective\n        objectives = archive_sorted[0][1]\n        worst_obj = objectives.index(max(objectives))\n\n        # Find the worst edge in the selected objective space\n        worst_edge = None\n        max_cost = -1\n        for i in range(len(new_solution)):\n            u = new_solution[i]\n            v = new_solution[(i + 1) % len(new_solution)]\n            if worst_obj == 0:\n                cost = distance_matrix_1[u, v]\n            elif worst_obj == 1:\n                cost = distance_matrix_2[u, v]\n            else:\n                cost = distance_matrix_3[u, v]\n            if cost > max_cost:\n                max_cost = cost\n                worst_edge = (i, (i + 1) % len(new_solution))\n\n        # Swap the worst edge with a random edge that improves the worst objective\n        if worst_edge:\n            i, j = worst_edge\n            # Find a random edge to swap with\n            k, l = sorted(random.sample(range(len(new_solution)), 2))\n            # Perform the swap\n            new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n            new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n\n    return new_solution\n\n",
        "score": [
            -0.7172952972474955,
            2.0033702492713927
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort archive by average objective value (ascending)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]) / 3)\n    selected = archive_sorted[0][0].copy()\n\n    # Apply hybrid local search\n    new_solution = selected.copy()\n\n    # Randomly choose between 2-opt, 3-opt, or objective-aware edge swap\n    operator_choice = random.random()\n\n    if operator_choice < 0.3:\n        # 2-opt: Randomly select two edges and reverse the segment between them\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    elif operator_choice < 0.6:\n        # 3-opt: Randomly select three edges and reconnect them in a new way\n        i, j, k = sorted(random.sample(range(len(new_solution)), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n    else:\n        # Objective-aware edge swap: Identify edges that contribute most to worst objective\n        objectives = archive_sorted[0][1]\n        worst_obj = objectives.index(max(objectives))\n\n        # Find the worst edge in the selected objective space\n        worst_edge = None\n        max_cost = -1\n        for i in range(len(new_solution)):\n            u = new_solution[i]\n            v = new_solution[(i + 1) % len(new_solution)]\n            if worst_obj == 0:\n                cost = distance_matrix_1[u, v]\n            elif worst_obj == 1:\n                cost = distance_matrix_2[u, v]\n            else:\n                cost = distance_matrix_3[u, v]\n            if cost > max_cost:\n                max_cost = cost\n                worst_edge = (i, (i + 1) % len(new_solution))\n\n        # Swap the worst edge with a random edge that improves the worst objective\n        if worst_edge:\n            i, j = worst_edge\n            # Find a random edge to swap with\n            k, l = sorted(random.sample(range(len(new_solution)), 2))\n            # Perform the swap\n            new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n            new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 38,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    normalized_objectives = np.array(objectives) / np.max(np.array(objectives), axis=0)\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Calculate edge costs across all three objectives\n    edge_costs = (\n        distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n        distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n        distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n    ) + (\n        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n        distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n    ) - (\n        distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n        distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] +\n        distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n    ) - (\n        distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n        distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n        distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]\n    )\n\n    # Apply 2-opt if it improves the total cost\n    if edge_costs < 0:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6943094604664543,
            1.9084442973136901
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    normalized_objectives = np.array(objectives) / np.max(np.array(objectives), axis=0)\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Calculate edge costs across all three objectives\n    edge_costs = (\n        distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n        distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n        distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n    ) + (\n        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n        distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n    ) - (\n        distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n        distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] +\n        distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n    ) - (\n        distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n        distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n        distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]\n    )\n\n    # Apply 2-opt if it improves the total cost\n    if edge_costs < 0:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 39,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by analyzing objective diversity and local search opportunities, then applies a hybrid local search combining 2-opt with a novel multi-objective edge-swapping heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective edge swapping\n    n = len(base_solution)\n    for _ in range(10):  # Limit iterations for efficiency\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # 2-opt move\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n        # Multi-objective edge swap\n        if i != k and j != l:\n            temp_solution[k], temp_solution[l] = temp_solution[l], temp_solution[k]\n\n        # Check feasibility and accept if better in at least one objective\n        if (np.all(np.unique(temp_solution) == np.unique(base_solution)) and\n            (np.sum(distance_matrix_1[temp_solution[:-1], temp_solution[1:]]) < np.sum(distance_matrix_1[new_solution[:-1], new_solution[1:]]) or\n             np.sum(distance_matrix_2[temp_solution[:-1], temp_solution[1:]]) < np.sum(distance_matrix_2[new_solution[:-1], new_solution[1:]]) or\n             np.sum(distance_matrix_3[temp_solution[:-1], temp_solution[1:]]) < np.sum(distance_matrix_3[new_solution[:-1], new_solution[1:]]))):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.752036360006637,
            3.8006522417068482
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with multi-objective edge swapping\n    n = len(base_solution)\n    for _ in range(10):  # Limit iterations for efficiency\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # 2-opt move\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n        # Multi-objective edge swap\n        if i != k and j != l:\n            temp_solution[k], temp_solution[l] = temp_solution[l], temp_solution[k]\n\n        # Check feasibility and accept if better in at least one objective\n        if (np.all(np.unique(temp_solution) == np.unique(base_solution)) and\n            (np.sum(distance_matrix_1[temp_solution[:-1], temp_solution[1:]]) < np.sum(distance_matrix_1[new_solution[:-1], new_solution[1:]]) or\n             np.sum(distance_matrix_2[temp_solution[:-1], temp_solution[1:]]) < np.sum(distance_matrix_2[new_solution[:-1], new_solution[1:]]) or\n             np.sum(distance_matrix_3[temp_solution[:-1], temp_solution[1:]]) < np.sum(distance_matrix_3[new_solution[:-1], new_solution[1:]]))):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 40,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    objectives = [obj for _, obj in archive]\n    if len(objectives) > 1:\n        # Calculate the spread of objectives\n        spreads = [max(obj) - min(obj) for obj in zip(*objectives)]\n        # Select solution with highest spread\n        selected_idx = spreads.index(max(spreads))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        # Select two random edges that are not adjacent\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        if i >= j:\n            continue\n\n        # Calculate potential improvement across all three objectives\n        obj1_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[i], new_solution[j+1]]) - \\\n                    (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_1[new_solution[j], new_solution[j+1]])\n\n        obj2_diff = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[i], new_solution[j+1]]) - \\\n                    (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_2[new_solution[j], new_solution[j+1]])\n\n        obj3_diff = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_3[new_solution[i], new_solution[j+1]]) - \\\n                    (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_3[new_solution[j], new_solution[j+1]])\n\n        # Accept if at least one objective improves\n        if obj1_diff < 0 or obj2_diff < 0 or obj3_diff < 0:\n            # Perform 2-opt swap\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.5632613981732872,
            1.3339630126953126
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    objectives = [obj for _, obj in archive]\n    if len(objectives) > 1:\n        # Calculate the spread of objectives\n        spreads = [max(obj) - min(obj) for obj in zip(*objectives)]\n        # Select solution with highest spread\n        selected_idx = spreads.index(max(spreads))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        # Select two random edges that are not adjacent\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        if i >= j:\n            continue\n\n        # Calculate potential improvement across all three objectives\n        obj1_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[i], new_solution[j+1]]) - \\\n                    (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_1[new_solution[j], new_solution[j+1]])\n\n        obj2_diff = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[i], new_solution[j+1]]) - \\\n                    (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_2[new_solution[j], new_solution[j+1]])\n\n        obj3_diff = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_3[new_solution[i], new_solution[j+1]]) - \\\n                    (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_3[new_solution[j], new_solution[j+1]])\n\n        # Accept if at least one objective improves\n        if obj1_diff < 0 or obj2_diff < 0 or obj3_diff < 0:\n            # Perform 2-opt swap\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 41,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: apply a combination of 2-opt and 3-opt moves\n    n = len(base_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt move (reverse a segment between i and j, then between j and k)\n    new_solution[i:j] = base_solution[i:j][::-1]\n    new_solution[j:k] = base_solution[j:k][::-1]\n\n    # Verify feasibility (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        # Fallback to 2-opt if 3-opt is invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = base_solution[i:j][::-1]\n        if len(np.unique(new_solution)) == n:\n            return new_solution\n        else:\n            # If still invalid, return the original solution\n            return base_solution\n\n",
        "score": [
            -0.8105242993837629,
            1.4783719301223754
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: apply a combination of 2-opt and 3-opt moves\n    n = len(base_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt move (reverse a segment between i and j, then between j and k)\n    new_solution[i:j] = base_solution[i:j][::-1]\n    new_solution[j:k] = base_solution[j:k][::-1]\n\n    # Verify feasibility (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        # Fallback to 2-opt if 3-opt is invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = base_solution[i:j][::-1]\n        if len(np.unique(new_solution)) == n:\n            return new_solution\n        else:\n            # If still invalid, return the original solution\n            return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 42,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n    selected_solution = sorted_archive[0][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # Choose two random segments and reverse them (2-opt-like move)\n    n = len(selected_solution)\n    i, j = sorted(np.random.choice(range(1, n), 2, replace=False))\n    new_solution = selected_solution.copy()\n    new_solution[i:j] = selected_solution[j-1:i-1:-1]\n\n    # Step 3: Ensure feasibility (valid TSP tour)\n    # Check if the new solution is a valid permutation (no duplicates/missing nodes)\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        # If invalid, revert to a simple swap\n        new_solution = selected_solution.copy()\n        k, l = np.random.choice(range(n), 2, replace=False)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n        return new_solution\n\n",
        "score": [
            -0.717791723898532,
            1.5006607055664063
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n    selected_solution = sorted_archive[0][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # Choose two random segments and reverse them (2-opt-like move)\n    n = len(selected_solution)\n    i, j = sorted(np.random.choice(range(1, n), 2, replace=False))\n    new_solution = selected_solution.copy()\n    new_solution[i:j] = selected_solution[j-1:i-1:-1]\n\n    # Step 3: Ensure feasibility (valid TSP tour)\n    # Check if the new solution is a valid permutation (no duplicates/missing nodes)\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        # If invalid, revert to a simple swap\n        new_solution = selected_solution.copy()\n        k, l = np.random.choice(range(n), 2, replace=False)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n        return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 43,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search: 2-opt on the objective with the highest variance\n    new_solution = base_solution.copy()\n\n    # Calculate variance for each objective across the archive\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    max_var_obj = np.argmax(variances)\n\n    # Perform 2-opt on the selected objective\n    i, j = np.random.choice(len(new_solution), 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == len(base_solution), \"Solution is not feasible\"\n\n    return new_solution\n\n",
        "score": [
            -0.7808400271708827,
            2.1041836857795717
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search: 2-opt on the objective with the highest variance\n    new_solution = base_solution.copy()\n\n    # Calculate variance for each objective across the archive\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    max_var_obj = np.argmax(variances)\n\n    # Perform 2-opt on the selected objective\n    i, j = np.random.choice(len(new_solution), 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == len(base_solution), \"Solution is not feasible\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 44,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1.0 / (1 + i) for i in range(len(archive))]  # Simple weighting scheme\n    weights = [w / sum(weights) for w in weights]  # Normalize\n    base_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[base_idx][0].copy()\n\n    # Create a copy of the base solution to modify\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt for one objective, then multi-objective edge swap\n    n = len(new_solution)\n\n    # First apply 2-opt on the objective with the highest improvement potential\n    objectives = archive[base_idx][1]\n    worst_obj = np.argmax(objectives)\n\n    # Perform 2-opt on the worst objective\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        if worst_obj == 0:\n            delta = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                     distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        elif worst_obj == 1:\n            delta = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                     distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                     distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        else:\n            delta = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                     distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                     distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        if delta < 0:  # Only accept improvements\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform multi-objective edge swap\n    for _ in range(5):  # Limit iterations\n        i, j = sorted(random.sample(range(n), 2))\n        # Calculate potential improvement in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[i]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[i]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[i]])\n\n        # If at least one objective improves, accept the swap\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7206803723360496,
            1.8286309599876405
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1.0 / (1 + i) for i in range(len(archive))]  # Simple weighting scheme\n    weights = [w / sum(weights) for w in weights]  # Normalize\n    base_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[base_idx][0].copy()\n\n    # Create a copy of the base solution to modify\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt for one objective, then multi-objective edge swap\n    n = len(new_solution)\n\n    # First apply 2-opt on the objective with the highest improvement potential\n    objectives = archive[base_idx][1]\n    worst_obj = np.argmax(objectives)\n\n    # Perform 2-opt on the worst objective\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        if worst_obj == 0:\n            delta = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                     distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        elif worst_obj == 1:\n            delta = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                     distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                     distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        else:\n            delta = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                     distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                     distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        if delta < 0:  # Only accept improvements\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform multi-objective edge swap\n    for _ in range(5):  # Limit iterations\n        i, j = sorted(random.sample(range(n), 2))\n        # Calculate potential improvement in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[i]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[i]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[i]])\n\n        # If at least one objective improves, accept the swap\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 45,
        "algorithm": "{This heuristic selects a solution from the archive with high potential for improvement by evaluating its objective values and applying a multi-objective aware 2-opt* local search that simultaneously considers all three objectives to generate a neighbor solution, ensuring feasibility and diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a multi-objective 2-opt* local search\n    n = len(selected_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution = selected_solution.copy()\n\n    # Reverse the segment between i and j to create a neighbor\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Verify feasibility (no duplicate nodes)\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        # If invalid, try another random segment\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = selected_solution.copy()\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        if len(np.unique(new_solution)) == n:\n            return new_solution\n        else:\n            # Fallback to a simple swap if still invalid\n            new_solution = selected_solution.copy()\n            new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n            return new_solution\n\n",
        "score": [
            -0.696547983705414,
            1.4382912993431092
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a multi-objective 2-opt* local search\n    n = len(selected_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution = selected_solution.copy()\n\n    # Reverse the segment between i and j to create a neighbor\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Verify feasibility (no duplicate nodes)\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        # If invalid, try another random segment\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = selected_solution.copy()\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        if len(np.unique(new_solution)) == n:\n            return new_solution\n        else:\n            # Fallback to a simple swap if still invalid\n            new_solution = selected_solution.copy()\n            new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n            return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 46,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct edges to swap\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Ensure the swap maintains feasibility\n    if i != k and j != l:\n        # Perform the swap\n        new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n        new_solution[k:l+1] = np.flip(new_solution[k:l+1])\n\n    return new_solution\n\n",
        "score": [
            -0.7237415446151114,
            1.7096141695976257
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct edges to swap\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Ensure the swap maintains feasibility\n    if i != k and j != l:\n        # Perform the swap\n        new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n        new_solution[k:l+1] = np.flip(new_solution[k:l+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 47,
        "algorithm": "{The algorithm selects a solution from the archive based on its potential for improvement in multiple objectives, then applies a hybrid local search combining 2-opt and 3-opt moves to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best in all objectives)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: 2-opt and 3-opt with objective-aware selection\n    n = len(base_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n - 1)\n\n    # 2-opt move (swap two edges)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 3-opt move (swap three edges)\n    if k < i or k > j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7611757360169367,
            1.4666006922721864
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best in all objectives)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: 2-opt and 3-opt with objective-aware selection\n    n = len(base_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n - 1)\n\n    # 2-opt move (swap two edges)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 3-opt move (swap three edges)\n    if k < i or k > j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 48,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    variance = np.var(objectives, axis=0)\n    selected_idx = np.argmax(variance)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Find the worst edge in any of the three objectives\n    worst_edge = -1\n    max_diff = -1\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i + 1) % n]\n        diff1 = distance_matrix_1[u, v] - np.min(distance_matrix_1[u]) - np.min(distance_matrix_1[:, v])\n        diff2 = distance_matrix_2[u, v] - np.min(distance_matrix_2[u]) - np.min(distance_matrix_2[:, v])\n        diff3 = distance_matrix_3[u, v] - np.min(distance_matrix_3[u]) - np.min(distance_matrix_3[:, v])\n        current_diff = max(diff1, diff2, diff3)\n        if current_diff > max_diff:\n            max_diff = current_diff\n            worst_edge = i\n\n    if worst_edge != -1:\n        # Apply 2-opt on the worst edge\n        i = worst_edge\n        j = (worst_edge + 1) % n\n        new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    return new_solution\n\n",
        "score": [
            -0.6697834781913393,
            3.7461395859718323
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    variance = np.var(objectives, axis=0)\n    selected_idx = np.argmax(variance)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Find the worst edge in any of the three objectives\n    worst_edge = -1\n    max_diff = -1\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i + 1) % n]\n        diff1 = distance_matrix_1[u, v] - np.min(distance_matrix_1[u]) - np.min(distance_matrix_1[:, v])\n        diff2 = distance_matrix_2[u, v] - np.min(distance_matrix_2[u]) - np.min(distance_matrix_2[:, v])\n        diff3 = distance_matrix_3[u, v] - np.min(distance_matrix_3[u]) - np.min(distance_matrix_3[:, v])\n        current_diff = max(diff1, diff2, diff3)\n        if current_diff > max_diff:\n            max_diff = current_diff\n            worst_edge = i\n\n    if worst_edge != -1:\n        # Apply 2-opt on the worst edge\n        i = worst_edge\n        j = (worst_edge + 1) % n\n        new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 49,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., worst in at least one objective)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == 0 and j == n-1:\n            continue  # Avoid invalid swaps\n\n        # Calculate potential improvement across all three objectives\n        old_edges = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]],\n            distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        ]\n        new_edges = [\n            distance_matrix_1[new_solution[i-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[j]],\n            distance_matrix_1[new_solution[i], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n        ]\n\n        # Check if swap improves at least one objective\n        if any(new_edges[k] < old_edges[k] for k in range(6)):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7104359834594847,
            1.4964709162712098
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., worst in at least one objective)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == 0 and j == n-1:\n            continue  # Avoid invalid swaps\n\n        # Calculate potential improvement across all three objectives\n        old_edges = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]],\n            distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        ]\n        new_edges = [\n            distance_matrix_1[new_solution[i-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[j]],\n            distance_matrix_1[new_solution[i], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n        ]\n\n        # Check if swap improves at least one objective\n        if any(new_edges[k] < old_edges[k] for k in range(6)):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 50,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives to prioritize those with lower total cost\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select the top 30% solutions\n        top_solutions = sorted_archive[:max(1, len(archive) // 3)]\n        # Randomly select one from the top solutions\n        selected_solution, _ = random.choice(top_solutions)\n    else:\n        selected_solution = archive[0][0]\n\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge swaps\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Perform a 2-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware edge swap: try to improve the worst-performing objective\n    worst_obj = np.argmax([sum(x[1]) for x in archive])  # Find the worst objective\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst edge in the current solution for the selected objective\n    max_edge_cost = -1\n    max_edge_indices = (0, 1)\n    for k in range(n):\n        u, v = new_solution[k], new_solution[(k + 1) % n]\n        edge_cost = dist_matrix[u, v]\n        if edge_cost > max_edge_cost:\n            max_edge_cost = edge_cost\n            max_edge_indices = (k, (k + 1) % n)\n\n    # Try to replace the worst edge with a better one\n    a, b = max_edge_indices\n    u, v = new_solution[a], new_solution[b]\n    for c in range(n):\n        for d in range(n):\n            if c != d and c != a and c != b and d != a and d != b:\n                x, y = new_solution[c], new_solution[d]\n                new_cost = dist_matrix[x, y] + dist_matrix[u, v]\n                old_cost = dist_matrix[u, v]\n                if new_cost < old_cost:\n                    # Perform the swap\n                    new_solution[a], new_solution[b] = new_solution[c], new_solution[d]\n                    break\n        else:\n            continue\n        break\n\n    return new_solution\n\n",
        "score": [
            -0.6073603124416143,
            3.0187493681907656
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives to prioritize those with lower total cost\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select the top 30% solutions\n        top_solutions = sorted_archive[:max(1, len(archive) // 3)]\n        # Randomly select one from the top solutions\n        selected_solution, _ = random.choice(top_solutions)\n    else:\n        selected_solution = archive[0][0]\n\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge swaps\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Perform a 2-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware edge swap: try to improve the worst-performing objective\n    worst_obj = np.argmax([sum(x[1]) for x in archive])  # Find the worst objective\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst edge in the current solution for the selected objective\n    max_edge_cost = -1\n    max_edge_indices = (0, 1)\n    for k in range(n):\n        u, v = new_solution[k], new_solution[(k + 1) % n]\n        edge_cost = dist_matrix[u, v]\n        if edge_cost > max_edge_cost:\n            max_edge_cost = edge_cost\n            max_edge_indices = (k, (k + 1) % n)\n\n    # Try to replace the worst edge with a better one\n    a, b = max_edge_indices\n    u, v = new_solution[a], new_solution[b]\n    for c in range(n):\n        for d in range(n):\n            if c != d and c != a and c != b and d != a and d != b:\n                x, y = new_solution[c], new_solution[d]\n                new_cost = dist_matrix[x, y] + dist_matrix[u, v]\n                old_cost = dist_matrix[u, v]\n                if new_cost < old_cost:\n                    # Perform the swap\n                    new_solution[a], new_solution[b] = new_solution[c], new_solution[d]\n                    break\n        else:\n            continue\n        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 51,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # We use a combination of 2-opt and edge exchange to optimize across multiple objectives\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to perform 2-opt\n    i, j = sorted(random.sample(range(1, n), 2))\n\n    # Reverse the segment between i and j to create a new tour\n    new_solution[i:j] = selected_solution[j-1:i-1:-1]\n\n    # Perform edge exchange to further optimize the tour\n    # We select two random edges and swap them if it improves the total cost\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Calculate the cost before and after the exchange\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return cost1 + cost2 + cost3\n\n    original_cost = calculate_cost(new_solution)\n\n    # Swap edges and check if the cost improves\n    temp_solution = new_solution.copy()\n    temp_solution[a], temp_solution[b], temp_solution[c], temp_solution[d] = temp_solution[c], temp_solution[d], temp_solution[a], temp_solution[b]\n\n    new_cost = calculate_cost(temp_solution)\n\n    if new_cost < original_cost:\n        new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.5687807061605519,
            2.065034556388855
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # We use a combination of 2-opt and edge exchange to optimize across multiple objectives\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to perform 2-opt\n    i, j = sorted(random.sample(range(1, n), 2))\n\n    # Reverse the segment between i and j to create a new tour\n    new_solution[i:j] = selected_solution[j-1:i-1:-1]\n\n    # Perform edge exchange to further optimize the tour\n    # We select two random edges and swap them if it improves the total cost\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Calculate the cost before and after the exchange\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return cost1 + cost2 + cost3\n\n    original_cost = calculate_cost(new_solution)\n\n    # Swap edges and check if the cost improves\n    temp_solution = new_solution.copy()\n    temp_solution[a], temp_solution[b], temp_solution[c], temp_solution[d] = temp_solution[c], temp_solution[d], temp_solution[a], temp_solution[b]\n\n    new_cost = calculate_cost(temp_solution)\n\n    if new_cost < original_cost:\n        new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 52,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest total objective value (promising for improvement)\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel multi-objective edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform a random 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply a novel multi-objective edge swap\n    for _ in range(2):  # Limit to 2 swaps for efficiency\n        # Find edges with high potential for improvement across all objectives\n        edge_scores = []\n        for k in range(n):\n            node1 = new_solution[k]\n            node2 = new_solution[(k+1)%n]\n            # Score based on the sum of improvements across all objectives\n            score = (distance_matrix_1[node1, node2] + distance_matrix_2[node1, node2] + distance_matrix_3[node1, node2])\n            edge_scores.append((score, k))\n\n        # Select worst edge to swap\n        edge_scores.sort(reverse=True)\n        worst_edge = edge_scores[0][1]\n\n        # Find best possible swap partner\n        best_score = float('inf')\n        best_swap = -1\n        for l in range(n):\n            if l != worst_edge and l != (worst_edge+1)%n:\n                # Calculate potential score after swap\n                node1 = new_solution[worst_edge]\n                node2 = new_solution[(worst_edge+1)%n]\n                node3 = new_solution[l]\n                node4 = new_solution[(l+1)%n]\n\n                # Calculate new edges\n                new_edge1 = distance_matrix_1[node1, node3] + distance_matrix_1[node2, node4]\n                new_edge2 = distance_matrix_2[node1, node3] + distance_matrix_2[node2, node4]\n                new_edge3 = distance_matrix_3[node1, node3] + distance_matrix_3[node2, node4]\n\n                # Calculate old edges\n                old_edge1 = distance_matrix_1[node1, node2]\n                old_edge2 = distance_matrix_2[node1, node2]\n                old_edge3 = distance_matrix_3[node1, node2]\n\n                # Score improvement\n                improvement = (new_edge1 + new_edge2 + new_edge3) - (old_edge1 + old_edge2 + old_edge3)\n                if improvement < best_score:\n                    best_score = improvement\n                    best_swap = l\n\n        if best_swap != -1:\n            # Perform the swap\n            i, j = sorted([worst_edge, best_swap])\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6867563329063714,
            1.9556307911872863
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest total objective value (promising for improvement)\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel multi-objective edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform a random 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply a novel multi-objective edge swap\n    for _ in range(2):  # Limit to 2 swaps for efficiency\n        # Find edges with high potential for improvement across all objectives\n        edge_scores = []\n        for k in range(n):\n            node1 = new_solution[k]\n            node2 = new_solution[(k+1)%n]\n            # Score based on the sum of improvements across all objectives\n            score = (distance_matrix_1[node1, node2] + distance_matrix_2[node1, node2] + distance_matrix_3[node1, node2])\n            edge_scores.append((score, k))\n\n        # Select worst edge to swap\n        edge_scores.sort(reverse=True)\n        worst_edge = edge_scores[0][1]\n\n        # Find best possible swap partner\n        best_score = float('inf')\n        best_swap = -1\n        for l in range(n):\n            if l != worst_edge and l != (worst_edge+1)%n:\n                # Calculate potential score after swap\n                node1 = new_solution[worst_edge]\n                node2 = new_solution[(worst_edge+1)%n]\n                node3 = new_solution[l]\n                node4 = new_solution[(l+1)%n]\n\n                # Calculate new edges\n                new_edge1 = distance_matrix_1[node1, node3] + distance_matrix_1[node2, node4]\n                new_edge2 = distance_matrix_2[node1, node3] + distance_matrix_2[node2, node4]\n                new_edge3 = distance_matrix_3[node1, node3] + distance_matrix_3[node2, node4]\n\n                # Calculate old edges\n                old_edge1 = distance_matrix_1[node1, node2]\n                old_edge2 = distance_matrix_2[node1, node2]\n                old_edge3 = distance_matrix_3[node1, node2]\n\n                # Score improvement\n                improvement = (new_edge1 + new_edge2 + new_edge3) - (old_edge1 + old_edge2 + old_edge3)\n                if improvement < best_score:\n                    best_score = improvement\n                    best_swap = l\n\n        if best_swap != -1:\n            # Perform the swap\n            i, j = sorted([worst_edge, best_swap])\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 53,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge swaps\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform 2-opt\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware edge swap: identify edges with high potential for improvement\n    for _ in range(3):  # Limit attempts to balance exploration/exploitation\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        if k == l or (k == i and l == j):\n            continue\n\n        # Calculate objective improvements\n        orig_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[k], new_solution[l-1]]\n\n        orig_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[k], new_solution[l-1]]\n\n        orig_cost3 = distance_matrix_3[new_solution[k-1], new_solution[k]] + distance_matrix_3[new_solution[l-1], new_solution[l]]\n        new_cost3 = distance_matrix_3[new_solution[k-1], new_solution[l]] + distance_matrix_3[new_solution[k], new_solution[l-1]]\n\n        # Accept if at least one objective improves\n        if (new_cost1 < orig_cost1) or (new_cost2 < orig_cost2) or (new_cost3 < orig_cost3):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7243792435158023,
            1.8265062689781189
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge swaps\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform 2-opt\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware edge swap: identify edges with high potential for improvement\n    for _ in range(3):  # Limit attempts to balance exploration/exploitation\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        if k == l or (k == i and l == j):\n            continue\n\n        # Calculate objective improvements\n        orig_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[k], new_solution[l-1]]\n\n        orig_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[k], new_solution[l-1]]\n\n        orig_cost3 = distance_matrix_3[new_solution[k-1], new_solution[k]] + distance_matrix_3[new_solution[l-1], new_solution[l]]\n        new_cost3 = distance_matrix_3[new_solution[k-1], new_solution[l]] + distance_matrix_3[new_solution[k], new_solution[l-1]]\n\n        # Accept if at least one objective improves\n        if (new_cost1 < orig_cost1) or (new_cost2 < orig_cost2) or (new_cost3 < orig_cost3):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 54,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distances for all solutions\n        objectives = np.array([obj for _, obj in archive])\n        crowding_distances = np.zeros(len(archive))\n\n        for m in range(3):  # For each objective\n            sorted_indices = np.argsort(objectives[:, m])\n            objectives_sorted = objectives[sorted_indices, m]\n\n            # Assign infinite crowding distance to boundary solutions\n            crowding_distances[sorted_indices[0]] = np.inf\n            crowding_distances[sorted_indices[-1]] = np.inf\n\n            # Calculate crowding distance for intermediate solutions\n            for i in range(1, len(archive) - 1):\n                crowding_distances[sorted_indices[i]] += (objectives_sorted[i+1] - objectives_sorted[i-1]) / (objectives_sorted[-1] - objectives_sorted[0] + 1e-10)\n\n        # Select the solution with the highest crowding distance\n        selected_idx = np.argmax(crowding_distances)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to swap (2-opt-like move)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply a 3-opt move to further improve the solution\n    if n >= 3:\n        a, b, c = sorted(np.random.choice(range(n), 3, replace=False))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution[a:c] = np.concatenate([segment2, segment1])\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6383838941648168,
            3.204880392551422
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distances for all solutions\n        objectives = np.array([obj for _, obj in archive])\n        crowding_distances = np.zeros(len(archive))\n\n        for m in range(3):  # For each objective\n            sorted_indices = np.argsort(objectives[:, m])\n            objectives_sorted = objectives[sorted_indices, m]\n\n            # Assign infinite crowding distance to boundary solutions\n            crowding_distances[sorted_indices[0]] = np.inf\n            crowding_distances[sorted_indices[-1]] = np.inf\n\n            # Calculate crowding distance for intermediate solutions\n            for i in range(1, len(archive) - 1):\n                crowding_distances[sorted_indices[i]] += (objectives_sorted[i+1] - objectives_sorted[i-1]) / (objectives_sorted[-1] - objectives_sorted[0] + 1e-10)\n\n        # Select the solution with the highest crowding distance\n        selected_idx = np.argmax(crowding_distances)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to swap (2-opt-like move)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply a 3-opt move to further improve the solution\n    if n >= 3:\n        a, b, c = sorted(np.random.choice(range(n), 3, replace=False))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution[a:c] = np.concatenate([segment2, segment1])\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 55,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate diversity based on objective values\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.std(objectives, axis=0)\n        selected_idx = np.argmax(np.sum(diversity))\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == 0 and j == n-1:\n            continue  # Skip circular swap to maintain feasibility\n\n        # Calculate potential improvement across all objectives\n        current_edges = [\n            (base_solution[i-1], base_solution[i]),\n            (base_solution[j], base_solution[(j+1)%n]),\n            (base_solution[i], base_solution[(i+1)%n]),\n            (base_solution[j-1], base_solution[j])\n        ]\n        new_edges = [\n            (base_solution[i-1], base_solution[j]),\n            (base_solution[i], base_solution[(j+1)%n]),\n            (base_solution[j-1], base_solution[i]),\n            (base_solution[(i+1)%n], base_solution[j])\n        ]\n\n        # Calculate delta for each objective\n        delta1 = sum(distance_matrix_1[a][b] for a, b in new_edges) - sum(distance_matrix_1[a][b] for a, b in current_edges)\n        delta2 = sum(distance_matrix_2[a][b] for a, b in new_edges) - sum(distance_matrix_2[a][b] for a, b in current_edges)\n        delta3 = sum(distance_matrix_3[a][b] for a, b in new_edges) - sum(distance_matrix_3[a][b] for a, b in current_edges)\n\n        # Apply the swap if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6848622608458717,
            2.6780547976493834
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate diversity based on objective values\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.std(objectives, axis=0)\n        selected_idx = np.argmax(np.sum(diversity))\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == 0 and j == n-1:\n            continue  # Skip circular swap to maintain feasibility\n\n        # Calculate potential improvement across all objectives\n        current_edges = [\n            (base_solution[i-1], base_solution[i]),\n            (base_solution[j], base_solution[(j+1)%n]),\n            (base_solution[i], base_solution[(i+1)%n]),\n            (base_solution[j-1], base_solution[j])\n        ]\n        new_edges = [\n            (base_solution[i-1], base_solution[j]),\n            (base_solution[i], base_solution[(j+1)%n]),\n            (base_solution[j-1], base_solution[i]),\n            (base_solution[(i+1)%n], base_solution[j])\n        ]\n\n        # Calculate delta for each objective\n        delta1 = sum(distance_matrix_1[a][b] for a, b in new_edges) - sum(distance_matrix_1[a][b] for a, b in current_edges)\n        delta2 = sum(distance_matrix_2[a][b] for a, b in new_edges) - sum(distance_matrix_2[a][b] for a, b in current_edges)\n        delta3 = sum(distance_matrix_3[a][b] for a, b in new_edges) - sum(distance_matrix_3[a][b] for a, b in current_edges)\n\n        # Apply the swap if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 56,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    normalized_objectives = np.array(objectives) / np.max(np.array(objectives), axis=0)\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb (ensuring feasibility)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Reverse the segment to create a new tour (2-opt variant)\n    new_segment = segment[::-1]\n    new_solution[i:j+1] = new_segment\n\n    # Further refine by swapping edges based on objective diversity\n    for _ in range(5):  # Limited iterations for efficiency\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n\n        # Objective-aware edge swap: prefer edges that improve at least one objective\n        old_edges = [\n            (new_solution[a], new_solution[(a+1)%n]),\n            (new_solution[b], new_solution[(b+1)%n]),\n            (new_solution[c], new_solution[(c+1)%n]),\n            (new_solution[d], new_solution[(d+1)%n])\n        ]\n        new_edges = [\n            (new_solution[a], new_solution[c]),\n            (new_solution[b], new_solution[d]),\n            (new_solution[c], new_solution[a]),\n            (new_solution[d], new_solution[b])\n        ]\n\n        # Compute delta for each objective\n        delta1 = sum(distance_matrix_1[u][v] for u, v in new_edges) - sum(distance_matrix_1[u][v] for u, v in old_edges)\n        delta2 = sum(distance_matrix_2[u][v] for u, v in new_edges) - sum(distance_matrix_2[u][v] for u, v in old_edges)\n        delta3 = sum(distance_matrix_3[u][v] for u, v in new_edges) - sum(distance_matrix_3[u][v] for u, v in old_edges)\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n            new_solution[b], new_solution[d] = new_solution[d], new_solution[b]\n\n    return new_solution\n\n",
        "score": [
            -0.6610892551913644,
            2.497902822494507
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    normalized_objectives = np.array(objectives) / np.max(np.array(objectives), axis=0)\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb (ensuring feasibility)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Reverse the segment to create a new tour (2-opt variant)\n    new_segment = segment[::-1]\n    new_solution[i:j+1] = new_segment\n\n    # Further refine by swapping edges based on objective diversity\n    for _ in range(5):  # Limited iterations for efficiency\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n\n        # Objective-aware edge swap: prefer edges that improve at least one objective\n        old_edges = [\n            (new_solution[a], new_solution[(a+1)%n]),\n            (new_solution[b], new_solution[(b+1)%n]),\n            (new_solution[c], new_solution[(c+1)%n]),\n            (new_solution[d], new_solution[(d+1)%n])\n        ]\n        new_edges = [\n            (new_solution[a], new_solution[c]),\n            (new_solution[b], new_solution[d]),\n            (new_solution[c], new_solution[a]),\n            (new_solution[d], new_solution[b])\n        ]\n\n        # Compute delta for each objective\n        delta1 = sum(distance_matrix_1[u][v] for u, v in new_edges) - sum(distance_matrix_1[u][v] for u, v in old_edges)\n        delta2 = sum(distance_matrix_2[u][v] for u, v in new_edges) - sum(distance_matrix_2[u][v] for u, v in old_edges)\n        delta3 = sum(distance_matrix_3[u][v] for u, v in new_edges) - sum(distance_matrix_3[u][v] for u, v in old_edges)\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n            new_solution[b], new_solution[d] = new_solution[d], new_solution[b]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 57,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: Apply a combination of 2-opt and node swap\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly choose between 2-opt or node swap\n    if random.random() < 0.5:\n        # 2-opt: Select two non-adjacent edges and reverse the segment between them\n        i, j = sorted(random.sample(range(n), 2))\n        if i + 1 < j:\n            new_solution[i+1:j] = new_solution[i+1:j][::-1]\n    else:\n        # Node swap: Swap two randomly selected nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7086315131467776,
            1.524478507041931
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: Apply a combination of 2-opt and node swap\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly choose between 2-opt or node swap\n    if random.random() < 0.5:\n        # 2-opt: Select two non-adjacent edges and reverse the segment between them\n        i, j = sorted(random.sample(range(n), 2))\n        if i + 1 < j:\n            new_solution[i+1:j] = new_solution[i+1:j][::-1]\n    else:\n        # Node swap: Swap two randomly selected nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 58,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search operator: 3-opt with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(3):  # Perform 3 iterations of local search\n        # Select three distinct random edges to modify\n        a, b, c = sorted(random.sample(range(1, n), 3))\n        # Calculate the improvement potential in all three objectives\n        delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_1[new_solution[b-1], new_solution[c]] +\n                  distance_matrix_1[new_solution[c-1], new_solution[a]]) - \\\n                 (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                  distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                  distance_matrix_1[new_solution[c-1], new_solution[c]])\n        delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_2[new_solution[b-1], new_solution[c]] +\n                  distance_matrix_2[new_solution[c-1], new_solution[a]]) - \\\n                 (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                  distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                  distance_matrix_2[new_solution[c-1], new_solution[c]])\n        delta3 = (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_3[new_solution[b-1], new_solution[c]] +\n                  distance_matrix_3[new_solution[c-1], new_solution[a]]) - \\\n                 (distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                  distance_matrix_3[new_solution[b-1], new_solution[b]] +\n                  distance_matrix_3[new_solution[c-1], new_solution[c]])\n\n        # If the modification improves at least one objective, apply it\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            # Reverse the segment between b and c\n            new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(set(new_solution)) == len(instance), \"Invalid tour generated\"\n    return new_solution\n\n",
        "score": [
            -0.6840609592640029,
            1.1275570034980773
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search operator: 3-opt with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(3):  # Perform 3 iterations of local search\n        # Select three distinct random edges to modify\n        a, b, c = sorted(random.sample(range(1, n), 3))\n        # Calculate the improvement potential in all three objectives\n        delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_1[new_solution[b-1], new_solution[c]] +\n                  distance_matrix_1[new_solution[c-1], new_solution[a]]) - \\\n                 (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                  distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                  distance_matrix_1[new_solution[c-1], new_solution[c]])\n        delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_2[new_solution[b-1], new_solution[c]] +\n                  distance_matrix_2[new_solution[c-1], new_solution[a]]) - \\\n                 (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                  distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                  distance_matrix_2[new_solution[c-1], new_solution[c]])\n        delta3 = (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_3[new_solution[b-1], new_solution[c]] +\n                  distance_matrix_3[new_solution[c-1], new_solution[a]]) - \\\n                 (distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                  distance_matrix_3[new_solution[b-1], new_solution[b]] +\n                  distance_matrix_3[new_solution[c-1], new_solution[c]])\n\n        # If the modification improves at least one objective, apply it\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            # Reverse the segment between b and c\n            new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(set(new_solution)) == len(instance), \"Invalid tour generated\"\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 59,
        "algorithm": "{The heuristic function selects a promising solution from the archive by prioritizing those with low objective values and applies a hybrid local search operator that combines edge swaps and segment reversals to generate a neighbor solution, ensuring feasibility and diversification across multiple objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined objective value\n    def combined_objective(obj):\n        return sum(obj)\n\n    archive_sorted = sorted(archive, key=lambda x: combined_objective(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: edge swap + segment reversal\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Edge swap\n    if np.random.rand() < 0.5:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    # Segment reversal\n    else:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6986815749969951,
            1.5333182692527771
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined objective value\n    def combined_objective(obj):\n        return sum(obj)\n\n    archive_sorted = sorted(archive, key=lambda x: combined_objective(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: edge swap + segment reversal\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Edge swap\n    if np.random.rand() < 0.5:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    # Segment reversal\n    else:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 60,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy() if len(archive) > 1 else archive[0][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt, 3-opt, or objective-aware swap\n    operator = np.random.choice(['2-opt', '3-opt', 'objective_swap'])\n\n    if operator == '2-opt':\n        # Perform a 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    elif operator == '3-opt':\n        # Perform a 3-opt move\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n    else:\n        # Objective-aware swap: choose nodes with high marginal cost in at least one objective\n        obj_costs = []\n        for i in range(n):\n            prev_node = new_solution[i-1]\n            next_node = new_solution[(i+1)%n]\n            cost1 = distance_matrix_1[prev_node, next_node] + distance_matrix_1[prev_node, new_solution[i]] + distance_matrix_1[new_solution[i], next_node]\n            cost2 = distance_matrix_2[prev_node, next_node] + distance_matrix_2[prev_node, new_solution[i]] + distance_matrix_2[new_solution[i], next_node]\n            cost3 = distance_matrix_3[prev_node, next_node] + distance_matrix_3[prev_node, new_solution[i]] + distance_matrix_3[new_solution[i], next_node]\n            obj_costs.append(max(cost1, cost2, cost3))\n        # Select nodes with highest marginal cost\n        candidates = np.argsort(obj_costs)[-2:]\n        if len(candidates) >= 2:\n            i, j = candidates[:2]\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7430375549568788,
            1.3999224543571471
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy() if len(archive) > 1 else archive[0][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt, 3-opt, or objective-aware swap\n    operator = np.random.choice(['2-opt', '3-opt', 'objective_swap'])\n\n    if operator == '2-opt':\n        # Perform a 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    elif operator == '3-opt':\n        # Perform a 3-opt move\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n    else:\n        # Objective-aware swap: choose nodes with high marginal cost in at least one objective\n        obj_costs = []\n        for i in range(n):\n            prev_node = new_solution[i-1]\n            next_node = new_solution[(i+1)%n]\n            cost1 = distance_matrix_1[prev_node, next_node] + distance_matrix_1[prev_node, new_solution[i]] + distance_matrix_1[new_solution[i], next_node]\n            cost2 = distance_matrix_2[prev_node, next_node] + distance_matrix_2[prev_node, new_solution[i]] + distance_matrix_2[new_solution[i], next_node]\n            cost3 = distance_matrix_3[prev_node, next_node] + distance_matrix_3[prev_node, new_solution[i]] + distance_matrix_3[new_solution[i], next_node]\n            obj_costs.append(max(cost1, cost2, cost3))\n        # Select nodes with highest marginal cost\n        candidates = np.argsort(obj_costs)[-2:]\n        if len(candidates) >= 2:\n            i, j = candidates[:2]\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 61,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt for two objectives and insertion for the third\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # 2-opt for objectives 1 and 2\n    if np.random.random() < 0.5:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Insertion for objective 3\n    else:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7274220102777358,
            1.6553829073905946
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt for two objectives and insertion for the third\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # 2-opt for objectives 1 and 2\n    if np.random.random() < 0.5:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Insertion for objective 3\n    else:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 62,
        "algorithm": "{A novel tri-objective local search method that intelligently combines 2-opt moves across all three objective spaces, prioritizes edges with high potential for improvement, and dynamically balances exploration-exploitation by favoring solutions with diverse objective contributions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive cannot be empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective diversity)\n    weights = [sum(obj) for _, obj in archive]\n    if all(w == 0 for w in weights):\n        weights = [1.0 for _ in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Calculate edge importance across all three objectives\n    edge_importance = np.zeros(len(base_solution))\n    for i in range(len(base_solution)):\n        u, v = base_solution[i], base_solution[(i+1) % len(base_solution)]\n        edge_importance[i] = (distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v])\n\n    # Identify the most critical edges to flip\n    critical_edges = np.argsort(edge_importance)[-max(2, len(base_solution)//5):]\n\n    # Perform hybrid 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    for edge in critical_edges:\n        i = edge\n        j = (i + 1) % len(new_solution)\n\n        # Try reversing the segment between i and j\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n\n        # Evaluate the candidate's potential improvement across all objectives\n        improvement = 0\n        for k in range(len(candidate)):\n            u, v = candidate[k], candidate[(k+1) % len(candidate)]\n            improvement -= (distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v])\n\n        # Accept if improvement is positive\n        if improvement > 0:\n            new_solution = candidate\n\n    # Additional move: swap two random nodes to ensure diversity\n    if len(new_solution) > 2:\n        a, b = random.sample(range(len(new_solution)), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6842729492179307,
            2.0710278868675234
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive cannot be empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective diversity)\n    weights = [sum(obj) for _, obj in archive]\n    if all(w == 0 for w in weights):\n        weights = [1.0 for _ in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Calculate edge importance across all three objectives\n    edge_importance = np.zeros(len(base_solution))\n    for i in range(len(base_solution)):\n        u, v = base_solution[i], base_solution[(i+1) % len(base_solution)]\n        edge_importance[i] = (distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v])\n\n    # Identify the most critical edges to flip\n    critical_edges = np.argsort(edge_importance)[-max(2, len(base_solution)//5):]\n\n    # Perform hybrid 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    for edge in critical_edges:\n        i = edge\n        j = (i + 1) % len(new_solution)\n\n        # Try reversing the segment between i and j\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n\n        # Evaluate the candidate's potential improvement across all objectives\n        improvement = 0\n        for k in range(len(candidate)):\n            u, v = candidate[k], candidate[(k+1) % len(candidate)]\n            improvement -= (distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v])\n\n        # Accept if improvement is positive\n        if improvement > 0:\n            new_solution = candidate\n\n    # Additional move: swap two random nodes to ensure diversity\n    if len(new_solution) > 2:\n        a, b = random.sample(range(len(new_solution)), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 63,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]  # Random weights for multi-objective optimization\n    scores = [sum(w * obj for w, obj in zip(weights, objective)) for _, objective in archive]\n    best_idx = np.argmin(scores)\n    base_solution = archive[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 2-opt with multi-objective edge selection\n    for _ in range(10):  # Limit the number of iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j:\n            continue\n\n        # Evaluate the new edges created by reversing the segment [i, j]\n        old_edges = [(new_solution[i-1], new_solution[i]), (new_solution[j], new_solution[(j+1)%n])]\n        new_edges = [(new_solution[i-1], new_solution[j]), (new_solution[i], new_solution[(j+1)%n])]\n\n        # Calculate the change in total distance for each objective\n        delta1 = (distance_matrix_1[new_edges[0][0], new_edges[0][1]] + distance_matrix_1[new_edges[1][0], new_edges[1][1]]) - \\\n                 (distance_matrix_1[old_edges[0][0], old_edges[0][1]] + distance_matrix_1[old_edges[1][0], old_edges[1][1]])\n\n        delta2 = (distance_matrix_2[new_edges[0][0], new_edges[0][1]] + distance_matrix_2[new_edges[1][0], new_edges[1][1]]) - \\\n                 (distance_matrix_2[old_edges[0][0], old_edges[0][1]] + distance_matrix_2[old_edges[1][0], old_edges[1][1]])\n\n        delta3 = (distance_matrix_3[new_edges[0][0], new_edges[0][1]] + distance_matrix_3[new_edges[1][0], new_edges[1][1]]) - \\\n                 (distance_matrix_3[old_edges[0][0], old_edges[0][1]] + distance_matrix_3[old_edges[1][0], old_edges[1][1]])\n\n        # Apply the move if it improves at least one objective\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.735009173788836,
            2.8698342561721804
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]  # Random weights for multi-objective optimization\n    scores = [sum(w * obj for w, obj in zip(weights, objective)) for _, objective in archive]\n    best_idx = np.argmin(scores)\n    base_solution = archive[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 2-opt with multi-objective edge selection\n    for _ in range(10):  # Limit the number of iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j:\n            continue\n\n        # Evaluate the new edges created by reversing the segment [i, j]\n        old_edges = [(new_solution[i-1], new_solution[i]), (new_solution[j], new_solution[(j+1)%n])]\n        new_edges = [(new_solution[i-1], new_solution[j]), (new_solution[i], new_solution[(j+1)%n])]\n\n        # Calculate the change in total distance for each objective\n        delta1 = (distance_matrix_1[new_edges[0][0], new_edges[0][1]] + distance_matrix_1[new_edges[1][0], new_edges[1][1]]) - \\\n                 (distance_matrix_1[old_edges[0][0], old_edges[0][1]] + distance_matrix_1[old_edges[1][0], old_edges[1][1]])\n\n        delta2 = (distance_matrix_2[new_edges[0][0], new_edges[0][1]] + distance_matrix_2[new_edges[1][0], new_edges[1][1]]) - \\\n                 (distance_matrix_2[old_edges[0][0], old_edges[0][1]] + distance_matrix_2[old_edges[1][0], old_edges[1][1]])\n\n        delta3 = (distance_matrix_3[new_edges[0][0], new_edges[0][1]] + distance_matrix_3[new_edges[1][0], new_edges[1][1]]) - \\\n                 (distance_matrix_3[old_edges[0][0], old_edges[0][1]] + distance_matrix_3[old_edges[1][0], old_edges[1][1]])\n\n        # Apply the move if it improves at least one objective\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 64,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest sum of normalized objective values (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to break (objective-aware selection)\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n\n    # Calculate edge costs based on objectives\n    edge_costs = np.zeros(n)\n    for i in range(n):\n        a, b = new_solution[i], new_solution[(i+1)%n]\n        edge_costs[i] = (distance_matrix_1[a, b] * (obj1 / total_obj) +\n                         distance_matrix_2[a, b] * (obj2 / total_obj) +\n                         distance_matrix_3[a, b] * (obj3 / total_obj))\n\n    # Select edges with highest cost to potentially improve\n    sorted_edges = np.argsort(edge_costs)[-2:]  # Top 2 most expensive edges\n    i, j = sorted_edges[0], sorted_edges[1]\n\n    # Perform 2-opt swap\n    if i < j:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n    else:\n        # Handle circular case\n        part1 = new_solution[i+1:]\n        part2 = new_solution[:j+1]\n        new_solution = np.concatenate([part1[::-1], part2[::-1]])\n\n    return new_solution\n\n",
        "score": [
            -0.6193180616264028,
            1.0863305807113648
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest sum of normalized objective values (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to break (objective-aware selection)\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n\n    # Calculate edge costs based on objectives\n    edge_costs = np.zeros(n)\n    for i in range(n):\n        a, b = new_solution[i], new_solution[(i+1)%n]\n        edge_costs[i] = (distance_matrix_1[a, b] * (obj1 / total_obj) +\n                         distance_matrix_2[a, b] * (obj2 / total_obj) +\n                         distance_matrix_3[a, b] * (obj3 / total_obj))\n\n    # Select edges with highest cost to potentially improve\n    sorted_edges = np.argsort(edge_costs)[-2:]  # Top 2 most expensive edges\n    i, j = sorted_edges[0], sorted_edges[1]\n\n    # Perform 2-opt swap\n    if i < j:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n    else:\n        # Handle circular case\n        part1 = new_solution[i+1:]\n        part2 = new_solution[:j+1]\n        new_solution = np.concatenate([part1[::-1], part2[::-1]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 65,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify edges with high potential for improvement across all objectives\n    edge_scores = []\n    for i in range(n):\n        a, b = new_solution[i], new_solution[(i+1)%n]\n        # Score based on distance in all three objectives\n        score = (distance_matrix_1[a, b] + distance_matrix_2[a, b] + distance_matrix_3[a, b]) / 3\n        edge_scores.append(score)\n\n    # Select the worst edge to potentially improve\n    worst_edge_idx = np.argmax(edge_scores)\n    a, b = new_solution[worst_edge_idx], new_solution[(worst_edge_idx+1)%n]\n\n    # Find the best possible replacement edge (2-opt move)\n    best_improvement = 0\n    best_i, best_j = -1, -1\n\n    for i in range(n):\n        for j in range(i+2, n):\n            x, y = new_solution[i], new_solution[j]\n            # Calculate potential improvement across all objectives\n            improvement = (distance_matrix_1[a, b] + distance_matrix_1[x, y] -\n                           (distance_matrix_1[a, x] + distance_matrix_1[y, b]) +\n                           distance_matrix_2[a, b] + distance_matrix_2[x, y] -\n                           (distance_matrix_2[a, x] + distance_matrix_2[y, b]) +\n                           distance_matrix_3[a, b] + distance_matrix_3[x, y] -\n                           (distance_matrix_3[a, x] + distance_matrix_3[y, b]))\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_i, best_j = i, j\n\n    if best_i != -1 and best_j != -1:\n        # Perform the 2-opt move\n        new_solution[best_i+1:best_j+1] = new_solution[best_i+1:best_j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7197258244028796,
            3.4163174390792848
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify edges with high potential for improvement across all objectives\n    edge_scores = []\n    for i in range(n):\n        a, b = new_solution[i], new_solution[(i+1)%n]\n        # Score based on distance in all three objectives\n        score = (distance_matrix_1[a, b] + distance_matrix_2[a, b] + distance_matrix_3[a, b]) / 3\n        edge_scores.append(score)\n\n    # Select the worst edge to potentially improve\n    worst_edge_idx = np.argmax(edge_scores)\n    a, b = new_solution[worst_edge_idx], new_solution[(worst_edge_idx+1)%n]\n\n    # Find the best possible replacement edge (2-opt move)\n    best_improvement = 0\n    best_i, best_j = -1, -1\n\n    for i in range(n):\n        for j in range(i+2, n):\n            x, y = new_solution[i], new_solution[j]\n            # Calculate potential improvement across all objectives\n            improvement = (distance_matrix_1[a, b] + distance_matrix_1[x, y] -\n                           (distance_matrix_1[a, x] + distance_matrix_1[y, b]) +\n                           distance_matrix_2[a, b] + distance_matrix_2[x, y] -\n                           (distance_matrix_2[a, x] + distance_matrix_2[y, b]) +\n                           distance_matrix_3[a, b] + distance_matrix_3[x, y] -\n                           (distance_matrix_3[a, x] + distance_matrix_3[y, b]))\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_i, best_j = i, j\n\n    if best_i != -1 and best_j != -1:\n        # Perform the 2-opt move\n        new_solution[best_i+1:best_j+1] = new_solution[best_i+1:best_j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 66,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest potential for improvement (highest sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine edge swaps and path relinking\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to relink\n    start, end = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[start:end+1]\n\n    # Apply edge swaps within the segment\n    for i in range(len(segment) - 1):\n        if np.random.rand() < 0.5:  # 50% chance to swap edges\n            segment[i], segment[i+1] = segment[i+1], segment[i]\n\n    # Reinsert the modified segment\n    new_solution[start:end+1] = segment\n\n    # Ensure the solution remains a valid tour\n    # Check for duplicates and fix if necessary\n    unique, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique[counts > 1]\n    for d in duplicates:\n        # Find missing nodes\n        missing = [node for node in range(n) if node not in new_solution]\n        if missing:\n            # Replace duplicate with a missing node\n            idx = np.where(new_solution == d)[0][1]  # second occurrence\n            new_solution[idx] = missing[0]\n\n    return new_solution\n\n",
        "score": [
            -0.5581615022702343,
            1.7006432652473449
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest potential for improvement (highest sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine edge swaps and path relinking\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to relink\n    start, end = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[start:end+1]\n\n    # Apply edge swaps within the segment\n    for i in range(len(segment) - 1):\n        if np.random.rand() < 0.5:  # 50% chance to swap edges\n            segment[i], segment[i+1] = segment[i+1], segment[i]\n\n    # Reinsert the modified segment\n    new_solution[start:end+1] = segment\n\n    # Ensure the solution remains a valid tour\n    # Check for duplicates and fix if necessary\n    unique, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique[counts > 1]\n    for d in duplicates:\n        # Find missing nodes\n        missing = [node for node in range(n) if node not in new_solution]\n        if missing:\n            # Replace duplicate with a missing node\n            idx = np.where(new_solution == d)[0][1]  # second occurrence\n            new_solution[idx] = missing[0]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 67,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to swap (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply a third objective-aware perturbation: reverse a segment if it improves the worst objective\n    worst_obj = max(archive, key=lambda x: max(x[1]))[1]\n    worst_obj_index = worst_obj.index(max(worst_obj))\n\n    if worst_obj_index == 0:\n        current_dist = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    elif worst_obj_index == 1:\n        current_dist = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    else:\n        current_dist = sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n    # Try reversing a random segment\n    a, b = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[a:b] = candidate[a:b][::-1]\n\n    if worst_obj_index == 0:\n        candidate_dist = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n    elif worst_obj_index == 1:\n        candidate_dist = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n    else:\n        candidate_dist = sum(distance_matrix_3[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n    if candidate_dist < current_dist:\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.6922410605458988,
            1.8422454118728637
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to swap (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply a third objective-aware perturbation: reverse a segment if it improves the worst objective\n    worst_obj = max(archive, key=lambda x: max(x[1]))[1]\n    worst_obj_index = worst_obj.index(max(worst_obj))\n\n    if worst_obj_index == 0:\n        current_dist = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    elif worst_obj_index == 1:\n        current_dist = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    else:\n        current_dist = sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n    # Try reversing a random segment\n    a, b = sorted(random.sample(range(n), 2))\n    candidate = new_solution.copy()\n    candidate[a:b] = candidate[a:b][::-1]\n\n    if worst_obj_index == 0:\n        candidate_dist = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n    elif worst_obj_index == 1:\n        candidate_dist = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n    else:\n        candidate_dist = sum(distance_matrix_3[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n    if candidate_dist < current_dist:\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 68,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # We use a combination of 2-opt and edge insertion to explore the solution space\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct positions for 2-opt\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select a node to reinsert (edge insertion)\n    k = random.randint(0, n-1)\n    node_to_move = new_solution[k]\n\n    # Remove the node and reinsert it at a random position\n    new_solution = np.delete(new_solution, k)\n    new_position = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, new_position, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.6823001213951636,
            1.6260015606880187
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # We use a combination of 2-opt and edge insertion to explore the solution space\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct positions for 2-opt\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select a node to reinsert (edge insertion)\n    k = random.randint(0, n-1)\n    node_to_move = new_solution[k]\n\n    # Remove the node and reinsert it at a random position\n    new_solution = np.delete(new_solution, k)\n    new_position = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, new_position, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 69,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # We use a combination of 2-opt and a novel 2.5-opt to explore the solution space\n    # The 2.5-opt involves selecting three edges and reconnecting them in a way that\n    # can improve multiple objectives simultaneously\n\n    # 2-opt for the first objective\n    i, j = sorted(np.random.choice(len(base_solution), 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # 2.5-opt for the other two objectives\n    a, b, c = sorted(np.random.choice(len(base_solution), 3, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.6978732234395411,
            1.830497634410858
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # We use a combination of 2-opt and a novel 2.5-opt to explore the solution space\n    # The 2.5-opt involves selecting three edges and reconnecting them in a way that\n    # can improve multiple objectives simultaneously\n\n    # 2-opt for the first objective\n    i, j = sorted(np.random.choice(len(base_solution), 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # 2.5-opt for the other two objectives\n    a, b, c = sorted(np.random.choice(len(base_solution), 3, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 70,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off across objectives using a weighted sum\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    scores = [sum(w * obj for w, obj in zip(weights, objective)) for _, objective in archive]\n    best_idx = np.argmin(scores)\n    base_solution = archive[best_idx][0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware perturbation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1].copy()\n\n    # Reverse the segment to apply 2-opt\n    new_solution[a:b+1] = segment[::-1]\n\n    # Apply objective-aware perturbation: swap nodes based on worst-performing objective\n    objectives = archive[best_idx][1]\n    worst_obj_idx = np.argmax(objectives)\n    if worst_obj_idx == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst node in the segment based on the worst objective\n    worst_node = None\n    max_cost = -1\n    for i in range(a, b+1):\n        node = new_solution[i]\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[(i+1)%n]\n        cost = dist_matrix[prev_node, node] + dist_matrix[node, next_node]\n        if cost > max_cost:\n            max_cost = cost\n            worst_node = i\n\n    if worst_node is not None:\n        # Swap with a random node not in the segment to improve the worst objective\n        candidates = [i for i in range(n) if i < a or i > b]\n        if candidates:\n            swap_with = np.random.choice(candidates)\n            new_solution[worst_node], new_solution[swap_with] = new_solution[swap_with], new_solution[worst_node]\n\n    return new_solution\n\n",
        "score": [
            -0.8329750125073503,
            1.7742000102996827
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off across objectives using a weighted sum\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    scores = [sum(w * obj for w, obj in zip(weights, objective)) for _, objective in archive]\n    best_idx = np.argmin(scores)\n    base_solution = archive[best_idx][0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware perturbation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1].copy()\n\n    # Reverse the segment to apply 2-opt\n    new_solution[a:b+1] = segment[::-1]\n\n    # Apply objective-aware perturbation: swap nodes based on worst-performing objective\n    objectives = archive[best_idx][1]\n    worst_obj_idx = np.argmax(objectives)\n    if worst_obj_idx == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst node in the segment based on the worst objective\n    worst_node = None\n    max_cost = -1\n    for i in range(a, b+1):\n        node = new_solution[i]\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[(i+1)%n]\n        cost = dist_matrix[prev_node, node] + dist_matrix[node, next_node]\n        if cost > max_cost:\n            max_cost = cost\n            worst_node = i\n\n    if worst_node is not None:\n        # Swap with a random node not in the segment to improve the worst objective\n        candidates = [i for i in range(n) if i < a or i > b]\n        if candidates:\n            swap_with = np.random.choice(candidates)\n            new_solution[worst_node], new_solution[swap_with] = new_solution[swap_with], new_solution[worst_node]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 70,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off across objectives using a weighted sum\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    scores = [sum(w * obj for w, obj in zip(weights, objective)) for _, objective in archive]\n    best_idx = np.argmin(scores)\n    base_solution = archive[best_idx][0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware perturbation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1].copy()\n\n    # Reverse the segment to apply 2-opt\n    new_solution[a:b+1] = segment[::-1]\n\n    # Apply objective-aware perturbation: swap nodes based on worst-performing objective\n    objectives = archive[best_idx][1]\n    worst_obj_idx = np.argmax(objectives)\n    if worst_obj_idx == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst node in the segment based on the worst objective\n    worst_node = None\n    max_cost = -1\n    for i in range(a, b+1):\n        node = new_solution[i]\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[(i+1)%n]\n        cost = dist_matrix[prev_node, node] + dist_matrix[node, next_node]\n        if cost > max_cost:\n            max_cost = cost\n            worst_node = i\n\n    if worst_node is not None:\n        # Swap with a random node not in the segment to improve the worst objective\n        candidates = [i for i in range(n) if i < a or i > b]\n        if candidates:\n            swap_with = np.random.choice(candidates)\n            new_solution[worst_node], new_solution[swap_with] = new_solution[swap_with], new_solution[worst_node]\n\n    return new_solution\n\n",
        "score": [
            -0.8329750125073503,
            1.7742000102996827
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off across objectives using a weighted sum\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    scores = [sum(w * obj for w, obj in zip(weights, objective)) for _, objective in archive]\n    best_idx = np.argmin(scores)\n    base_solution = archive[best_idx][0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware perturbation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1].copy()\n\n    # Reverse the segment to apply 2-opt\n    new_solution[a:b+1] = segment[::-1]\n\n    # Apply objective-aware perturbation: swap nodes based on worst-performing objective\n    objectives = archive[best_idx][1]\n    worst_obj_idx = np.argmax(objectives)\n    if worst_obj_idx == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst node in the segment based on the worst objective\n    worst_node = None\n    max_cost = -1\n    for i in range(a, b+1):\n        node = new_solution[i]\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[(i+1)%n]\n        cost = dist_matrix[prev_node, node] + dist_matrix[node, next_node]\n        if cost > max_cost:\n            max_cost = cost\n            worst_node = i\n\n    if worst_node is not None:\n        # Swap with a random node not in the segment to improve the worst objective\n        candidates = [i for i in range(n) if i < a or i > b]\n        if candidates:\n            swap_with = np.random.choice(candidates)\n            new_solution[worst_node], new_solution[swap_with] = new_solution[swap_with], new_solution[worst_node]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 71,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two non-adjacent edges to reverse\n    i, j = sorted(random.sample(range(1, n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply a 3-opt move for further improvement\n    if n >= 4:\n        a, b, c = sorted(random.sample(range(1, n-1), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution[a:c] = np.concatenate([segment2, segment1])\n\n    return new_solution\n\n",
        "score": [
            -0.7616480185287859,
            1.1948328971862794
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two non-adjacent edges to reverse\n    i, j = sorted(random.sample(range(1, n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply a 3-opt move for further improvement\n    if n >= 4:\n        a, b, c = sorted(random.sample(range(1, n-1), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution[a:c] = np.concatenate([segment2, segment1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 72,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = max(archive, key=lambda x: -(sum(x[1]) / 3))[0].copy()\n\n    # Apply a hybrid local search: 2-opt with multi-objective edge selection\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to potentially swap\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Ensure the swap maintains a valid tour\n    if i != k and j != l:\n        # Perform the swap\n        new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n        new_solution[k:l+1] = np.flip(new_solution[k:l+1])\n\n    # Ensure the solution remains valid\n    if not (len(new_solution) == len(best_solution) and len(np.unique(new_solution)) == len(best_solution)):\n        new_solution = best_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7578366493445977,
            1.4882583379745484
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = max(archive, key=lambda x: -(sum(x[1]) / 3))[0].copy()\n\n    # Apply a hybrid local search: 2-opt with multi-objective edge selection\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to potentially swap\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Ensure the swap maintains a valid tour\n    if i != k and j != l:\n        # Perform the swap\n        new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n        new_solution[k:l+1] = np.flip(new_solution[k:l+1])\n\n    # Ensure the solution remains valid\n    if not (len(new_solution) == len(best_solution) and len(np.unique(new_solution)) == len(best_solution)):\n        new_solution = best_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 73,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    potential_solutions = []\n    for sol, obj in archive:\n        # Calculate the sum of normalized objectives\n        total_obj = sum(obj)\n        potential_solutions.append((sol, total_obj))\n\n    # Step 2: Select the solution with the highest potential\n    selected_solution = max(potential_solutions, key=lambda x: x[1])[0].copy()\n\n    # Step 3: Apply a hybrid local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments to reverse\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes to ensure diversity\n    k, l = random.sample(range(n), 2)\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility by checking for duplicates\n    if len(set(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5579835016976465,
            1.2714297413825988
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    potential_solutions = []\n    for sol, obj in archive:\n        # Calculate the sum of normalized objectives\n        total_obj = sum(obj)\n        potential_solutions.append((sol, total_obj))\n\n    # Step 2: Select the solution with the highest potential\n    selected_solution = max(potential_solutions, key=lambda x: x[1])[0].copy()\n\n    # Step 3: Apply a hybrid local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments to reverse\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes to ensure diversity\n    k, l = random.sample(range(n), 2)\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility by checking for duplicates\n    if len(set(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 74,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest sum of objectives (potentially less crowded)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Perform a hybrid local search: 2-opt swap with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    segment_start = np.random.randint(0, n)\n    segment_length = np.random.randint(2, min(5, n))\n    segment_end = (segment_start + segment_length) % n\n\n    # Extract the segment\n    segment = new_solution[segment_start:segment_end]\n\n    # Reverse the segment (2-opt move)\n    reversed_segment = segment[::-1]\n\n    # Insert the reversed segment back\n    new_solution[segment_start:segment_end] = reversed_segment\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if reversal causes duplicates\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6935552653914135,
            1.4348511815071106
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest sum of objectives (potentially less crowded)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Perform a hybrid local search: 2-opt swap with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    segment_start = np.random.randint(0, n)\n    segment_length = np.random.randint(2, min(5, n))\n    segment_end = (segment_start + segment_length) % n\n\n    # Extract the segment\n    segment = new_solution[segment_start:segment_end]\n\n    # Reverse the segment (2-opt move)\n    reversed_segment = segment[::-1]\n\n    # Insert the reversed segment back\n    new_solution[segment_start:segment_end] = reversed_segment\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if reversal causes duplicates\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 75,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    base_solution = selected_solution.copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search strategy\n    # This strategy combines 2-opt with a biased random selection to handle multiple objectives\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct positions to swap, with a bias towards nodes with higher marginal improvement\n    i, j = np.random.choice(n, size=2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid TSP tour\"\n\n    return new_solution\n\n",
        "score": [
            -0.5589043286607814,
            1.7823818922042847
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    base_solution = selected_solution.copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search strategy\n    # This strategy combines 2-opt with a biased random selection to handle multiple objectives\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct positions to swap, with a bias towards nodes with higher marginal improvement\n    i, j = np.random.choice(n, size=2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid TSP tour\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 76,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two non-adjacent edges to swap\n    i, j = sorted(random.sample(range(n), 2))\n    while j == i + 1 or (j == n - 1 and i == 0):  # Ensure non-adjacent and not wrapping\n        i, j = sorted(random.sample(range(n), 2))\n\n    # Calculate the change in all three objectives\n    def calculate_delta(a, b, c, d):\n        delta1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n        delta2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n        delta3 = (distance_matrix_3[a, c] + distance_matrix_3[b, d]) - (distance_matrix_3[a, b] + distance_matrix_3[c, d])\n        return delta1, delta2, delta3\n\n    # Try both possible swaps (i,j) and (i+1,j-1)\n    a, b = new_solution[i], new_solution[j]\n    c, d = new_solution[(i + 1) % n], new_solution[(j - 1) % n]\n\n    delta1, delta2, delta3 = calculate_delta(a, b, c, d)\n    if delta1 < 0 or delta2 < 0 or delta3 < 0:  # At least one objective improves\n        new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6833853487566796,
            1.544307565689087
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two non-adjacent edges to swap\n    i, j = sorted(random.sample(range(n), 2))\n    while j == i + 1 or (j == n - 1 and i == 0):  # Ensure non-adjacent and not wrapping\n        i, j = sorted(random.sample(range(n), 2))\n\n    # Calculate the change in all three objectives\n    def calculate_delta(a, b, c, d):\n        delta1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n        delta2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n        delta3 = (distance_matrix_3[a, c] + distance_matrix_3[b, d]) - (distance_matrix_3[a, b] + distance_matrix_3[c, d])\n        return delta1, delta2, delta3\n\n    # Try both possible swaps (i,j) and (i+1,j-1)\n    a, b = new_solution[i], new_solution[j]\n    c, d = new_solution[(i + 1) % n], new_solution[(j - 1) % n]\n\n    delta1, delta2, delta3 = calculate_delta(a, b, c, d)\n    if delta1 < 0 or delta2 < 0 or delta3 < 0:  # At least one objective improves\n        new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 77,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, base_objectives = max(archive, key=lambda x: sum(x[1]))\n\n    # Perform a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify edges with high potential for improvement in any objective\n    for i in range(n):\n        for j in range(i + 2, n):\n            a, b = new_solution[i], new_solution[i+1]\n            c, d = new_solution[j], new_solution[j+1] if j+1 < n else new_solution[0]\n\n            # Calculate the change in all three objectives\n            delta_1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n            delta_2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n            delta_3 = (distance_matrix_3[a, c] + distance_matrix_3[b, d]) - (distance_matrix_3[a, b] + distance_matrix_3[c, d])\n\n            # If any objective improves, perform the swap\n            if delta_1 < 0 or delta_2 < 0 or delta_3 < 0:\n                new_solution[i+1:j+1] = new_solution[j:i:-1]\n                return new_solution\n\n    # If no improvement found, perform a random 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i+1:j+1] = new_solution[j:i:-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6830511392486389,
            1.2733060717582703
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, base_objectives = max(archive, key=lambda x: sum(x[1]))\n\n    # Perform a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify edges with high potential for improvement in any objective\n    for i in range(n):\n        for j in range(i + 2, n):\n            a, b = new_solution[i], new_solution[i+1]\n            c, d = new_solution[j], new_solution[j+1] if j+1 < n else new_solution[0]\n\n            # Calculate the change in all three objectives\n            delta_1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n            delta_2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n            delta_3 = (distance_matrix_3[a, c] + distance_matrix_3[b, d]) - (distance_matrix_3[a, b] + distance_matrix_3[c, d])\n\n            # If any objective improves, perform the swap\n            if delta_1 < 0 or delta_2 < 0 or delta_3 < 0:\n                new_solution[i+1:j+1] = new_solution[j:i:-1]\n                return new_solution\n\n    # If no improvement found, perform a random 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i+1:j+1] = new_solution[j:i:-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 78,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge swaps\n    N = len(selected)\n    new_solution = selected.copy()\n\n    # Randomly select a segment to perturb\n    i = np.random.randint(0, N-1)\n    j = np.random.randint(i+1, N)\n\n    # Reverse the segment (2-opt)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware edge swap: find edges with high total distance across objectives\n    for _ in range(2):  # Perform a few swaps\n        # Find the edge with maximum total distance across objectives\n        max_dist = -1\n        swap_i, swap_j = -1, -1\n\n        for k in range(N-1):\n            u, v = new_solution[k], new_solution[k+1]\n            dist = (distance_matrix_1[u, v] +\n                    distance_matrix_2[u, v] +\n                    distance_matrix_3[u, v])\n\n            if dist > max_dist:\n                max_dist = dist\n                swap_i, swap_j = k, k+1\n\n        if swap_i != -1 and swap_j != -1:\n            # Swap the nodes to potentially reduce total distance\n            if swap_j + 1 < N:\n                new_solution[swap_i], new_solution[swap_j+1] = new_solution[swap_j+1], new_solution[swap_i]\n\n    # Ensure the solution remains a valid tour\n    assert len(np.unique(new_solution)) == N, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            -0.7191131710927905,
            1.6366989970207215
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge swaps\n    N = len(selected)\n    new_solution = selected.copy()\n\n    # Randomly select a segment to perturb\n    i = np.random.randint(0, N-1)\n    j = np.random.randint(i+1, N)\n\n    # Reverse the segment (2-opt)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware edge swap: find edges with high total distance across objectives\n    for _ in range(2):  # Perform a few swaps\n        # Find the edge with maximum total distance across objectives\n        max_dist = -1\n        swap_i, swap_j = -1, -1\n\n        for k in range(N-1):\n            u, v = new_solution[k], new_solution[k+1]\n            dist = (distance_matrix_1[u, v] +\n                    distance_matrix_2[u, v] +\n                    distance_matrix_3[u, v])\n\n            if dist > max_dist:\n                max_dist = dist\n                swap_i, swap_j = k, k+1\n\n        if swap_i != -1 and swap_j != -1:\n            # Swap the nodes to potentially reduce total distance\n            if swap_j + 1 < N:\n                new_solution[swap_i], new_solution[swap_j+1] = new_solution[swap_j+1], new_solution[swap_i]\n\n    # Ensure the solution remains a valid tour\n    assert len(np.unique(new_solution)) == N, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 79,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmin(scores)  # Select the solution with the lowest sum of normalized objectives\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Apply 2-opt within the segment\n    if len(segment) >= 4:\n        k, l = sorted(np.random.choice(len(segment), 2, replace=False))\n        segment[k:l+1] = segment[k:l+1][::-1]\n\n    # Apply edge exchange between segments\n    if i > 0 and j < n-1:\n        new_solution[i], new_solution[j+1] = new_solution[j+1], new_solution[i]\n\n    # Ensure the solution is valid (visits all nodes exactly once)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6893966134544076,
            1.9418088674545289
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmin(scores)  # Select the solution with the lowest sum of normalized objectives\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator combining 2-opt and edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Apply 2-opt within the segment\n    if len(segment) >= 4:\n        k, l = sorted(np.random.choice(len(segment), 2, replace=False))\n        segment[k:l+1] = segment[k:l+1][::-1]\n\n    # Apply edge exchange between segments\n    if i > 0 and j < n-1:\n        new_solution[i], new_solution[j+1] = new_solution[j+1], new_solution[i]\n\n    # Ensure the solution is valid (visits all nodes exactly once)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 80,
        "algorithm": "{This heuristic function selects a promising solution from the archive by evaluating the diversity and potential for improvement in each objective space, then applies a hybrid local search combining 2-opt and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Evaluate diversity and potential improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: 2-opt combined with segment reversal\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # 2-opt move\n    if random.random() < 0.5:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Segment reversal with objective-aware selection\n        segment = new_solution[i:j+1]\n        segment_lengths = [\n            sum(distance_matrix_1[segment[k], segment[k+1]] for k in range(len(segment)-1)),\n            sum(distance_matrix_2[segment[k], segment[k+1]] for k in range(len(segment)-1)),\n            sum(distance_matrix_3[segment[k], segment[k+1]] for k in range(len(segment)-1))\n        ]\n        if random.random() < 0.7:  # Higher probability for objectives with higher diversity\n            segment = segment[::-1]\n        new_solution[i:j+1] = segment\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7399093279126256,
            1.3526769518852233
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Evaluate diversity and potential improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: 2-opt combined with segment reversal\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # 2-opt move\n    if random.random() < 0.5:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Segment reversal with objective-aware selection\n        segment = new_solution[i:j+1]\n        segment_lengths = [\n            sum(distance_matrix_1[segment[k], segment[k+1]] for k in range(len(segment)-1)),\n            sum(distance_matrix_2[segment[k], segment[k+1]] for k in range(len(segment)-1)),\n            sum(distance_matrix_3[segment[k], segment[k+1]] for k in range(len(segment)-1))\n        ]\n        if random.random() < 0.7:  # Higher probability for objectives with higher diversity\n            segment = segment[::-1]\n        new_solution[i:j+1] = segment\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 81,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges (i, i+1) and (j, j+1)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Calculate the cost reduction for all three objectives\n    def cost_reduction(a, b, c, d):\n        old_cost = (distance_matrix_1[a, b] + distance_matrix_1[c, d] +\n                     distance_matrix_2[a, b] + distance_matrix_2[c, d] +\n                     distance_matrix_3[a, b] + distance_matrix_3[c, d])\n        new_cost = (distance_matrix_1[a, d] + distance_matrix_1[c, b] +\n                    distance_matrix_2[a, d] + distance_matrix_2[c, b] +\n                    distance_matrix_3[a, d] + distance_matrix_3[c, b])\n        return old_cost - new_cost\n\n    a, b = new_solution[i], new_solution[(i+1)%n]\n    c, d = new_solution[j], new_solution[(j+1)%n]\n\n    if cost_reduction(a, b, c, d) > 0:\n        # Reverse the segment between i+1 and j\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7008523500358825,
            1.5234413146972656
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges (i, i+1) and (j, j+1)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Calculate the cost reduction for all three objectives\n    def cost_reduction(a, b, c, d):\n        old_cost = (distance_matrix_1[a, b] + distance_matrix_1[c, d] +\n                     distance_matrix_2[a, b] + distance_matrix_2[c, d] +\n                     distance_matrix_3[a, b] + distance_matrix_3[c, d])\n        new_cost = (distance_matrix_1[a, d] + distance_matrix_1[c, b] +\n                    distance_matrix_2[a, d] + distance_matrix_2[c, b] +\n                    distance_matrix_3[a, d] + distance_matrix_3[c, b])\n        return old_cost - new_cost\n\n    a, b = new_solution[i], new_solution[(i+1)%n]\n    c, d = new_solution[j], new_solution[(j+1)%n]\n\n    if cost_reduction(a, b, c, d) > 0:\n        # Reverse the segment between i+1 and j\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 82,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    objective_ranges = np.ptp(objectives, axis=0)\n    diversity_scores = np.sum((objectives - np.mean(objectives, axis=0))**2 / objective_ranges, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt for one objective, node insertion for another\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on the first objective\n    for _ in range(10):  # Limited iterations for efficiency\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j or j == (i + 1) % n:\n            continue\n        # Evaluate the current and reversed segment\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]])\n        reversed_cost = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                         distance_matrix_1[new_solution[i], new_solution[j]])\n        if reversed_cost < current_cost:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform node insertion on the second objective\n    for _ in range(5):  # Limited iterations for efficiency\n        node = random.choice(new_solution)\n        pos = np.where(new_solution == node)[0][0]\n        new_pos = random.randint(0, n-1)\n        if pos == new_pos:\n            continue\n        # Remove node and insert at new position\n        temp_solution = np.delete(new_solution, pos)\n        temp_solution = np.insert(temp_solution, new_pos, node)\n        # Evaluate the change in the second objective\n        old_cost = (distance_matrix_2[new_solution[pos-1], node] +\n                    distance_matrix_2[node, new_solution[(pos+1)%n]])\n        new_cost = (distance_matrix_2[temp_solution[new_pos-1], node] +\n                    distance_matrix_2[node, temp_solution[(new_pos+1)%n]])\n        if new_cost < old_cost:\n            new_solution = temp_solution\n\n    # Perform a small 2-opt on the third objective\n    for _ in range(3):  # Very limited iterations\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j or j == (i + 1) % n:\n            continue\n        current_cost = (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_3[new_solution[j-1], new_solution[j]])\n        reversed_cost = (distance_matrix_3[new_solution[i-1], new_solution[j-1]] +\n                         distance_matrix_3[new_solution[i], new_solution[j]])\n        if reversed_cost < current_cost:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6492677022282896,
            2.2563000082969666
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    objective_ranges = np.ptp(objectives, axis=0)\n    diversity_scores = np.sum((objectives - np.mean(objectives, axis=0))**2 / objective_ranges, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt for one objective, node insertion for another\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on the first objective\n    for _ in range(10):  # Limited iterations for efficiency\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j or j == (i + 1) % n:\n            continue\n        # Evaluate the current and reversed segment\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]])\n        reversed_cost = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                         distance_matrix_1[new_solution[i], new_solution[j]])\n        if reversed_cost < current_cost:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform node insertion on the second objective\n    for _ in range(5):  # Limited iterations for efficiency\n        node = random.choice(new_solution)\n        pos = np.where(new_solution == node)[0][0]\n        new_pos = random.randint(0, n-1)\n        if pos == new_pos:\n            continue\n        # Remove node and insert at new position\n        temp_solution = np.delete(new_solution, pos)\n        temp_solution = np.insert(temp_solution, new_pos, node)\n        # Evaluate the change in the second objective\n        old_cost = (distance_matrix_2[new_solution[pos-1], node] +\n                    distance_matrix_2[node, new_solution[(pos+1)%n]])\n        new_cost = (distance_matrix_2[temp_solution[new_pos-1], node] +\n                    distance_matrix_2[node, temp_solution[(new_pos+1)%n]])\n        if new_cost < old_cost:\n            new_solution = temp_solution\n\n    # Perform a small 2-opt on the third objective\n    for _ in range(3):  # Very limited iterations\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j or j == (i + 1) % n:\n            continue\n        current_cost = (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_3[new_solution[j-1], new_solution[j]])\n        reversed_cost = (distance_matrix_3[new_solution[i-1], new_solution[j-1]] +\n                         distance_matrix_3[new_solution[i], new_solution[j]])\n        if reversed_cost < current_cost:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 83,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    objectives = archive[selected_idx][1]\n\n    # Hybrid local search: 2-opt with objective-aware edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt with a probability based on objective improvement potential\n    if random.random() < 0.7:  # Higher probability for 2-opt\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Objective-aware edge swap: prioritize edges with high potential for improvement\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while abs(i - j) < 2 or abs(i - j) >= n - 1:  # Ensure meaningful swap\n            j = random.randint(0, n - 1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Verify the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.8006451874887428,
            0.9400730133056641
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    objectives = archive[selected_idx][1]\n\n    # Hybrid local search: 2-opt with objective-aware edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt with a probability based on objective improvement potential\n    if random.random() < 0.7:  # Higher probability for 2-opt\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Objective-aware edge swap: prioritize edges with high potential for improvement\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while abs(i - j) < 2 or abs(i - j) >= n - 1:  # Ensure meaningful swap\n            j = random.randint(0, n - 1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Verify the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 83,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    objectives = archive[selected_idx][1]\n\n    # Hybrid local search: 2-opt with objective-aware edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt with a probability based on objective improvement potential\n    if random.random() < 0.7:  # Higher probability for 2-opt\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Objective-aware edge swap: prioritize edges with high potential for improvement\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while abs(i - j) < 2 or abs(i - j) >= n - 1:  # Ensure meaningful swap\n            j = random.randint(0, n - 1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Verify the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.8006451874887428,
            0.9400730133056641
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    objectives = archive[selected_idx][1]\n\n    # Hybrid local search: 2-opt with objective-aware edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt with a probability based on objective improvement potential\n    if random.random() < 0.7:  # Higher probability for 2-opt\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Objective-aware edge swap: prioritize edges with high potential for improvement\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while abs(i - j) < 2 or abs(i - j) >= n - 1:  # Ensure meaningful swap\n            j = random.randint(0, n - 1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Verify the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 84,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge swaps\n    n = len(base_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform 2-opt swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware edge selection: prioritize edges with better combined distance\n    for _ in range(3):  # Perform 3 additional objective-guided swaps\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        if k == l or abs(k - l) == 1:\n            continue\n\n        # Calculate current and potential distances across all objectives\n        current_dist = (distance_matrix_1[base_solution[k-1], base_solution[k]] +\n                         distance_matrix_2[base_solution[k-1], base_solution[k]] +\n                         distance_matrix_3[base_solution[k-1], base_solution[k]] +\n                         distance_matrix_1[base_solution[l-1], base_solution[l]] +\n                         distance_matrix_2[base_solution[l-1], base_solution[l]] +\n                         distance_matrix_3[base_solution[l-1], base_solution[l]])\n\n        potential_dist = (distance_matrix_1[base_solution[k-1], base_solution[l]] +\n                           distance_matrix_2[base_solution[k-1], base_solution[l]] +\n                           distance_matrix_3[base_solution[k-1], base_solution[l]] +\n                           distance_matrix_1[base_solution[k], base_solution[l-1]] +\n                           distance_matrix_2[base_solution[k], base_solution[l-1]] +\n                           distance_matrix_3[base_solution[k], base_solution[l-1]])\n\n        if potential_dist < current_dist:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.5515327800445794,
            1.8072187781333924
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge swaps\n    n = len(base_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform 2-opt swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware edge selection: prioritize edges with better combined distance\n    for _ in range(3):  # Perform 3 additional objective-guided swaps\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        if k == l or abs(k - l) == 1:\n            continue\n\n        # Calculate current and potential distances across all objectives\n        current_dist = (distance_matrix_1[base_solution[k-1], base_solution[k]] +\n                         distance_matrix_2[base_solution[k-1], base_solution[k]] +\n                         distance_matrix_3[base_solution[k-1], base_solution[k]] +\n                         distance_matrix_1[base_solution[l-1], base_solution[l]] +\n                         distance_matrix_2[base_solution[l-1], base_solution[l]] +\n                         distance_matrix_3[base_solution[l-1], base_solution[l]])\n\n        potential_dist = (distance_matrix_1[base_solution[k-1], base_solution[l]] +\n                           distance_matrix_2[base_solution[k-1], base_solution[l]] +\n                           distance_matrix_3[base_solution[k-1], base_solution[l]] +\n                           distance_matrix_1[base_solution[k], base_solution[l-1]] +\n                           distance_matrix_2[base_solution[k], base_solution[l-1]] +\n                           distance_matrix_3[base_solution[k], base_solution[l-1]])\n\n        if potential_dist < current_dist:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 85,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives for fair comparison\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n\n    # Select the solution with the highest sum of normalized objectives\n    selected_idx = np.argmax(np.sum(normalized_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to balance exploration and computation\n        # Select edges based on their contribution to the worst objective\n        edge_contributions = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i + 1) % n]\n            # Contribution is the max of the three objectives for this edge\n            contribution = max(distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n            edge_contributions.append((contribution, i))\n\n        # Sort edges by contribution (descending) to prioritize worst edges\n        edge_contributions.sort(reverse=True, key=lambda x: x[0])\n        worst_edge_idx = edge_contributions[0][1]\n\n        # Perform 2-opt on the worst edge\n        i = worst_edge_idx\n        j = (i + 1) % n\n        if j < i:\n            i, j = j, i\n\n        # Find the best possible swap to improve the worst objective\n        best_gain = 0\n        best_k = -1\n        for k in range(i + 1, j):\n            l = (k + 1) % n\n            # Calculate gain for each objective\n            gain1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[j], new_solution[l]] - distance_matrix_1[new_solution[i], new_solution[j]] - distance_matrix_1[new_solution[k], new_solution[l]]\n            gain2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[j], new_solution[l]] - distance_matrix_2[new_solution[i], new_solution[j]] - distance_matrix_2[new_solution[k], new_solution[l]]\n            gain3 = distance_matrix_3[new_solution[i], new_solution[k]] + distance_matrix_3[new_solution[j], new_solution[l]] - distance_matrix_3[new_solution[i], new_solution[j]] - distance_matrix_3[new_solution[k], new_solution[l]]\n            # Total gain is the maximum improvement across objectives\n            total_gain = max(gain1, gain2, gain3)\n            if total_gain > best_gain:\n                best_gain = total_gain\n                best_k = k\n\n        if best_k != -1:\n            # Perform the 2-opt swap\n            new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    return new_solution\n\n",
        "score": [
            -0.6763885643930275,
            2.7428770899772643
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives for fair comparison\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n\n    # Select the solution with the highest sum of normalized objectives\n    selected_idx = np.argmax(np.sum(normalized_obj, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to balance exploration and computation\n        # Select edges based on their contribution to the worst objective\n        edge_contributions = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i + 1) % n]\n            # Contribution is the max of the three objectives for this edge\n            contribution = max(distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n            edge_contributions.append((contribution, i))\n\n        # Sort edges by contribution (descending) to prioritize worst edges\n        edge_contributions.sort(reverse=True, key=lambda x: x[0])\n        worst_edge_idx = edge_contributions[0][1]\n\n        # Perform 2-opt on the worst edge\n        i = worst_edge_idx\n        j = (i + 1) % n\n        if j < i:\n            i, j = j, i\n\n        # Find the best possible swap to improve the worst objective\n        best_gain = 0\n        best_k = -1\n        for k in range(i + 1, j):\n            l = (k + 1) % n\n            # Calculate gain for each objective\n            gain1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[j], new_solution[l]] - distance_matrix_1[new_solution[i], new_solution[j]] - distance_matrix_1[new_solution[k], new_solution[l]]\n            gain2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[j], new_solution[l]] - distance_matrix_2[new_solution[i], new_solution[j]] - distance_matrix_2[new_solution[k], new_solution[l]]\n            gain3 = distance_matrix_3[new_solution[i], new_solution[k]] + distance_matrix_3[new_solution[j], new_solution[l]] - distance_matrix_3[new_solution[i], new_solution[j]] - distance_matrix_3[new_solution[k], new_solution[l]]\n            # Total gain is the maximum improvement across objectives\n            total_gain = max(gain1, gain2, gain3)\n            if total_gain > best_gain:\n                best_gain = total_gain\n                best_k = k\n\n        if best_k != -1:\n            # Perform the 2-opt swap\n            new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 86,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: perform a combination of 2-opt and node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select a node to reinsert for node insertion\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.5900211406629999,
            1.198138678073883
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: perform a combination of 2-opt and node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select a node to reinsert for node insertion\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 87,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    # Randomly select two segments and reverse them to create a new tour\n    n = len(selected_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution = selected_solution.copy()\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7202825420031502,
            0.9895577907562256
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    # Randomly select two segments and reverse them to create a new tour\n    n = len(selected_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution = selected_solution.copy()\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 88,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.linspace(0.1, 0.9, len(archive)).sum())\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        # Evaluate edge swaps in all three objectives\n        obj1 = (distance_matrix_1[new_solution[i-1], new_solution[k]] +\n                distance_matrix_1[new_solution[k], new_solution[j]] +\n                distance_matrix_1[new_solution[j], new_solution[i]])\n        obj2 = (distance_matrix_2[new_solution[i-1], new_solution[k]] +\n                distance_matrix_2[new_solution[k], new_solution[j]] +\n                distance_matrix_2[new_solution[j], new_solution[i]])\n        obj3 = (distance_matrix_3[new_solution[i-1], new_solution[k]] +\n                distance_matrix_3[new_solution[k], new_solution[j]] +\n                distance_matrix_3[new_solution[j], new_solution[i]])\n        # Accept if any objective improves\n        if (obj1 < distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[i], new_solution[j]] +\n            distance_matrix_1[new_solution[j], new_solution[k]] +\n            distance_matrix_1[new_solution[k], new_solution[i-1]]) or \\\n           (obj2 < distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[i], new_solution[j]] +\n            distance_matrix_2[new_solution[j], new_solution[k]] +\n            distance_matrix_2[new_solution[k], new_solution[i-1]]) or \\\n           (obj3 < distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[i], new_solution[j]] +\n            distance_matrix_3[new_solution[j], new_solution[k]] +\n            distance_matrix_3[new_solution[k], new_solution[i-1]]):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7696755688717497,
            2.079326128959656
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.linspace(0.1, 0.9, len(archive)).sum())\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        # Evaluate edge swaps in all three objectives\n        obj1 = (distance_matrix_1[new_solution[i-1], new_solution[k]] +\n                distance_matrix_1[new_solution[k], new_solution[j]] +\n                distance_matrix_1[new_solution[j], new_solution[i]])\n        obj2 = (distance_matrix_2[new_solution[i-1], new_solution[k]] +\n                distance_matrix_2[new_solution[k], new_solution[j]] +\n                distance_matrix_2[new_solution[j], new_solution[i]])\n        obj3 = (distance_matrix_3[new_solution[i-1], new_solution[k]] +\n                distance_matrix_3[new_solution[k], new_solution[j]] +\n                distance_matrix_3[new_solution[j], new_solution[i]])\n        # Accept if any objective improves\n        if (obj1 < distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[i], new_solution[j]] +\n            distance_matrix_1[new_solution[j], new_solution[k]] +\n            distance_matrix_1[new_solution[k], new_solution[i-1]]) or \\\n           (obj2 < distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[i], new_solution[j]] +\n            distance_matrix_2[new_solution[j], new_solution[k]] +\n            distance_matrix_2[new_solution[k], new_solution[i-1]]) or \\\n           (obj3 < distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[i], new_solution[j]] +\n            distance_matrix_3[new_solution[j], new_solution[k]] +\n            distance_matrix_3[new_solution[k], new_solution[i-1]]):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 89,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Compute the crowding distance for each solution in the archive\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(3):  # For each objective\n        sorted_indices = np.argsort(objectives[:, m])\n        objectives_sorted = objectives[sorted_indices, m]\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        for i in range(1, len(archive)-1):\n            if objectives_sorted[-1] == objectives_sorted[0]:\n                crowding_distances[sorted_indices[i]] += 0\n            else:\n                crowding_distances[sorted_indices[i]] += (objectives_sorted[i+1] - objectives_sorted[i-1]) / (objectives_sorted[-1] - objectives_sorted[0])\n\n    # Select the solution with the highest crowding distance (most diverse)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to swap (ensuring no revisits)\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Ensure the segments are distinct\n    if i == k and j == l:\n        k, l = (k + 1) % n, (l + 1) % n\n\n    # Create a new solution by swapping the segments\n    new_solution = np.concatenate([new_solution[:i], new_solution[k:l+1], new_solution[i:j+1], new_solution[l+1:], new_solution[j+1:]])\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple 2-opt move if the swap causes duplicates\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7152917358397511,
            2.112385320663452
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Compute the crowding distance for each solution in the archive\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(3):  # For each objective\n        sorted_indices = np.argsort(objectives[:, m])\n        objectives_sorted = objectives[sorted_indices, m]\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        for i in range(1, len(archive)-1):\n            if objectives_sorted[-1] == objectives_sorted[0]:\n                crowding_distances[sorted_indices[i]] += 0\n            else:\n                crowding_distances[sorted_indices[i]] += (objectives_sorted[i+1] - objectives_sorted[i-1]) / (objectives_sorted[-1] - objectives_sorted[0])\n\n    # Select the solution with the highest crowding distance (most diverse)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to swap (ensuring no revisits)\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Ensure the segments are distinct\n    if i == k and j == l:\n        k, l = (k + 1) % n, (l + 1) % n\n\n    # Create a new solution by swapping the segments\n    new_solution = np.concatenate([new_solution[:i], new_solution[k:l+1], new_solution[i:j+1], new_solution[l+1:], new_solution[j+1:]])\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple 2-opt move if the swap causes duplicates\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 90,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a promising solution from the archive and applies a multi-objective edge-swap and segment-reversal operator to generate a neighbor solution, ensuring feasibility and diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = archive[0][0].copy()  # Placeholder for selection logic\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose two distinct segments and reverse them\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Ensure the segments are not too small\n    if j - i > 2:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly swap two edges to further perturb the solution\n    k, l = np.random.choice(n, size=2, replace=False)\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7253363756258708,
            1.4295976400375365
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = archive[0][0].copy()  # Placeholder for selection logic\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose two distinct segments and reverse them\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Ensure the segments are not too small\n    if j - i > 2:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly swap two edges to further perturb the solution\n    k, l = np.random.choice(n, size=2, replace=False)\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 91,
        "algorithm": "{A novel hybrid local search algorithm that intelligently combines 2-opt moves with adaptive segment swaps across all three objectives, prioritizing segments with the highest potential for multi-objective improvement by evaluating the trade-off between edge deletions and insertions in the combined distance space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap\n    i, j = np.random.choice(n, 2, replace=False)\n    a, b = min(i, j), max(i, j)\n\n    # Perform a segment swap\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Apply 2-opt to further refine the solution\n    for _ in range(10):  # Limit the number of 2-opt steps\n        i, j = np.random.choice(n, 2, replace=False)\n        a, b = min(i, j), max(i, j)\n\n        # Calculate the current and potential costs\n        current_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                        distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_3[new_solution[b-1], new_solution[b]])\n\n        potential_cost = (distance_matrix_1[new_solution[a-1], new_solution[b-1]] +\n                         distance_matrix_1[new_solution[a], new_solution[b]] +\n                         distance_matrix_2[new_solution[a-1], new_solution[b-1]] +\n                         distance_matrix_2[new_solution[a], new_solution[b]] +\n                         distance_matrix_3[new_solution[a-1], new_solution[b-1]] +\n                         distance_matrix_3[new_solution[a], new_solution[b]])\n\n        if potential_cost < current_cost:\n            new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n",
        "score": [
            -0.6086584595723121,
            2.130573868751526
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap\n    i, j = np.random.choice(n, 2, replace=False)\n    a, b = min(i, j), max(i, j)\n\n    # Perform a segment swap\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Apply 2-opt to further refine the solution\n    for _ in range(10):  # Limit the number of 2-opt steps\n        i, j = np.random.choice(n, 2, replace=False)\n        a, b = min(i, j), max(i, j)\n\n        # Calculate the current and potential costs\n        current_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                        distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_3[new_solution[b-1], new_solution[b]])\n\n        potential_cost = (distance_matrix_1[new_solution[a-1], new_solution[b-1]] +\n                         distance_matrix_1[new_solution[a], new_solution[b]] +\n                         distance_matrix_2[new_solution[a-1], new_solution[b-1]] +\n                         distance_matrix_2[new_solution[a], new_solution[b]] +\n                         distance_matrix_3[new_solution[a-1], new_solution[b-1]] +\n                         distance_matrix_3[new_solution[a], new_solution[b]])\n\n        if potential_cost < current_cost:\n            new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 92,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(o[0] for o in objectives)\n    max_obj2 = max(o[1] for o in objectives)\n    max_obj3 = max(o[2] for o in objectives)\n\n    candidates = []\n    for sol, obj in archive:\n        if obj[0] == max_obj1 and obj[1] <= max_obj2 * 0.9 and obj[2] <= max_obj3 * 0.9:\n            candidates.append(sol)\n        elif obj[1] == max_obj2 and obj[0] <= max_obj1 * 0.9 and obj[2] <= max_obj3 * 0.9:\n            candidates.append(sol)\n        elif obj[2] == max_obj3 and obj[0] <= max_obj1 * 0.9 and obj[1] <= max_obj2 * 0.9:\n            candidates.append(sol)\n\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of 2-opt and node insertion\n    n = len(base_solution)\n    for _ in range(10):  # Number of attempts\n        # Randomly select two distinct edges to break\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # Perform 2-opt swap\n        new_solution = np.concatenate([\n            new_solution[:i+1],\n            new_solution[j:i:-1],\n            new_solution[l:k:-1],\n            new_solution[j+1:]\n        ])\n\n        # Check feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Node insertion for further improvement\n    for _ in range(5):\n        # Randomly select a node to move\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Remove the node\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Find the best insertion point considering all three objectives\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(n-1):\n            # Calculate the change in all three objectives\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos]\n\n            delta1 = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] -\n                     distance_matrix_1[prev_node, next_node])\n            delta2 = (distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] -\n                     distance_matrix_2[prev_node, next_node])\n            delta3 = (distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node] -\n                     distance_matrix_3[prev_node, next_node])\n\n            # Use a weighted sum of deltas as the score\n            score = delta1 * 0.4 + delta2 * 0.3 + delta3 * 0.3\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.690388928866232,
            1.6405029773712159
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(o[0] for o in objectives)\n    max_obj2 = max(o[1] for o in objectives)\n    max_obj3 = max(o[2] for o in objectives)\n\n    candidates = []\n    for sol, obj in archive:\n        if obj[0] == max_obj1 and obj[1] <= max_obj2 * 0.9 and obj[2] <= max_obj3 * 0.9:\n            candidates.append(sol)\n        elif obj[1] == max_obj2 and obj[0] <= max_obj1 * 0.9 and obj[2] <= max_obj3 * 0.9:\n            candidates.append(sol)\n        elif obj[2] == max_obj3 and obj[0] <= max_obj1 * 0.9 and obj[1] <= max_obj2 * 0.9:\n            candidates.append(sol)\n\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of 2-opt and node insertion\n    n = len(base_solution)\n    for _ in range(10):  # Number of attempts\n        # Randomly select two distinct edges to break\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # Perform 2-opt swap\n        new_solution = np.concatenate([\n            new_solution[:i+1],\n            new_solution[j:i:-1],\n            new_solution[l:k:-1],\n            new_solution[j+1:]\n        ])\n\n        # Check feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Node insertion for further improvement\n    for _ in range(5):\n        # Randomly select a node to move\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Remove the node\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Find the best insertion point considering all three objectives\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(n-1):\n            # Calculate the change in all three objectives\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos]\n\n            delta1 = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] -\n                     distance_matrix_1[prev_node, next_node])\n            delta2 = (distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] -\n                     distance_matrix_2[prev_node, next_node])\n            delta3 = (distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node] -\n                     distance_matrix_3[prev_node, next_node])\n\n            # Use a weighted sum of deltas as the score\n            score = delta1 * 0.4 + delta2 * 0.3 + delta3 * 0.3\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 93,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = sorted(archive, key=lambda x: sum(x[1]))\n    num_candidates = max(5, len(candidates) // 5)\n    selected = random.choice(candidates[:num_candidates])\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform a random 2-opt move (ensures feasibility)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform an objective-aware swap: identify the worst edge in any objective and swap it with a better alternative\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        # Find the worst edge in this objective\n        worst_edge = -1\n        max_dist = -1\n        for k in range(n):\n            u, v = new_solution[k], new_solution[(k+1)%n]\n            dist = distance_matrix[u, v]\n            if dist > max_dist:\n                max_dist = dist\n                worst_edge = k\n\n        if worst_edge != -1:\n            # Find a better swap candidate\n            best_improvement = 0\n            best_swap = None\n            u = new_solution[worst_edge]\n            v = new_solution[(worst_edge+1)%n]\n\n            # Try swapping with a random node\n            for _ in range(5):  # Limit attempts to maintain efficiency\n                k = random.randint(0, n-1)\n                if k != worst_edge and k != (worst_edge+1)%n:\n                    # Calculate improvement\n                    old_dist = distance_matrix[u, v] + distance_matrix[new_solution[(worst_edge-1)%n], u]\n                    new_dist = distance_matrix[new_solution[(worst_edge-1)%n], new_solution[k]] + distance_matrix[new_solution[k], v]\n                    improvement = old_dist - new_dist\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_swap = k\n\n            if best_swap is not None:\n                # Perform the swap\n                temp = new_solution[worst_edge]\n                new_solution[worst_edge] = new_solution[best_swap]\n                new_solution[best_swap] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.7594712404273684,
            1.631797432899475
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = sorted(archive, key=lambda x: sum(x[1]))\n    num_candidates = max(5, len(candidates) // 5)\n    selected = random.choice(candidates[:num_candidates])\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform a random 2-opt move (ensures feasibility)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform an objective-aware swap: identify the worst edge in any objective and swap it with a better alternative\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        # Find the worst edge in this objective\n        worst_edge = -1\n        max_dist = -1\n        for k in range(n):\n            u, v = new_solution[k], new_solution[(k+1)%n]\n            dist = distance_matrix[u, v]\n            if dist > max_dist:\n                max_dist = dist\n                worst_edge = k\n\n        if worst_edge != -1:\n            # Find a better swap candidate\n            best_improvement = 0\n            best_swap = None\n            u = new_solution[worst_edge]\n            v = new_solution[(worst_edge+1)%n]\n\n            # Try swapping with a random node\n            for _ in range(5):  # Limit attempts to maintain efficiency\n                k = random.randint(0, n-1)\n                if k != worst_edge and k != (worst_edge+1)%n:\n                    # Calculate improvement\n                    old_dist = distance_matrix[u, v] + distance_matrix[new_solution[(worst_edge-1)%n], u]\n                    new_dist = distance_matrix[new_solution[(worst_edge-1)%n], new_solution[k]] + distance_matrix[new_solution[k], v]\n                    improvement = old_dist - new_dist\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_swap = k\n\n            if best_swap is not None:\n                # Perform the swap\n                temp = new_solution[worst_edge]\n                new_solution[worst_edge] = new_solution[best_swap]\n                new_solution[best_swap] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 94,
        "algorithm": "{This heuristic function selects a solution from the archive based on its potential for improvement across multiple objectives, then applies a hybrid local search operator that combines 2-opt and 3-opt moves, guided by a multi-objective improvement criterion, to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected = random.choices(\n        archive,\n        weights=[1 / (obj[0] + obj[1] + obj[2] + 1e-6) for _, obj in archive],\n        k=1\n    )[0]\n    base_solution = selected[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    for _ in range(10):  # Number of attempts\n        # Randomly choose between 2-opt and 3-opt\n        op = random.choice(['2-opt', '3-opt'])\n\n        if op == '2-opt':\n            # Perform 2-opt move\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Perform 3-opt move\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            new_solution[i:k] = np.concatenate([segment2, segment1])\n\n        # Check if the new solution is non-dominated compared to the original\n        original_obj = selected[1]\n        new_obj = (\n            sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        )\n\n        # Accept if at least one objective is better\n        if any(new < orig for new, orig in zip(new_obj, original_obj)):\n            return new_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8083918149731539,
            1.6537862062454223
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected = random.choices(\n        archive,\n        weights=[1 / (obj[0] + obj[1] + obj[2] + 1e-6) for _, obj in archive],\n        k=1\n    )[0]\n    base_solution = selected[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    for _ in range(10):  # Number of attempts\n        # Randomly choose between 2-opt and 3-opt\n        op = random.choice(['2-opt', '3-opt'])\n\n        if op == '2-opt':\n            # Perform 2-opt move\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Perform 3-opt move\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            new_solution[i:k] = np.concatenate([segment2, segment1])\n\n        # Check if the new solution is non-dominated compared to the original\n        original_obj = selected[1]\n        new_obj = (\n            sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        )\n\n        # Accept if at least one objective is better\n        if any(new < orig for new, orig in zip(new_obj, original_obj)):\n            return new_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 95,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with multi-objective aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select two edges to swap based on their contribution to all three objectives\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Calculate the cost of the current and new edges in all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n        cost3 = sum(distance_matrix_3[sol[i], sol[(i+1)%n]] for i in range(n))\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n    temp_solution = new_solution.copy()\n    temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n    temp_solution[k:l+1] = temp_solution[k:l+1][::-1]\n    new_cost = calculate_cost(temp_solution)\n\n    # Accept the move if it improves at least one objective\n    if any(new_cost[i] < current_cost[i] for i in range(3)):\n        new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.6806678723009549,
            2.180853569507599
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with multi-objective aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select two edges to swap based on their contribution to all three objectives\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Calculate the cost of the current and new edges in all three objectives\n    def calculate_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n        cost3 = sum(distance_matrix_3[sol[i], sol[(i+1)%n]] for i in range(n))\n        return (cost1, cost2, cost3)\n\n    current_cost = calculate_cost(new_solution)\n    temp_solution = new_solution.copy()\n    temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n    temp_solution[k:l+1] = temp_solution[k:l+1][::-1]\n    new_cost = calculate_cost(temp_solution)\n\n    # Accept the move if it improves at least one objective\n    if any(new_cost[i] < current_cost[i] for i in range(3)):\n        new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 96,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n_nodes = len(base_solution)\n    i, j = sorted(np.random.choice(n_nodes, 2, replace=False))\n\n    # Calculate edge contributions in all three objectives\n    edge1 = (distance_matrix_1[base_solution[i-1], base_solution[i]] +\n             distance_matrix_1[base_solution[j], base_solution[(j+1)%n_nodes]])\n    edge2 = (distance_matrix_2[base_solution[i-1], base_solution[i]] +\n             distance_matrix_2[base_solution[j], base_solution[(j+1)%n_nodes]])\n    edge3 = (distance_matrix_3[base_solution[i-1], base_solution[i]] +\n             distance_matrix_3[base_solution[j], base_solution[(j+1)%n_nodes]])\n\n    new_edge1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] +\n                 distance_matrix_1[base_solution[i], base_solution[(j+1)%n_nodes]])\n    new_edge2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] +\n                 distance_matrix_2[base_solution[i], base_solution[(j+1)%n_nodes]])\n    new_edge3 = (distance_matrix_3[base_solution[i-1], base_solution[j]] +\n                 distance_matrix_3[base_solution[i], base_solution[(j+1)%n_nodes]])\n\n    # Only perform swap if it improves at least one objective\n    if (new_edge1 < edge1 or new_edge2 < edge2 or new_edge3 < edge3):\n        new_solution[i:j+1] = np.flip(base_solution[i:j+1])\n\n    return new_solution\n\n",
        "score": [
            -0.7754747530383461,
            2.062618887424469
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n_nodes = len(base_solution)\n    i, j = sorted(np.random.choice(n_nodes, 2, replace=False))\n\n    # Calculate edge contributions in all three objectives\n    edge1 = (distance_matrix_1[base_solution[i-1], base_solution[i]] +\n             distance_matrix_1[base_solution[j], base_solution[(j+1)%n_nodes]])\n    edge2 = (distance_matrix_2[base_solution[i-1], base_solution[i]] +\n             distance_matrix_2[base_solution[j], base_solution[(j+1)%n_nodes]])\n    edge3 = (distance_matrix_3[base_solution[i-1], base_solution[i]] +\n             distance_matrix_3[base_solution[j], base_solution[(j+1)%n_nodes]])\n\n    new_edge1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] +\n                 distance_matrix_1[base_solution[i], base_solution[(j+1)%n_nodes]])\n    new_edge2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] +\n                 distance_matrix_2[base_solution[i], base_solution[(j+1)%n_nodes]])\n    new_edge3 = (distance_matrix_3[base_solution[i-1], base_solution[j]] +\n                 distance_matrix_3[base_solution[i], base_solution[(j+1)%n_nodes]])\n\n    # Only perform swap if it improves at least one objective\n    if (new_edge1 < edge1 or new_edge2 < edge2 or new_edge3 < edge3):\n        new_solution[i:j+1] = np.flip(base_solution[i:j+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 97,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Randomly select a solution with a bias towards those with lower objective values\n    weights = [1 / (1 + sum(obj)) for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=np.array(weights) / sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with multi-objective edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to break and reconnect\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Ensure the edges are not adjacent\n    if abs(i - j) == 1 or abs(k - l) == 1:\n        return new_solution\n\n    # Perform the 2-opt move\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    new_solution[k:l+1] = np.flip(new_solution[k:l+1])\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7965018835172542,
            1.9736953258514405
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Randomly select a solution with a bias towards those with lower objective values\n    weights = [1 / (1 + sum(obj)) for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=np.array(weights) / sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with multi-objective edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to break and reconnect\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Ensure the edges are not adjacent\n    if abs(i - j) == 1 or abs(k - l) == 1:\n        return new_solution\n\n    # Perform the 2-opt move\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    new_solution[k:l+1] = np.flip(new_solution[k:l+1])\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 98,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance in the objective space\n    def crowding_distance(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        distances = np.zeros(len(objectives))\n        for m in range(3):  # For each objective\n            sorted_idx = np.argsort(objectives[:, m])\n            sorted_obj = objectives[sorted_idx, m]\n            distances[sorted_idx[0]] = np.inf\n            distances[sorted_idx[-1]] = np.inf\n            for i in range(1, len(sorted_idx) - 1):\n                if sorted_obj[-1] == sorted_obj[0]:\n                    distances[sorted_idx[i]] = np.inf\n                else:\n                    distances[sorted_idx[i]] += (sorted_obj[i+1] - sorted_obj[i-1]) / (sorted_obj[-1] - sorted_obj[0])\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: 2-opt with adaptive node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with random segments\n    for _ in range(5):  # Number of 2-opt iterations\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Adaptive node insertion based on objective improvements\n    for _ in range(3):  # Number of insertion iterations\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i == j:\n            continue\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        # Insert node at position j with highest potential improvement\n        best_pos = j\n        best_improvement = 0\n        for pos in range(n-1):\n            if pos == i:\n                continue\n            # Calculate improvement for each objective\n            old_cost = (distance_matrix_1[new_solution[pos-1], new_solution[pos]] +\n                        distance_matrix_1[new_solution[pos], new_solution[(pos+1)%(n-1)]])\n            new_cost = (distance_matrix_1[new_solution[pos-1], node] +\n                        distance_matrix_1[node, new_solution[(pos+1)%(n-1)]])\n            improvement = old_cost - new_cost\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6423206054891776,
            2.6534465312957765
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance in the objective space\n    def crowding_distance(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        distances = np.zeros(len(objectives))\n        for m in range(3):  # For each objective\n            sorted_idx = np.argsort(objectives[:, m])\n            sorted_obj = objectives[sorted_idx, m]\n            distances[sorted_idx[0]] = np.inf\n            distances[sorted_idx[-1]] = np.inf\n            for i in range(1, len(sorted_idx) - 1):\n                if sorted_obj[-1] == sorted_obj[0]:\n                    distances[sorted_idx[i]] = np.inf\n                else:\n                    distances[sorted_idx[i]] += (sorted_obj[i+1] - sorted_obj[i-1]) / (sorted_obj[-1] - sorted_obj[0])\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: 2-opt with adaptive node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with random segments\n    for _ in range(5):  # Number of 2-opt iterations\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Adaptive node insertion based on objective improvements\n    for _ in range(3):  # Number of insertion iterations\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i == j:\n            continue\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        # Insert node at position j with highest potential improvement\n        best_pos = j\n        best_improvement = 0\n        for pos in range(n-1):\n            if pos == i:\n                continue\n            # Calculate improvement for each objective\n            old_cost = (distance_matrix_1[new_solution[pos-1], new_solution[pos]] +\n                        distance_matrix_1[new_solution[pos], new_solution[(pos+1)%(n-1)]])\n            new_cost = (distance_matrix_1[new_solution[pos-1], node] +\n                        distance_matrix_1[node, new_solution[(pos+1)%(n-1)]])\n            improvement = old_cost - new_cost\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 99,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        # Normalize objectives\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        # Select solution with highest variance (most diverse objectives)\n        variances = np.var(normalized, axis=1)\n        selected_idx = np.argmax(variances)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 2-opt with multi-objective aware swap\n    for _ in range(10):  # Perform multiple iterations\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # 2-opt move\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Multi-objective aware swap\n        if l - k > 1:\n            # Calculate current and potential costs\n            current_cost = (\n                distance_matrix_1[new_solution[k], new_solution[k+1]] +\n                distance_matrix_1[new_solution[l], new_solution[(l+1)%n]] +\n                distance_matrix_2[new_solution[k], new_solution[k+1]] +\n                distance_matrix_2[new_solution[l], new_solution[(l+1)%n]] +\n                distance_matrix_3[new_solution[k], new_solution[k+1]] +\n                distance_matrix_3[new_solution[l], new_solution[(l+1)%n]]\n            )\n\n            # Swap k+1 to l\n            temp = new_solution[k+1:l+1].copy()\n            new_solution[k+1:l+1] = new_solution[k+1:l+1][::-1]\n\n            new_cost = (\n                distance_matrix_1[new_solution[k], new_solution[k+1]] +\n                distance_matrix_1[new_solution[l], new_solution[(l+1)%n]] +\n                distance_matrix_2[new_solution[k], new_solution[k+1]] +\n                distance_matrix_2[new_solution[l], new_solution[(l+1)%n]] +\n                distance_matrix_3[new_solution[k], new_solution[k+1]] +\n                distance_matrix_3[new_solution[l], new_solution[(l+1)%n]]\n            )\n\n            # If swap doesn't improve all objectives, revert\n            if new_cost >= current_cost:\n                new_solution[k+1:l+1] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.7914371258595613,
            2.175461459159851
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        # Normalize objectives\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        # Select solution with highest variance (most diverse objectives)\n        variances = np.var(normalized, axis=1)\n        selected_idx = np.argmax(variances)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 2-opt with multi-objective aware swap\n    for _ in range(10):  # Perform multiple iterations\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # 2-opt move\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Multi-objective aware swap\n        if l - k > 1:\n            # Calculate current and potential costs\n            current_cost = (\n                distance_matrix_1[new_solution[k], new_solution[k+1]] +\n                distance_matrix_1[new_solution[l], new_solution[(l+1)%n]] +\n                distance_matrix_2[new_solution[k], new_solution[k+1]] +\n                distance_matrix_2[new_solution[l], new_solution[(l+1)%n]] +\n                distance_matrix_3[new_solution[k], new_solution[k+1]] +\n                distance_matrix_3[new_solution[l], new_solution[(l+1)%n]]\n            )\n\n            # Swap k+1 to l\n            temp = new_solution[k+1:l+1].copy()\n            new_solution[k+1:l+1] = new_solution[k+1:l+1][::-1]\n\n            new_cost = (\n                distance_matrix_1[new_solution[k], new_solution[k+1]] +\n                distance_matrix_1[new_solution[l], new_solution[(l+1)%n]] +\n                distance_matrix_2[new_solution[k], new_solution[k+1]] +\n                distance_matrix_2[new_solution[l], new_solution[(l+1)%n]] +\n                distance_matrix_3[new_solution[k], new_solution[k+1]] +\n                distance_matrix_3[new_solution[l], new_solution[(l+1)%n]]\n            )\n\n            # If swap doesn't improve all objectives, revert\n            if new_cost >= current_cost:\n                new_solution[k+1:l+1] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 100,
        "algorithm": "{The algorithm selects a solution from the archive with the highest improvement potential by combining objective diversity and solution quality, then applies a hybrid local search operator that combines 2-opt with objective-specific edge swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_solution = None\n    max_potential = -1\n\n    for sol, obj in archive:\n        # Calculate potential as a combination of objective diversity and solution quality\n        diversity = (obj[0] - obj[1])**2 + (obj[1] - obj[2])**2 + (obj[2] - obj[0])**2\n        quality = sum(obj)\n        potential = diversity / (1 + quality)\n\n        if potential > max_potential:\n            max_potential = potential\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = random.choice(archive)[0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct positions\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Apply 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply objective-specific edge swaps\n    for _ in range(2):  # Apply 2 random edge swaps\n        k, l = random.sample(range(n), 2)\n        if k > l:\n            k, l = l, k\n\n        # Check if swap improves any objective\n        current_cost = (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                        distance_matrix_2[new_solution[l-1], new_solution[l]] +\n                        distance_matrix_3[new_solution[k-1], new_solution[k]])\n\n        new_cost = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                     distance_matrix_2[new_solution[l-1], new_solution[k]] +\n                     distance_matrix_3[new_solution[k-1], new_solution[l]])\n\n        if new_cost < current_cost:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.47192011714135856,
            1.725727379322052
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_solution = None\n    max_potential = -1\n\n    for sol, obj in archive:\n        # Calculate potential as a combination of objective diversity and solution quality\n        diversity = (obj[0] - obj[1])**2 + (obj[1] - obj[2])**2 + (obj[2] - obj[0])**2\n        quality = sum(obj)\n        potential = diversity / (1 + quality)\n\n        if potential > max_potential:\n            max_potential = potential\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = random.choice(archive)[0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct positions\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Apply 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply objective-specific edge swaps\n    for _ in range(2):  # Apply 2 random edge swaps\n        k, l = random.sample(range(n), 2)\n        if k > l:\n            k, l = l, k\n\n        # Check if swap improves any objective\n        current_cost = (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                        distance_matrix_2[new_solution[l-1], new_solution[l]] +\n                        distance_matrix_3[new_solution[k-1], new_solution[k]])\n\n        new_cost = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                     distance_matrix_2[new_solution[l-1], new_solution[k]] +\n                     distance_matrix_3[new_solution[k-1], new_solution[l]])\n\n        if new_cost < current_cost:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 101,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: 2-opt with multi-objective adaptive perturbation\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to balance exploration and computation\n        i, j = sorted(random.sample(range(n), 2))\n        # Check if the swap improves any objective\n        original_costs = [\n            sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n        ]\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse the segment\n        new_costs = [\n            sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n        ]\n        # Revert if no improvement in any objective\n        if all(new_cost >= orig_cost for new_cost, orig_cost in zip(new_costs, original_costs)):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7446857097634908,
            3.938579297065735
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: 2-opt with multi-objective adaptive perturbation\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to balance exploration and computation\n        i, j = sorted(random.sample(range(n), 2))\n        # Check if the swap improves any objective\n        original_costs = [\n            sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n        ]\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse the segment\n        new_costs = [\n            sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n        ]\n        # Revert if no improvement in any objective\n        if all(new_cost >= orig_cost for new_cost, orig_cost in zip(new_costs, original_costs)):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 102,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search: combine 2-opt with a novel 3-way swap for multi-objective optimization\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # First, perform a random 2-opt move\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Then, perform a 3-way swap to optimize across multiple objectives\n    if n >= 3:\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5292658348912489,
            1.0030482172966004
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search: combine 2-opt with a novel 3-way swap for multi-objective optimization\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # First, perform a random 2-opt move\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Then, perform a 3-way swap to optimize across multiple objectives\n    if n >= 3:\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 103,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations for better exploration\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # 2-opt move\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Objective-aware swap: identify nodes with high marginal improvement\n        for k in range(n):\n            if k == i or k == j:\n                continue\n            # Calculate potential improvement across all objectives\n            delta1 = (distance_matrix_1[new_solution[k-1], new_solution[i]] +\n                     distance_matrix_1[new_solution[j], new_solution[(k+1)%n]] -\n                     distance_matrix_1[new_solution[k-1], new_solution[k]] -\n                     distance_matrix_1[new_solution[i], new_solution[(k+1)%n]])\n\n            delta2 = (distance_matrix_2[new_solution[k-1], new_solution[i]] +\n                     distance_matrix_2[new_solution[j], new_solution[(k+1)%n]] -\n                     distance_matrix_2[new_solution[k-1], new_solution[k]] -\n                     distance_matrix_2[new_solution[i], new_solution[(k+1)%n]])\n\n            delta3 = (distance_matrix_3[new_solution[k-1], new_solution[i]] +\n                     distance_matrix_3[new_solution[j], new_solution[(k+1)%n]] -\n                     distance_matrix_3[new_solution[k-1], new_solution[k]] -\n                     distance_matrix_3[new_solution[i], new_solution[(k+1)%n]])\n\n            if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                # Perform the swap if it improves at least one objective\n                temp = new_solution[k]\n                new_solution[k] = new_solution[i]\n                new_solution[i] = temp\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7271805563919911,
            2.269748032093048
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations for better exploration\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # 2-opt move\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Objective-aware swap: identify nodes with high marginal improvement\n        for k in range(n):\n            if k == i or k == j:\n                continue\n            # Calculate potential improvement across all objectives\n            delta1 = (distance_matrix_1[new_solution[k-1], new_solution[i]] +\n                     distance_matrix_1[new_solution[j], new_solution[(k+1)%n]] -\n                     distance_matrix_1[new_solution[k-1], new_solution[k]] -\n                     distance_matrix_1[new_solution[i], new_solution[(k+1)%n]])\n\n            delta2 = (distance_matrix_2[new_solution[k-1], new_solution[i]] +\n                     distance_matrix_2[new_solution[j], new_solution[(k+1)%n]] -\n                     distance_matrix_2[new_solution[k-1], new_solution[k]] -\n                     distance_matrix_2[new_solution[i], new_solution[(k+1)%n]])\n\n            delta3 = (distance_matrix_3[new_solution[k-1], new_solution[i]] +\n                     distance_matrix_3[new_solution[j], new_solution[(k+1)%n]] -\n                     distance_matrix_3[new_solution[k-1], new_solution[k]] -\n                     distance_matrix_3[new_solution[i], new_solution[(k+1)%n]])\n\n            if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                # Perform the swap if it improves at least one objective\n                temp = new_solution[k]\n                new_solution[k] = new_solution[i]\n                new_solution[i] = temp\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 104,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    # Select the top 10% of solutions\n    top_solutions = sorted_archive[:max(1, len(sorted_archive) // 10)]\n    # Randomly select one solution from the top candidates\n    selected = random.choice(top_solutions)\n    base_solution = selected[0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: Combine 2-opt with objective-aware swaps\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap\n    # Identify nodes with high marginal contributions in any objective\n    marginal_contributions = []\n    for k in range(n):\n        # Calculate the change in each objective if we remove node k\n        prev = base_solution[k-1]\n        next_node = base_solution[(k+1) % n]\n        obj1_change = distance_matrix_1[prev, next_node] - distance_matrix_1[prev, base_solution[k]] - distance_matrix_1[base_solution[k], next_node]\n        obj2_change = distance_matrix_2[prev, next_node] - distance_matrix_2[prev, base_solution[k]] - distance_matrix_2[base_solution[k], next_node]\n        obj3_change = distance_matrix_3[prev, next_node] - distance_matrix_3[prev, base_solution[k]] - distance_matrix_3[base_solution[k], next_node]\n        marginal_contributions.append((obj1_change + obj2_change + obj3_change, k))\n\n    # Sort by marginal contribution (highest first)\n    marginal_contributions.sort(reverse=True, key=lambda x: x[0])\n    # Select top 20% nodes to consider for swapping\n    candidates = [x[1] for x in marginal_contributions[:max(1, len(marginal_contributions) // 5)]]\n\n    if len(candidates) >= 2:\n        # Perform a swap between two high-marginal nodes\n        a, b = random.sample(candidates, 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7259255290198533,
            1.7786763310432434
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    # Select the top 10% of solutions\n    top_solutions = sorted_archive[:max(1, len(sorted_archive) // 10)]\n    # Randomly select one solution from the top candidates\n    selected = random.choice(top_solutions)\n    base_solution = selected[0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: Combine 2-opt with objective-aware swaps\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap\n    # Identify nodes with high marginal contributions in any objective\n    marginal_contributions = []\n    for k in range(n):\n        # Calculate the change in each objective if we remove node k\n        prev = base_solution[k-1]\n        next_node = base_solution[(k+1) % n]\n        obj1_change = distance_matrix_1[prev, next_node] - distance_matrix_1[prev, base_solution[k]] - distance_matrix_1[base_solution[k], next_node]\n        obj2_change = distance_matrix_2[prev, next_node] - distance_matrix_2[prev, base_solution[k]] - distance_matrix_2[base_solution[k], next_node]\n        obj3_change = distance_matrix_3[prev, next_node] - distance_matrix_3[prev, base_solution[k]] - distance_matrix_3[base_solution[k], next_node]\n        marginal_contributions.append((obj1_change + obj2_change + obj3_change, k))\n\n    # Sort by marginal contribution (highest first)\n    marginal_contributions.sort(reverse=True, key=lambda x: x[0])\n    # Select top 20% nodes to consider for swapping\n    candidates = [x[1] for x in marginal_contributions[:max(1, len(marginal_contributions) // 5)]]\n\n    if len(candidates) >= 2:\n        # Perform a swap between two high-marginal nodes\n        a, b = random.sample(candidates, 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 105,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select a segment to modify based on edge diversity and objective impact\n    i, j = np.random.randint(0, n, size=2)\n    if i > j:\n        i, j = j, i\n\n    # Evaluate the segment's impact across objectives\n    segment_edges = [(new_solution[k], new_solution[(k+1)%n]) for k in range(i, j+1)]\n    segment_costs = [\n        sum(distance_matrix_1[a][b] for a, b in segment_edges),\n        sum(distance_matrix_2[a][b] for a, b in segment_edges),\n        sum(distance_matrix_3[a][b] for a, b in segment_edges)\n    ]\n\n    # Reverse the segment if it improves any objective\n    if any(segment_costs[k] > 0.5 * sum(segment_costs) for k in range(3)):\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply a second move: swap two nodes with high cross-objective potential\n    k, l = np.random.randint(0, n, size=2)\n    if k != l:\n        # Check if swap improves any objective\n        original_cost = sum([\n            distance_matrix_1[new_solution[k-1]][new_solution[k]] + distance_matrix_1[new_solution[k]][new_solution[(k+1)%n]] +\n            distance_matrix_2[new_solution[k-1]][new_solution[k]] + distance_matrix_2[new_solution[k]][new_solution[(k+1)%n]] +\n            distance_matrix_3[new_solution[k-1]][new_solution[k]] + distance_matrix_3[new_solution[k]][new_solution[(k+1)%n]]\n        ])\n\n        swapped_cost = sum([\n            distance_matrix_1[new_solution[k-1]][new_solution[l]] + distance_matrix_1[new_solution[l]][new_solution[(k+1)%n]] +\n            distance_matrix_2[new_solution[k-1]][new_solution[l]] + distance_matrix_2[new_solution[l]][new_solution[(k+1)%n]] +\n            distance_matrix_3[new_solution[k-1]][new_solution[l]] + distance_matrix_3[new_solution[l]][new_solution[(k+1)%n]]\n        ])\n\n        if swapped_cost < original_cost:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.691185785168,
            1.681303906440735
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select a segment to modify based on edge diversity and objective impact\n    i, j = np.random.randint(0, n, size=2)\n    if i > j:\n        i, j = j, i\n\n    # Evaluate the segment's impact across objectives\n    segment_edges = [(new_solution[k], new_solution[(k+1)%n]) for k in range(i, j+1)]\n    segment_costs = [\n        sum(distance_matrix_1[a][b] for a, b in segment_edges),\n        sum(distance_matrix_2[a][b] for a, b in segment_edges),\n        sum(distance_matrix_3[a][b] for a, b in segment_edges)\n    ]\n\n    # Reverse the segment if it improves any objective\n    if any(segment_costs[k] > 0.5 * sum(segment_costs) for k in range(3)):\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply a second move: swap two nodes with high cross-objective potential\n    k, l = np.random.randint(0, n, size=2)\n    if k != l:\n        # Check if swap improves any objective\n        original_cost = sum([\n            distance_matrix_1[new_solution[k-1]][new_solution[k]] + distance_matrix_1[new_solution[k]][new_solution[(k+1)%n]] +\n            distance_matrix_2[new_solution[k-1]][new_solution[k]] + distance_matrix_2[new_solution[k]][new_solution[(k+1)%n]] +\n            distance_matrix_3[new_solution[k-1]][new_solution[k]] + distance_matrix_3[new_solution[k]][new_solution[(k+1)%n]]\n        ])\n\n        swapped_cost = sum([\n            distance_matrix_1[new_solution[k-1]][new_solution[l]] + distance_matrix_1[new_solution[l]][new_solution[(k+1)%n]] +\n            distance_matrix_2[new_solution[k-1]][new_solution[l]] + distance_matrix_2[new_solution[l]][new_solution[(k+1)%n]] +\n            distance_matrix_3[new_solution[k-1]][new_solution[l]] + distance_matrix_3[new_solution[l]][new_solution[(k+1)%n]]\n        ])\n\n        if swapped_cost < original_cost:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 106,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    worst_obj = np.max(objectives, axis=0)\n    selected_idx = np.argmax([np.max(obj) for obj in objectives])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n\n    # Apply 2-opt within the segment\n    for i in range(a, b):\n        for j in range(i + 1, b + 1):\n            # Evaluate the swap in all three objectives\n            obj1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_1[new_solution[j-1], new_solution[j]])\n            obj2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[j-1], new_solution[j]])\n            obj3 = (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_3[new_solution[j-1], new_solution[j]])\n\n            new_obj1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[i], new_solution[j-1]])\n            new_obj2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[i], new_solution[j-1]])\n            new_obj3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_3[new_solution[i], new_solution[j-1]])\n\n            # Accept if at least one objective improves\n            if (new_obj1 < obj1 or new_obj2 < obj2 or new_obj3 < obj3):\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n                break\n\n    # Apply objective-aware swaps\n    for _ in range(3):\n        i, j = np.random.choice(n, 2, replace=False)\n        obj1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        obj2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        obj3 = (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                distance_matrix_3[new_solution[j-1], new_solution[j]] +\n                distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        new_obj1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                    distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        new_obj2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                    distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        new_obj3 = (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                    distance_matrix_3[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        if not (new_obj1 <= obj1 and new_obj2 <= obj2 and new_obj3 <= obj3):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5295232784052906,
            3.6146141409873964
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    worst_obj = np.max(objectives, axis=0)\n    selected_idx = np.argmax([np.max(obj) for obj in objectives])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n\n    # Apply 2-opt within the segment\n    for i in range(a, b):\n        for j in range(i + 1, b + 1):\n            # Evaluate the swap in all three objectives\n            obj1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_1[new_solution[j-1], new_solution[j]])\n            obj2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[j-1], new_solution[j]])\n            obj3 = (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_3[new_solution[j-1], new_solution[j]])\n\n            new_obj1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[i], new_solution[j-1]])\n            new_obj2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[i], new_solution[j-1]])\n            new_obj3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_3[new_solution[i], new_solution[j-1]])\n\n            # Accept if at least one objective improves\n            if (new_obj1 < obj1 or new_obj2 < obj2 or new_obj3 < obj3):\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n                break\n\n    # Apply objective-aware swaps\n    for _ in range(3):\n        i, j = np.random.choice(n, 2, replace=False)\n        obj1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        obj2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        obj3 = (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                distance_matrix_3[new_solution[j-1], new_solution[j]] +\n                distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        new_obj1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                    distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        new_obj2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                    distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        new_obj3 = (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                    distance_matrix_3[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        if not (new_obj1 <= obj1 and new_obj2 <= obj2 and new_obj3 <= obj3):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 107,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, base_objectives = max(archive, key=lambda x: sum(x[1]))\n\n    # Create a copy of the base solution\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: combine 2-opt with a novel 3-way edge swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform a 2-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform a 3-way edge swap (novel operator)\n    if i < k < j:\n        new_solution[k:j] = new_solution[k:j][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or skips)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7102831434392839,
            1.5427299857139587
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, base_objectives = max(archive, key=lambda x: sum(x[1]))\n\n    # Create a copy of the base solution\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: combine 2-opt with a novel 3-way edge swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform a 2-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform a 3-way edge swap (novel operator)\n    if i < k < j:\n        new_solution[k:j] = new_solution[k:j][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or skips)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 108,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Choose a segment of the tour at random\n    n = len(selected_solution)\n    start = np.random.randint(0, n)\n    length = np.random.randint(2, min(5, n // 2))\n    end = (start + length) % n\n\n    # Extract the segment and reverse it (or apply a different local search operator)\n    if start < end:\n        segment = selected_solution[start:end]\n    else:\n        segment = np.concatenate((selected_solution[start:], selected_solution[:end]))\n\n    # Apply a hybrid local search: reverse the segment and optionally swap nodes to improve multiple objectives\n    new_segment = segment[::-1]  # Reverse the segment\n\n    # Randomly swap nodes in the segment to explore different trade-offs\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(len(new_segment), 2, replace=False)\n        new_segment[i], new_segment[j] = new_segment[j], new_segment[i]\n\n    # Reconstruct the new solution\n    new_solution = selected_solution.copy()\n    if start < end:\n        new_solution[start:end] = new_segment\n    else:\n        new_solution[start:] = new_segment[:n-start]\n        new_solution[:end] = new_segment[n-start:]\n\n    return new_solution\n\n",
        "score": [
            -0.6572622867278127,
            1.324877417087555
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Choose a segment of the tour at random\n    n = len(selected_solution)\n    start = np.random.randint(0, n)\n    length = np.random.randint(2, min(5, n // 2))\n    end = (start + length) % n\n\n    # Extract the segment and reverse it (or apply a different local search operator)\n    if start < end:\n        segment = selected_solution[start:end]\n    else:\n        segment = np.concatenate((selected_solution[start:], selected_solution[:end]))\n\n    # Apply a hybrid local search: reverse the segment and optionally swap nodes to improve multiple objectives\n    new_segment = segment[::-1]  # Reverse the segment\n\n    # Randomly swap nodes in the segment to explore different trade-offs\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(len(new_segment), 2, replace=False)\n        new_segment[i], new_segment[j] = new_segment[j], new_segment[i]\n\n    # Reconstruct the new solution\n    new_solution = selected_solution.copy()\n    if start < end:\n        new_solution[start:end] = new_segment\n    else:\n        new_solution[start:] = new_segment[:n-start]\n        new_solution[:end] = new_segment[n-start:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 109,
        "algorithm": "{The algorithm intelligently selects a non-dominated solution from the archive with the highest potential for local improvement by evaluating the diversity and objective values of neighboring solutions, then applies a novel 3-objective-aware local search operator that combines edge swaps with objective-space-aware perturbations to generate high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by combined objective values (ascending)\n        sorted_solutions = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from top 30% solutions\n        candidate_solutions = sorted_solutions[:max(1, len(sorted_solutions) // 3)]\n        # Select randomly from candidates\n        base_solution = random.choice(candidate_solutions)[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply 3-objective-aware local search\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # 3-objective edge swap\n    if random.random() < 0.7:  # Higher probability for edge swaps\n        # Swap edges in all three objective spaces\n        for dm in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n            if dm[new_solution[i-1], new_solution[i]] + dm[new_solution[j], new_solution[(j+1)%n]] > \\\n               dm[new_solution[i-1], new_solution[j]] + dm[new_solution[i], new_solution[(j+1)%n]]:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n                break\n    else:\n        # Objective-space-aware perturbation\n        # Select objective space with worst improvement potential\n        obj_values = []\n        for dm in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n            current_cost = dm[new_solution[i-1], new_solution[i]] + dm[new_solution[j], new_solution[(j+1)%n]]\n            new_cost = dm[new_solution[i-1], new_solution[j]] + dm[new_solution[i], new_solution[(j+1)%n]]\n            obj_values.append(new_cost - current_cost)\n\n        worst_obj = np.argmax(obj_values)\n        if worst_obj == 0:\n            dm = distance_matrix_1\n        elif worst_obj == 1:\n            dm = distance_matrix_2\n        else:\n            dm = distance_matrix_3\n\n        # Perform swap only if improves the worst objective\n        if dm[new_solution[i-1], new_solution[i]] + dm[new_solution[j], new_solution[(j+1)%n]] > \\\n           dm[new_solution[i-1], new_solution[j]] + dm[new_solution[i], new_solution[(j+1)%n]]:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6333910045464539,
            4.091449022293091
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by combined objective values (ascending)\n        sorted_solutions = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from top 30% solutions\n        candidate_solutions = sorted_solutions[:max(1, len(sorted_solutions) // 3)]\n        # Select randomly from candidates\n        base_solution = random.choice(candidate_solutions)[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply 3-objective-aware local search\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # 3-objective edge swap\n    if random.random() < 0.7:  # Higher probability for edge swaps\n        # Swap edges in all three objective spaces\n        for dm in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n            if dm[new_solution[i-1], new_solution[i]] + dm[new_solution[j], new_solution[(j+1)%n]] > \\\n               dm[new_solution[i-1], new_solution[j]] + dm[new_solution[i], new_solution[(j+1)%n]]:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n                break\n    else:\n        # Objective-space-aware perturbation\n        # Select objective space with worst improvement potential\n        obj_values = []\n        for dm in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n            current_cost = dm[new_solution[i-1], new_solution[i]] + dm[new_solution[j], new_solution[(j+1)%n]]\n            new_cost = dm[new_solution[i-1], new_solution[j]] + dm[new_solution[i], new_solution[(j+1)%n]]\n            obj_values.append(new_cost - current_cost)\n\n        worst_obj = np.argmax(obj_values)\n        if worst_obj == 0:\n            dm = distance_matrix_1\n        elif worst_obj == 1:\n            dm = distance_matrix_2\n        else:\n            dm = distance_matrix_3\n\n        # Perform swap only if improves the worst objective\n        if dm[new_solution[i-1], new_solution[i]] + dm[new_solution[j], new_solution[(j+1)%n]] > \\\n           dm[new_solution[i-1], new_solution[j]] + dm[new_solution[i], new_solution[(j+1)%n]]:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 110,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    worst_obj_indices = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[worst_obj_indices][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and segment inversion with objective-aware swaps\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt swap\n    if j - i > 1:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply segment inversion\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Objective-aware swap: swap nodes that are farthest in any objective space\n    if random.random() < 0.3:  # 30% chance to perform objective-aware swap\n        # Find nodes with the largest distance in any objective space\n        max_dist = -1\n        swap_i, swap_j = 0, 0\n        for p in range(n):\n            for q in range(p + 1, n):\n                dist1 = distance_matrix_1[new_solution[p], new_solution[q]]\n                dist2 = distance_matrix_2[new_solution[p], new_solution[q]]\n                dist3 = distance_matrix_3[new_solution[p], new_solution[q]]\n                max_current = max(dist1, dist2, dist3)\n                if max_current > max_dist:\n                    max_dist = max_current\n                    swap_i, swap_j = p, q\n        # Perform the swap\n        new_solution[swap_i], new_solution[swap_j] = new_solution[swap_j], new_solution[swap_i]\n\n    return new_solution\n\n",
        "score": [
            -0.7164810483879286,
            1.6856706023216248
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    worst_obj_indices = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[worst_obj_indices][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and segment inversion with objective-aware swaps\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt swap\n    if j - i > 1:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply segment inversion\n    if l - k > 1:\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Objective-aware swap: swap nodes that are farthest in any objective space\n    if random.random() < 0.3:  # 30% chance to perform objective-aware swap\n        # Find nodes with the largest distance in any objective space\n        max_dist = -1\n        swap_i, swap_j = 0, 0\n        for p in range(n):\n            for q in range(p + 1, n):\n                dist1 = distance_matrix_1[new_solution[p], new_solution[q]]\n                dist2 = distance_matrix_2[new_solution[p], new_solution[q]]\n                dist3 = distance_matrix_3[new_solution[p], new_solution[q]]\n                max_current = max(dist1, dist2, dist3)\n                if max_current > max_dist:\n                    max_dist = max_current\n                    swap_i, swap_j = p, q\n        # Perform the swap\n        new_solution[swap_i], new_solution[swap_j] = new_solution[swap_j], new_solution[swap_i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 111,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the highest total objective value (for diversification)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Perform a hybrid local search: 2-opt swap with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify edges with high potential for improvement in any objective\n    for i in range(n):\n        for j in range(i + 2, n):\n            a, b = new_solution[i], new_solution[i+1]\n            c, d = new_solution[j], new_solution[(j+1)%n]\n\n            # Calculate potential improvement in each objective\n            improvement1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n            improvement2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n            improvement3 = (distance_matrix_3[a, c] + distance_matrix_3[b, d]) - (distance_matrix_3[a, b] + distance_matrix_3[c, d])\n\n            # Apply 2-opt if any objective shows improvement\n            if improvement1 < 0 or improvement2 < 0 or improvement3 < 0:\n                new_solution[i+1:j+1] = new_solution[j:i:-1]\n                break\n\n    # Additional diversification: random 2-opt if no improvement found\n    if np.array_equal(new_solution, base_solution):\n        i, j = np.random.choice(n, 2, replace=False)\n        i, j = min(i, j), max(i, j)\n        if j - i > 1:\n            new_solution[i+1:j+1] = new_solution[j:i:-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6469433051138369,
            1.636159932613373
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the highest total objective value (for diversification)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Perform a hybrid local search: 2-opt swap with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify edges with high potential for improvement in any objective\n    for i in range(n):\n        for j in range(i + 2, n):\n            a, b = new_solution[i], new_solution[i+1]\n            c, d = new_solution[j], new_solution[(j+1)%n]\n\n            # Calculate potential improvement in each objective\n            improvement1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n            improvement2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n            improvement3 = (distance_matrix_3[a, c] + distance_matrix_3[b, d]) - (distance_matrix_3[a, b] + distance_matrix_3[c, d])\n\n            # Apply 2-opt if any objective shows improvement\n            if improvement1 < 0 or improvement2 < 0 or improvement3 < 0:\n                new_solution[i+1:j+1] = new_solution[j:i:-1]\n                break\n\n    # Additional diversification: random 2-opt if no improvement found\n    if np.array_equal(new_solution, base_solution):\n        i, j = np.random.choice(n, 2, replace=False)\n        i, j = min(i, j), max(i, j)\n        if j - i > 1:\n            new_solution[i+1:j+1] = new_solution[j:i:-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 112,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with low objective values and high diversity, then applies a hybrid local search combining 2-opt and node insertion, guided by Pareto dominance and objective-specific improvements, to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (lowest sum of objectives or most diverse)\n    objectives = np.array([obj for _, obj in archive])\n    objective_sums = np.sum(objectives, axis=1)\n    min_sum_idx = np.argmin(objective_sums)\n    base_solution = archive[min_sum_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 2-opt with objective-aware swaps\n    for _ in range(10):  # Number of iterations\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == 0 and j == n-1:\n            continue  # Skip full reversal to maintain feasibility\n\n        # Evaluate 2-opt move for each objective\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        ]\n\n        new_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Node insertion with objective-aware selection\n    for _ in range(5):\n        i = np.random.randint(n)\n        j = np.random.randint(n)\n        if i == j:\n            continue\n\n        # Evaluate insertion move for each objective\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        ]\n\n        new_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7422689856097249,
            1.9565652132034301
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (lowest sum of objectives or most diverse)\n    objectives = np.array([obj for _, obj in archive])\n    objective_sums = np.sum(objectives, axis=1)\n    min_sum_idx = np.argmin(objective_sums)\n    base_solution = archive[min_sum_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 2-opt with objective-aware swaps\n    for _ in range(10):  # Number of iterations\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == 0 and j == n-1:\n            continue  # Skip full reversal to maintain feasibility\n\n        # Evaluate 2-opt move for each objective\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        ]\n\n        new_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Node insertion with objective-aware selection\n    for _ in range(5):\n        i = np.random.randint(n)\n        j = np.random.randint(n)\n        if i == j:\n            continue\n\n        # Evaluate insertion move for each objective\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        ]\n\n        new_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_cost < original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 113,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Perform a hybrid local search: 2-opt + node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on a random segment\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node insertion: move a random node to a random position\n    node_to_move = np.random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n    insert_pos = np.random.randint(0, n)\n    new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.6473119206954826,
            1.6290743350982666
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Perform a hybrid local search: 2-opt + node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on a random segment\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node insertion: move a random node to a random position\n    node_to_move = np.random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n    insert_pos = np.random.randint(0, n)\n    new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 114,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects high-potential solutions from the archive, applies a combination of 2-opt and edge-swapping operators across all three objectives, and ensures feasibility by maintaining a valid TSP tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [s[0] for s in archive]\n    archive_objectives = [s[1] for s in archive]\n\n    # Calculate the worst objective for each solution\n    worst_objectives = [max(obj) for obj in archive_objectives]\n\n    # Select the solution with the best worst objective (potential for improvement)\n    selected_idx = np.argmin(worst_objectives)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt or edge-swap\n    if random.random() < 0.5:\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Edge-swap local search\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Revert to original if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6612403805038396,
            1.4766145706176759
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [s[0] for s in archive]\n    archive_objectives = [s[1] for s in archive]\n\n    # Calculate the worst objective for each solution\n    worst_objectives = [max(obj) for obj in archive_objectives]\n\n    # Select the solution with the best worst objective (potential for improvement)\n    selected_idx = np.argmin(worst_objectives)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt or edge-swap\n    if random.random() < 0.5:\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Edge-swap local search\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Revert to original if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 115,
        "algorithm": "{The heuristic function selects a solution from the archive based on its dominance and diversity, then applies a multi-objective local search operator that combines 2-opt moves with a novel objective-aware perturbation to explore trade-offs across the three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution that is non-dominated and has high diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform a multi-objective 2-opt move with objective-aware perturbation\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:\n        # Reverse the segment between i and j\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Objective-aware perturbation: randomly swap two nodes if it improves any objective\n        k, l = sorted(random.sample(range(n), 2))\n        current_cost = (\n            sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n        )\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n        new_cost = (\n            sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n        )\n\n        # Accept if any objective improves\n        if not all(new_cost[i] >= current_cost[i] for i in range(3)):\n            pass  # Keep the swap\n        else:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]  # Revert\n\n    return new_solution\n\n",
        "score": [
            -0.7959584420812986,
            1.4815054655075073
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution that is non-dominated and has high diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform a multi-objective 2-opt move with objective-aware perturbation\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:\n        # Reverse the segment between i and j\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Objective-aware perturbation: randomly swap two nodes if it improves any objective\n        k, l = sorted(random.sample(range(n), 2))\n        current_cost = (\n            sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n        )\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n        new_cost = (\n            sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n        )\n\n        # Accept if any objective improves\n        if not all(new_cost[i] >= current_cost[i] for i in range(3)):\n            pass  # Keep the swap\n        else:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]  # Revert\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 116,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware node selection\n    n = len(best_solution)\n    new_solution = best_solution.copy()\n\n    # Randomly select two distinct positions to perform 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        return best_solution  # Fallback to original if invalid\n\n    # Apply objective-aware swaps: for each objective, find the worst edge and try to improve it\n    for obj_idx, dist_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        # Find the worst edge in this objective space\n        worst_edge = -1\n        worst_cost = -1\n        for k in range(n):\n            node_a = new_solution[k]\n            node_b = new_solution[(k+1) % n]\n            cost = dist_matrix[node_a, node_b]\n            if cost > worst_cost:\n                worst_cost = cost\n                worst_edge = k\n\n        # Try to replace the worst edge with a better one\n        if worst_edge != -1:\n            node_a = new_solution[worst_edge]\n            node_b = new_solution[(worst_edge+1) % n]\n\n            # Find the best possible replacement for this edge\n            best_replacement = -1\n            best_replacement_cost = worst_cost\n            for candidate in range(n):\n                if candidate == node_a or candidate == node_b or candidate in new_solution:\n                    continue\n                cost_a = dist_matrix[node_a, candidate]\n                cost_b = dist_matrix[candidate, node_b]\n                if cost_a + cost_b < best_replacement_cost:\n                    best_replacement_cost = cost_a + cost_b\n                    best_replacement = candidate\n\n            if best_replacement != -1:\n                # Insert the best replacement between node_a and node_b\n                new_solution = np.insert(new_solution, worst_edge+1, best_replacement)\n                new_solution = np.delete(new_solution, np.where(new_solution == node_b)[0][0])\n\n    # Ensure the solution is still valid after all operations\n    if len(np.unique(new_solution)) != n:\n        return best_solution\n\n    return new_solution\n\n",
        "score": [
            -0.6165287509338628,
            2.5027122139930724
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware node selection\n    n = len(best_solution)\n    new_solution = best_solution.copy()\n\n    # Randomly select two distinct positions to perform 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        return best_solution  # Fallback to original if invalid\n\n    # Apply objective-aware swaps: for each objective, find the worst edge and try to improve it\n    for obj_idx, dist_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        # Find the worst edge in this objective space\n        worst_edge = -1\n        worst_cost = -1\n        for k in range(n):\n            node_a = new_solution[k]\n            node_b = new_solution[(k+1) % n]\n            cost = dist_matrix[node_a, node_b]\n            if cost > worst_cost:\n                worst_cost = cost\n                worst_edge = k\n\n        # Try to replace the worst edge with a better one\n        if worst_edge != -1:\n            node_a = new_solution[worst_edge]\n            node_b = new_solution[(worst_edge+1) % n]\n\n            # Find the best possible replacement for this edge\n            best_replacement = -1\n            best_replacement_cost = worst_cost\n            for candidate in range(n):\n                if candidate == node_a or candidate == node_b or candidate in new_solution:\n                    continue\n                cost_a = dist_matrix[node_a, candidate]\n                cost_b = dist_matrix[candidate, node_b]\n                if cost_a + cost_b < best_replacement_cost:\n                    best_replacement_cost = cost_a + cost_b\n                    best_replacement = candidate\n\n            if best_replacement != -1:\n                # Insert the best replacement between node_a and node_b\n                new_solution = np.insert(new_solution, worst_edge+1, best_replacement)\n                new_solution = np.delete(new_solution, np.where(new_solution == node_b)[0][0])\n\n    # Ensure the solution is still valid after all operations\n    if len(np.unique(new_solution)) != n:\n        return best_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 117,
        "algorithm": "{A heuristic function that intelligently selects a non-dominated solution from the archive, applies a hybrid local search operator combining 2-opt, edge insertion, and objective-aware perturbation to generate a neighbor solution while ensuring feasibility across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (e.g., not too good in all objectives)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful changes\n\n    # Step 1: 2-opt for one objective (randomly chosen)\n    obj_choice = random.choice([0, 1, 2])\n    if obj_choice == 0:\n        dist_matrix = distance_matrix_1\n    elif obj_choice == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    i, j = sorted(random.sample(range(n), 2))\n    if i + 1 < j:\n        # Reverse the segment between i and j\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Step 2: Edge insertion for another objective (randomly chosen)\n    obj_choice = random.choice([0, 1, 2])\n    if obj_choice == 0:\n        dist_matrix = distance_matrix_1\n    elif obj_choice == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Remove a random edge and reinsert it\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Objective-aware perturbation (swap nodes based on worst objective)\n    obj_values = archive[selected_idx][1]\n    worst_obj = np.argmax(obj_values)\n\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst node in this objective\n    worst_node_idx = np.argmax([dist_matrix[new_solution[i], new_solution[(i+1)%n]] for i in range(n)])\n    worst_node = new_solution[worst_node_idx]\n\n    # Swap with a random node to improve the worst objective\n    swap_idx = random.randint(0, n-1)\n    new_solution[worst_node_idx], new_solution[swap_idx] = new_solution[swap_idx], new_solution[worst_node_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7705553600556747,
            1.5563646793365478
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (e.g., not too good in all objectives)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful changes\n\n    # Step 1: 2-opt for one objective (randomly chosen)\n    obj_choice = random.choice([0, 1, 2])\n    if obj_choice == 0:\n        dist_matrix = distance_matrix_1\n    elif obj_choice == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    i, j = sorted(random.sample(range(n), 2))\n    if i + 1 < j:\n        # Reverse the segment between i and j\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Step 2: Edge insertion for another objective (randomly chosen)\n    obj_choice = random.choice([0, 1, 2])\n    if obj_choice == 0:\n        dist_matrix = distance_matrix_1\n    elif obj_choice == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Remove a random edge and reinsert it\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Objective-aware perturbation (swap nodes based on worst objective)\n    obj_values = archive[selected_idx][1]\n    worst_obj = np.argmax(obj_values)\n\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst node in this objective\n    worst_node_idx = np.argmax([dist_matrix[new_solution[i], new_solution[(i+1)%n]] for i in range(n)])\n    worst_node = new_solution[worst_node_idx]\n\n    # Swap with a random node to improve the worst objective\n    swap_idx = random.randint(0, n-1)\n    new_solution[worst_node_idx], new_solution[swap_idx] = new_solution[swap_idx], new_solution[worst_node_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 118,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a multi-objective 2-opt local search\n    def calculate_total_cost(solution, dist_matrices):\n        cost = 0\n        for i in range(len(solution)):\n            cost += dist_matrices[0][solution[i-1], solution[i]]\n            cost += dist_matrices[1][solution[i-1], solution[i]]\n            cost += dist_matrices[2][solution[i-1], solution[i]]\n        return cost\n\n    best_cost = calculate_total_cost(base_solution, [distance_matrix_1, distance_matrix_2, distance_matrix_3])\n    new_solution = base_solution.copy()\n\n    # Perform a random 2-opt move\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Check if the move improves the solution\n    current_cost = calculate_total_cost(new_solution, [distance_matrix_1, distance_matrix_2, distance_matrix_3])\n    if current_cost < best_cost:\n        return new_solution\n    else:\n        # If not, try a 3-opt move for more exploration\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        if k > l:\n            k, l = l, k\n        new_solution = np.concatenate([new_solution[:k], new_solution[k:l][::-1], new_solution[l:]])\n        return new_solution\n\n",
        "score": [
            -0.6707147311377744,
            1.7648253202438355
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a multi-objective 2-opt local search\n    def calculate_total_cost(solution, dist_matrices):\n        cost = 0\n        for i in range(len(solution)):\n            cost += dist_matrices[0][solution[i-1], solution[i]]\n            cost += dist_matrices[1][solution[i-1], solution[i]]\n            cost += dist_matrices[2][solution[i-1], solution[i]]\n        return cost\n\n    best_cost = calculate_total_cost(base_solution, [distance_matrix_1, distance_matrix_2, distance_matrix_3])\n    new_solution = base_solution.copy()\n\n    # Perform a random 2-opt move\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Check if the move improves the solution\n    current_cost = calculate_total_cost(new_solution, [distance_matrix_1, distance_matrix_2, distance_matrix_3])\n    if current_cost < best_cost:\n        return new_solution\n    else:\n        # If not, try a 3-opt move for more exploration\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        if k > l:\n            k, l = l, k\n        new_solution = np.concatenate([new_solution[:k], new_solution[k:l][::-1], new_solution[l:]])\n        return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 119,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate the sum of objectives for each solution\n    objective_sums = [sum(obj) for obj in archive_objectives]\n\n    # Select the solution with the lowest sum of objectives (most promising)\n    best_idx = np.argmin(objective_sums)\n    base_solution = archive_solutions[best_idx].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap (2-opt move)\n    i, j = sorted(random.sample(range(n), 2))\n    if i == j:\n        j = (j + 1) % n\n\n    # Perform the 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware edge selection: pick edges that improve at least one objective\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Randomly select two edges\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Calculate current and potential new distances for all three objectives\n        current_dist1 = distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[c], new_solution[d]]\n        new_dist1 = distance_matrix_1[new_solution[a], new_solution[c]] + distance_matrix_1[new_solution[b], new_solution[d]]\n\n        current_dist2 = distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[c], new_solution[d]]\n        new_dist2 = distance_matrix_2[new_solution[a], new_solution[c]] + distance_matrix_2[new_solution[b], new_solution[d]]\n\n        current_dist3 = distance_matrix_3[new_solution[a], new_solution[b]] + distance_matrix_3[new_solution[c], new_solution[d]]\n        new_dist3 = distance_matrix_3[new_solution[a], new_solution[c]] + distance_matrix_3[new_solution[b], new_solution[d]]\n\n        # Check if the move improves at least one objective\n        if (new_dist1 < current_dist1) or (new_dist2 < current_dist2) or (new_dist3 < current_dist3):\n            # Perform the swap\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.6548658417244728,
            1.2610286712646483
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate the sum of objectives for each solution\n    objective_sums = [sum(obj) for obj in archive_objectives]\n\n    # Select the solution with the lowest sum of objectives (most promising)\n    best_idx = np.argmin(objective_sums)\n    base_solution = archive_solutions[best_idx].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap (2-opt move)\n    i, j = sorted(random.sample(range(n), 2))\n    if i == j:\n        j = (j + 1) % n\n\n    # Perform the 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware edge selection: pick edges that improve at least one objective\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Randomly select two edges\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Calculate current and potential new distances for all three objectives\n        current_dist1 = distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[c], new_solution[d]]\n        new_dist1 = distance_matrix_1[new_solution[a], new_solution[c]] + distance_matrix_1[new_solution[b], new_solution[d]]\n\n        current_dist2 = distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[c], new_solution[d]]\n        new_dist2 = distance_matrix_2[new_solution[a], new_solution[c]] + distance_matrix_2[new_solution[b], new_solution[d]]\n\n        current_dist3 = distance_matrix_3[new_solution[a], new_solution[b]] + distance_matrix_3[new_solution[c], new_solution[d]]\n        new_dist3 = distance_matrix_3[new_solution[a], new_solution[c]] + distance_matrix_3[new_solution[b], new_solution[d]]\n\n        # Check if the move improves at least one objective\n        if (new_dist1 < current_dist1) or (new_dist2 < current_dist2) or (new_dist3 < current_dist3):\n            # Perform the swap\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 120,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    n = len(selected_solution)\n\n    # Hybrid local search: combine 2-opt with a multi-objective aware swap\n    new_solution = selected_solution.copy()\n\n    # Perform 2-opt on the first objective space\n    i, j = np.random.randint(0, n, size=2)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective aware swap: select a node with high difference in objectives\n    node_to_swap = np.argmax([sum(distance_matrix_1[node] + distance_matrix_2[node] + distance_matrix_3[node]) for node in new_solution])\n    swap_pos = np.random.randint(0, n)\n    new_solution[node_to_swap], new_solution[swap_pos] = new_solution[swap_pos], new_solution[node_to_swap]\n\n    return new_solution\n\n",
        "score": [
            -0.6699011622511545,
            1.896528434753418
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    n = len(selected_solution)\n\n    # Hybrid local search: combine 2-opt with a multi-objective aware swap\n    new_solution = selected_solution.copy()\n\n    # Perform 2-opt on the first objective space\n    i, j = np.random.randint(0, n, size=2)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective aware swap: select a node with high difference in objectives\n    node_to_swap = np.argmax([sum(distance_matrix_1[node] + distance_matrix_2[node] + distance_matrix_3[node]) for node in new_solution])\n    swap_pos = np.random.randint(0, n)\n    new_solution[node_to_swap], new_solution[swap_pos] = new_solution[swap_pos], new_solution[node_to_swap]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 121,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Step 2: Apply a hybrid local search operator: 2-opt with objective-aware node selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct edges to disrupt and reconnect\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform a 2-opt swap between the selected edges\n    if i != k and j != l:\n        new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n        new_solution[k:l+1] = np.flip(new_solution[k:l+1])\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7562723243159798,
            1.379347574710846
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Step 2: Apply a hybrid local search operator: 2-opt with objective-aware node selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct edges to disrupt and reconnect\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform a 2-opt swap between the selected edges\n    if i != k and j != l:\n        new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n        new_solution[k:l+1] = np.flip(new_solution[k:l+1])\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 122,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest potential for improvement (lowest objective values)\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware perturbation\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply objective-aware perturbation: swap nodes that are critical in any objective space\n    for _ in range(2):  # Limit perturbations to maintain feasibility\n        # Identify nodes with high marginal contribution in any objective\n        marginal_contributions = []\n        for k in range(n):\n            # Calculate change in objectives if node k is removed and reinserted\n            before_node = selected_solution[k-1] if k > 0 else selected_solution[-1]\n            after_node = selected_solution[k+1] if k < n-1 else selected_solution[0]\n            cost_change = (\n                distance_matrix_1[before_node, selected_solution[k]] + distance_matrix_1[selected_solution[k], after_node] -\n                distance_matrix_1[before_node, after_node]\n            ) + (\n                distance_matrix_2[before_node, selected_solution[k]] + distance_matrix_2[selected_solution[k], after_node] -\n                distance_matrix_2[before_node, after_node]\n            ) + (\n                distance_matrix_3[before_node, selected_solution[k]] + distance_matrix_3[selected_solution[k], after_node] -\n                distance_matrix_3[before_node, after_node]\n            )\n            marginal_contributions.append(cost_change)\n\n        # Select a node with high marginal contribution and reinsert it\n        if marginal_contributions:\n            worst_node_idx = np.argmax(marginal_contributions)\n            worst_node = new_solution[worst_node_idx]\n            new_solution = np.delete(new_solution, worst_node_idx)\n            # Find the best insertion point\n            best_insertion = 0\n            min_cost = float('inf')\n            for pos in range(len(new_solution)):\n                # Calculate cost of inserting after position pos\n                before = new_solution[pos-1] if pos > 0 else new_solution[-1]\n                after = new_solution[pos] if pos < len(new_solution) else new_solution[0]\n                cost = (\n                    distance_matrix_1[before, worst_node] + distance_matrix_1[worst_node, after] -\n                    distance_matrix_1[before, after]\n                ) + (\n                    distance_matrix_2[before, worst_node] + distance_matrix_2[worst_node, after] -\n                    distance_matrix_2[before, after]\n                ) + (\n                    distance_matrix_3[before, worst_node] + distance_matrix_3[worst_node, after] -\n                    distance_matrix_3[before, after]\n                )\n                if cost < min_cost:\n                    min_cost = cost\n                    best_insertion = pos\n            new_solution = np.insert(new_solution, best_insertion, worst_node)\n\n    return new_solution\n\n",
        "score": [
            -0.5678155498353897,
            2.675522971153259
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest potential for improvement (lowest objective values)\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware perturbation\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply objective-aware perturbation: swap nodes that are critical in any objective space\n    for _ in range(2):  # Limit perturbations to maintain feasibility\n        # Identify nodes with high marginal contribution in any objective\n        marginal_contributions = []\n        for k in range(n):\n            # Calculate change in objectives if node k is removed and reinserted\n            before_node = selected_solution[k-1] if k > 0 else selected_solution[-1]\n            after_node = selected_solution[k+1] if k < n-1 else selected_solution[0]\n            cost_change = (\n                distance_matrix_1[before_node, selected_solution[k]] + distance_matrix_1[selected_solution[k], after_node] -\n                distance_matrix_1[before_node, after_node]\n            ) + (\n                distance_matrix_2[before_node, selected_solution[k]] + distance_matrix_2[selected_solution[k], after_node] -\n                distance_matrix_2[before_node, after_node]\n            ) + (\n                distance_matrix_3[before_node, selected_solution[k]] + distance_matrix_3[selected_solution[k], after_node] -\n                distance_matrix_3[before_node, after_node]\n            )\n            marginal_contributions.append(cost_change)\n\n        # Select a node with high marginal contribution and reinsert it\n        if marginal_contributions:\n            worst_node_idx = np.argmax(marginal_contributions)\n            worst_node = new_solution[worst_node_idx]\n            new_solution = np.delete(new_solution, worst_node_idx)\n            # Find the best insertion point\n            best_insertion = 0\n            min_cost = float('inf')\n            for pos in range(len(new_solution)):\n                # Calculate cost of inserting after position pos\n                before = new_solution[pos-1] if pos > 0 else new_solution[-1]\n                after = new_solution[pos] if pos < len(new_solution) else new_solution[0]\n                cost = (\n                    distance_matrix_1[before, worst_node] + distance_matrix_1[worst_node, after] -\n                    distance_matrix_1[before, after]\n                ) + (\n                    distance_matrix_2[before, worst_node] + distance_matrix_2[worst_node, after] -\n                    distance_matrix_2[before, after]\n                ) + (\n                    distance_matrix_3[before, worst_node] + distance_matrix_3[worst_node, after] -\n                    distance_matrix_3[before, after]\n                )\n                if cost < min_cost:\n                    min_cost = cost\n                    best_insertion = pos\n            new_solution = np.insert(new_solution, best_insertion, worst_node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 123,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = None\n    for sol, _ in archive:\n        if np.random.rand() < 0.3:  # Random selection with a bias toward better solutions\n            selected_solution = sol\n            break\n    if selected_solution is None:\n        selected_solution = archive[np.random.randint(0, len(archive))][0]\n\n    # Apply a hybrid local search operator: a combination of 2-opt and node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on a randomly selected segment\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform node insertion: remove a random node and reinsert it at a new position\n    if n > 2:\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        l = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7430647786900056,
            1.5993142008781434
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = None\n    for sol, _ in archive:\n        if np.random.rand() < 0.3:  # Random selection with a bias toward better solutions\n            selected_solution = sol\n            break\n    if selected_solution is None:\n        selected_solution = archive[np.random.randint(0, len(archive))][0]\n\n    # Apply a hybrid local search operator: a combination of 2-opt and node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on a randomly selected segment\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform node insertion: remove a random node and reinsert it at a new position\n    if n > 2:\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        l = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 124,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., least dominated or most diverse)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly choose between 2-opt, 3-opt, or objective-aware swap\n    operator = random.choice(['2-opt', '3-opt', 'objective-aware'])\n\n    if operator == '2-opt':\n        # Perform 2-opt swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == '3-opt':\n        # Perform 3-opt swap\n        i, j, k = sorted(random.sample(range(1, n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    else:\n        # Objective-aware swap: identify a segment that improves at least one objective\n        for _ in range(10):  # Try up to 10 random swaps\n            i, j = sorted(random.sample(range(1, n), 2))\n            temp_solution = new_solution.copy()\n            temp_solution[i:j] = temp_solution[i:j][::-1]\n\n            # Check if the swap improves at least one objective\n            old_cost1 = distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[j-1], base_solution[j]]\n            new_cost1 = distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]]\n            if new_cost1 < old_cost1:\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.834296034205073,
            1.5056393146514893
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., least dominated or most diverse)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly choose between 2-opt, 3-opt, or objective-aware swap\n    operator = random.choice(['2-opt', '3-opt', 'objective-aware'])\n\n    if operator == '2-opt':\n        # Perform 2-opt swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == '3-opt':\n        # Perform 3-opt swap\n        i, j, k = sorted(random.sample(range(1, n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    else:\n        # Objective-aware swap: identify a segment that improves at least one objective\n        for _ in range(10):  # Try up to 10 random swaps\n            i, j = sorted(random.sample(range(1, n), 2))\n            temp_solution = new_solution.copy()\n            temp_solution[i:j] = temp_solution[i:j][::-1]\n\n            # Check if the swap improves at least one objective\n            old_cost1 = distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[j-1], base_solution[j]]\n            new_cost1 = distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]]\n            if new_cost1 < old_cost1:\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 124,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., least dominated or most diverse)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly choose between 2-opt, 3-opt, or objective-aware swap\n    operator = random.choice(['2-opt', '3-opt', 'objective-aware'])\n\n    if operator == '2-opt':\n        # Perform 2-opt swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == '3-opt':\n        # Perform 3-opt swap\n        i, j, k = sorted(random.sample(range(1, n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    else:\n        # Objective-aware swap: identify a segment that improves at least one objective\n        for _ in range(10):  # Try up to 10 random swaps\n            i, j = sorted(random.sample(range(1, n), 2))\n            temp_solution = new_solution.copy()\n            temp_solution[i:j] = temp_solution[i:j][::-1]\n\n            # Check if the swap improves at least one objective\n            old_cost1 = distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[j-1], base_solution[j]]\n            new_cost1 = distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]]\n            if new_cost1 < old_cost1:\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.834296034205073,
            1.5056393146514893
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., least dominated or most diverse)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly choose between 2-opt, 3-opt, or objective-aware swap\n    operator = random.choice(['2-opt', '3-opt', 'objective-aware'])\n\n    if operator == '2-opt':\n        # Perform 2-opt swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == '3-opt':\n        # Perform 3-opt swap\n        i, j, k = sorted(random.sample(range(1, n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    else:\n        # Objective-aware swap: identify a segment that improves at least one objective\n        for _ in range(10):  # Try up to 10 random swaps\n            i, j = sorted(random.sample(range(1, n), 2))\n            temp_solution = new_solution.copy()\n            temp_solution[i:j] = temp_solution[i:j][::-1]\n\n            # Check if the swap improves at least one objective\n            old_cost1 = distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[j-1], base_solution[j]]\n            new_cost1 = distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]]\n            if new_cost1 < old_cost1:\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 125,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Generate a neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Apply a multi-objective aware perturbation\n    if np.random.rand() < 0.5:\n        # Reverse the segment\n        segment = segment[::-1]\n    else:\n        # Shuffle the segment while maintaining feasibility\n        np.random.shuffle(segment)\n\n    # Evaluate the new segment's impact on all three objectives\n    def evaluate_segment(solution, start, end):\n        cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(start, end+1))\n        cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(start, end+1))\n        cost3 = sum(distance_matrix_3[solution[i-1], solution[i]] for i in range(start, end+1))\n        return cost1, cost2, cost3\n\n    original_cost = evaluate_segment(base_solution, a, b)\n    new_cost = evaluate_segment(np.concatenate([base_solution[:a], segment, base_solution[b+1:]]), a, b)\n\n    # Accept the change if it improves at least one objective\n    if any(new_cost[i] < original_cost[i] for i in range(3)):\n        new_solution[a:b+1] = segment\n\n    # Ensure the solution remains feasible (circular tour)\n    if new_solution[0] != new_solution[-1]:\n        new_solution[-1] = new_solution[0]\n\n    return new_solution\n\n",
        "score": [
            -0.7085604231458016,
            0.4589451432228088
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Generate a neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Apply a multi-objective aware perturbation\n    if np.random.rand() < 0.5:\n        # Reverse the segment\n        segment = segment[::-1]\n    else:\n        # Shuffle the segment while maintaining feasibility\n        np.random.shuffle(segment)\n\n    # Evaluate the new segment's impact on all three objectives\n    def evaluate_segment(solution, start, end):\n        cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(start, end+1))\n        cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(start, end+1))\n        cost3 = sum(distance_matrix_3[solution[i-1], solution[i]] for i in range(start, end+1))\n        return cost1, cost2, cost3\n\n    original_cost = evaluate_segment(base_solution, a, b)\n    new_cost = evaluate_segment(np.concatenate([base_solution[:a], segment, base_solution[b+1:]]), a, b)\n\n    # Accept the change if it improves at least one objective\n    if any(new_cost[i] < original_cost[i] for i in range(3)):\n        new_solution[a:b+1] = segment\n\n    # Ensure the solution remains feasible (circular tour)\n    if new_solution[0] != new_solution[-1]:\n        new_solution[-1] = new_solution[0]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 125,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Generate a neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Apply a multi-objective aware perturbation\n    if np.random.rand() < 0.5:\n        # Reverse the segment\n        segment = segment[::-1]\n    else:\n        # Shuffle the segment while maintaining feasibility\n        np.random.shuffle(segment)\n\n    # Evaluate the new segment's impact on all three objectives\n    def evaluate_segment(solution, start, end):\n        cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(start, end+1))\n        cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(start, end+1))\n        cost3 = sum(distance_matrix_3[solution[i-1], solution[i]] for i in range(start, end+1))\n        return cost1, cost2, cost3\n\n    original_cost = evaluate_segment(base_solution, a, b)\n    new_cost = evaluate_segment(np.concatenate([base_solution[:a], segment, base_solution[b+1:]]), a, b)\n\n    # Accept the change if it improves at least one objective\n    if any(new_cost[i] < original_cost[i] for i in range(3)):\n        new_solution[a:b+1] = segment\n\n    # Ensure the solution remains feasible (circular tour)\n    if new_solution[0] != new_solution[-1]:\n        new_solution[-1] = new_solution[0]\n\n    return new_solution\n\n",
        "score": [
            -0.7085604231458016,
            0.4589451432228088
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Generate a neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Apply a multi-objective aware perturbation\n    if np.random.rand() < 0.5:\n        # Reverse the segment\n        segment = segment[::-1]\n    else:\n        # Shuffle the segment while maintaining feasibility\n        np.random.shuffle(segment)\n\n    # Evaluate the new segment's impact on all three objectives\n    def evaluate_segment(solution, start, end):\n        cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(start, end+1))\n        cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(start, end+1))\n        cost3 = sum(distance_matrix_3[solution[i-1], solution[i]] for i in range(start, end+1))\n        return cost1, cost2, cost3\n\n    original_cost = evaluate_segment(base_solution, a, b)\n    new_cost = evaluate_segment(np.concatenate([base_solution[:a], segment, base_solution[b+1:]]), a, b)\n\n    # Accept the change if it improves at least one objective\n    if any(new_cost[i] < original_cost[i] for i in range(3)):\n        new_solution[a:b+1] = segment\n\n    # Ensure the solution remains feasible (circular tour)\n    if new_solution[0] != new_solution[-1]:\n        new_solution[-1] = new_solution[0]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 126,
        "algorithm": "{This algorithm intelligently selects a solution from the archive with high potential for improvement by analyzing objective values and applies a hybrid local search operator that combines 2-opt moves with a novel multi-objective edge swap strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = None\n    for sol, obj in archive:\n        # Prioritize solutions that are not the best in all objectives\n        if not all(obj[i] == min([o[i] for _, o in archive]) for i in range(3)):\n            selected_solution = sol\n            break\n    if selected_solution is None:\n        selected_solution = archive[0][0]\n\n    # Make a copy of the selected solution\n    new_solution = selected_solution.copy()\n\n    # Perform hybrid local search\n    n = len(new_solution)\n    i, j = np.random.randint(0, n, size=2)\n    if i > j:\n        i, j = j, i\n\n    # 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective edge swap\n    if np.random.rand() < 0.5:  # 50% chance to perform edge swap\n        k, l = np.random.randint(0, n, size=2)\n        if k > l:\n            k, l = l, k\n\n        # Check if the swap improves at least one objective\n        original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        original_cost3 = (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[i], new_solution[(j+1)%n]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n        new_cost3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_3[new_solution[i], new_solution[(j+1)%n]])\n\n        if (new_cost1 < original_cost1 or new_cost2 < original_cost2 or new_cost3 < original_cost3):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6386959483638498,
            1.6157838344573974
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = None\n    for sol, obj in archive:\n        # Prioritize solutions that are not the best in all objectives\n        if not all(obj[i] == min([o[i] for _, o in archive]) for i in range(3)):\n            selected_solution = sol\n            break\n    if selected_solution is None:\n        selected_solution = archive[0][0]\n\n    # Make a copy of the selected solution\n    new_solution = selected_solution.copy()\n\n    # Perform hybrid local search\n    n = len(new_solution)\n    i, j = np.random.randint(0, n, size=2)\n    if i > j:\n        i, j = j, i\n\n    # 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective edge swap\n    if np.random.rand() < 0.5:  # 50% chance to perform edge swap\n        k, l = np.random.randint(0, n, size=2)\n        if k > l:\n            k, l = l, k\n\n        # Check if the swap improves at least one objective\n        original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        original_cost3 = (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[i], new_solution[(j+1)%n]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n        new_cost3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_3[new_solution[i], new_solution[(j+1)%n]])\n\n        if (new_cost1 < original_cost1 or new_cost2 < original_cost2 or new_cost3 < original_cost3):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 127,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    normalized_objectives = np.array(objectives) / np.max(np.array(objectives), axis=0)\n    scores = np.sum(normalized_objectives, axis=1)\n    base_solution = archive[np.argmax(scores)][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to swap, considering their impact on all three objectives\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    k, l = sorted(np.random.choice(n, size=2, replace=False))\n\n    # Calculate the cost difference for each objective\n    def calculate_cost_diff(i, j, k, l):\n        original_cost = (\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n            distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n            distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n            distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        )\n        new_cost = (\n            distance_matrix_1[new_solution[i], new_solution[k]] +\n            distance_matrix_1[new_solution[j], new_solution[l]] +\n            distance_matrix_2[new_solution[i], new_solution[k]] +\n            distance_matrix_2[new_solution[j], new_solution[l]] +\n            distance_matrix_3[new_solution[i], new_solution[k]] +\n            distance_matrix_3[new_solution[j], new_solution[l]]\n        )\n        return new_cost - original_cost\n\n    # Perform the swap if it improves at least one objective\n    if calculate_cost_diff(i, j, k, l) < 0:\n        new_solution[[i, j, k, l]] = new_solution[[i, k, j, l]]\n\n    return new_solution\n\n",
        "score": [
            -0.7412933695305964,
            1.969780957698822
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    normalized_objectives = np.array(objectives) / np.max(np.array(objectives), axis=0)\n    scores = np.sum(normalized_objectives, axis=1)\n    base_solution = archive[np.argmax(scores)][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to swap, considering their impact on all three objectives\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    k, l = sorted(np.random.choice(n, size=2, replace=False))\n\n    # Calculate the cost difference for each objective\n    def calculate_cost_diff(i, j, k, l):\n        original_cost = (\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n            distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n            distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n            distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        )\n        new_cost = (\n            distance_matrix_1[new_solution[i], new_solution[k]] +\n            distance_matrix_1[new_solution[j], new_solution[l]] +\n            distance_matrix_2[new_solution[i], new_solution[k]] +\n            distance_matrix_2[new_solution[j], new_solution[l]] +\n            distance_matrix_3[new_solution[i], new_solution[k]] +\n            distance_matrix_3[new_solution[j], new_solution[l]]\n        )\n        return new_cost - original_cost\n\n    # Perform the swap if it improves at least one objective\n    if calculate_cost_diff(i, j, k, l) < 0:\n        new_solution[[i, j, k, l]] = new_solution[[i, k, j, l]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 128,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with multi-objective edge selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6990018740618119,
            1.4400984287261962
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with multi-objective edge selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 129,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (ascending)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the top 30% of the archive\n        selected_idx = random.randint(0, max(0, len(archive) // 3 - 1))\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform an objective-aware swap\n    # Calculate the current total cost for each objective\n    def calculate_total_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n        cost3 = sum(distance_matrix_3[solution[i], solution[(i+1)%n]] for i in range(n))\n        return (cost1, cost2, cost3)\n\n    current_costs = calculate_total_cost(new_solution)\n\n    # Try to find a better swap by considering all objectives\n    best_swap = None\n    best_improvement = 0\n\n    for _ in range(10):  # Limit the number of trials for efficiency\n        a, b = sorted(random.sample(range(n), 2))\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n        # Calculate new costs\n        new_costs = calculate_total_cost(temp_solution)\n\n        # Calculate improvement (sum of improvements across all objectives)\n        improvement = sum(current - new for current, new in zip(current_costs, new_costs))\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_swap = (a, b)\n\n    if best_swap:\n        a, b = best_swap\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7135170138421316,
            3.4519100904464723
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (ascending)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the top 30% of the archive\n        selected_idx = random.randint(0, max(0, len(archive) // 3 - 1))\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform an objective-aware swap\n    # Calculate the current total cost for each objective\n    def calculate_total_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n        cost3 = sum(distance_matrix_3[solution[i], solution[(i+1)%n]] for i in range(n))\n        return (cost1, cost2, cost3)\n\n    current_costs = calculate_total_cost(new_solution)\n\n    # Try to find a better swap by considering all objectives\n    best_swap = None\n    best_improvement = 0\n\n    for _ in range(10):  # Limit the number of trials for efficiency\n        a, b = sorted(random.sample(range(n), 2))\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n        # Calculate new costs\n        new_costs = calculate_total_cost(temp_solution)\n\n        # Calculate improvement (sum of improvements across all objectives)\n        improvement = sum(current - new for current, new in zip(current_costs, new_costs))\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_swap = (a, b)\n\n    if best_swap:\n        a, b = best_swap\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 130,
        "algorithm": "{The algorithm intelligently selects a non-dominated solution from the archive, applies a hybrid 3-objective local search operator combining 2-opt with a novel segment inversion and swap strategy, and ensures feasibility by maintaining valid TSP tours while prioritizing solutions with higher potential for multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here we choose the one with the best average objective)\n    objectives = np.array([obj for _, obj in archive])\n    avg_objectives = np.mean(objectives, axis=1)\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform hybrid local search\n    n = len(base_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt if it improves any objective\n    def calculate_tour_length(solution, matrix):\n        return sum(matrix[solution[k], solution[(k+1)%n]] for k in range(n))\n\n    current_lengths = [\n        calculate_tour_length(base_solution, distance_matrix_1),\n        calculate_tour_length(base_solution, distance_matrix_2),\n        calculate_tour_length(base_solution, distance_matrix_3)\n    ]\n\n    # Try 2-opt\n    candidate = base_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    new_lengths = [\n        calculate_tour_length(candidate, distance_matrix_1),\n        calculate_tour_length(candidate, distance_matrix_2),\n        calculate_tour_length(candidate, distance_matrix_3)\n    ]\n\n    if any(new < current for new, current in zip(new_lengths, current_lengths)):\n        new_solution = candidate.copy()\n\n    # Apply segment inversion with probability 0.5\n    if np.random.rand() < 0.5:\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Apply 3-objective swap with probability 0.3\n    if np.random.rand() < 0.3:\n        m, n_ = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[m], new_solution[n_] = new_solution[n_], new_solution[m]\n\n    return new_solution\n\n",
        "score": [
            -0.6575895086399004,
            2.7898890376091003
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here we choose the one with the best average objective)\n    objectives = np.array([obj for _, obj in archive])\n    avg_objectives = np.mean(objectives, axis=1)\n    selected_idx = np.argmin(avg_objectives)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform hybrid local search\n    n = len(base_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt if it improves any objective\n    def calculate_tour_length(solution, matrix):\n        return sum(matrix[solution[k], solution[(k+1)%n]] for k in range(n))\n\n    current_lengths = [\n        calculate_tour_length(base_solution, distance_matrix_1),\n        calculate_tour_length(base_solution, distance_matrix_2),\n        calculate_tour_length(base_solution, distance_matrix_3)\n    ]\n\n    # Try 2-opt\n    candidate = base_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    new_lengths = [\n        calculate_tour_length(candidate, distance_matrix_1),\n        calculate_tour_length(candidate, distance_matrix_2),\n        calculate_tour_length(candidate, distance_matrix_3)\n    ]\n\n    if any(new < current for new, current in zip(new_lengths, current_lengths)):\n        new_solution = candidate.copy()\n\n    # Apply segment inversion with probability 0.5\n    if np.random.rand() < 0.5:\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Apply 3-objective swap with probability 0.3\n    if np.random.rand() < 0.3:\n        m, n_ = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[m], new_solution[n_] = new_solution[n_], new_solution[m]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 131,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the highest sum of objectives (promising for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two non-adjacent edges to swap\n    i, j = sorted(random.sample(range(1, n), 2))\n    k, l = sorted(random.sample(range(1, n), 2))\n\n    # Ensure valid 2-opt move\n    if i != j and k != l:\n        # Swap edges to form a new tour\n        new_solution[i:j] = np.flip(new_solution[i:j])\n        new_solution[k:l] = np.flip(new_solution[k:l])\n\n    # Ensure tour validity\n    if not np.array_equal(np.unique(new_solution), selected_solution):\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6822068793044394,
            1.1382255911827088
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the highest sum of objectives (promising for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two non-adjacent edges to swap\n    i, j = sorted(random.sample(range(1, n), 2))\n    k, l = sorted(random.sample(range(1, n), 2))\n\n    # Ensure valid 2-opt move\n    if i != j and k != l:\n        # Swap edges to form a new tour\n        new_solution[i:j] = np.flip(new_solution[i:j])\n        new_solution[k:l] = np.flip(new_solution[k:l])\n\n    # Ensure tour validity\n    if not np.array_equal(np.unique(new_solution), selected_solution):\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 132,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware node selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Reverse the segment (2-opt move)\n    new_solution[i:j+1] = segment[::-1]\n\n    # Apply objective-aware node swaps to further improve\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        candidate = new_solution.copy()\n        candidate[k], candidate[l] = candidate[l], candidate[k]\n\n        # Evaluate the candidate in all three objectives\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        cost3 = sum(distance_matrix_3[candidate[i], candidate[(i+1)%n]] for i in range(n))\n\n        # Accept if any objective improves\n        if (cost1 < sum(archive[selected_idx][1]) or\n            cost2 < sum(archive[selected_idx][1]) or\n            cost3 < sum(archive[selected_idx][1])):\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7135282896926587,
            2.1233731269836427
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware node selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Reverse the segment (2-opt move)\n    new_solution[i:j+1] = segment[::-1]\n\n    # Apply objective-aware node swaps to further improve\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        candidate = new_solution.copy()\n        candidate[k], candidate[l] = candidate[l], candidate[k]\n\n        # Evaluate the candidate in all three objectives\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        cost3 = sum(distance_matrix_3[candidate[i], candidate[(i+1)%n]] for i in range(n))\n\n        # Accept if any objective improves\n        if (cost1 < sum(archive[selected_idx][1]) or\n            cost2 < sum(archive[selected_idx][1]) or\n            cost3 < sum(archive[selected_idx][1])):\n            new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 133,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the lowest objective values across the three objectives, then applies a hybrid local search combining 2-opt and a novel objective-aware edge swap to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the lowest sum of objectives (promising for improvement)\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Perform hybrid local search: 2-opt combined with objective-aware edge swap\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to optimize\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j+1]\n\n    # Apply 2-opt within the segment\n    if len(segment) > 1:\n        segment = segment[::-1]\n\n    # Replace the segment in the solution\n    new_solution[i:j+1] = segment\n\n    # Perform objective-aware edge swap\n    for _ in range(3):  # Number of swaps to perform\n        a, b = sorted(random.sample(range(n), 2))\n        node_a, node_b = new_solution[a], new_solution[b]\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[a-1], node_b] + distance_matrix_1[node_b, new_solution[(a+1)%n]] +\n                  distance_matrix_1[new_solution[b-1], node_a] + distance_matrix_1[node_a, new_solution[(b+1)%n]]) - \\\n                 (distance_matrix_1[new_solution[a-1], node_a] + distance_matrix_1[node_a, new_solution[(a+1)%n]] +\n                  distance_matrix_1[new_solution[b-1], node_b] + distance_matrix_1[node_b, new_solution[(b+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[a-1], node_b] + distance_matrix_2[node_b, new_solution[(a+1)%n]] +\n                  distance_matrix_2[new_solution[b-1], node_a] + distance_matrix_2[node_a, new_solution[(b+1)%n]]) - \\\n                 (distance_matrix_2[new_solution[a-1], node_a] + distance_matrix_2[node_a, new_solution[(a+1)%n]] +\n                  distance_matrix_2[new_solution[b-1], node_b] + distance_matrix_2[node_b, new_solution[(b+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[a-1], node_b] + distance_matrix_3[node_b, new_solution[(a+1)%n]] +\n                  distance_matrix_3[new_solution[b-1], node_a] + distance_matrix_3[node_a, new_solution[(b+1)%n]]) - \\\n                 (distance_matrix_3[new_solution[a-1], node_a] + distance_matrix_3[node_a, new_solution[(a+1)%n]] +\n                  distance_matrix_3[new_solution[b-1], node_b] + distance_matrix_3[node_b, new_solution[(b+1)%n]])\n\n        # Accept the swap if it improves at least one objective\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7573050923143615,
            1.4476047039031983
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the lowest sum of objectives (promising for improvement)\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Perform hybrid local search: 2-opt combined with objective-aware edge swap\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to optimize\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j+1]\n\n    # Apply 2-opt within the segment\n    if len(segment) > 1:\n        segment = segment[::-1]\n\n    # Replace the segment in the solution\n    new_solution[i:j+1] = segment\n\n    # Perform objective-aware edge swap\n    for _ in range(3):  # Number of swaps to perform\n        a, b = sorted(random.sample(range(n), 2))\n        node_a, node_b = new_solution[a], new_solution[b]\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[a-1], node_b] + distance_matrix_1[node_b, new_solution[(a+1)%n]] +\n                  distance_matrix_1[new_solution[b-1], node_a] + distance_matrix_1[node_a, new_solution[(b+1)%n]]) - \\\n                 (distance_matrix_1[new_solution[a-1], node_a] + distance_matrix_1[node_a, new_solution[(a+1)%n]] +\n                  distance_matrix_1[new_solution[b-1], node_b] + distance_matrix_1[node_b, new_solution[(b+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[a-1], node_b] + distance_matrix_2[node_b, new_solution[(a+1)%n]] +\n                  distance_matrix_2[new_solution[b-1], node_a] + distance_matrix_2[node_a, new_solution[(b+1)%n]]) - \\\n                 (distance_matrix_2[new_solution[a-1], node_a] + distance_matrix_2[node_a, new_solution[(a+1)%n]] +\n                  distance_matrix_2[new_solution[b-1], node_b] + distance_matrix_2[node_b, new_solution[(b+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[a-1], node_b] + distance_matrix_3[node_b, new_solution[(a+1)%n]] +\n                  distance_matrix_3[new_solution[b-1], node_a] + distance_matrix_3[node_a, new_solution[(b+1)%n]]) - \\\n                 (distance_matrix_3[new_solution[a-1], node_a] + distance_matrix_3[node_a, new_solution[(a+1)%n]] +\n                  distance_matrix_3[new_solution[b-1], node_b] + distance_matrix_3[node_b, new_solution[(b+1)%n]])\n\n        # Accept the swap if it improves at least one objective\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 134,
        "algorithm": "{The algorithm selects a solution from the archive with the highest potential for improvement by prioritizing solutions with lower objective values and applies a hybrid local search that combines 2-opt moves across all three objectives, followed by a randomized edge insertion to escape local optima, ensuring feasibility and multi-objective optimization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the best solution based on a weighted sum of objectives (prioritize lower values)\n    weights = [0.3, 0.3, 0.4]  # Weight for each objective (adjustable)\n    best_solution = min(archive, key=lambda x: sum(w * obj for w, obj in zip(weights, x[1])))\n    base_solution = best_solution[0].copy()\n\n    # Apply hybrid local search: 2-opt across all objectives followed by randomized edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # 2-opt move (across all objectives)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Check feasibility (no repeated nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    # Randomized edge insertion (exploration)\n    if random.random() < 0.3:  # 30% chance to apply\n        k, l = sorted(random.sample(range(n), 2))\n        if k != l:\n            edge = new_solution[k]\n            new_solution = np.concatenate([new_solution[:k], new_solution[k+1:l], [edge], new_solution[l:]])\n\n    # Ensure feasibility after insertion\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6447913281181197,
            1.7436876535415649
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the best solution based on a weighted sum of objectives (prioritize lower values)\n    weights = [0.3, 0.3, 0.4]  # Weight for each objective (adjustable)\n    best_solution = min(archive, key=lambda x: sum(w * obj for w, obj in zip(weights, x[1])))\n    base_solution = best_solution[0].copy()\n\n    # Apply hybrid local search: 2-opt across all objectives followed by randomized edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # 2-opt move (across all objectives)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Check feasibility (no repeated nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    # Randomized edge insertion (exploration)\n    if random.random() < 0.3:  # 30% chance to apply\n        k, l = sorted(random.sample(range(n), 2))\n        if k != l:\n            edge = new_solution[k]\n            new_solution = np.concatenate([new_solution[:k], new_solution[k+1:l], [edge], new_solution[l:]])\n\n    # Ensure feasibility after insertion\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 135,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Find the worst edge in terms of the sum of distances across all three objectives\n    max_edge_cost = -1\n    i, j = 0, 0\n    for idx in range(n - 1):\n        a, b = new_solution[idx], new_solution[idx + 1]\n        cost = distance_matrix_1[a, b] + distance_matrix_2[a, b] + distance_matrix_3[a, b]\n        if cost > max_edge_cost:\n            max_edge_cost = cost\n            i, j = idx, idx + 1\n\n    # Perform 2-opt swap to improve the worst edge\n    if i < j:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6859922192158372,
            1.294276511669159
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Find the worst edge in terms of the sum of distances across all three objectives\n    max_edge_cost = -1\n    i, j = 0, 0\n    for idx in range(n - 1):\n        a, b = new_solution[idx], new_solution[idx + 1]\n        cost = distance_matrix_1[a, b] + distance_matrix_2[a, b] + distance_matrix_3[a, b]\n        if cost > max_edge_cost:\n            max_edge_cost = cost\n            i, j = idx, idx + 1\n\n    # Perform 2-opt swap to improve the worst edge\n    if i < j:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 136,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([np.sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with objective-aware edge selection\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Objective-aware edge selection\n    obj1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[k], new_solution[(i+1)%n]]\n    obj2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[k], new_solution[(i+1)%n]]\n    obj3 = distance_matrix_3[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[k], new_solution[(i+1)%n]]\n\n    if obj1 + obj2 + obj3 > 0:  # If improvement potential exists\n        # Perform 3-opt move\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.711084419431157,
            2.7533979535102846
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([np.sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with objective-aware edge selection\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Objective-aware edge selection\n    obj1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[k], new_solution[(i+1)%n]]\n    obj2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[k], new_solution[(i+1)%n]]\n    obj3 = distance_matrix_3[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[k], new_solution[(i+1)%n]]\n\n    if obj1 + obj2 + obj3 > 0:  # If improvement potential exists\n        # Perform 3-opt move\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 137,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate a score for each solution based on normalized total distance\n    scores = []\n    for sol, obj in archive:\n        total_dist = sum(obj)  # Sum of all three objectives\n        scores.append(total_dist)\n\n    # Normalize scores to create a probability distribution\n    min_score = min(scores)\n    max_score = max(scores)\n    if min_score == max_score:\n        normalized_scores = [1.0 / len(scores)] * len(scores)\n    else:\n        normalized_scores = [(max_score - s) / (max_score - min_score) for s in scores]\n        total = sum(normalized_scores)\n        normalized_scores = [s / total for s in normalized_scores]\n\n    # Select a solution based on the probability distribution\n    selected_idx = np.random.choice(len(archive), p=normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Randomly choose between two local search operators\n    if random.random() < 0.5:\n        # 2-opt local search (for one randomly selected objective)\n        obj_idx = random.randint(0, 2)\n        if obj_idx == 0:\n            dist_matrix = distance_matrix_1\n        elif obj_idx == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Select two distinct edges to swap\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        if i == 0 and j == len(new_solution) - 1:\n            pass  # Avoid swapping the first and last nodes\n        else:\n            # Perform the 2-opt swap\n            new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # 3-opt local search (for all three objectives combined)\n        # Select three distinct edges to swap\n        i, j, k = sorted(random.sample(range(len(new_solution)), 3))\n        if i == 0 and k == len(new_solution) - 1:\n            pass  # Avoid modifying the first and last nodes\n        else:\n            # Perform the 3-opt swap\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    return new_solution\n\n",
        "score": [
            -0.7635072806799362,
            1.1724120140075684
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate a score for each solution based on normalized total distance\n    scores = []\n    for sol, obj in archive:\n        total_dist = sum(obj)  # Sum of all three objectives\n        scores.append(total_dist)\n\n    # Normalize scores to create a probability distribution\n    min_score = min(scores)\n    max_score = max(scores)\n    if min_score == max_score:\n        normalized_scores = [1.0 / len(scores)] * len(scores)\n    else:\n        normalized_scores = [(max_score - s) / (max_score - min_score) for s in scores]\n        total = sum(normalized_scores)\n        normalized_scores = [s / total for s in normalized_scores]\n\n    # Select a solution based on the probability distribution\n    selected_idx = np.random.choice(len(archive), p=normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Randomly choose between two local search operators\n    if random.random() < 0.5:\n        # 2-opt local search (for one randomly selected objective)\n        obj_idx = random.randint(0, 2)\n        if obj_idx == 0:\n            dist_matrix = distance_matrix_1\n        elif obj_idx == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Select two distinct edges to swap\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        if i == 0 and j == len(new_solution) - 1:\n            pass  # Avoid swapping the first and last nodes\n        else:\n            # Perform the 2-opt swap\n            new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # 3-opt local search (for all three objectives combined)\n        # Select three distinct edges to swap\n        i, j, k = sorted(random.sample(range(len(new_solution)), 3))\n        if i == 0 and k == len(new_solution) - 1:\n            pass  # Avoid modifying the first and last nodes\n        else:\n            # Perform the 3-opt swap\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 138,
        "algorithm": "{This heuristic function intelligently selects a non-dominated solution from the archive, then applies a hybrid local search operator that combines 2-opt moves with a novel multi-objective edge selection criterion to generate a neighbor solution, ensuring feasibility and promoting diversity in objective optimization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(1, 0.1, len(archive)) / np.sum(np.linspace(1, 0.1, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n_nodes = len(base_solution)\n    if n_nodes < 4:\n        return new_solution  # No possible 2-opt move\n\n    # Select two random edges to break\n    i, j = sorted(np.random.choice(n_nodes, 2, replace=False))\n    k, l = sorted(np.random.choice(n_nodes, 2, replace=False))\n\n    # Perform 2-opt move\n    new_solution[i:j+1] = base_solution[i:j+1][::-1]\n    new_solution[k:l+1] = base_solution[k:l+1][::-1]\n\n    # Multi-objective edge selection criterion\n    for _ in range(min(3, n_nodes // 2)):\n        # Select a random segment to reverse\n        a, b = sorted(np.random.choice(n_nodes, 2, replace=False))\n        segment = base_solution[a:b+1]\n\n        # Calculate improvement potential across all objectives\n        current_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        current_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        current_cost3 = sum(distance_matrix_3[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n        reversed_segment = segment[::-1]\n        new_cost1 = sum(distance_matrix_1[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n        new_cost2 = sum(distance_matrix_2[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n        new_cost3 = sum(distance_matrix_3[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n\n        # Apply if improves at least one objective\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2) or (new_cost3 < current_cost3):\n            new_solution[a:b+1] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            -0.6981969912348974,
            1.0718401432037354
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(1, 0.1, len(archive)) / np.sum(np.linspace(1, 0.1, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n_nodes = len(base_solution)\n    if n_nodes < 4:\n        return new_solution  # No possible 2-opt move\n\n    # Select two random edges to break\n    i, j = sorted(np.random.choice(n_nodes, 2, replace=False))\n    k, l = sorted(np.random.choice(n_nodes, 2, replace=False))\n\n    # Perform 2-opt move\n    new_solution[i:j+1] = base_solution[i:j+1][::-1]\n    new_solution[k:l+1] = base_solution[k:l+1][::-1]\n\n    # Multi-objective edge selection criterion\n    for _ in range(min(3, n_nodes // 2)):\n        # Select a random segment to reverse\n        a, b = sorted(np.random.choice(n_nodes, 2, replace=False))\n        segment = base_solution[a:b+1]\n\n        # Calculate improvement potential across all objectives\n        current_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        current_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        current_cost3 = sum(distance_matrix_3[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n        reversed_segment = segment[::-1]\n        new_cost1 = sum(distance_matrix_1[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n        new_cost2 = sum(distance_matrix_2[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n        new_cost3 = sum(distance_matrix_3[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n\n        # Apply if improves at least one objective\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2) or (new_cost3 < current_cost3):\n            new_solution[a:b+1] = reversed_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 139,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_idx = np.argmin([sum(obj) for sol, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n\n    # Apply a hybrid local search: 2-opt with weighted objective-based edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6260306230407917,
            1.6266210913658141
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_idx = np.argmin([sum(obj) for sol, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n\n    # Apply a hybrid local search: 2-opt with weighted objective-based edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 140,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware perturbation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments to reverse (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perturbation: randomly swap two nodes to escape local optima\n    if random.random() < 0.3:  # 30% chance of perturbation\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility by checking for duplicates and missing nodes\n    if len(set(new_solution)) != n:\n        # Fallback: revert to original if invalid\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6996799273015835,
            1.440627348423004
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware perturbation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments to reverse (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perturbation: randomly swap two nodes to escape local optima\n    if random.random() < 0.3:  # 30% chance of perturbation\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility by checking for duplicates and missing nodes\n    if len(set(new_solution)) != n:\n        # Fallback: revert to original if invalid\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 141,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variances = np.var(objectives, axis=0)\n    selected_idx = np.argmax(objective_variances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: combine 2-opt with a multi-objective aware swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on the objective with highest variance\n    obj_idx = np.argmax(objective_variances)\n    if obj_idx == 0:\n        dist_matrix = distance_matrix_1\n    elif obj_idx == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Randomly select two edges to reverse\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply a multi-objective aware swap: swap nodes that are outliers in any objective\n    for _ in range(2):  # Limit swaps to maintain diversity\n        # Find nodes with high distances in any objective\n        node_distances = []\n        for node in base_solution:\n            coords = instance[node]\n            dist1 = np.sum(distance_matrix_1[node])\n            dist2 = np.sum(distance_matrix_2[node])\n            dist3 = np.sum(distance_matrix_3[node])\n            node_distances.append((dist1 + dist2 + dist3, node))\n\n        node_distances.sort(reverse=True)\n        if len(node_distances) >= 2:\n            a, b = node_distances[0][1], node_distances[1][1]\n            a_idx = np.where(new_solution == a)[0][0]\n            b_idx = np.where(new_solution == b)[0][0]\n            new_solution[a_idx], new_solution[b_idx] = new_solution[b_idx], new_solution[a_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.6200011803959626,
            3.5603159785270693
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variances = np.var(objectives, axis=0)\n    selected_idx = np.argmax(objective_variances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: combine 2-opt with a multi-objective aware swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on the objective with highest variance\n    obj_idx = np.argmax(objective_variances)\n    if obj_idx == 0:\n        dist_matrix = distance_matrix_1\n    elif obj_idx == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Randomly select two edges to reverse\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply a multi-objective aware swap: swap nodes that are outliers in any objective\n    for _ in range(2):  # Limit swaps to maintain diversity\n        # Find nodes with high distances in any objective\n        node_distances = []\n        for node in base_solution:\n            coords = instance[node]\n            dist1 = np.sum(distance_matrix_1[node])\n            dist2 = np.sum(distance_matrix_2[node])\n            dist3 = np.sum(distance_matrix_3[node])\n            node_distances.append((dist1 + dist2 + dist3, node))\n\n        node_distances.sort(reverse=True)\n        if len(node_distances) >= 2:\n            a, b = node_distances[0][1], node_distances[1][1]\n            a_idx = np.where(new_solution == a)[0][0]\n            b_idx = np.where(new_solution == b)[0][0]\n            new_solution[a_idx], new_solution[b_idx] = new_solution[b_idx], new_solution[a_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 142,
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive 2-opt moves with multi-objective aware segment inversions to balance improvements across all three objectives by dynamically selecting segments based on their potential to reduce the combined objective values.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too good, not too bad)\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate the normalized objective values to identify promising solutions\n    normalized = np.array(objectives)\n    normalized = (normalized - normalized.min(axis=0)) / (normalized.max(axis=0) - normalized.min(axis=0) + 1e-8)\n    combined_scores = normalized.sum(axis=1)\n    median_score = np.median(combined_scores)\n\n    # Select solutions with scores near the median (promising but not too good)\n    candidates = [i for i, score in enumerate(combined_scores) if 0.8 * median_score <= score <= 1.2 * median_score]\n    if not candidates:\n        candidates = list(range(len(archive)))\n\n    selected_idx = random.choice(candidates)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful perturbation possible\n\n    # Adaptive 2-opt move with multi-objective awareness\n    i, j = sorted(random.sample(range(n), 2))\n    segment = base_solution[i:j+1]\n\n    # Evaluate segment inversion potential across all objectives\n    def evaluate_segment(seg):\n        total = 0\n        for k in range(len(distance_matrix_1)):\n            total += distance_matrix_1[k, seg[0]] + distance_matrix_2[k, seg[0]] + distance_matrix_3[k, seg[0]]\n        return total\n\n    original_cost = evaluate_segment(segment)\n    inverted_segment = segment[::-1]\n    inverted_cost = evaluate_segment(inverted_segment)\n\n    if inverted_cost < original_cost:\n        new_solution[i:j+1] = inverted_segment\n\n    # Additional multi-objective aware segment inversion\n    if random.random() < 0.3:  # 30% chance for secondary move\n        i, j = sorted(random.sample(range(n), 2))\n        segment = base_solution[i:j+1]\n\n        # Randomly select one objective to prioritize\n        obj_idx = random.randint(0, 2)\n        if obj_idx == 0:\n            dm = distance_matrix_1\n        elif obj_idx == 1:\n            dm = distance_matrix_2\n        else:\n            dm = distance_matrix_3\n\n        def evaluate_single_obj(seg):\n            total = 0\n            for k in range(len(dm)):\n                total += dm[k, seg[0]]\n            return total\n\n        original_cost = evaluate_single_obj(segment)\n        inverted_segment = segment[::-1]\n        inverted_cost = evaluate_single_obj(inverted_segment)\n\n        if inverted_cost < original_cost:\n            new_solution[i:j+1] = inverted_segment\n\n    return new_solution\n\n",
        "score": [
            -0.7007384479321281,
            2.4143134474754335
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too good, not too bad)\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate the normalized objective values to identify promising solutions\n    normalized = np.array(objectives)\n    normalized = (normalized - normalized.min(axis=0)) / (normalized.max(axis=0) - normalized.min(axis=0) + 1e-8)\n    combined_scores = normalized.sum(axis=1)\n    median_score = np.median(combined_scores)\n\n    # Select solutions with scores near the median (promising but not too good)\n    candidates = [i for i, score in enumerate(combined_scores) if 0.8 * median_score <= score <= 1.2 * median_score]\n    if not candidates:\n        candidates = list(range(len(archive)))\n\n    selected_idx = random.choice(candidates)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful perturbation possible\n\n    # Adaptive 2-opt move with multi-objective awareness\n    i, j = sorted(random.sample(range(n), 2))\n    segment = base_solution[i:j+1]\n\n    # Evaluate segment inversion potential across all objectives\n    def evaluate_segment(seg):\n        total = 0\n        for k in range(len(distance_matrix_1)):\n            total += distance_matrix_1[k, seg[0]] + distance_matrix_2[k, seg[0]] + distance_matrix_3[k, seg[0]]\n        return total\n\n    original_cost = evaluate_segment(segment)\n    inverted_segment = segment[::-1]\n    inverted_cost = evaluate_segment(inverted_segment)\n\n    if inverted_cost < original_cost:\n        new_solution[i:j+1] = inverted_segment\n\n    # Additional multi-objective aware segment inversion\n    if random.random() < 0.3:  # 30% chance for secondary move\n        i, j = sorted(random.sample(range(n), 2))\n        segment = base_solution[i:j+1]\n\n        # Randomly select one objective to prioritize\n        obj_idx = random.randint(0, 2)\n        if obj_idx == 0:\n            dm = distance_matrix_1\n        elif obj_idx == 1:\n            dm = distance_matrix_2\n        else:\n            dm = distance_matrix_3\n\n        def evaluate_single_obj(seg):\n            total = 0\n            for k in range(len(dm)):\n                total += dm[k, seg[0]]\n            return total\n\n        original_cost = evaluate_single_obj(segment)\n        inverted_segment = segment[::-1]\n        inverted_cost = evaluate_single_obj(inverted_segment)\n\n        if inverted_cost < original_cost:\n            new_solution[i:j+1] = inverted_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 143,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the total objective values for each solution\n    objectives = [obj for (sol, obj) in archive]\n    total_objectives = [sum(obj) for obj in objectives]\n\n    # Select the solution with the lowest total objective (promising for improvement)\n    selected_idx = np.argmin(total_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Randomly select two distinct nodes to swap (2-opt move)\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n\n    # Ensure i < j for simplicity\n    if i > j:\n        i, j = j, i\n\n    # Reverse the segment between i and j to create a new tour\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 3: Apply a novel objective-aware perturbation\n    # Identify the worst objective and try to improve it\n    obj_values = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(obj_values)\n\n    # If the worst objective is the first, use distance_matrix_1 to find a better segment\n    if worst_obj_idx == 0:\n        # Find the segment with the highest cost in the first objective\n        max_cost = -1\n        best_i, best_j = 0, 1\n        for i in range(n):\n            for j in range(i+1, n):\n                segment_cost = 0\n                for k in range(i, j):\n                    segment_cost += distance_matrix_1[base_solution[k], base_solution[k+1]]\n                if segment_cost > max_cost:\n                    max_cost = segment_cost\n                    best_i, best_j = i, j\n        # Reverse the worst segment to improve the first objective\n        new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n    # If the worst objective is the second, use distance_matrix_2\n    elif worst_obj_idx == 1:\n        # Find the segment with the highest cost in the second objective\n        max_cost = -1\n        best_i, best_j = 0, 1\n        for i in range(n):\n            for j in range(i+1, n):\n                segment_cost = 0\n                for k in range(i, j):\n                    segment_cost += distance_matrix_2[base_solution[k], base_solution[k+1]]\n                if segment_cost > max_cost:\n                    max_cost = segment_cost\n                    best_i, best_j = i, j\n        # Reverse the worst segment to improve the second objective\n        new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n    # If the worst objective is the third, use distance_matrix_3\n    else:\n        # Find the segment with the highest cost in the third objective\n        max_cost = -1\n        best_i, best_j = 0, 1\n        for i in range(n):\n            for j in range(i+1, n):\n                segment_cost = 0\n                for k in range(i, j):\n                    segment_cost += distance_matrix_3[base_solution[k], base_solution[k+1]]\n                if segment_cost > max_cost:\n                    max_cost = segment_cost\n                    best_i, best_j = i, j\n        # Reverse the worst segment to improve the third objective\n        new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5841809147158363,
            3.7441762685775757
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the total objective values for each solution\n    objectives = [obj for (sol, obj) in archive]\n    total_objectives = [sum(obj) for obj in objectives]\n\n    # Select the solution with the lowest total objective (promising for improvement)\n    selected_idx = np.argmin(total_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Randomly select two distinct nodes to swap (2-opt move)\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n\n    # Ensure i < j for simplicity\n    if i > j:\n        i, j = j, i\n\n    # Reverse the segment between i and j to create a new tour\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 3: Apply a novel objective-aware perturbation\n    # Identify the worst objective and try to improve it\n    obj_values = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(obj_values)\n\n    # If the worst objective is the first, use distance_matrix_1 to find a better segment\n    if worst_obj_idx == 0:\n        # Find the segment with the highest cost in the first objective\n        max_cost = -1\n        best_i, best_j = 0, 1\n        for i in range(n):\n            for j in range(i+1, n):\n                segment_cost = 0\n                for k in range(i, j):\n                    segment_cost += distance_matrix_1[base_solution[k], base_solution[k+1]]\n                if segment_cost > max_cost:\n                    max_cost = segment_cost\n                    best_i, best_j = i, j\n        # Reverse the worst segment to improve the first objective\n        new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n    # If the worst objective is the second, use distance_matrix_2\n    elif worst_obj_idx == 1:\n        # Find the segment with the highest cost in the second objective\n        max_cost = -1\n        best_i, best_j = 0, 1\n        for i in range(n):\n            for j in range(i+1, n):\n                segment_cost = 0\n                for k in range(i, j):\n                    segment_cost += distance_matrix_2[base_solution[k], base_solution[k+1]]\n                if segment_cost > max_cost:\n                    max_cost = segment_cost\n                    best_i, best_j = i, j\n        # Reverse the worst segment to improve the second objective\n        new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n    # If the worst objective is the third, use distance_matrix_3\n    else:\n        # Find the segment with the highest cost in the third objective\n        max_cost = -1\n        best_i, best_j = 0, 1\n        for i in range(n):\n            for j in range(i+1, n):\n                segment_cost = 0\n                for k in range(i, j):\n                    segment_cost += distance_matrix_3[base_solution[k], base_solution[k+1]]\n                if segment_cost > max_cost:\n                    max_cost = segment_cost\n                    best_i, best_j = i, j\n        # Reverse the worst segment to improve the third objective\n        new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 144,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with high variance in objectives\n    objectives = np.array([obj for _, obj in archive])\n    obj_variance = np.var(objectives, axis=0)\n    selected_idx = np.argmax(obj_variance)  # Select space with highest variance\n\n    # Sort solutions by the selected objective and pick the middle one (promising for trade-offs)\n    sorted_indices = np.argsort(objectives[:, selected_idx])\n    selected_solution = archive[sorted_indices[len(sorted_indices)//2]][0].copy()\n\n    # Hybrid local search: 2-opt for one space, node insertion for another\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # 2-opt in one space (minimizing the selected objective)\n    for _ in range(10):  # Limited iterations for efficiency\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == 0 or j == n-1:\n            continue  # Avoid breaking the tour\n\n        # Evaluate 2-opt in the selected space\n        old_dist = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        new_dist = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n\n        if new_dist < old_dist:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Node insertion in another space (exploring trade-offs)\n    for _ in range(5):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i == j:\n            continue\n\n        # Evaluate insertion in a different space\n        old_dist = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n        new_dist = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n\n        if new_dist < old_dist:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7598592302987571,
            2.8534376859664916
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with high variance in objectives\n    objectives = np.array([obj for _, obj in archive])\n    obj_variance = np.var(objectives, axis=0)\n    selected_idx = np.argmax(obj_variance)  # Select space with highest variance\n\n    # Sort solutions by the selected objective and pick the middle one (promising for trade-offs)\n    sorted_indices = np.argsort(objectives[:, selected_idx])\n    selected_solution = archive[sorted_indices[len(sorted_indices)//2]][0].copy()\n\n    # Hybrid local search: 2-opt for one space, node insertion for another\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # 2-opt in one space (minimizing the selected objective)\n    for _ in range(10):  # Limited iterations for efficiency\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == 0 or j == n-1:\n            continue  # Avoid breaking the tour\n\n        # Evaluate 2-opt in the selected space\n        old_dist = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        new_dist = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n\n        if new_dist < old_dist:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Node insertion in another space (exploring trade-offs)\n    for _ in range(5):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i == j:\n            continue\n\n        # Evaluate insertion in a different space\n        old_dist = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n        new_dist = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n\n        if new_dist < old_dist:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 145,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: 3-opt for large improvements, 2-opt for fine-tuning\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # 3-opt: Randomly select 3 edges and reconnect them\n    i, j, k = sorted(random.sample(range(1, n), 3))\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # 2-opt: Apply to a random segment\n    a, b = sorted(random.sample(range(1, n), 2))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7270658068471274,
            1.3975734829902648
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: 3-opt for large improvements, 2-opt for fine-tuning\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # 3-opt: Randomly select 3 edges and reconnect them\n    i, j, k = sorted(random.sample(range(1, n), 3))\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # 2-opt: Apply to a random segment\n    a, b = sorted(random.sample(range(1, n), 2))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 146,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    worst_objectives = [max(obj) for obj in objectives]\n    selected_idx = np.argmax(worst_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a multi-objective aware swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt for the worst objective\n    worst_obj_idx = np.argmax(archive[selected_idx][1])\n    if worst_obj_idx == 0:\n        distance_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Find the best 2-opt move\n    best_improvement = 0\n    best_i, best_j = 0, 0\n    for i in range(n - 1):\n        for j in range(i + 2, n):\n            # Current edges: (i, i+1) and (j, j+1)\n            # Proposed edges: (i, j) and (i+1, j+1)\n            delta = (distance_matrix[new_solution[i], new_solution[j]] +\n                     distance_matrix[new_solution[i + 1], new_solution[(j + 1) % n]]) - \\\n                    (distance_matrix[new_solution[i], new_solution[i + 1]] +\n                     distance_matrix[new_solution[j], new_solution[(j + 1) % n]])\n            if delta < best_improvement:\n                best_improvement = delta\n                best_i, best_j = i, j\n\n    if best_improvement < 0:\n        # Apply the 2-opt move\n        new_solution[best_i + 1:best_j + 1] = np.flip(new_solution[best_i + 1:best_j + 1])\n\n    # Perform a multi-objective aware swap to improve other objectives\n    if np.random.rand() < 0.3:  # 30% chance to perform swap\n        i, j = np.random.choice(n, 2, replace=False)\n        # Check if swap improves at least one objective\n        current_costs = [0, 0, 0]\n        for k in range(n):\n            node1 = new_solution[k]\n            node2 = new_solution[(k + 1) % n]\n            current_costs[0] += distance_matrix_1[node1, node2]\n            current_costs[1] += distance_matrix_2[node1, node2]\n            current_costs[2] += distance_matrix_3[node1, node2]\n\n        # Swap nodes i and j\n        temp = new_solution[i]\n        new_solution[i] = new_solution[j]\n        new_solution[j] = temp\n\n        # Calculate new costs\n        new_costs = [0, 0, 0]\n        for k in range(n):\n            node1 = new_solution[k]\n            node2 = new_solution[(k + 1) % n]\n            new_costs[0] += distance_matrix_1[node1, node2]\n            new_costs[1] += distance_matrix_2[node1, node2]\n            new_costs[2] += distance_matrix_3[node1, node2]\n\n        # Revert if no improvement in any objective\n        if all(new_cost >= current_cost for new_cost, current_cost in zip(new_costs, current_costs)):\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.5436823317610479,
            2.856076192855835
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    worst_objectives = [max(obj) for obj in objectives]\n    selected_idx = np.argmax(worst_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a multi-objective aware swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt for the worst objective\n    worst_obj_idx = np.argmax(archive[selected_idx][1])\n    if worst_obj_idx == 0:\n        distance_matrix = distance_matrix_1\n    elif worst_obj_idx == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Find the best 2-opt move\n    best_improvement = 0\n    best_i, best_j = 0, 0\n    for i in range(n - 1):\n        for j in range(i + 2, n):\n            # Current edges: (i, i+1) and (j, j+1)\n            # Proposed edges: (i, j) and (i+1, j+1)\n            delta = (distance_matrix[new_solution[i], new_solution[j]] +\n                     distance_matrix[new_solution[i + 1], new_solution[(j + 1) % n]]) - \\\n                    (distance_matrix[new_solution[i], new_solution[i + 1]] +\n                     distance_matrix[new_solution[j], new_solution[(j + 1) % n]])\n            if delta < best_improvement:\n                best_improvement = delta\n                best_i, best_j = i, j\n\n    if best_improvement < 0:\n        # Apply the 2-opt move\n        new_solution[best_i + 1:best_j + 1] = np.flip(new_solution[best_i + 1:best_j + 1])\n\n    # Perform a multi-objective aware swap to improve other objectives\n    if np.random.rand() < 0.3:  # 30% chance to perform swap\n        i, j = np.random.choice(n, 2, replace=False)\n        # Check if swap improves at least one objective\n        current_costs = [0, 0, 0]\n        for k in range(n):\n            node1 = new_solution[k]\n            node2 = new_solution[(k + 1) % n]\n            current_costs[0] += distance_matrix_1[node1, node2]\n            current_costs[1] += distance_matrix_2[node1, node2]\n            current_costs[2] += distance_matrix_3[node1, node2]\n\n        # Swap nodes i and j\n        temp = new_solution[i]\n        new_solution[i] = new_solution[j]\n        new_solution[j] = temp\n\n        # Calculate new costs\n        new_costs = [0, 0, 0]\n        for k in range(n):\n            node1 = new_solution[k]\n            node2 = new_solution[(k + 1) % n]\n            new_costs[0] += distance_matrix_1[node1, node2]\n            new_costs[1] += distance_matrix_2[node1, node2]\n            new_costs[2] += distance_matrix_3[node1, node2]\n\n        # Revert if no improvement in any objective\n        if all(new_cost >= current_cost for new_cost, current_cost in zip(new_costs, current_costs)):\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 147,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        std_devs = np.std(objectives, axis=0)\n        total_std_dev = np.sum(std_devs)\n        selected_idx = np.argmax(total_std_dev)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n\n    # Objective-aware edge selection: prefer edges that are critical in any objective\n    obj1_diff = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n    obj2_diff = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n    obj3_diff = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n\n    # Calculate the potential improvement in any objective\n    potential_improvement = max(obj1_diff, obj2_diff, obj3_diff)\n\n    # Apply 2-opt with probability proportional to potential improvement\n    if np.random.rand() < potential_improvement / (np.max(distance_matrix_1) + np.max(distance_matrix_2) + np.max(distance_matrix_3)):\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply a small perturbation to escape local optima\n    if np.random.rand() < 0.2:\n        k, l = sorted(np.random.choice(range(n), size=2, replace=False))\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.6288926860168765,
            1.8693372011184692
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        std_devs = np.std(objectives, axis=0)\n        total_std_dev = np.sum(std_devs)\n        selected_idx = np.argmax(total_std_dev)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n\n    # Objective-aware edge selection: prefer edges that are critical in any objective\n    obj1_diff = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n    obj2_diff = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n    obj3_diff = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n\n    # Calculate the potential improvement in any objective\n    potential_improvement = max(obj1_diff, obj2_diff, obj3_diff)\n\n    # Apply 2-opt with probability proportional to potential improvement\n    if np.random.rand() < potential_improvement / (np.max(distance_matrix_1) + np.max(distance_matrix_2) + np.max(distance_matrix_3)):\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply a small perturbation to escape local optima\n    if np.random.rand() < 0.2:\n        k, l = sorted(np.random.choice(range(n), size=2, replace=False))\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 148,
        "algorithm": "{The algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement in multiple objectives, then applies a hybrid local search operator that combines 2-opt moves with a novel multi-objective segment relocation strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_solution = None\n    max_potential = -1\n    for sol, obj in archive:\n        # Calculate potential as the sum of normalized improvement potential across objectives\n        potential = sum(obj)  # Placeholder for more sophisticated potential calculation\n        if potential > max_potential:\n            max_potential = potential\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    # Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and multi-objective segment relocation\n    if random.random() < 0.5:\n        # 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Multi-objective segment relocation\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            -0.6630050040835517,
            1.4096212148666383
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_solution = None\n    max_potential = -1\n    for sol, obj in archive:\n        # Calculate potential as the sum of normalized improvement potential across objectives\n        potential = sum(obj)  # Placeholder for more sophisticated potential calculation\n        if potential > max_potential:\n            max_potential = potential\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    # Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and multi-objective segment relocation\n    if random.random() < 0.5:\n        # 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Multi-objective segment relocation\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 149,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Perform a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to break and reconnect\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Find the best reconnection in terms of total improvement across objectives\n    best_improvement = -float('inf')\n    best_k, best_l = -1, -1\n\n    for k in range(i + 1, j):\n        for l in range(k + 1, j + 1 if j < n - 1 else n):\n            # Calculate improvement for each objective\n            obj1_improvement = (distance_matrix_1[new_solution[i], new_solution[k]] +\n                               distance_matrix_1[new_solution[l], new_solution[j]]) - \\\n                              (distance_matrix_1[new_solution[i], new_solution[j]] +\n                               distance_matrix_1[new_solution[k], new_solution[l]])\n\n            obj2_improvement = (distance_matrix_2[new_solution[i], new_solution[k]] +\n                               distance_matrix_2[new_solution[l], new_solution[j]]) - \\\n                              (distance_matrix_2[new_solution[i], new_solution[j]] +\n                               distance_matrix_2[new_solution[k], new_solution[l]])\n\n            obj3_improvement = (distance_matrix_3[new_solution[i], new_solution[k]] +\n                               distance_matrix_3[new_solution[l], new_solution[j]]) - \\\n                              (distance_matrix_3[new_solution[i], new_solution[j]] +\n                               distance_matrix_3[new_solution[k], new_solution[l]])\n\n            total_improvement = obj1_improvement + obj2_improvement + obj3_improvement\n\n            if total_improvement > best_improvement:\n                best_improvement = total_improvement\n                best_k, best_l = k, l\n\n    if best_k != -1:\n        # Reverse the segment between best_k and best_l\n        new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    return new_solution\n\n",
        "score": [
            -0.6678181851338015,
            2.208692419528961
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Perform a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to break and reconnect\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Find the best reconnection in terms of total improvement across objectives\n    best_improvement = -float('inf')\n    best_k, best_l = -1, -1\n\n    for k in range(i + 1, j):\n        for l in range(k + 1, j + 1 if j < n - 1 else n):\n            # Calculate improvement for each objective\n            obj1_improvement = (distance_matrix_1[new_solution[i], new_solution[k]] +\n                               distance_matrix_1[new_solution[l], new_solution[j]]) - \\\n                              (distance_matrix_1[new_solution[i], new_solution[j]] +\n                               distance_matrix_1[new_solution[k], new_solution[l]])\n\n            obj2_improvement = (distance_matrix_2[new_solution[i], new_solution[k]] +\n                               distance_matrix_2[new_solution[l], new_solution[j]]) - \\\n                              (distance_matrix_2[new_solution[i], new_solution[j]] +\n                               distance_matrix_2[new_solution[k], new_solution[l]])\n\n            obj3_improvement = (distance_matrix_3[new_solution[i], new_solution[k]] +\n                               distance_matrix_3[new_solution[l], new_solution[j]]) - \\\n                              (distance_matrix_3[new_solution[i], new_solution[j]] +\n                               distance_matrix_3[new_solution[k], new_solution[l]])\n\n            total_improvement = obj1_improvement + obj2_improvement + obj3_improvement\n\n            if total_improvement > best_improvement:\n                best_improvement = total_improvement\n                best_k, best_l = k, l\n\n    if best_k != -1:\n        # Reverse the segment between best_k and best_l\n        new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 150,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[np.random.choice(len(archive))][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and segment reversal with objective-aware selection\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Objective-aware segment selection\n    segment_costs = np.zeros(3)\n    for k in range(i, j):\n        segment_costs[0] += distance_matrix_1[new_solution[k], new_solution[(k+1)%n]]\n        segment_costs[1] += distance_matrix_2[new_solution[k], new_solution[(k+1)%n]]\n        segment_costs[2] += distance_matrix_3[new_solution[k], new_solution[(k+1)%n]]\n\n    # Apply segment reversal if it shows potential improvement in at least one objective\n    if np.random.rand() < 0.7 or np.any(segment_costs > np.mean([s[1][0] for s in archive])):\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply 2-opt with objective-aware edge selection\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    if (a != i and b != j) and (np.random.rand() < 0.5 or\n        (distance_matrix_1[new_solution[a], new_solution[b]] +\n         distance_matrix_1[new_solution[(a+1)%n], new_solution[(b+1)%n]] >\n         distance_matrix_1[new_solution[a], new_solution[(b+1)%n]] +\n         distance_matrix_1[new_solution[b], new_solution[(a+1)%n]])):\n        new_solution[a+1:b+1] = new_solution[a+1:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7576193975374276,
            1.5593314528465272
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[np.random.choice(len(archive))][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and segment reversal with objective-aware selection\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Objective-aware segment selection\n    segment_costs = np.zeros(3)\n    for k in range(i, j):\n        segment_costs[0] += distance_matrix_1[new_solution[k], new_solution[(k+1)%n]]\n        segment_costs[1] += distance_matrix_2[new_solution[k], new_solution[(k+1)%n]]\n        segment_costs[2] += distance_matrix_3[new_solution[k], new_solution[(k+1)%n]]\n\n    # Apply segment reversal if it shows potential improvement in at least one objective\n    if np.random.rand() < 0.7 or np.any(segment_costs > np.mean([s[1][0] for s in archive])):\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply 2-opt with objective-aware edge selection\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    if (a != i and b != j) and (np.random.rand() < 0.5 or\n        (distance_matrix_1[new_solution[a], new_solution[b]] +\n         distance_matrix_1[new_solution[(a+1)%n], new_solution[(b+1)%n]] >\n         distance_matrix_1[new_solution[a], new_solution[(b+1)%n]] +\n         distance_matrix_1[new_solution[b], new_solution[(a+1)%n]])):\n        new_solution[a+1:b+1] = new_solution[a+1:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 151,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search: 2-opt with multi-objective awareness\n    n = len(best_solution)\n    new_solution = best_solution.copy()\n\n    # Randomly select two distinct edges to reverse\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains valid by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = best_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6521943215162976,
            1.3413109302520752
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search: 2-opt with multi-objective awareness\n    n = len(best_solution)\n    new_solution = best_solution.copy()\n\n    # Randomly select two distinct edges to reverse\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains valid by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = best_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 152,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive by prioritizing those with lower objective values, then applies a hybrid local search strategy that combines 2-opt swaps and node insertion moves across all three objective spaces to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower objectives for potential improvement\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: 2-opt swap + node insertion across all objectives\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, perform random swaps\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger instances, perform 2-opt swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Additional node insertion for multi-objective optimization\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7206725741951658,
            1.3852493524551392
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower objectives for potential improvement\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: 2-opt swap + node insertion across all objectives\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, perform random swaps\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger instances, perform 2-opt swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Additional node insertion for multi-objective optimization\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 153,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, base_objective = max(archive, key=lambda x: sum(x[1]))\n\n    # Perform a hybrid local search: 2-opt with objective-aware node selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify critical segments in each objective space\n    def get_critical_segments(obj_matrix):\n        total_cost = sum(obj_matrix[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        avg_cost = total_cost / n\n        critical_edges = [(i, (i+1)%n) for i in range(n) if obj_matrix[new_solution[i], new_solution[(i+1)%n]] > avg_cost]\n        return critical_edges\n\n    critical_1 = get_critical_segments(distance_matrix_1)\n    critical_2 = get_critical_segments(distance_matrix_2)\n    critical_3 = get_critical_segments(distance_matrix_3)\n\n    # Combine critical segments from all objectives\n    all_critical = set(critical_1 + critical_2 + critical_3)\n\n    if not all_critical:\n        # Fallback to random 2-opt if no critical segments found\n        i, j = sorted(random.sample(range(n), 2))\n    else:\n        # Select a segment from the most critical objective\n        obj_weights = [len(critical_1), len(critical_2), len(critical_3)]\n        selected_obj = np.argmax(obj_weights)\n\n        if selected_obj == 0:\n            i, j = random.choice(critical_1)\n        elif selected_obj == 1:\n            i, j = random.choice(critical_2)\n        else:\n            i, j = random.choice(critical_3)\n\n    # Perform 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6891405726027396,
            1.7718136429786682
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, base_objective = max(archive, key=lambda x: sum(x[1]))\n\n    # Perform a hybrid local search: 2-opt with objective-aware node selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify critical segments in each objective space\n    def get_critical_segments(obj_matrix):\n        total_cost = sum(obj_matrix[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        avg_cost = total_cost / n\n        critical_edges = [(i, (i+1)%n) for i in range(n) if obj_matrix[new_solution[i], new_solution[(i+1)%n]] > avg_cost]\n        return critical_edges\n\n    critical_1 = get_critical_segments(distance_matrix_1)\n    critical_2 = get_critical_segments(distance_matrix_2)\n    critical_3 = get_critical_segments(distance_matrix_3)\n\n    # Combine critical segments from all objectives\n    all_critical = set(critical_1 + critical_2 + critical_3)\n\n    if not all_critical:\n        # Fallback to random 2-opt if no critical segments found\n        i, j = sorted(random.sample(range(n), 2))\n    else:\n        # Select a segment from the most critical objective\n        obj_weights = [len(critical_1), len(critical_2), len(critical_3)]\n        selected_obj = np.argmax(obj_weights)\n\n        if selected_obj == 0:\n            i, j = random.choice(critical_1)\n        elif selected_obj == 1:\n            i, j = random.choice(critical_2)\n        else:\n            i, j = random.choice(critical_3)\n\n    # Perform 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 154,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: 2-opt with objective-based edge selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Identify edges with high improvement potential in any objective\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            # Calculate potential improvement in all three objectives\n            obj1_improvement = (distance_matrix_1[selected_solution[i], selected_solution[j]] +\n                               distance_matrix_1[selected_solution[i+1], selected_solution[(j+1)%n]]) - \\\n                              (distance_matrix_1[selected_solution[i], selected_solution[i+1]] +\n                               distance_matrix_1[selected_solution[j], selected_solution[(j+1)%n]])\n\n            obj2_improvement = (distance_matrix_2[selected_solution[i], selected_solution[j]] +\n                               distance_matrix_2[selected_solution[i+1], selected_solution[(j+1)%n]]) - \\\n                              (distance_matrix_2[selected_solution[i], selected_solution[i+1]] +\n                               distance_matrix_2[selected_solution[j], selected_solution[(j+1)%n]])\n\n            obj3_improvement = (distance_matrix_3[selected_solution[i], selected_solution[j]] +\n                               distance_matrix_3[selected_solution[i+1], selected_solution[(j+1)%n]]) - \\\n                              (distance_matrix_3[selected_solution[i], selected_solution[i+1]] +\n                               distance_matrix_3[selected_solution[j], selected_solution[(j+1)%n]])\n\n            # Apply 2-opt if any objective shows improvement\n            if obj1_improvement < 0 or obj2_improvement < 0 or obj3_improvement < 0:\n                new_solution[i+1:j+1] = selected_solution[j:i:-1]\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.6836008517124238,
            0.9767474055290222
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: 2-opt with objective-based edge selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Identify edges with high improvement potential in any objective\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            # Calculate potential improvement in all three objectives\n            obj1_improvement = (distance_matrix_1[selected_solution[i], selected_solution[j]] +\n                               distance_matrix_1[selected_solution[i+1], selected_solution[(j+1)%n]]) - \\\n                              (distance_matrix_1[selected_solution[i], selected_solution[i+1]] +\n                               distance_matrix_1[selected_solution[j], selected_solution[(j+1)%n]])\n\n            obj2_improvement = (distance_matrix_2[selected_solution[i], selected_solution[j]] +\n                               distance_matrix_2[selected_solution[i+1], selected_solution[(j+1)%n]]) - \\\n                              (distance_matrix_2[selected_solution[i], selected_solution[i+1]] +\n                               distance_matrix_2[selected_solution[j], selected_solution[(j+1)%n]])\n\n            obj3_improvement = (distance_matrix_3[selected_solution[i], selected_solution[j]] +\n                               distance_matrix_3[selected_solution[i+1], selected_solution[(j+1)%n]]) - \\\n                              (distance_matrix_3[selected_solution[i], selected_solution[i+1]] +\n                               distance_matrix_3[selected_solution[j], selected_solution[(j+1)%n]])\n\n            # Apply 2-opt if any objective shows improvement\n            if obj1_improvement < 0 or obj2_improvement < 0 or obj3_improvement < 0:\n                new_solution[i+1:j+1] = selected_solution[j:i:-1]\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 155,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # Choose between 3-opt or 2-opt with probability based on objective diversity\n    objectives = [obj for _, obj in archive]\n    diversity = np.std([sum(obj) for obj in objectives])\n\n    if random.random() < 0.7 or diversity < 1000:  # Higher probability for 3-opt if objectives are diverse\n        # 3-opt local search: randomly select 3 edges and reconnect them\n        n = len(selected_solution)\n        i, j, k = sorted(random.sample(range(1, n-1), 3))\n        new_solution = selected_solution.copy()\n\n        # Reconnect the three edges in a different way\n        new_solution[i:j] = selected_solution[i:j][::-1]  # Reverse segment i to j\n        new_solution[j:k] = selected_solution[j:k][::-1]  # Reverse segment j to k\n    else:\n        # 2-opt local search: swap two edges\n        n = len(selected_solution)\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution = selected_solution.copy()\n        new_solution[i:j] = selected_solution[i:j][::-1]  # Reverse segment i to j\n\n    return new_solution\n\n",
        "score": [
            -0.6527585785291496,
            1.8908970713615418
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # Choose between 3-opt or 2-opt with probability based on objective diversity\n    objectives = [obj for _, obj in archive]\n    diversity = np.std([sum(obj) for obj in objectives])\n\n    if random.random() < 0.7 or diversity < 1000:  # Higher probability for 3-opt if objectives are diverse\n        # 3-opt local search: randomly select 3 edges and reconnect them\n        n = len(selected_solution)\n        i, j, k = sorted(random.sample(range(1, n-1), 3))\n        new_solution = selected_solution.copy()\n\n        # Reconnect the three edges in a different way\n        new_solution[i:j] = selected_solution[i:j][::-1]  # Reverse segment i to j\n        new_solution[j:k] = selected_solution[j:k][::-1]  # Reverse segment j to k\n    else:\n        # 2-opt local search: swap two edges\n        n = len(selected_solution)\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution = selected_solution.copy()\n        new_solution[i:j] = selected_solution[i:j][::-1]  # Reverse segment i to j\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 156,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the lowest sum of objectives for diversity\n    selected_idx = np.argmin([sum(obj) for (sol, obj) in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments to swap (2-opt)\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    k, l = sorted(np.random.choice(n, size=2, replace=False))\n\n    # Ensure the swap is valid and improves at least one objective\n    def is_valid_and_improving(sol):\n        # Check for validity (no duplicates)\n        if len(np.unique(sol)) != n:\n            return False\n\n        # Calculate new objectives\n        obj1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n        obj2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n        obj3 = sum(distance_matrix_3[sol[i], sol[(i+1)%n]] for i in range(n))\n\n        # Check if at least one objective improves\n        original_obj = archive[selected_idx][1]\n        return (obj1 < original_obj[0]) or (obj2 < original_obj[1]) or (obj3 < original_obj[2])\n\n    # Try different swaps until a valid and improving solution is found\n    max_attempts = 10\n    for _ in range(max_attempts):\n        # Perform 2-opt swap\n        new_solution = np.concatenate([base_solution[:i], base_solution[j:k+1][::-1], base_solution[l:]])\n\n        if is_valid_and_improving(new_solution):\n            return new_solution\n\n    # If no improving solution found, return a slightly perturbed version\n    new_solution = base_solution.copy()\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7164316229490066,
            1.6701871514320374
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the lowest sum of objectives for diversity\n    selected_idx = np.argmin([sum(obj) for (sol, obj) in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments to swap (2-opt)\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    k, l = sorted(np.random.choice(n, size=2, replace=False))\n\n    # Ensure the swap is valid and improves at least one objective\n    def is_valid_and_improving(sol):\n        # Check for validity (no duplicates)\n        if len(np.unique(sol)) != n:\n            return False\n\n        # Calculate new objectives\n        obj1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n        obj2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n        obj3 = sum(distance_matrix_3[sol[i], sol[(i+1)%n]] for i in range(n))\n\n        # Check if at least one objective improves\n        original_obj = archive[selected_idx][1]\n        return (obj1 < original_obj[0]) or (obj2 < original_obj[1]) or (obj3 < original_obj[2])\n\n    # Try different swaps until a valid and improving solution is found\n    max_attempts = 10\n    for _ in range(max_attempts):\n        # Perform 2-opt swap\n        new_solution = np.concatenate([base_solution[:i], base_solution[j:k+1][::-1], base_solution[l:]])\n\n        if is_valid_and_improving(new_solution):\n            return new_solution\n\n    # If no improving solution found, return a slightly perturbed version\n    new_solution = base_solution.copy()\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 157,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: combine 2-opt with a novel multi-objective edge swap\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct edges to swap\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Ensure the swap maintains a valid tour\n    if i != j and k != l:\n        # Perform a multi-objective edge swap: choose the best swap among the three objectives\n        original_costs = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        )\n\n        swapped_costs = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]],\n            distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]],\n            distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]]\n        )\n\n        # Choose the swap that improves the most in at least one objective\n        if any(swapped_costs[obj] < original_costs[obj] for obj in range(3)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7305765657928157,
            1.2373106241226197
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: combine 2-opt with a novel multi-objective edge swap\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct edges to swap\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Ensure the swap maintains a valid tour\n    if i != j and k != l:\n        # Perform a multi-objective edge swap: choose the best swap among the three objectives\n        original_costs = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        )\n\n        swapped_costs = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]],\n            distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]],\n            distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]]\n        )\n\n        # Choose the swap that improves the most in at least one objective\n        if any(swapped_costs[obj] < original_costs[obj] for obj in range(3)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 158,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution, selected_objective = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: apply multiple operators based on objective diversity\n    n = len(new_solution)\n\n    # 1. Edge exchange with objective-aware selection\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        if i < n-1 and j < n-1:\n            # Calculate potential improvement across all objectives\n            old_edges = [\n                (distance_matrix_1[new_solution[i-1], new_solution[i]],\n                 distance_matrix_2[new_solution[i-1], new_solution[i]],\n                 distance_matrix_3[new_solution[i-1], new_solution[i]]),\n                (distance_matrix_1[new_solution[j], new_solution[j+1]],\n                 distance_matrix_2[new_solution[j], new_solution[j+1]],\n                 distance_matrix_3[new_solution[j], new_solution[j+1]])\n            ]\n            new_edges = [\n                (distance_matrix_1[new_solution[i-1], new_solution[j]],\n                 distance_matrix_2[new_solution[i-1], new_solution[j]],\n                 distance_matrix_3[new_solution[i-1], new_solution[j]]),\n                (distance_matrix_1[new_solution[i], new_solution[j+1]],\n                 distance_matrix_2[new_solution[i], new_solution[j+1]],\n                 distance_matrix_3[new_solution[i], new_solution[j+1]])\n            ]\n\n            # Accept if at least one objective improves\n            if any(new < old for new, old in zip(new_edges[0], old_edges[0])) or \\\n               any(new < old for new, old in zip(new_edges[1], old_edges[1])):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # 2. 2-opt with objective-aware segment selection\n    if n > 4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        if a < b:\n            # Calculate potential improvement\n            old_costs = [\n                distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                distance_matrix_3[new_solution[b], new_solution[(b+1)%n]]\n            ]\n            new_costs = [\n                distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                distance_matrix_1[new_solution[a], new_solution[(b+1)%n]],\n                distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                distance_matrix_2[new_solution[a], new_solution[(b+1)%n]],\n                distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                distance_matrix_3[new_solution[a], new_solution[(b+1)%n]]\n            ]\n\n            # Accept if at least one objective improves\n            if any(new < old for new, old in zip(new_costs, old_costs)):\n                new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # 3. Objective-aware segment reversal\n    if n > 5:\n        k = random.randint(3, min(8, n//2))\n        start = random.randint(0, n - k)\n        segment = new_solution[start:start+k]\n\n        # Calculate original and reversed segment costs\n        orig_costs = [\n            sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment))),\n            sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment))),\n            sum(distance_matrix_3[segment[i-1], segment[i]] for i in range(len(segment)))\n        ]\n        reversed_costs = [\n            sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)-1, -1, -1)),\n            sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)-1, -1, -1)),\n            sum(distance_matrix_3[segment[i-1], segment[i]] for i in range(len(segment)-1, -1, -1))\n        ]\n\n        # Accept if at least one objective improves\n        if any(new < old for new, old in zip(reversed_costs, orig_costs)):\n            new_solution[start:start+k] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7933782788458023,
            1.6261154651641845
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution, selected_objective = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: apply multiple operators based on objective diversity\n    n = len(new_solution)\n\n    # 1. Edge exchange with objective-aware selection\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        if i < n-1 and j < n-1:\n            # Calculate potential improvement across all objectives\n            old_edges = [\n                (distance_matrix_1[new_solution[i-1], new_solution[i]],\n                 distance_matrix_2[new_solution[i-1], new_solution[i]],\n                 distance_matrix_3[new_solution[i-1], new_solution[i]]),\n                (distance_matrix_1[new_solution[j], new_solution[j+1]],\n                 distance_matrix_2[new_solution[j], new_solution[j+1]],\n                 distance_matrix_3[new_solution[j], new_solution[j+1]])\n            ]\n            new_edges = [\n                (distance_matrix_1[new_solution[i-1], new_solution[j]],\n                 distance_matrix_2[new_solution[i-1], new_solution[j]],\n                 distance_matrix_3[new_solution[i-1], new_solution[j]]),\n                (distance_matrix_1[new_solution[i], new_solution[j+1]],\n                 distance_matrix_2[new_solution[i], new_solution[j+1]],\n                 distance_matrix_3[new_solution[i], new_solution[j+1]])\n            ]\n\n            # Accept if at least one objective improves\n            if any(new < old for new, old in zip(new_edges[0], old_edges[0])) or \\\n               any(new < old for new, old in zip(new_edges[1], old_edges[1])):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # 2. 2-opt with objective-aware segment selection\n    if n > 4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        if a < b:\n            # Calculate potential improvement\n            old_costs = [\n                distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                distance_matrix_3[new_solution[b], new_solution[(b+1)%n]]\n            ]\n            new_costs = [\n                distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                distance_matrix_1[new_solution[a], new_solution[(b+1)%n]],\n                distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                distance_matrix_2[new_solution[a], new_solution[(b+1)%n]],\n                distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                distance_matrix_3[new_solution[a], new_solution[(b+1)%n]]\n            ]\n\n            # Accept if at least one objective improves\n            if any(new < old for new, old in zip(new_costs, old_costs)):\n                new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # 3. Objective-aware segment reversal\n    if n > 5:\n        k = random.randint(3, min(8, n//2))\n        start = random.randint(0, n - k)\n        segment = new_solution[start:start+k]\n\n        # Calculate original and reversed segment costs\n        orig_costs = [\n            sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment))),\n            sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment))),\n            sum(distance_matrix_3[segment[i-1], segment[i]] for i in range(len(segment)))\n        ]\n        reversed_costs = [\n            sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)-1, -1, -1)),\n            sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)-1, -1, -1)),\n            sum(distance_matrix_3[segment[i-1], segment[i]] for i in range(len(segment)-1, -1, -1))\n        ]\n\n        # Accept if at least one objective improves\n        if any(new < old for new, old in zip(reversed_costs, orig_costs)):\n            new_solution[start:start+k] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 159,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its potential for improvement across multiple objectives, then applies a hybrid local search operator that combines edge exchange and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly choose between edge exchange and segment reversal\n    if random.random() < 0.5:\n        # Edge exchange: swap two random edges\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = random.randint(0, n - 1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal: reverse a random segment\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7595768422895505,
            1.3516885876655578
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly choose between edge exchange and segment reversal\n    if random.random() < 0.5:\n        # Edge exchange: swap two random edges\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = random.randint(0, n - 1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal: reverse a random segment\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 160,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    # Reverse the segment to create a 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Evaluate the new solution's objectives\n    def calculate_objective(solution):\n        obj1 = sum(distance_matrix_1[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        obj2 = sum(distance_matrix_2[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        obj3 = sum(distance_matrix_3[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_3[solution[-1], solution[0]]\n        return (obj1, obj2, obj3)\n\n    current_obj = calculate_objective(base_solution)\n    new_obj = calculate_objective(new_solution)\n\n    # If the new solution is not dominated by the current one, accept it\n    if not (new_obj[0] > current_obj[0] and new_obj[1] > current_obj[1] and new_obj[2] > current_obj[2]):\n        return new_solution\n    else:\n        return base_solution\n\n",
        "score": [
            -0.7003808738301235,
            1.402996051311493
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    # Reverse the segment to create a 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Evaluate the new solution's objectives\n    def calculate_objective(solution):\n        obj1 = sum(distance_matrix_1[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        obj2 = sum(distance_matrix_2[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        obj3 = sum(distance_matrix_3[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_3[solution[-1], solution[0]]\n        return (obj1, obj2, obj3)\n\n    current_obj = calculate_objective(base_solution)\n    new_obj = calculate_objective(new_solution)\n\n    # If the new solution is not dominated by the current one, accept it\n    if not (new_obj[0] > current_obj[0] and new_obj[1] > current_obj[1] and new_obj[2] > current_obj[2]):\n        return new_solution\n    else:\n        return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 161,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.mean(axis=0)) / objectives.std(axis=0)\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 3-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges for 3-opt\n    edges = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted(edges)\n\n    # Perform 3-opt move: reverse the segment between i and j, then between j and k\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    new_solution[j:k+1] = np.flip(new_solution[j:k+1])\n\n    # Ensure the solution remains feasible (no revisits or skips)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7067317432390413,
            2.0172476291656496
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.mean(axis=0)) / objectives.std(axis=0)\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 3-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges for 3-opt\n    edges = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted(edges)\n\n    # Perform 3-opt move: reverse the segment between i and j, then between j and k\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    new_solution[j:k+1] = np.flip(new_solution[j:k+1])\n\n    # Ensure the solution remains feasible (no revisits or skips)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 162,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with objective-aware edge selection\n    n = len(base_solution)\n    best_improvement = 0\n    best_i, best_j = 0, 0\n\n    # Evaluate edges based on their contribution to all three objectives\n    for i in range(n):\n        for j in range(i + 2, n):\n            # Current edges\n            a, b = base_solution[i], base_solution[i+1]\n            c, d = base_solution[j], base_solution[j+1] if j+1 < n else base_solution[0]\n\n            # Proposed edges\n            new_a, new_b = a, c\n            new_c, new_d = b, d\n\n            # Calculate improvement across all objectives\n            improvement = (\n                (distance_matrix_1[a, b] + distance_matrix_1[c, d]) -\n                (distance_matrix_1[new_a, new_b] + distance_matrix_1[new_c, new_d]) +\n                (distance_matrix_2[a, b] + distance_matrix_2[c, d]) -\n                (distance_matrix_2[new_a, new_b] + distance_matrix_2[new_c, new_d]) +\n                (distance_matrix_3[a, b] + distance_matrix_3[c, d]) -\n                (distance_matrix_3[new_a, new_b] + distance_matrix_3[new_c, new_d])\n            )\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_i, best_j = i, j\n\n    if best_improvement > 0:\n        # Apply the 2-opt move\n        new_solution[best_i+1:best_j+1] = np.flip(base_solution[best_i+1:best_j+1])\n\n    # If no improvement, perform a random 2-opt move to escape local optima\n    else:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i+1:j+1] = np.flip(base_solution[i+1:j+1])\n\n    return new_solution\n\n",
        "score": [
            -0.6596205447590309,
            3.812709188461304
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with objective-aware edge selection\n    n = len(base_solution)\n    best_improvement = 0\n    best_i, best_j = 0, 0\n\n    # Evaluate edges based on their contribution to all three objectives\n    for i in range(n):\n        for j in range(i + 2, n):\n            # Current edges\n            a, b = base_solution[i], base_solution[i+1]\n            c, d = base_solution[j], base_solution[j+1] if j+1 < n else base_solution[0]\n\n            # Proposed edges\n            new_a, new_b = a, c\n            new_c, new_d = b, d\n\n            # Calculate improvement across all objectives\n            improvement = (\n                (distance_matrix_1[a, b] + distance_matrix_1[c, d]) -\n                (distance_matrix_1[new_a, new_b] + distance_matrix_1[new_c, new_d]) +\n                (distance_matrix_2[a, b] + distance_matrix_2[c, d]) -\n                (distance_matrix_2[new_a, new_b] + distance_matrix_2[new_c, new_d]) +\n                (distance_matrix_3[a, b] + distance_matrix_3[c, d]) -\n                (distance_matrix_3[new_a, new_b] + distance_matrix_3[new_c, new_d])\n            )\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_i, best_j = i, j\n\n    if best_improvement > 0:\n        # Apply the 2-opt move\n        new_solution[best_i+1:best_j+1] = np.flip(base_solution[best_i+1:best_j+1])\n\n    # If no improvement, perform a random 2-opt move to escape local optima\n    else:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i+1:j+1] = np.flip(base_solution[i+1:j+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 163,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = ranked_solutions[0][0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Determine which objective to prioritize for the swap\n    obj_weights = [1.0, 1.0, 1.0]  # Equal weights for simplicity\n    obj_values = [archive[0][1][0], archive[0][1][1], archive[0][1][2]]\n\n    # Calculate edge costs for the selected segment\n    edges = []\n    for k in range(i, j):\n        edge_cost = (obj_weights[0] * distance_matrix_1[new_solution[k], new_solution[k+1]] +\n                     obj_weights[1] * distance_matrix_2[new_solution[k], new_solution[k+1]] +\n                     obj_weights[2] * distance_matrix_3[new_solution[k], new_solution[k+1]])\n        edges.append((k, k+1, edge_cost))\n\n    # Sort edges by cost and select the worst one to flip\n    edges.sort(key=lambda x: -x[2])\n    if edges:\n        flip_start, flip_end, _ = edges[0]\n        new_solution[flip_start:flip_end+1] = new_solution[flip_start:flip_end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.589021407089376,
            2.971000409126282
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = ranked_solutions[0][0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Determine which objective to prioritize for the swap\n    obj_weights = [1.0, 1.0, 1.0]  # Equal weights for simplicity\n    obj_values = [archive[0][1][0], archive[0][1][1], archive[0][1][2]]\n\n    # Calculate edge costs for the selected segment\n    edges = []\n    for k in range(i, j):\n        edge_cost = (obj_weights[0] * distance_matrix_1[new_solution[k], new_solution[k+1]] +\n                     obj_weights[1] * distance_matrix_2[new_solution[k], new_solution[k+1]] +\n                     obj_weights[2] * distance_matrix_3[new_solution[k], new_solution[k+1]])\n        edges.append((k, k+1, edge_cost))\n\n    # Sort edges by cost and select the worst one to flip\n    edges.sort(key=lambda x: -x[2])\n    if edges:\n        flip_start, flip_end, _ = edges[0]\n        new_solution[flip_start:flip_end+1] = new_solution[flip_start:flip_end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 164,
        "algorithm": "{The heuristic selects a solution from the archive with the highest potential for improvement by evaluating the diversity of its objectives and applies a hybrid local search combining 2-opt and edge exchange to generate neighbors, ensuring feasibility while optimizing across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with diverse objectives)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: 2-opt with edge exchange\n    n = len(base_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Perform 2-opt\n    new_solution[i:j+1] = base_solution[i:j+1][::-1]\n\n    # Perform edge exchange (swap two edges)\n    if k != i and l != j:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if infeasible\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7716642960497371,
            1.1873181104660033
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with diverse objectives)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: 2-opt with edge exchange\n    n = len(base_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Perform 2-opt\n    new_solution[i:j+1] = base_solution[i:j+1][::-1]\n\n    # Perform edge exchange (swap two edges)\n    if k != i and l != j:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if infeasible\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 165,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # We use a combination of 2-opt and node insertion to explore the search space effectively\n    new_solution = base_solution.copy()\n\n    # Randomly select two distinct positions to perform 2-opt\n    i, j = np.random.choice(len(new_solution), size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Perform 2-opt\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select a node to reinsert elsewhere\n    k = np.random.randint(len(new_solution))\n    node = new_solution[k]\n\n    # Remove the node and insert it at a random position\n    new_solution = np.delete(new_solution, k)\n    pos = np.random.randint(len(new_solution) + 1)\n    new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.685614293964085,
            1.4499079704284668
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # We use a combination of 2-opt and node insertion to explore the search space effectively\n    new_solution = base_solution.copy()\n\n    # Randomly select two distinct positions to perform 2-opt\n    i, j = np.random.choice(len(new_solution), size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Perform 2-opt\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select a node to reinsert elsewhere\n    k = np.random.randint(len(new_solution))\n    node = new_solution[k]\n\n    # Remove the node and insert it at a random position\n    new_solution = np.delete(new_solution, k)\n    pos = np.random.randint(len(new_solution) + 1)\n    new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 166,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1] + x[1][2]) / 3)  # Select solution with highest average objective value\n    base_solution = selected_solution[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 1. Edge exchange followed by 2. Objective-aware node insertion\n    n = len(base_solution)\n\n    # Step 1: Edge exchange (2-opt) with objective-aware selection\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    if (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[i], base_solution[j+1]] +\n        distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[i], base_solution[j+1]] +\n        distance_matrix_3[base_solution[i-1], base_solution[j]] + distance_matrix_3[base_solution[i], base_solution[j+1]]) < (\n        distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[j], base_solution[j+1]] +\n        distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[j], base_solution[j+1]] +\n        distance_matrix_3[base_solution[i-1], base_solution[i]] + distance_matrix_3[base_solution[j], base_solution[j+1]]):\n        new_solution[i:j+1] = base_solution[j:i-1:-1]  # Apply edge exchange\n\n    # Step 2: Objective-aware node insertion\n    node_to_move = random.choice(base_solution)\n    pos = random.randint(0, n-1)\n    if pos != 0 and pos != n-1:\n        # Calculate improvement potential across all objectives\n        old_cost = (distance_matrix_1[base_solution[pos-1], base_solution[pos]] +\n                    distance_matrix_2[base_solution[pos-1], base_solution[pos]] +\n                    distance_matrix_3[base_solution[pos-1], base_solution[pos]])\n        new_cost = (distance_matrix_1[base_solution[pos-1], node_to_move] +\n                    distance_matrix_2[base_solution[pos-1], node_to_move] +\n                    distance_matrix_3[base_solution[pos-1], node_to_move])\n        if new_cost < old_cost:\n            # Remove node and insert at new position\n            new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n            new_solution = np.insert(new_solution, pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.6721836313802977,
            1.536667251586914
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1] + x[1][2]) / 3)  # Select solution with highest average objective value\n    base_solution = selected_solution[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 1. Edge exchange followed by 2. Objective-aware node insertion\n    n = len(base_solution)\n\n    # Step 1: Edge exchange (2-opt) with objective-aware selection\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    if (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[i], base_solution[j+1]] +\n        distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[i], base_solution[j+1]] +\n        distance_matrix_3[base_solution[i-1], base_solution[j]] + distance_matrix_3[base_solution[i], base_solution[j+1]]) < (\n        distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[j], base_solution[j+1]] +\n        distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[j], base_solution[j+1]] +\n        distance_matrix_3[base_solution[i-1], base_solution[i]] + distance_matrix_3[base_solution[j], base_solution[j+1]]):\n        new_solution[i:j+1] = base_solution[j:i-1:-1]  # Apply edge exchange\n\n    # Step 2: Objective-aware node insertion\n    node_to_move = random.choice(base_solution)\n    pos = random.randint(0, n-1)\n    if pos != 0 and pos != n-1:\n        # Calculate improvement potential across all objectives\n        old_cost = (distance_matrix_1[base_solution[pos-1], base_solution[pos]] +\n                    distance_matrix_2[base_solution[pos-1], base_solution[pos]] +\n                    distance_matrix_3[base_solution[pos-1], base_solution[pos]])\n        new_cost = (distance_matrix_1[base_solution[pos-1], node_to_move] +\n                    distance_matrix_2[base_solution[pos-1], node_to_move] +\n                    distance_matrix_3[base_solution[pos-1], node_to_move])\n        if new_cost < old_cost:\n            # Remove node and insert at new position\n            new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n            new_solution = np.insert(new_solution, pos, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 167,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    normalized_obj = np.array(objectives)\n    if len(normalized_obj) > 0:\n        normalized_obj = (normalized_obj - np.min(normalized_obj, axis=0)) / (np.max(normalized_obj, axis=0) - np.min(normalized_obj, axis=0) + 1e-10)\n        sum_obj = np.sum(normalized_obj, axis=1)\n        selected_idx = np.argmax(sum_obj)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select segments of the tour and apply a combination of 2-opt and 3-opt moves\n    a, b = sorted(np.random.choice(range(n), 2, replace=False))\n    c, d = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform 2-opt on segment [a, b]\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Perform 3-opt on segment [c, d]\n    if d - c >= 2:\n        segment = new_solution[c:d+1]\n        segment = np.concatenate([segment[:1], segment[2:], segment[1:2]])\n        new_solution[c:d+1] = segment\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.unique(new_solution), np.arange(n)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5482948084828775,
            1.80255047082901
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    normalized_obj = np.array(objectives)\n    if len(normalized_obj) > 0:\n        normalized_obj = (normalized_obj - np.min(normalized_obj, axis=0)) / (np.max(normalized_obj, axis=0) - np.min(normalized_obj, axis=0) + 1e-10)\n        sum_obj = np.sum(normalized_obj, axis=1)\n        selected_idx = np.argmax(sum_obj)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select segments of the tour and apply a combination of 2-opt and 3-opt moves\n    a, b = sorted(np.random.choice(range(n), 2, replace=False))\n    c, d = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform 2-opt on segment [a, b]\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Perform 3-opt on segment [c, d]\n    if d - c >= 2:\n        segment = new_solution[c:d+1]\n        segment = np.concatenate([segment[:1], segment[2:], segment[1:2]])\n        new_solution[c:d+1] = segment\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.unique(new_solution), np.arange(n)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 168,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware swaps\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct positions to swap\n    i, j = np.random.choice(n, size=2, replace=False)\n\n    # Perform the swap\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid (no revisits or skips)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7138924128042289,
            1.5081317901611329
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware swaps\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct positions to swap\n    i, j = np.random.choice(n, size=2, replace=False)\n\n    # Perform the swap\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid (no revisits or skips)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 169,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search operator: 3-opt with objective-aware edge selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to break\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Generate all possible reconnections (3-opt)\n    candidates = []\n    for a in [i, i+1]:\n        for b in [j, j+1]:\n            for c in [k, k+1]:\n                if a % n != b % n and b % n != c % n and c % n != a % n:\n                    # Create new tour by reconnecting edges\n                    tour = np.concatenate([\n                        new_solution[:a%n],\n                        new_solution[b%n:c%n],\n                        new_solution[j%n:k%n],\n                        new_solution[a%n:b%n],\n                        new_solution[c%n:]\n                    ])\n                    candidates.append(tour)\n\n    # Evaluate candidates based on all three objectives\n    best_candidate = None\n    best_score = float('inf')\n\n    for candidate in candidates:\n        # Calculate total tour length across all three objectives\n        total_length = 0\n        for m in range(n):\n            u = candidate[m]\n            v = candidate[(m+1)%n]\n            total_length += distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v]\n\n        # Select the candidate with the best combined score\n        if total_length < best_score:\n            best_score = total_length\n            best_candidate = candidate\n\n    return best_candidate if best_candidate is not None else selected_solution\n\n",
        "score": [
            -0.7531578153954399,
            1.0287163496017455
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search operator: 3-opt with objective-aware edge selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to break\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Generate all possible reconnections (3-opt)\n    candidates = []\n    for a in [i, i+1]:\n        for b in [j, j+1]:\n            for c in [k, k+1]:\n                if a % n != b % n and b % n != c % n and c % n != a % n:\n                    # Create new tour by reconnecting edges\n                    tour = np.concatenate([\n                        new_solution[:a%n],\n                        new_solution[b%n:c%n],\n                        new_solution[j%n:k%n],\n                        new_solution[a%n:b%n],\n                        new_solution[c%n:]\n                    ])\n                    candidates.append(tour)\n\n    # Evaluate candidates based on all three objectives\n    best_candidate = None\n    best_score = float('inf')\n\n    for candidate in candidates:\n        # Calculate total tour length across all three objectives\n        total_length = 0\n        for m in range(n):\n            u = candidate[m]\n            v = candidate[(m+1)%n]\n            total_length += distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v]\n\n        # Select the candidate with the best combined score\n        if total_length < best_score:\n            best_score = total_length\n            best_candidate = candidate\n\n    return best_candidate if best_candidate is not None else selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 170,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1] + x[1][2]) / np.std(x[1]))\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # 2-opt swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Edge insertion: move a segment to another position\n    if k < i:\n        new_solution = np.concatenate([new_solution[:k], new_solution[i:j], new_solution[k:i], new_solution[j:]])\n    else:\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j], new_solution[k:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9418684822394685,
            4.279238593578339
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1] + x[1][2]) / np.std(x[1]))\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # 2-opt swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Edge insertion: move a segment to another position\n    if k < i:\n        new_solution = np.concatenate([new_solution[:k], new_solution[i:j], new_solution[k:i], new_solution[j:]])\n    else:\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j], new_solution[k:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 170,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1] + x[1][2]) / np.std(x[1]))\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # 2-opt swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Edge insertion: move a segment to another position\n    if k < i:\n        new_solution = np.concatenate([new_solution[:k], new_solution[i:j], new_solution[k:i], new_solution[j:]])\n    else:\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j], new_solution[k:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9418684822394685,
            4.279238593578339
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1] + x[1][2]) / np.std(x[1]))\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and edge insertion\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # 2-opt swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Edge insertion: move a segment to another position\n    if k < i:\n        new_solution = np.concatenate([new_solution[:k], new_solution[i:j], new_solution[k:i], new_solution[j:]])\n    else:\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j], new_solution[k:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 171,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: combine 2-opt with a novel 3-way edge swap\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly choose two distinct edges and perform 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform a 3-way edge swap to further improve the solution\n    if n >= 4:\n        a, b, c = sorted(random.sample(range(n), 3))\n        new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.5974130868655725,
            1.4456803679466248
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: combine 2-opt with a novel 3-way edge swap\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly choose two distinct edges and perform 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform a 3-way edge swap to further improve the solution\n    if n >= 4:\n        a, b, c = sorted(random.sample(range(n), 3))\n        new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 172,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate objective diversity for each solution\n        objectives = np.array([obj for _, obj in archive])\n        normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0))\n        diversity_scores = np.sum(normalized_objectives, axis=1)\n        selected_idx = np.argmax(diversity_scores)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Objective-aware edge selection: prefer edges that improve multiple objectives\n    obj1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n    obj2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n    obj3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n\n    new_obj1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n    new_obj2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n    new_obj3 = distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j-1]]\n\n    # If the new edges improve at least two objectives, perform the swap\n    if sum([new_obj1 < obj1, new_obj2 < obj2, new_obj3 < obj3]) >= 2:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Additional: try a random 2-opt move if the above condition isn't met\n    else:\n        if np.random.rand() < 0.3:  # 30% chance for random move\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6866089064215111,
            1.8177525997161865
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate objective diversity for each solution\n        objectives = np.array([obj for _, obj in archive])\n        normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0))\n        diversity_scores = np.sum(normalized_objectives, axis=1)\n        selected_idx = np.argmax(diversity_scores)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Objective-aware edge selection: prefer edges that improve multiple objectives\n    obj1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n    obj2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n    obj3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n\n    new_obj1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n    new_obj2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n    new_obj3 = distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j-1]]\n\n    # If the new edges improve at least two objectives, perform the swap\n    if sum([new_obj1 < obj1, new_obj2 < obj2, new_obj3 < obj3]) >= 2:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Additional: try a random 2-opt move if the above condition isn't met\n    else:\n        if np.random.rand() < 0.3:  # 30% chance for random move\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 173,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to break and reconnect\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Ensure the new edges improve at least one objective\n    def edge_cost(a, b, dm):\n        return dm[a, b] + dm[b, a]\n\n    current_cost1 = edge_cost(new_solution[i], new_solution[j], distance_matrix_1) + edge_cost(new_solution[k], new_solution[l], distance_matrix_1)\n    new_cost1 = edge_cost(new_solution[i], new_solution[k], distance_matrix_1) + edge_cost(new_solution[j], new_solution[l], distance_matrix_1)\n\n    if new_cost1 < current_cost1:\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n        new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n        return new_solution\n\n    # If no improvement in first objective, try second objective\n    current_cost2 = edge_cost(new_solution[i], new_solution[j], distance_matrix_2) + edge_cost(new_solution[k], new_solution[l], distance_matrix_2)\n    new_cost2 = edge_cost(new_solution[i], new_solution[k], distance_matrix_2) + edge_cost(new_solution[j], new_solution[l], distance_matrix_2)\n\n    if new_cost2 < current_cost2:\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n        new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n        return new_solution\n\n    # If no improvement in second objective, try third objective\n    current_cost3 = edge_cost(new_solution[i], new_solution[j], distance_matrix_3) + edge_cost(new_solution[k], new_solution[l], distance_matrix_3)\n    new_cost3 = edge_cost(new_solution[i], new_solution[k], distance_matrix_3) + edge_cost(new_solution[j], new_solution[l], distance_matrix_3)\n\n    if new_cost3 < current_cost3:\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n        new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n        return new_solution\n\n    # If no improvement in any objective, return original solution\n    return base_solution\n\n",
        "score": [
            -0.6772503359183258,
            1.8713265895843505
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to break and reconnect\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Ensure the new edges improve at least one objective\n    def edge_cost(a, b, dm):\n        return dm[a, b] + dm[b, a]\n\n    current_cost1 = edge_cost(new_solution[i], new_solution[j], distance_matrix_1) + edge_cost(new_solution[k], new_solution[l], distance_matrix_1)\n    new_cost1 = edge_cost(new_solution[i], new_solution[k], distance_matrix_1) + edge_cost(new_solution[j], new_solution[l], distance_matrix_1)\n\n    if new_cost1 < current_cost1:\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n        new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n        return new_solution\n\n    # If no improvement in first objective, try second objective\n    current_cost2 = edge_cost(new_solution[i], new_solution[j], distance_matrix_2) + edge_cost(new_solution[k], new_solution[l], distance_matrix_2)\n    new_cost2 = edge_cost(new_solution[i], new_solution[k], distance_matrix_2) + edge_cost(new_solution[j], new_solution[l], distance_matrix_2)\n\n    if new_cost2 < current_cost2:\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n        new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n        return new_solution\n\n    # If no improvement in second objective, try third objective\n    current_cost3 = edge_cost(new_solution[i], new_solution[j], distance_matrix_3) + edge_cost(new_solution[k], new_solution[l], distance_matrix_3)\n    new_cost3 = edge_cost(new_solution[i], new_solution[k], distance_matrix_3) + edge_cost(new_solution[j], new_solution[l], distance_matrix_3)\n\n    if new_cost3 < current_cost3:\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n        new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n        return new_solution\n\n    # If no improvement in any objective, return original solution\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 174,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.array([0.3, 0.3, 0.4])  # Custom weights for the three objectives\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    selected_idx = np.argmin(scores)  # Prefer solutions with lower weighted sum\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search operator\n    for _ in range(3):  # Perform multiple passes for better exploration\n        # Randomly choose between 2-opt, edge swap, or objective-specific move\n        move_type = np.random.choice(['2-opt', 'edge-swap', 'objective-specific'])\n\n        if move_type == '2-opt':\n            # Perform a 2-opt move: reverse a segment of the tour\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        elif move_type == 'edge-swap':\n            # Swap two edges: select two non-adjacent nodes and swap their positions\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            if i + 1 == j:  # Ensure they are not adjacent\n                i = (i - 1) % n\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        elif move_type == 'objective-specific':\n            # Perturb the solution based on the objective with the worst relative improvement\n            obj = archive[selected_idx][1]\n            worst_obj_idx = np.argmax(obj)  # Identify the worst objective\n            if worst_obj_idx == 0:\n                # Optimize for the first objective: swap nodes to reduce distance in space 1\n                i, j = np.random.choice(n, 2, replace=False)\n                if distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] < distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[(j+1)%n]]:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            elif worst_obj_idx == 1:\n                # Optimize for the second objective: swap nodes to reduce distance in space 2\n                i, j = np.random.choice(n, 2, replace=False)\n                if distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] < distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[(j+1)%n]]:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                # Optimize for the third objective: swap nodes to reduce distance in space 3\n                i, j = np.random.choice(n, 2, replace=False)\n                if distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] < distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[(j+1)%n]]:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7457820272091521,
            2.2192840695381166
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.array([0.3, 0.3, 0.4])  # Custom weights for the three objectives\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    selected_idx = np.argmin(scores)  # Prefer solutions with lower weighted sum\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search operator\n    for _ in range(3):  # Perform multiple passes for better exploration\n        # Randomly choose between 2-opt, edge swap, or objective-specific move\n        move_type = np.random.choice(['2-opt', 'edge-swap', 'objective-specific'])\n\n        if move_type == '2-opt':\n            # Perform a 2-opt move: reverse a segment of the tour\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        elif move_type == 'edge-swap':\n            # Swap two edges: select two non-adjacent nodes and swap their positions\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            if i + 1 == j:  # Ensure they are not adjacent\n                i = (i - 1) % n\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        elif move_type == 'objective-specific':\n            # Perturb the solution based on the objective with the worst relative improvement\n            obj = archive[selected_idx][1]\n            worst_obj_idx = np.argmax(obj)  # Identify the worst objective\n            if worst_obj_idx == 0:\n                # Optimize for the first objective: swap nodes to reduce distance in space 1\n                i, j = np.random.choice(n, 2, replace=False)\n                if distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] < distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[(j+1)%n]]:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            elif worst_obj_idx == 1:\n                # Optimize for the second objective: swap nodes to reduce distance in space 2\n                i, j = np.random.choice(n, 2, replace=False)\n                if distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] < distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[(j+1)%n]]:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                # Optimize for the third objective: swap nodes to reduce distance in space 3\n                i, j = np.random.choice(n, 2, replace=False)\n                if distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] < distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[(j+1)%n]]:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 175,
        "algorithm": "{This heuristic function intelligently selects a promising solution from the archive based on objective diversity and applies a hybrid 3-objective-aware local search operator that combines edge swaps with objective-specific path reordering to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the top 30% to balance exploration and exploitation\n        candidate_solutions = sorted_archive[:max(1, len(archive) // 3)]\n        # Randomly select one of the candidate solutions\n        selected_idx = np.random.randint(0, len(candidate_solutions))\n        base_solution = candidate_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random edges\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger tours, apply a combination of operations\n        operation = np.random.choice(['swap', 'reinsert', 'reverse', 'objective_specific_swap'])\n\n        if operation == 'swap':\n            # Random edge swap\n            i, j = np.random.choice(n, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        elif operation == 'reinsert':\n            # Reinsert a segment\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], segment])\n\n        elif operation == 'reverse':\n            # Reverse a segment\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        elif operation == 'objective_specific_swap':\n            # Objective-specific edge swap\n            # Calculate the difference in objectives between the current and neighbor solutions\n            def get_objective_diff(sol, obj_idx):\n                if obj_idx == 0:\n                    dm = distance_matrix_1\n                elif obj_idx == 1:\n                    dm = distance_matrix_2\n                else:\n                    dm = distance_matrix_3\n\n                total = 0\n                for i in range(len(sol)):\n                    u = sol[i]\n                    v = sol[(i+1)%len(sol)]\n                    total += dm[u, v]\n                return total\n\n            # Try multiple swaps and keep the one that improves at least one objective\n            best_sol = new_solution.copy()\n            best_improvement = 0\n\n            for _ in range(5):  # Try 5 random swaps\n                temp_sol = new_solution.copy()\n                i, j = np.random.choice(n, 2, replace=False)\n                temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n\n                # Calculate improvement for each objective\n                improvements = []\n                for obj_idx in range(3):\n                    current_obj = get_objective_diff(new_solution, obj_idx)\n                    new_obj = get_objective_diff(temp_sol, obj_idx)\n                    improvements.append(current_obj - new_obj)\n\n                # Check if at least one objective improved\n                if any(imp > 0 for imp in improvements):\n                    total_improvement = sum(imp for imp in improvements if imp > 0)\n                    if total_improvement > best_improvement:\n                        best_improvement = total_improvement\n                        best_sol = temp_sol.copy()\n\n            new_solution = best_sol\n\n    return new_solution\n\n",
        "score": [
            -0.7244712674800496,
            2.3599196553230284
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the top 30% to balance exploration and exploitation\n        candidate_solutions = sorted_archive[:max(1, len(archive) // 3)]\n        # Randomly select one of the candidate solutions\n        selected_idx = np.random.randint(0, len(candidate_solutions))\n        base_solution = candidate_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random edges\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger tours, apply a combination of operations\n        operation = np.random.choice(['swap', 'reinsert', 'reverse', 'objective_specific_swap'])\n\n        if operation == 'swap':\n            # Random edge swap\n            i, j = np.random.choice(n, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        elif operation == 'reinsert':\n            # Reinsert a segment\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], segment])\n\n        elif operation == 'reverse':\n            # Reverse a segment\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        elif operation == 'objective_specific_swap':\n            # Objective-specific edge swap\n            # Calculate the difference in objectives between the current and neighbor solutions\n            def get_objective_diff(sol, obj_idx):\n                if obj_idx == 0:\n                    dm = distance_matrix_1\n                elif obj_idx == 1:\n                    dm = distance_matrix_2\n                else:\n                    dm = distance_matrix_3\n\n                total = 0\n                for i in range(len(sol)):\n                    u = sol[i]\n                    v = sol[(i+1)%len(sol)]\n                    total += dm[u, v]\n                return total\n\n            # Try multiple swaps and keep the one that improves at least one objective\n            best_sol = new_solution.copy()\n            best_improvement = 0\n\n            for _ in range(5):  # Try 5 random swaps\n                temp_sol = new_solution.copy()\n                i, j = np.random.choice(n, 2, replace=False)\n                temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n\n                # Calculate improvement for each objective\n                improvements = []\n                for obj_idx in range(3):\n                    current_obj = get_objective_diff(new_solution, obj_idx)\n                    new_obj = get_objective_diff(temp_sol, obj_idx)\n                    improvements.append(current_obj - new_obj)\n\n                # Check if at least one objective improved\n                if any(imp > 0 for imp in improvements):\n                    total_improvement = sum(imp for imp in improvements if imp > 0)\n                    if total_improvement > best_improvement:\n                        best_improvement = total_improvement\n                        best_sol = temp_sol.copy()\n\n            new_solution = best_sol\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 176,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 2-opt with a custom multi-objective operator\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct positions to perturb\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt to improve the tour\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply a custom multi-objective operator: swap nodes that are close in one space but far in others\n    for _ in range(3):  # Perform 3 random swaps\n        k, l = random.sample(range(n), 2)\n        node_k, node_l = new_solution[k], new_solution[l]\n\n        # Calculate distances in all three spaces\n        dist1 = distance_matrix_1[node_k, node_l]\n        dist2 = distance_matrix_2[node_k, node_l]\n        dist3 = distance_matrix_3[node_k, node_l]\n\n        # If nodes are close in one space but far in others, swap them\n        if (dist1 < 10 and (dist2 > 20 or dist3 > 20)) or \\\n           (dist2 < 10 and (dist1 > 20 or dist3 > 20)) or \\\n           (dist3 < 10 and (dist1 > 20 or dist2 > 20)):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.6530540984976964,
            1.2412768840789794
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 2-opt with a custom multi-objective operator\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct positions to perturb\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt to improve the tour\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply a custom multi-objective operator: swap nodes that are close in one space but far in others\n    for _ in range(3):  # Perform 3 random swaps\n        k, l = random.sample(range(n), 2)\n        node_k, node_l = new_solution[k], new_solution[l]\n\n        # Calculate distances in all three spaces\n        dist1 = distance_matrix_1[node_k, node_l]\n        dist2 = distance_matrix_2[node_k, node_l]\n        dist3 = distance_matrix_3[node_k, node_l]\n\n        # If nodes are close in one space but far in others, swap them\n        if (dist1 < 10 and (dist2 > 20 or dist3 > 20)) or \\\n           (dist2 < 10 and (dist1 > 20 or dist3 > 20)) or \\\n           (dist3 < 10 and (dist1 > 20 or dist2 > 20)):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 177,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    # Select the top 10% of solutions (or at least 1 if archive is small)\n    top_k = max(1, len(archive) // 10)\n    candidates = archive[:top_k]\n    # Randomly select one candidate\n    base_solution, _ = random.choice(candidates)\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Hybrid operator: 3-opt with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations\n        # Randomly select 3 distinct edges\n        a, b, c = sorted(random.sample(range(n), 3))\n        # Create three possible 3-opt moves\n        moves = [\n            np.concatenate([new_solution[:a], new_solution[b:c+1][::-1], new_solution[a:b], new_solution[c+1:]]),\n            np.concatenate([new_solution[:b], new_solution[a:c+1][::-1], new_solution[b:a], new_solution[c+1:]]),\n            np.concatenate([new_solution[:a], new_solution[c:b-1:-1], new_solution[a:b], new_solution[c+1:]])\n        ]\n        # Evaluate each move across all three objectives\n        move_scores = []\n        for move in moves:\n            cost1 = sum(distance_matrix_1[move[i], move[i+1]] for i in range(n-1)) + distance_matrix_1[move[-1], move[0]]\n            cost2 = sum(distance_matrix_2[move[i], move[i+1]] for i in range(n-1)) + distance_matrix_2[move[-1], move[0]]\n            cost3 = sum(distance_matrix_3[move[i], move[i+1]] for i in range(n-1)) + distance_matrix_3[move[-1], move[0]]\n            # Combine objectives with equal weights (can be adjusted)\n            total_cost = cost1 + cost2 + cost3\n            move_scores.append(total_cost)\n        # Select the best move\n        best_move_idx = np.argmin(move_scores)\n        new_solution = moves[best_move_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7108866669174743,
            4.382891523838043
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    # Select the top 10% of solutions (or at least 1 if archive is small)\n    top_k = max(1, len(archive) // 10)\n    candidates = archive[:top_k]\n    # Randomly select one candidate\n    base_solution, _ = random.choice(candidates)\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Hybrid operator: 3-opt with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations\n        # Randomly select 3 distinct edges\n        a, b, c = sorted(random.sample(range(n), 3))\n        # Create three possible 3-opt moves\n        moves = [\n            np.concatenate([new_solution[:a], new_solution[b:c+1][::-1], new_solution[a:b], new_solution[c+1:]]),\n            np.concatenate([new_solution[:b], new_solution[a:c+1][::-1], new_solution[b:a], new_solution[c+1:]]),\n            np.concatenate([new_solution[:a], new_solution[c:b-1:-1], new_solution[a:b], new_solution[c+1:]])\n        ]\n        # Evaluate each move across all three objectives\n        move_scores = []\n        for move in moves:\n            cost1 = sum(distance_matrix_1[move[i], move[i+1]] for i in range(n-1)) + distance_matrix_1[move[-1], move[0]]\n            cost2 = sum(distance_matrix_2[move[i], move[i+1]] for i in range(n-1)) + distance_matrix_2[move[-1], move[0]]\n            cost3 = sum(distance_matrix_3[move[i], move[i+1]] for i in range(n-1)) + distance_matrix_3[move[-1], move[0]]\n            # Combine objectives with equal weights (can be adjusted)\n            total_cost = cost1 + cost2 + cost3\n            move_scores.append(total_cost)\n        # Select the best move\n        best_move_idx = np.argmin(move_scores)\n        new_solution = moves[best_move_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 178,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))  # Select the solution with the highest total cost\n    base_solution = selected[0].copy()\n\n    # Apply a hybrid local search operator: 3-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Reverse the segment between i and j, then reverse between j and k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    # Verify no node is skipped or revisited\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple 2-opt move\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7203960717617007,
            1.588945698738098
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))  # Select the solution with the highest total cost\n    base_solution = selected[0].copy()\n\n    # Apply a hybrid local search operator: 3-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Reverse the segment between i and j, then reverse between j and k\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    # Verify no node is skipped or revisited\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple 2-opt move\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 179,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: combine 2-opt with objective-aware swaps\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt to improve the tour structure\n    for i in range(n):\n        for j in range(i + 2, n):\n            if j + 1 < n:\n                # Calculate the change in total distance for all three objectives\n                delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                          distance_matrix_1[new_solution[i+1], new_solution[j+1]]) - \\\n                         (distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                          distance_matrix_1[new_solution[j], new_solution[j+1]])\n\n                delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                          distance_matrix_2[new_solution[i+1], new_solution[j+1]]) - \\\n                         (distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                          distance_matrix_2[new_solution[j], new_solution[j+1]])\n\n                delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                          distance_matrix_3[new_solution[i+1], new_solution[j+1]]) - \\\n                         (distance_matrix_3[new_solution[i], new_solution[i+1]] +\n                          distance_matrix_3[new_solution[j], new_solution[j+1]])\n\n                # If any objective improves, perform the swap\n                if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                    new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                    break\n\n    # Perform objective-aware swaps to balance improvements across all three objectives\n    for _ in range(10):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in total distance for all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                  distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                 (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                  distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                  distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                 (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                  distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] +\n                  distance_matrix_3[new_solution[j-1], new_solution[i]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]) - \\\n                 (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                  distance_matrix_3[new_solution[j-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # If any objective improves, perform the swap\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7185302523713929,
            3.15529088973999
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: combine 2-opt with objective-aware swaps\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt to improve the tour structure\n    for i in range(n):\n        for j in range(i + 2, n):\n            if j + 1 < n:\n                # Calculate the change in total distance for all three objectives\n                delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                          distance_matrix_1[new_solution[i+1], new_solution[j+1]]) - \\\n                         (distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                          distance_matrix_1[new_solution[j], new_solution[j+1]])\n\n                delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                          distance_matrix_2[new_solution[i+1], new_solution[j+1]]) - \\\n                         (distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                          distance_matrix_2[new_solution[j], new_solution[j+1]])\n\n                delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                          distance_matrix_3[new_solution[i+1], new_solution[j+1]]) - \\\n                         (distance_matrix_3[new_solution[i], new_solution[i+1]] +\n                          distance_matrix_3[new_solution[j], new_solution[j+1]])\n\n                # If any objective improves, perform the swap\n                if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                    new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                    break\n\n    # Perform objective-aware swaps to balance improvements across all three objectives\n    for _ in range(10):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in total distance for all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                  distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                 (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                  distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                  distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                 (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                  distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] +\n                  distance_matrix_3[new_solution[j-1], new_solution[i]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]) - \\\n                 (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                  distance_matrix_3[new_solution[j-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # If any objective improves, perform the swap\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 180,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([len(np.unique(sol[0:len(sol)//2])) for sol, _ in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid 3-opt local search that considers all three objectives\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to modify\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    i, j, k = new_solution[a], new_solution[b], new_solution[c]\n\n    # Generate all possible 3-opt moves and evaluate them\n    moves = [\n        (i, j, k), (i, k, j), (j, i, k), (j, k, i), (k, i, j), (k, j, i)\n    ]\n\n    best_move = None\n    best_improvement = 0\n\n    for move in moves:\n        # Create a temporary solution\n        temp_sol = new_solution.copy()\n        temp_sol[a:b] = temp_sol[a:b][::-1]  # Reverse segment\n        temp_sol[b:c] = temp_sol[b:c][::-1]  # Reverse segment\n        temp_sol[a:c] = temp_sol[a:c][::-1]  # Reverse entire segment\n\n        # Calculate the total improvement across all three objectives\n        original_cost = (\n            distance_matrix_1[new_solution[a-1], new_solution[a]] +\n            distance_matrix_1[new_solution[b-1], new_solution[b]] +\n            distance_matrix_1[new_solution[c-1], new_solution[c]] +\n            distance_matrix_2[new_solution[a-1], new_solution[a]] +\n            distance_matrix_2[new_solution[b-1], new_solution[b]] +\n            distance_matrix_2[new_solution[c-1], new_solution[c]] +\n            distance_matrix_3[new_solution[a-1], new_solution[a]] +\n            distance_matrix_3[new_solution[b-1], new_solution[b]] +\n            distance_matrix_3[new_solution[c-1], new_solution[c]]\n        )\n\n        new_cost = (\n            distance_matrix_1[temp_sol[a-1], temp_sol[a]] +\n            distance_matrix_1[temp_sol[b-1], temp_sol[b]] +\n            distance_matrix_1[temp_sol[c-1], temp_sol[c]] +\n            distance_matrix_2[temp_sol[a-1], temp_sol[a]] +\n            distance_matrix_2[temp_sol[b-1], temp_sol[b]] +\n            distance_matrix_2[temp_sol[c-1], temp_sol[c]] +\n            distance_matrix_3[temp_sol[a-1], temp_sol[a]] +\n            distance_matrix_3[temp_sol[b-1], temp_sol[b]] +\n            distance_matrix_3[temp_sol[c-1], temp_sol[c]]\n        )\n\n        improvement = original_cost - new_cost\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_move = move\n\n    if best_move is not None:\n        # Apply the best move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n        new_solution[a:c] = new_solution[a:c][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6641223005830065,
            3.9761895656585695
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([len(np.unique(sol[0:len(sol)//2])) for sol, _ in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid 3-opt local search that considers all three objectives\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to modify\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    i, j, k = new_solution[a], new_solution[b], new_solution[c]\n\n    # Generate all possible 3-opt moves and evaluate them\n    moves = [\n        (i, j, k), (i, k, j), (j, i, k), (j, k, i), (k, i, j), (k, j, i)\n    ]\n\n    best_move = None\n    best_improvement = 0\n\n    for move in moves:\n        # Create a temporary solution\n        temp_sol = new_solution.copy()\n        temp_sol[a:b] = temp_sol[a:b][::-1]  # Reverse segment\n        temp_sol[b:c] = temp_sol[b:c][::-1]  # Reverse segment\n        temp_sol[a:c] = temp_sol[a:c][::-1]  # Reverse entire segment\n\n        # Calculate the total improvement across all three objectives\n        original_cost = (\n            distance_matrix_1[new_solution[a-1], new_solution[a]] +\n            distance_matrix_1[new_solution[b-1], new_solution[b]] +\n            distance_matrix_1[new_solution[c-1], new_solution[c]] +\n            distance_matrix_2[new_solution[a-1], new_solution[a]] +\n            distance_matrix_2[new_solution[b-1], new_solution[b]] +\n            distance_matrix_2[new_solution[c-1], new_solution[c]] +\n            distance_matrix_3[new_solution[a-1], new_solution[a]] +\n            distance_matrix_3[new_solution[b-1], new_solution[b]] +\n            distance_matrix_3[new_solution[c-1], new_solution[c]]\n        )\n\n        new_cost = (\n            distance_matrix_1[temp_sol[a-1], temp_sol[a]] +\n            distance_matrix_1[temp_sol[b-1], temp_sol[b]] +\n            distance_matrix_1[temp_sol[c-1], temp_sol[c]] +\n            distance_matrix_2[temp_sol[a-1], temp_sol[a]] +\n            distance_matrix_2[temp_sol[b-1], temp_sol[b]] +\n            distance_matrix_2[temp_sol[c-1], temp_sol[c]] +\n            distance_matrix_3[temp_sol[a-1], temp_sol[a]] +\n            distance_matrix_3[temp_sol[b-1], temp_sol[b]] +\n            distance_matrix_3[temp_sol[c-1], temp_sol[c]]\n        )\n\n        improvement = original_cost - new_cost\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_move = move\n\n    if best_move is not None:\n        # Apply the best move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n        new_solution[a:c] = new_solution[a:c][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 181,
        "algorithm": "{\"This heuristic selects a solution from the archive with high potential for improvement by focusing on solutions with the largest gaps between objectives, then applies a hybrid local search combining 2-opt and objective-specific edge swaps to generate a neighbor solution while ensuring feasibility.\"}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (largest gap between objectives)\n    def gap(obj):\n        return max(obj) - min(obj)\n\n    archive_sorted = sorted(archive, key=lambda x: -gap(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: 2-opt with objective-specific edge swaps\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Reverse the segment (2-opt move)\n    new_solution[i:j+1] = segment[::-1]\n\n    # Apply objective-specific edge swaps\n    for k in range(i, j):\n        # For each objective, find the best swap in the segment\n        for obj_idx, dist_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n            current_cost = dist_matrix[new_solution[k], new_solution[(k+1)%n]] + dist_matrix[new_solution[k-1], new_solution[k]]\n            best_swap = None\n            best_improvement = 0\n\n            # Check possible swaps with nodes in the segment\n            for l in range(k+1, j+1):\n                new_cost = dist_matrix[new_solution[k-1], new_solution[l]] + dist_matrix[new_solution[l], new_solution[k]]\n                improvement = current_cost - new_cost\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = l\n\n            if best_swap is not None:\n                # Perform the swap\n                new_solution[k], new_solution[best_swap] = new_solution[best_swap], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.6510112685892008,
            3.2645850658416746
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (largest gap between objectives)\n    def gap(obj):\n        return max(obj) - min(obj)\n\n    archive_sorted = sorted(archive, key=lambda x: -gap(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: 2-opt with objective-specific edge swaps\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Reverse the segment (2-opt move)\n    new_solution[i:j+1] = segment[::-1]\n\n    # Apply objective-specific edge swaps\n    for k in range(i, j):\n        # For each objective, find the best swap in the segment\n        for obj_idx, dist_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n            current_cost = dist_matrix[new_solution[k], new_solution[(k+1)%n]] + dist_matrix[new_solution[k-1], new_solution[k]]\n            best_swap = None\n            best_improvement = 0\n\n            # Check possible swaps with nodes in the segment\n            for l in range(k+1, j+1):\n                new_cost = dist_matrix[new_solution[k-1], new_solution[l]] + dist_matrix[new_solution[l], new_solution[k]]\n                improvement = current_cost - new_cost\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = l\n\n            if best_swap is not None:\n                # Perform the swap\n                new_solution[k], new_solution[best_swap] = new_solution[best_swap], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 182,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its dominance and diversity, then applies a hybrid local search combining edge-swapping and path-relinking to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most promising solution from the archive\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly choose between edge-swapping and path-relinking\n    if random.random() < 0.5:\n        # Edge-swapping\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Path-relinking\n        # Select two random positions and swap the path between them\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7438515153946554,
            1.350073790550232
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most promising solution from the archive\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly choose between edge-swapping and path-relinking\n    if random.random() < 0.5:\n        # Edge-swapping\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Path-relinking\n        # Select two random positions and swap the path between them\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 183,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: apply a combination of 2-opt and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt to improve the worst-performing objective\n    worst_obj = np.argmax(archive[selected_idx][1])\n    if worst_obj == 0:\n        dm = distance_matrix_1\n    elif worst_obj == 1:\n        dm = distance_matrix_2\n    else:\n        dm = distance_matrix_3\n\n    # Check if 2-opt improves the worst objective\n    current_cost = dm[new_solution[i-1], new_solution[i]] + dm[new_solution[j-1], new_solution[j]]\n    new_cost = dm[new_solution[i-1], new_solution[j]] + dm[new_solution[i], new_solution[j-1]]\n    if new_cost < current_cost:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply node swap to improve the other objectives\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.6938468844257053,
            1.6283869385719298
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: apply a combination of 2-opt and node swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt to improve the worst-performing objective\n    worst_obj = np.argmax(archive[selected_idx][1])\n    if worst_obj == 0:\n        dm = distance_matrix_1\n    elif worst_obj == 1:\n        dm = distance_matrix_2\n    else:\n        dm = distance_matrix_3\n\n    # Check if 2-opt improves the worst objective\n    current_cost = dm[new_solution[i-1], new_solution[i]] + dm[new_solution[j-1], new_solution[j]]\n    new_cost = dm[new_solution[i-1], new_solution[j]] + dm[new_solution[i], new_solution[j-1]]\n    if new_cost < current_cost:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply node swap to improve the other objectives\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 184,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of the three local search operators\n    operator = random.choice(['2opt', 'node_insertion', 'objective_aware_swap'])\n\n    if operator == '2opt':\n        # Perform 2-opt to reduce total path length in one or more objectives\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'node_insertion':\n        # Perform node insertion to potentially improve multiple objectives\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    elif operator == 'objective_aware_swap':\n        # Swap nodes that are critical in at least two objectives\n        i, j = random.sample(range(n), 2)\n        # Check if swapping improves at least two objectives\n        obj1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        obj1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        obj2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        obj2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n        obj3_before = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        obj3_after = distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]]\n\n        improvements = 0\n        if obj1_after < obj1_before:\n            improvements += 1\n        if obj2_after < obj2_before:\n            improvements += 1\n        if obj3_after < obj3_before:\n            improvements += 1\n\n        if improvements >= 2:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7504160703189104,
            1.1727624177932738
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of the three local search operators\n    operator = random.choice(['2opt', 'node_insertion', 'objective_aware_swap'])\n\n    if operator == '2opt':\n        # Perform 2-opt to reduce total path length in one or more objectives\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'node_insertion':\n        # Perform node insertion to potentially improve multiple objectives\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    elif operator == 'objective_aware_swap':\n        # Swap nodes that are critical in at least two objectives\n        i, j = random.sample(range(n), 2)\n        # Check if swapping improves at least two objectives\n        obj1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        obj1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        obj2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        obj2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n        obj3_before = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n        obj3_after = distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]]\n\n        improvements = 0\n        if obj1_after < obj1_before:\n            improvements += 1\n        if obj2_after < obj2_before:\n            improvements += 1\n        if obj3_after < obj3_before:\n            improvements += 1\n\n        if improvements >= 2:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 185,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest potential for improvement (lowest objective values)\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware perturbation\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply objective-aware perturbation: swap nodes that are critical in any objective space\n    for _ in range(2):  # Limit perturbations to maintain feasibility\n        # Identify nodes with high marginal contribution in any objective\n        marginal_contributions = []\n        for k in range(n):\n            # Calculate change in objectives if node k is removed and reinserted\n            before_node = selected_solution[k-1] if k > 0 else selected_solution[-1]\n            after_node = selected_solution[k+1] if k < n-1 else selected_solution[0]\n            cost_change = (\n                distance_matrix_1[before_node, selected_solution[k]] + distance_matrix_1[selected_solution[k], after_node] -\n                distance_matrix_1[before_node, after_node]\n            ) + (\n                distance_matrix_2[before_node, selected_solution[k]] + distance_matrix_2[selected_solution[k], after_node] -\n                distance_matrix_2[before_node, after_node]\n            ) + (\n                distance_matrix_3[before_node, selected_solution[k]] + distance_matrix_3[selected_solution[k], after_node] -\n                distance_matrix_3[before_node, after_node]\n            )\n            marginal_contributions.append(cost_change)\n\n        # Select a node with high marginal contribution and reinsert it\n        if marginal_contributions:\n            worst_node_idx = np.argmax(marginal_contributions)\n            worst_node = new_solution[worst_node_idx]\n            new_solution = np.delete(new_solution, worst_node_idx)\n            # Find the best insertion point\n            best_insertion = 0\n            min_cost = float('inf')\n            for pos in range(len(new_solution)):\n                # Calculate cost of inserting after position pos\n                before = new_solution[pos-1] if pos > 0 else new_solution[-1]\n                after = new_solution[pos] if pos < len(new_solution) else new_solution[0]\n                cost = (\n                    distance_matrix_1[before, worst_node] + distance_matrix_1[worst_node, after] -\n                    distance_matrix_1[before, after]\n                ) + (\n                    distance_matrix_2[before, worst_node] + distance_matrix_2[worst_node, after] -\n                    distance_matrix_2[before, after]\n                ) + (\n                    distance_matrix_3[before, worst_node] + distance_matrix_3[worst_node, after] -\n                    distance_matrix_3[before, after]\n                )\n                if cost < min_cost:\n                    min_cost = cost\n                    best_insertion = pos\n            new_solution = np.insert(new_solution, best_insertion, worst_node)\n\n    return new_solution\n\n",
        "score": [
            -0.6357875474077843,
            2.7266047596931458
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest potential for improvement (lowest objective values)\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware perturbation\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply objective-aware perturbation: swap nodes that are critical in any objective space\n    for _ in range(2):  # Limit perturbations to maintain feasibility\n        # Identify nodes with high marginal contribution in any objective\n        marginal_contributions = []\n        for k in range(n):\n            # Calculate change in objectives if node k is removed and reinserted\n            before_node = selected_solution[k-1] if k > 0 else selected_solution[-1]\n            after_node = selected_solution[k+1] if k < n-1 else selected_solution[0]\n            cost_change = (\n                distance_matrix_1[before_node, selected_solution[k]] + distance_matrix_1[selected_solution[k], after_node] -\n                distance_matrix_1[before_node, after_node]\n            ) + (\n                distance_matrix_2[before_node, selected_solution[k]] + distance_matrix_2[selected_solution[k], after_node] -\n                distance_matrix_2[before_node, after_node]\n            ) + (\n                distance_matrix_3[before_node, selected_solution[k]] + distance_matrix_3[selected_solution[k], after_node] -\n                distance_matrix_3[before_node, after_node]\n            )\n            marginal_contributions.append(cost_change)\n\n        # Select a node with high marginal contribution and reinsert it\n        if marginal_contributions:\n            worst_node_idx = np.argmax(marginal_contributions)\n            worst_node = new_solution[worst_node_idx]\n            new_solution = np.delete(new_solution, worst_node_idx)\n            # Find the best insertion point\n            best_insertion = 0\n            min_cost = float('inf')\n            for pos in range(len(new_solution)):\n                # Calculate cost of inserting after position pos\n                before = new_solution[pos-1] if pos > 0 else new_solution[-1]\n                after = new_solution[pos] if pos < len(new_solution) else new_solution[0]\n                cost = (\n                    distance_matrix_1[before, worst_node] + distance_matrix_1[worst_node, after] -\n                    distance_matrix_1[before, after]\n                ) + (\n                    distance_matrix_2[before, worst_node] + distance_matrix_2[worst_node, after] -\n                    distance_matrix_2[before, after]\n                ) + (\n                    distance_matrix_3[before, worst_node] + distance_matrix_3[worst_node, after] -\n                    distance_matrix_3[before, after]\n                )\n                if cost < min_cost:\n                    min_cost = cost\n                    best_insertion = pos\n            new_solution = np.insert(new_solution, best_insertion, worst_node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 186,
        "algorithm": "{The algorithm selects a solution from the archive with the highest potential for improvement by evaluating the diversity and non-dominated status of solutions, then applies a hybrid local search combining 2-opt and 3-opt moves with adaptive perturbation to optimize across three objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt and 3-opt with adaptive perturbation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with adaptive selection\n    for _ in range(10):\n        i, j = sorted(random.sample(range(n), 2))\n        if random.random() < 0.7:  # Higher probability for 2-opt\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:  # 3-opt perturbation\n            k = random.randint(i, j)\n            # Apply 3-opt move\n            if random.random() < 0.5:\n                new_solution[i:k] = new_solution[i:k][::-1]\n            else:\n                new_solution[k:j] = new_solution[k:j][::-1]\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Recover by repairing the solution\n        missing = set(range(n)) - set(new_solution)\n        duplicates = unique[counts > 1]\n        for dup in duplicates:\n            new_solution[np.where(new_solution == dup)[0][1:]] = next(iter(missing))\n            missing.remove(next(iter(missing)))\n\n    return new_solution\n\n",
        "score": [
            -0.6937139792935924,
            1.349634850025177
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt and 3-opt with adaptive perturbation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with adaptive selection\n    for _ in range(10):\n        i, j = sorted(random.sample(range(n), 2))\n        if random.random() < 0.7:  # Higher probability for 2-opt\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:  # 3-opt perturbation\n            k = random.randint(i, j)\n            # Apply 3-opt move\n            if random.random() < 0.5:\n                new_solution[i:k] = new_solution[i:k][::-1]\n            else:\n                new_solution[k:j] = new_solution[k:j][::-1]\n\n    # Ensure feasibility (no duplicates)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # Recover by repairing the solution\n        missing = set(range(n)) - set(new_solution)\n        duplicates = unique[counts > 1]\n        for dup in duplicates:\n            new_solution[np.where(new_solution == dup)[0][1:]] = next(iter(missing))\n            missing.remove(next(iter(missing)))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 187,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest total improvement potential\n    best_solution = None\n    best_potential = -1\n    for sol, obj in archive:\n        potential = sum(obj)\n        if potential > best_potential:\n            best_potential = potential\n            best_solution = sol.copy()\n\n    if best_solution is None:\n        best_solution = archive[0][0].copy()\n\n    new_solution = best_solution.copy()\n\n    # Hybrid 2-opt and 3-opt local search\n    n = len(new_solution)\n    for _ in range(5):  # Perform multiple iterations for thorough exploration\n        # Randomly select a segment for 2-opt\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Randomly select a segment for 3-opt\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = np.concatenate([segment[:c-a], segment[c-a:][::-1]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != len(new_solution):\n        # If invalid, revert to the original solution\n        new_solution = best_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6445374673711733,
            1.7255342602729797
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest total improvement potential\n    best_solution = None\n    best_potential = -1\n    for sol, obj in archive:\n        potential = sum(obj)\n        if potential > best_potential:\n            best_potential = potential\n            best_solution = sol.copy()\n\n    if best_solution is None:\n        best_solution = archive[0][0].copy()\n\n    new_solution = best_solution.copy()\n\n    # Hybrid 2-opt and 3-opt local search\n    n = len(new_solution)\n    for _ in range(5):  # Perform multiple iterations for thorough exploration\n        # Randomly select a segment for 2-opt\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Randomly select a segment for 3-opt\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = np.concatenate([segment[:c-a], segment[c-a:][::-1]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != len(new_solution):\n        # If invalid, revert to the original solution\n        new_solution = best_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 188,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.dirichlet(np.ones(3))  # Random weights for multi-objective selection\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores)  # Select solution with the best weighted score\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt + node swap with multi-objective consideration\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and node swap\n    if np.random.rand() < 0.5:\n        # 2-opt move: select two edges and reverse the segment between them\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Node swap: select two nodes and swap their positions\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.7066631198145105,
            2.5768802046775816
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.dirichlet(np.ones(3))  # Random weights for multi-objective selection\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores)  # Select solution with the best weighted score\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt + node swap with multi-objective consideration\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and node swap\n    if np.random.rand() < 0.5:\n        # 2-opt move: select two edges and reverse the segment between them\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Node swap: select two nodes and swap their positions\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 189,
        "algorithm": "{This algorithm intelligently selects a high-potential solution from the archive by leveraging a hybrid local search strategy that combines 2-opt moves, random swaps, and objective-aware segment reversals to simultaneously optimize across three objectives, ensuring feasibility and diversity in the generated neighbor solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already locally optimal)\n    selected = archive[np.random.choice(len(archive))][0]\n    new_solution = selected.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    if n < 2:\n        return new_solution\n\n    # Step 1: Randomly select a segment and reverse it (2-opt-like move)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Randomly swap two nodes (exploration)\n    a, b = np.random.choice(n, 2, replace=False)\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Step 3: Objective-aware segment reversal (improve worst objective)\n    def calculate_objective(sol):\n        cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_obj = calculate_objective(new_solution)\n    worst_obj = np.argmax(current_obj)\n\n    # Reverse a segment to improve the worst objective\n    if worst_obj == 0:\n        matrix = distance_matrix_1\n    elif worst_obj == 1:\n        matrix = distance_matrix_2\n    else:\n        matrix = distance_matrix_3\n\n    best_improvement = 0\n    best_i, best_j = 0, 0\n    for i in range(n):\n        for j in range(i+1, n):\n            # Calculate the change in cost if we reverse the segment\n            before = matrix[new_solution[i-1], new_solution[i]] + matrix[new_solution[j], new_solution[(j+1)%n]]\n            after = matrix[new_solution[i-1], new_solution[j]] + matrix[new_solution[i], new_solution[(j+1)%n]]\n            improvement = before - after\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_i, best_j = i, j\n\n    if best_improvement > 0:\n        new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7874283734646154,
            3.3310131072998046
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already locally optimal)\n    selected = archive[np.random.choice(len(archive))][0]\n    new_solution = selected.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    if n < 2:\n        return new_solution\n\n    # Step 1: Randomly select a segment and reverse it (2-opt-like move)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Randomly swap two nodes (exploration)\n    a, b = np.random.choice(n, 2, replace=False)\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Step 3: Objective-aware segment reversal (improve worst objective)\n    def calculate_objective(sol):\n        cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    current_obj = calculate_objective(new_solution)\n    worst_obj = np.argmax(current_obj)\n\n    # Reverse a segment to improve the worst objective\n    if worst_obj == 0:\n        matrix = distance_matrix_1\n    elif worst_obj == 1:\n        matrix = distance_matrix_2\n    else:\n        matrix = distance_matrix_3\n\n    best_improvement = 0\n    best_i, best_j = 0, 0\n    for i in range(n):\n        for j in range(i+1, n):\n            # Calculate the change in cost if we reverse the segment\n            before = matrix[new_solution[i-1], new_solution[i]] + matrix[new_solution[j], new_solution[(j+1)%n]]\n            after = matrix[new_solution[i-1], new_solution[j]] + matrix[new_solution[i], new_solution[(j+1)%n]]\n            improvement = before - after\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_i, best_j = i, j\n\n    if best_improvement > 0:\n        new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 190,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    ranked_solutions = sorted(archive, key=lambda x: sum(sorted([x[1][i] for i in range(3)]).index(x[1][i]) for i in range(3)))\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply a hybrid local search: 2-opt for one objective, followed by a multi-objective edge swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # 2-opt for the first objective\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Multi-objective edge swap\n    for _ in range(5):  # Limit iterations\n        i = np.random.randint(n)\n        j = np.random.randint(n)\n        if i != j:\n            # Calculate potential improvement across all objectives\n            original_costs = [\n                distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n                distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n                distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n            ]\n            swapped_costs = [\n                distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]],\n                distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]],\n                distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]]\n            ]\n\n            # Accept if at least one objective improves\n            if any(swapped_costs[k] < original_costs[k] for k in range(3)):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7103902089218159,
            2.1617374420166016
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    ranked_solutions = sorted(archive, key=lambda x: sum(sorted([x[1][i] for i in range(3)]).index(x[1][i]) for i in range(3)))\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply a hybrid local search: 2-opt for one objective, followed by a multi-objective edge swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # 2-opt for the first objective\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Multi-objective edge swap\n    for _ in range(5):  # Limit iterations\n        i = np.random.randint(n)\n        j = np.random.randint(n)\n        if i != j:\n            # Calculate potential improvement across all objectives\n            original_costs = [\n                distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]],\n                distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]],\n                distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n            ]\n            swapped_costs = [\n                distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]],\n                distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]],\n                distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]]\n            ]\n\n            # Accept if at least one objective improves\n            if any(swapped_costs[k] < original_costs[k] for k in range(3)):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 191,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware node selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to break\n    i, j = sorted(random.sample(range(n), 2))\n    if i == 0 and j == n-1:\n        return new_solution  # Avoid complete reversal\n\n    # Reverse the segment between i and j to form a new tour\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Evaluate the new solution across all three objectives\n    def evaluate(solution):\n        cost1 = sum(distance_matrix_1[solution[k], solution[(k+1)%n]] for k in range(n))\n        cost2 = sum(distance_matrix_2[solution[k], solution[(k+1)%n]] for k in range(n))\n        cost3 = sum(distance_matrix_3[solution[k], solution[(k+1)%n]] for k in range(n))\n        return (cost1, cost2, cost3)\n\n    new_cost = evaluate(new_solution)\n\n    # If the new solution is dominated, try an alternative 2-opt move\n    if any(new_cost[k] > max(cost[k] for _, cost in archive) for k in range(3)):\n        # Try a different segment reversal\n        k, l = sorted(random.sample(range(n), 2))\n        if k == 0 and l == n-1:\n            return new_solution\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7308009686890741,
            1.6735592246055604
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware node selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to break\n    i, j = sorted(random.sample(range(n), 2))\n    if i == 0 and j == n-1:\n        return new_solution  # Avoid complete reversal\n\n    # Reverse the segment between i and j to form a new tour\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Evaluate the new solution across all three objectives\n    def evaluate(solution):\n        cost1 = sum(distance_matrix_1[solution[k], solution[(k+1)%n]] for k in range(n))\n        cost2 = sum(distance_matrix_2[solution[k], solution[(k+1)%n]] for k in range(n))\n        cost3 = sum(distance_matrix_3[solution[k], solution[(k+1)%n]] for k in range(n))\n        return (cost1, cost2, cost3)\n\n    new_cost = evaluate(new_solution)\n\n    # If the new solution is dominated, try an alternative 2-opt move\n    if any(new_cost[k] > max(cost[k] for _, cost in archive) for k in range(3)):\n        # Try a different segment reversal\n        k, l = sorted(random.sample(range(n), 2))\n        if k == 0 and l == n-1:\n            return new_solution\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 192,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    i, j = np.random.choice(len(new_solution), 2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Evaluate the edges to be reversed in all three objectives\n    edge1 = (new_solution[i-1], new_solution[i])\n    edge2 = (new_solution[j], new_solution[(j+1)%len(new_solution)])\n    new_edge1 = (new_solution[i-1], new_solution[j])\n    new_edge2 = (new_solution[i], new_solution[(j+1)%len(new_solution)])\n\n    # Calculate the total improvement across all three objectives\n    improvement = 0\n    for dm in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n        current_cost = dm[edge1[0], edge1[1]] + dm[edge2[0], edge2[1]]\n        new_cost = dm[new_edge1[0], new_edge1[1]] + dm[new_edge2[0], new_edge2[1]]\n        improvement += (current_cost - new_cost)\n\n    # Apply 2-opt if it improves at least one objective\n    if improvement > 0:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additionally, apply a random 3-opt move for diversity\n    a, b, c = np.random.choice(len(new_solution), 3, replace=False)\n    a, b, c = sorted([a, b, c])\n    if np.random.rand() < 0.3:  # 30% chance to apply 3-opt\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7570990484590345,
            2.837525999546051
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    i, j = np.random.choice(len(new_solution), 2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Evaluate the edges to be reversed in all three objectives\n    edge1 = (new_solution[i-1], new_solution[i])\n    edge2 = (new_solution[j], new_solution[(j+1)%len(new_solution)])\n    new_edge1 = (new_solution[i-1], new_solution[j])\n    new_edge2 = (new_solution[i], new_solution[(j+1)%len(new_solution)])\n\n    # Calculate the total improvement across all three objectives\n    improvement = 0\n    for dm in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n        current_cost = dm[edge1[0], edge1[1]] + dm[edge2[0], edge2[1]]\n        new_cost = dm[new_edge1[0], new_edge1[1]] + dm[new_edge2[0], new_edge2[1]]\n        improvement += (current_cost - new_cost)\n\n    # Apply 2-opt if it improves at least one objective\n    if improvement > 0:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additionally, apply a random 3-opt move for diversity\n    a, b, c = np.random.choice(len(new_solution), 3, replace=False)\n    a, b, c = sorted([a, b, c])\n    if np.random.rand() < 0.3:  # 30% chance to apply 3-opt\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 193,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    # Objective-aware refinement: swap nodes if they improve the worst objective\n    for _ in range(2):  # Limit refinement steps to avoid excessive computation\n        k, l = np.random.choice(n, 2, replace=False)\n        if k == l:\n            continue\n\n        # Calculate current and proposed costs\n        current_costs = (\n            distance_matrix_1[base_solution[k-1], base_solution[k]] + distance_matrix_1[base_solution[l-1], base_solution[l]],\n            distance_matrix_2[base_solution[k-1], base_solution[k]] + distance_matrix_2[base_solution[l-1], base_solution[l]],\n            distance_matrix_3[base_solution[k-1], base_solution[k]] + distance_matrix_3[base_solution[l-1], base_solution[l]]\n        )\n        proposed_costs = (\n            distance_matrix_1[base_solution[k-1], base_solution[l]] + distance_matrix_1[base_solution[l-1], base_solution[k]],\n            distance_matrix_2[base_solution[k-1], base_solution[l]] + distance_matrix_2[base_solution[l-1], base_solution[k]],\n            distance_matrix_3[base_solution[k-1], base_solution[l]] + distance_matrix_3[base_solution[l-1], base_solution[k]]\n        )\n\n        # Accept if at least one objective improves\n        if any(p < c for p, c in zip(proposed_costs, current_costs)):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7306796735280395,
            1.7727454900741577
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    # Objective-aware refinement: swap nodes if they improve the worst objective\n    for _ in range(2):  # Limit refinement steps to avoid excessive computation\n        k, l = np.random.choice(n, 2, replace=False)\n        if k == l:\n            continue\n\n        # Calculate current and proposed costs\n        current_costs = (\n            distance_matrix_1[base_solution[k-1], base_solution[k]] + distance_matrix_1[base_solution[l-1], base_solution[l]],\n            distance_matrix_2[base_solution[k-1], base_solution[k]] + distance_matrix_2[base_solution[l-1], base_solution[l]],\n            distance_matrix_3[base_solution[k-1], base_solution[k]] + distance_matrix_3[base_solution[l-1], base_solution[l]]\n        )\n        proposed_costs = (\n            distance_matrix_1[base_solution[k-1], base_solution[l]] + distance_matrix_1[base_solution[l-1], base_solution[k]],\n            distance_matrix_2[base_solution[k-1], base_solution[l]] + distance_matrix_2[base_solution[l-1], base_solution[k]],\n            distance_matrix_3[base_solution[k-1], base_solution[l]] + distance_matrix_3[base_solution[l-1], base_solution[k]]\n        )\n\n        # Accept if at least one objective improves\n        if any(p < c for p, c in zip(proposed_costs, current_costs)):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 194,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    avg_objectives = np.mean(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(objectives > avg_objectives, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify edges with high contribution to objectives\n    def edge_cost(i, j):\n        a, b = new_solution[i], new_solution[j]\n        return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n    # Find worst edge in any objective\n    worst_edge = None\n    max_cost = -1\n    for i in range(n):\n        j = (i + 1) % n\n        costs = edge_cost(i, j)\n        current_max = max(costs)\n        if current_max > max_cost:\n            max_cost = current_max\n            worst_edge = (i, j)\n\n    if worst_edge:\n        i, j = worst_edge\n        # Try to improve by reconnecting the worst edge\n        k = np.random.randint(0, n)\n        l = (k + 1) % n\n        if k != i and k != j and l != i and l != j:\n            # 2-opt swap\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n            # Additional swap to ensure feasibility\n            new_solution[k+1:l+1] = new_solution[k+1:l+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7668832894692903,
            1.813420331478119
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    avg_objectives = np.mean(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(objectives > avg_objectives, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify edges with high contribution to objectives\n    def edge_cost(i, j):\n        a, b = new_solution[i], new_solution[j]\n        return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n    # Find worst edge in any objective\n    worst_edge = None\n    max_cost = -1\n    for i in range(n):\n        j = (i + 1) % n\n        costs = edge_cost(i, j)\n        current_max = max(costs)\n        if current_max > max_cost:\n            max_cost = current_max\n            worst_edge = (i, j)\n\n    if worst_edge:\n        i, j = worst_edge\n        # Try to improve by reconnecting the worst edge\n        k = np.random.randint(0, n)\n        l = (k + 1) % n\n        if k != i and k != j and l != i and l != j:\n            # 2-opt swap\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n            # Additional swap to ensure feasibility\n            new_solution[k+1:l+1] = new_solution[k+1:l+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 195,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware node selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n\n    if i > j:\n        i, j = j, i\n\n    # Reverse the segment to create a 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply objective-aware edge swaps\n    for _ in range(3):  # Limited iterations for efficiency\n        # Select two random edges\n        a, b = np.random.choice(n, 2, replace=False)\n        c, d = np.random.choice(n, 2, replace=False)\n\n        # Calculate edge costs in all three objectives\n        cost_before = (\n            distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n            distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] +\n            distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n            distance_matrix_2[new_solution[b], new_solution[(b+1)%n]] +\n            distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] +\n            distance_matrix_3[new_solution[b], new_solution[(b+1)%n]]\n        )\n\n        cost_after = (\n            distance_matrix_1[new_solution[a], new_solution[b]] +\n            distance_matrix_1[new_solution[c], new_solution[d]] +\n            distance_matrix_2[new_solution[a], new_solution[b]] +\n            distance_matrix_2[new_solution[c], new_solution[d]] +\n            distance_matrix_3[new_solution[a], new_solution[b]] +\n            distance_matrix_3[new_solution[c], new_solution[d]]\n        )\n\n        # Accept if total cost is improved in at least one objective\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n            new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    return new_solution\n\n",
        "score": [
            -0.6016824738727611,
            1.8896756410598754
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware node selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n\n    if i > j:\n        i, j = j, i\n\n    # Reverse the segment to create a 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply objective-aware edge swaps\n    for _ in range(3):  # Limited iterations for efficiency\n        # Select two random edges\n        a, b = np.random.choice(n, 2, replace=False)\n        c, d = np.random.choice(n, 2, replace=False)\n\n        # Calculate edge costs in all three objectives\n        cost_before = (\n            distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n            distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] +\n            distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n            distance_matrix_2[new_solution[b], new_solution[(b+1)%n]] +\n            distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] +\n            distance_matrix_3[new_solution[b], new_solution[(b+1)%n]]\n        )\n\n        cost_after = (\n            distance_matrix_1[new_solution[a], new_solution[b]] +\n            distance_matrix_1[new_solution[c], new_solution[d]] +\n            distance_matrix_2[new_solution[a], new_solution[b]] +\n            distance_matrix_2[new_solution[c], new_solution[d]] +\n            distance_matrix_3[new_solution[a], new_solution[b]] +\n            distance_matrix_3[new_solution[c], new_solution[d]]\n        )\n\n        # Accept if total cost is improved in at least one objective\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n            new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 196,
        "algorithm": "{This heuristic function selects a promising solution from the archive by evaluating the trade-off between objectives, then applies a hybrid local search operator that combines 2-opt and 3-opt moves with a novel adaptive perturbation mechanism to generate a neighbor solution, ensuring feasibility while effectively optimizing across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off between objectives\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two random nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Adaptive perturbation: choose between 2-opt and 3-opt based on objective diversity\n        obj1, obj2, obj3 = archive[selected_idx][1]\n        diversity = max(obj1, obj2, obj3) - min(obj1, obj2, obj3)\n\n        if diversity > (max(obj1, obj2, obj3) * 0.1):  # If objectives are diverse enough\n            # Apply 3-opt for better exploration\n            i, j, k = np.random.choice(n, 3, replace=False)\n            i, j, k = sorted([i, j, k])\n            new_solution[i:j] = new_solution[i:j][::-1]\n            new_solution[j:k] = new_solution[j:k][::-1]\n        else:\n            # Apply 2-opt for better exploitation\n            i, j = np.random.choice(n, 2, replace=False)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Additional adaptive perturbation: occasionally swap nodes based on distance matrix\n        if np.random.rand() < 0.3:\n            # Choose a node to perturb based on the worst objective\n            obj_values = archive[selected_idx][1]\n            worst_obj = np.argmax(obj_values)\n            if worst_obj == 0:\n                dist_mat = distance_matrix_1\n            elif worst_obj == 1:\n                dist_mat = distance_matrix_2\n            else:\n                dist_mat = distance_matrix_3\n\n            # Find the node with the highest total distance to its neighbors\n            total_dist = np.zeros(n)\n            for i in range(n):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[(i+1)%n]\n                total_dist[i] = dist_mat[new_solution[i], prev_node] + dist_mat[new_solution[i], next_node]\n\n            node_to_perturb = np.argmax(total_dist)\n            # Swap with a random neighbor\n            neighbors = [new_solution[(node_to_perturb-1)%n], new_solution[(node_to_perturb+1)%n]]\n            swap_with = np.random.choice(neighbors)\n            idx_swap = np.where(new_solution == swap_with)[0][0]\n            new_solution[node_to_perturb], new_solution[idx_swap] = new_solution[idx_swap], new_solution[node_to_perturb]\n\n    return new_solution\n\n",
        "score": [
            -0.6289237613399558,
            2.1517993330955507
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off between objectives\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two random nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Adaptive perturbation: choose between 2-opt and 3-opt based on objective diversity\n        obj1, obj2, obj3 = archive[selected_idx][1]\n        diversity = max(obj1, obj2, obj3) - min(obj1, obj2, obj3)\n\n        if diversity > (max(obj1, obj2, obj3) * 0.1):  # If objectives are diverse enough\n            # Apply 3-opt for better exploration\n            i, j, k = np.random.choice(n, 3, replace=False)\n            i, j, k = sorted([i, j, k])\n            new_solution[i:j] = new_solution[i:j][::-1]\n            new_solution[j:k] = new_solution[j:k][::-1]\n        else:\n            # Apply 2-opt for better exploitation\n            i, j = np.random.choice(n, 2, replace=False)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Additional adaptive perturbation: occasionally swap nodes based on distance matrix\n        if np.random.rand() < 0.3:\n            # Choose a node to perturb based on the worst objective\n            obj_values = archive[selected_idx][1]\n            worst_obj = np.argmax(obj_values)\n            if worst_obj == 0:\n                dist_mat = distance_matrix_1\n            elif worst_obj == 1:\n                dist_mat = distance_matrix_2\n            else:\n                dist_mat = distance_matrix_3\n\n            # Find the node with the highest total distance to its neighbors\n            total_dist = np.zeros(n)\n            for i in range(n):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[(i+1)%n]\n                total_dist[i] = dist_mat[new_solution[i], prev_node] + dist_mat[new_solution[i], next_node]\n\n            node_to_perturb = np.argmax(total_dist)\n            # Swap with a random neighbor\n            neighbors = [new_solution[(node_to_perturb-1)%n], new_solution[(node_to_perturb+1)%n]]\n            swap_with = np.random.choice(neighbors)\n            idx_swap = np.where(new_solution == swap_with)[0][0]\n            new_solution[node_to_perturb], new_solution[idx_swap] = new_solution[idx_swap], new_solution[node_to_perturb]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 197,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Hybrid Operator: Combine 2-opt with a multi-objective-aware swap\n    # First, perform a standard 2-opt move to improve one objective\n    i, j = sorted(np.random.choice(len(new_solution), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform a swap between two nodes that are critical in two different objectives\n    # Find nodes with high contribution to the objectives\n    def get_contribution(node1, node2, dm):\n        return dm[node1, node2] + dm[node2, node1]\n\n    # Calculate contributions for all pairs in the current solution\n    contributions1 = []\n    contributions2 = []\n    contributions3 = []\n\n    for k in range(len(new_solution)-1):\n        node1, node2 = new_solution[k], new_solution[k+1]\n        contributions1.append(get_contribution(node1, node2, distance_matrix_1))\n        contributions2.append(get_contribution(node1, node2, distance_matrix_2))\n        contributions3.append(get_contribution(node1, node2, distance_matrix_3))\n\n    # Find the worst edges in each objective\n    worst1 = np.argmax(contributions1)\n    worst2 = np.argmax(contributions2)\n    worst3 = np.argmax(contributions3)\n\n    # Perform swaps to improve the worst edges in two different objectives\n    if worst1 != worst2:\n        # Swap the nodes at the worst edges in two different objectives\n        new_solution[worst1], new_solution[worst2] = new_solution[worst2], new_solution[worst1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.7647159664147561,
            1.6735620737075805
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Hybrid Operator: Combine 2-opt with a multi-objective-aware swap\n    # First, perform a standard 2-opt move to improve one objective\n    i, j = sorted(np.random.choice(len(new_solution), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform a swap between two nodes that are critical in two different objectives\n    # Find nodes with high contribution to the objectives\n    def get_contribution(node1, node2, dm):\n        return dm[node1, node2] + dm[node2, node1]\n\n    # Calculate contributions for all pairs in the current solution\n    contributions1 = []\n    contributions2 = []\n    contributions3 = []\n\n    for k in range(len(new_solution)-1):\n        node1, node2 = new_solution[k], new_solution[k+1]\n        contributions1.append(get_contribution(node1, node2, distance_matrix_1))\n        contributions2.append(get_contribution(node1, node2, distance_matrix_2))\n        contributions3.append(get_contribution(node1, node2, distance_matrix_3))\n\n    # Find the worst edges in each objective\n    worst1 = np.argmax(contributions1)\n    worst2 = np.argmax(contributions2)\n    worst3 = np.argmax(contributions3)\n\n    # Perform swaps to improve the worst edges in two different objectives\n    if worst1 != worst2:\n        # Swap the nodes at the worst edges in two different objectives\n        new_solution[worst1], new_solution[worst2] = new_solution[worst2], new_solution[worst1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 198,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the highest diversity in objectives\n    def diversity_score(solution):\n        obj1, obj2, obj3 = solution[1]\n        return (obj1 - obj2)**2 + (obj2 - obj3)**2 + (obj3 - obj1)**2\n\n    archive.sort(key=lambda x: diversity_score(x), reverse=True)\n    base_solution = archive[0][0].copy()\n\n    # Apply a hybrid local search: 2-opt for one objective, then edge insertion for another\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to perform 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select a node to relocate\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_solution = np.insert(new_solution, random.randint(0, n-2), node)\n\n    return new_solution\n\n",
        "score": [
            -0.45695449305199737,
            1.5592225790023804
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the highest diversity in objectives\n    def diversity_score(solution):\n        obj1, obj2, obj3 = solution[1]\n        return (obj1 - obj2)**2 + (obj2 - obj3)**2 + (obj3 - obj1)**2\n\n    archive.sort(key=lambda x: diversity_score(x), reverse=True)\n    base_solution = archive[0][0].copy()\n\n    # Apply a hybrid local search: 2-opt for one objective, then edge insertion for another\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to perform 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select a node to relocate\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_solution = np.insert(new_solution, random.randint(0, n-2), node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 199,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware swaps\n    n = len(base_solution)\n    for _ in range(10):  # Limited iterations to balance exploration and exploitation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Evaluate the swap's impact on all three objectives\n        delta_obj1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] +\n                      distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] -\n                      distance_matrix_1[base_solution[i-1], base_solution[i]] -\n                      distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n        delta_obj2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] +\n                      distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] -\n                      distance_matrix_2[base_solution[i-1], base_solution[i]] -\n                      distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n        delta_obj3 = (distance_matrix_3[base_solution[i-1], base_solution[j]] +\n                      distance_matrix_3[base_solution[j], base_solution[(i+1)%n]] -\n                      distance_matrix_3[base_solution[i-1], base_solution[i]] -\n                      distance_matrix_3[base_solution[j], base_solution[(j+1)%n]])\n        # Accept the swap if it improves at least one objective\n        if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7053310018735032,
            2.052524185180664
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware swaps\n    n = len(base_solution)\n    for _ in range(10):  # Limited iterations to balance exploration and exploitation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Evaluate the swap's impact on all three objectives\n        delta_obj1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] +\n                      distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] -\n                      distance_matrix_1[base_solution[i-1], base_solution[i]] -\n                      distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n        delta_obj2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] +\n                      distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] -\n                      distance_matrix_2[base_solution[i-1], base_solution[i]] -\n                      distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n        delta_obj3 = (distance_matrix_3[base_solution[i-1], base_solution[j]] +\n                      distance_matrix_3[base_solution[j], base_solution[(i+1)%n]] -\n                      distance_matrix_3[base_solution[i-1], base_solution[i]] -\n                      distance_matrix_3[base_solution[j], base_solution[(j+1)%n]])\n        # Accept the swap if it improves at least one objective\n        if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 200,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (could be replaced with Pareto ranking)\n        sorted_solutions = sorted(archive, key=lambda x: sum(x[1]))\n        # Select the top 20% of solutions\n        top_solutions = sorted_solutions[:max(1, len(archive) // 5)]\n        # Randomly choose one from the top candidates\n        selected_idx = np.random.choice(len(top_solutions))\n        base_solution = top_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with multi-objective edge selection\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Evaluate potential edges in all three objectives\n    def edge_cost(a, b):\n        return (distance_matrix_1[a, b],\n                distance_matrix_2[a, b],\n                distance_matrix_3[a, b])\n\n    # Current edges\n    edge1 = edge_cost(new_solution[i-1], new_solution[i])\n    edge2 = edge_cost(new_solution[j], new_solution[j+1] if j+1 < n else new_solution[0])\n\n    # Potential new edges\n    new_edge1 = edge_cost(new_solution[i-1], new_solution[j])\n    new_edge2 = edge_cost(new_solution[i], new_solution[j+1] if j+1 < n else new_solution[0])\n\n    # Calculate improvement in all three objectives\n    improvement = (\n        (edge1[0] + edge2[0]) - (new_edge1[0] + new_edge2[0]),\n        (edge1[1] + edge2[1]) - (new_edge1[1] + new_edge2[1]),\n        (edge1[2] + edge2[2]) - (new_edge1[2] + new_edge2[2])\n    )\n\n    # Apply the move if it improves at least one objective\n    if any(imp > 0 for imp in improvement):\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional multi-objective refinement: try to optimize the worst objective\n    if np.random.random() < 0.3:  # 30% chance for additional refinement\n        worst_obj = np.argmin(improvement)\n        # Find edges that could improve the worst objective\n        for k in range(n):\n            for l in range(k+2, n):\n                edge_k = edge_cost(new_solution[k-1], new_solution[k])\n                edge_l = edge_cost(new_solution[l], new_solution[l+1] if l+1 < n else new_solution[0])\n                new_edge_k = edge_cost(new_solution[k-1], new_solution[l])\n                new_edge_l = edge_cost(new_solution[k], new_solution[l+1] if l+1 < n else new_solution[0])\n\n                if (new_edge_k[worst_obj] + new_edge_l[worst_obj]) < (edge_k[worst_obj] + edge_l[worst_obj]):\n                    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7260847343051582,
            3.3887898445129396
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (could be replaced with Pareto ranking)\n        sorted_solutions = sorted(archive, key=lambda x: sum(x[1]))\n        # Select the top 20% of solutions\n        top_solutions = sorted_solutions[:max(1, len(archive) // 5)]\n        # Randomly choose one from the top candidates\n        selected_idx = np.random.choice(len(top_solutions))\n        base_solution = top_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with multi-objective edge selection\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Evaluate potential edges in all three objectives\n    def edge_cost(a, b):\n        return (distance_matrix_1[a, b],\n                distance_matrix_2[a, b],\n                distance_matrix_3[a, b])\n\n    # Current edges\n    edge1 = edge_cost(new_solution[i-1], new_solution[i])\n    edge2 = edge_cost(new_solution[j], new_solution[j+1] if j+1 < n else new_solution[0])\n\n    # Potential new edges\n    new_edge1 = edge_cost(new_solution[i-1], new_solution[j])\n    new_edge2 = edge_cost(new_solution[i], new_solution[j+1] if j+1 < n else new_solution[0])\n\n    # Calculate improvement in all three objectives\n    improvement = (\n        (edge1[0] + edge2[0]) - (new_edge1[0] + new_edge2[0]),\n        (edge1[1] + edge2[1]) - (new_edge1[1] + new_edge2[1]),\n        (edge1[2] + edge2[2]) - (new_edge1[2] + new_edge2[2])\n    )\n\n    # Apply the move if it improves at least one objective\n    if any(imp > 0 for imp in improvement):\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional multi-objective refinement: try to optimize the worst objective\n    if np.random.random() < 0.3:  # 30% chance for additional refinement\n        worst_obj = np.argmin(improvement)\n        # Find edges that could improve the worst objective\n        for k in range(n):\n            for l in range(k+2, n):\n                edge_k = edge_cost(new_solution[k-1], new_solution[k])\n                edge_l = edge_cost(new_solution[l], new_solution[l+1] if l+1 < n else new_solution[0])\n                new_edge_k = edge_cost(new_solution[k-1], new_solution[l])\n                new_edge_l = edge_cost(new_solution[k], new_solution[l+1] if l+1 < n else new_solution[0])\n\n                if (new_edge_k[worst_obj] + new_edge_l[worst_obj]) < (edge_k[worst_obj] + edge_l[worst_obj]):\n                    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 201,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objective improvements\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: edge exchange or segment reversal with probability 0.7\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if random.random() < 0.7:\n        # Edge exchange: swap two edges to form a 4-opt move\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        if a != b:\n            new_solution[a:b+1] = base_solution[a:b+1][::-1]  # Reverse segment\n    else:\n        # 2-opt: select two non-adjacent edges and reverse the segment between them\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        if i != j and abs(i-j) > 1:\n            new_solution[i:j+1] = base_solution[i:j+1][::-1]\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6100391674436915,
            1.5796518683433534
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objective improvements\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: edge exchange or segment reversal with probability 0.7\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if random.random() < 0.7:\n        # Edge exchange: swap two edges to form a 4-opt move\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        if a != b:\n            new_solution[a:b+1] = base_solution[a:b+1][::-1]  # Reverse segment\n    else:\n        # 2-opt: select two non-adjacent edges and reverse the segment between them\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        if i != j and abs(i-j) > 1:\n            new_solution[i:j+1] = base_solution[i:j+1][::-1]\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 202,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly among top 30% by objective diversity)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    top_k = max(1, len(sorted_archive) // 3)\n    selected_idx = random.randint(0, top_k - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply hybrid local search: 50% 2-opt, 30% 3D-aware swap, 20% random 3D-aware insertion\n    operator_choice = random.random()\n    if operator_choice < 0.5:  # 2-opt\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    elif operator_choice < 0.8:  # 3D-aware swap\n        # Select nodes based on their relative performance in all three objectives\n        node_scores = np.zeros(n)\n        for k in range(n):\n            node = new_solution[k]\n            next_node = new_solution[(k+1)%n]\n            prev_node = new_solution[k-1]\n            # Score based on improvement potential in all three objectives\n            node_scores[k] = (distance_matrix_1[prev_node, next_node] -\n                             distance_matrix_1[prev_node, node] -\n                             distance_matrix_1[node, next_node]) + \\\n                            (distance_matrix_2[prev_node, next_node] -\n                             distance_matrix_2[prev_node, node] -\n                             distance_matrix_2[node, next_node]) + \\\n                            (distance_matrix_3[prev_node, next_node] -\n                             distance_matrix_3[prev_node, node] -\n                             distance_matrix_3[node, next_node])\n        # Swap nodes with highest and lowest scores\n        best_idx = np.argmax(node_scores)\n        worst_idx = np.argmin(node_scores)\n        new_solution[best_idx], new_solution[worst_idx] = new_solution[worst_idx], new_solution[best_idx]\n    else:  # Random 3D-aware insertion\n        # Select a node to move based on its potential to improve all objectives\n        node_scores = np.zeros(n)\n        for k in range(n):\n            node = new_solution[k]\n            next_node = new_solution[(k+1)%n]\n            prev_node = new_solution[k-1]\n            # Score based on removal impact across all objectives\n            node_scores[k] = (distance_matrix_1[prev_node, next_node] -\n                             distance_matrix_1[prev_node, node] -\n                             distance_matrix_1[node, next_node]) + \\\n                            (distance_matrix_2[prev_node, next_node] -\n                             distance_matrix_2[prev_node, node] -\n                             distance_matrix_2[node, next_node]) + \\\n                            (distance_matrix_3[prev_node, next_node] -\n                             distance_matrix_3[prev_node, node] -\n                             distance_matrix_3[node, next_node])\n        # Remove node with highest score and reinsert at best position\n        node_to_move = new_solution[np.argmax(node_scores)]\n        temp_solution = np.delete(new_solution, np.argmax(node_scores))\n        # Find best insertion position considering all three objectives\n        best_pos = 0\n        best_improvement = 0\n        for i in range(len(temp_solution)):\n            prev_node = temp_solution[i-1]\n            next_node = temp_solution[i]\n            improvement = (distance_matrix_1[prev_node, next_node] -\n                          (distance_matrix_1[prev_node, node_to_move] +\n                           distance_matrix_1[node_to_move, next_node])) + \\\n                         (distance_matrix_2[prev_node, next_node] -\n                          (distance_matrix_2[prev_node, node_to_move] +\n                           distance_matrix_2[node_to_move, next_node])) + \\\n                         (distance_matrix_3[prev_node, next_node] -\n                          (distance_matrix_3[prev_node, node_to_move] +\n                           distance_matrix_3[node_to_move, next_node]))\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = i\n        new_solution = np.insert(temp_solution, best_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.6466207772331469,
            1.5695523023605347
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly among top 30% by objective diversity)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    top_k = max(1, len(sorted_archive) // 3)\n    selected_idx = random.randint(0, top_k - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply hybrid local search: 50% 2-opt, 30% 3D-aware swap, 20% random 3D-aware insertion\n    operator_choice = random.random()\n    if operator_choice < 0.5:  # 2-opt\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    elif operator_choice < 0.8:  # 3D-aware swap\n        # Select nodes based on their relative performance in all three objectives\n        node_scores = np.zeros(n)\n        for k in range(n):\n            node = new_solution[k]\n            next_node = new_solution[(k+1)%n]\n            prev_node = new_solution[k-1]\n            # Score based on improvement potential in all three objectives\n            node_scores[k] = (distance_matrix_1[prev_node, next_node] -\n                             distance_matrix_1[prev_node, node] -\n                             distance_matrix_1[node, next_node]) + \\\n                            (distance_matrix_2[prev_node, next_node] -\n                             distance_matrix_2[prev_node, node] -\n                             distance_matrix_2[node, next_node]) + \\\n                            (distance_matrix_3[prev_node, next_node] -\n                             distance_matrix_3[prev_node, node] -\n                             distance_matrix_3[node, next_node])\n        # Swap nodes with highest and lowest scores\n        best_idx = np.argmax(node_scores)\n        worst_idx = np.argmin(node_scores)\n        new_solution[best_idx], new_solution[worst_idx] = new_solution[worst_idx], new_solution[best_idx]\n    else:  # Random 3D-aware insertion\n        # Select a node to move based on its potential to improve all objectives\n        node_scores = np.zeros(n)\n        for k in range(n):\n            node = new_solution[k]\n            next_node = new_solution[(k+1)%n]\n            prev_node = new_solution[k-1]\n            # Score based on removal impact across all objectives\n            node_scores[k] = (distance_matrix_1[prev_node, next_node] -\n                             distance_matrix_1[prev_node, node] -\n                             distance_matrix_1[node, next_node]) + \\\n                            (distance_matrix_2[prev_node, next_node] -\n                             distance_matrix_2[prev_node, node] -\n                             distance_matrix_2[node, next_node]) + \\\n                            (distance_matrix_3[prev_node, next_node] -\n                             distance_matrix_3[prev_node, node] -\n                             distance_matrix_3[node, next_node])\n        # Remove node with highest score and reinsert at best position\n        node_to_move = new_solution[np.argmax(node_scores)]\n        temp_solution = np.delete(new_solution, np.argmax(node_scores))\n        # Find best insertion position considering all three objectives\n        best_pos = 0\n        best_improvement = 0\n        for i in range(len(temp_solution)):\n            prev_node = temp_solution[i-1]\n            next_node = temp_solution[i]\n            improvement = (distance_matrix_1[prev_node, next_node] -\n                          (distance_matrix_1[prev_node, node_to_move] +\n                           distance_matrix_1[node_to_move, next_node])) + \\\n                         (distance_matrix_2[prev_node, next_node] -\n                          (distance_matrix_2[prev_node, node_to_move] +\n                           distance_matrix_2[node_to_move, next_node])) + \\\n                         (distance_matrix_3[prev_node, next_node] -\n                          (distance_matrix_3[prev_node, node_to_move] +\n                           distance_matrix_3[node_to_move, next_node]))\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = i\n        new_solution = np.insert(temp_solution, best_pos, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 203,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # We use a combination of 2-opt and edge insertion to explore the solution space\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Step 2.1: Perform 2-opt on a random segment\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2.2: Perform edge insertion to further improve the solution\n    # Select a random edge to break and reinsert\n    k = np.random.randint(0, n)\n    node_to_reinsert = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    l = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, l, node_to_reinsert)\n\n    # Ensure the solution remains feasible\n    assert len(new_solution) == len(selected_solution), \"Solution length changed\"\n    assert len(np.unique(new_solution)) == len(selected_solution), \"Duplicate nodes detected\"\n\n    return new_solution\n\n",
        "score": [
            -0.6758488778155404,
            1.1842303633689881
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # We use a combination of 2-opt and edge insertion to explore the solution space\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Step 2.1: Perform 2-opt on a random segment\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2.2: Perform edge insertion to further improve the solution\n    # Select a random edge to break and reinsert\n    k = np.random.randint(0, n)\n    node_to_reinsert = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    l = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, l, node_to_reinsert)\n\n    # Ensure the solution remains feasible\n    assert len(new_solution) == len(selected_solution), \"Solution length changed\"\n    assert len(np.unique(new_solution)) == len(selected_solution), \"Duplicate nodes detected\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 204,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate hypervolume contribution for each solution in the archive\n    def calculate_hypervolume(solution, objectives):\n        # Placeholder for hypervolume calculation (simplified for this example)\n        return sum(objectives)\n\n    hypervolumes = [calculate_hypervolume(sol, obj) for sol, obj in archive]\n    selected_idx = np.argmax(hypervolumes)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt + node swap + edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of the three operators\n    operator = np.random.choice(['2opt', 'swap', 'edge_swap'])\n\n    if operator == '2opt':\n        # Perform 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    elif operator == 'swap':\n        # Perform node swap\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform edge swap (swap two edges)\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n-1)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6895706643166417,
            1.5731487989425659
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate hypervolume contribution for each solution in the archive\n    def calculate_hypervolume(solution, objectives):\n        # Placeholder for hypervolume calculation (simplified for this example)\n        return sum(objectives)\n\n    hypervolumes = [calculate_hypervolume(sol, obj) for sol, obj in archive]\n    selected_idx = np.argmax(hypervolumes)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt + node swap + edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of the three operators\n    operator = np.random.choice(['2opt', 'swap', 'edge_swap'])\n\n    if operator == '2opt':\n        # Perform 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    elif operator == 'swap':\n        # Perform node swap\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform edge swap (swap two edges)\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n-1)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 205,
        "algorithm": "{A novel hybrid local search algorithm combines adaptive segment inversion with multi-objective path relinking, dynamically balancing improvements across three objectives by prioritizing critical segments and leveraging reference solutions from the archive to guide exploration while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.linspace(0.1, 0.9, len(archive)).sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Adaptive segment inversion with multi-objective path relinking\n    n = len(new_solution)\n    segment_size = np.random.randint(2, min(10, n//2))\n\n    # Select a random segment to invert\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Path relinking: blend with another reference solution\n    if len(archive) > 1:\n        ref_idx = np.random.choice([i for i in range(len(archive)) if i != selected_idx])\n        reference = archive[ref_idx][0]\n\n        # Find common structure and fill gaps\n        common = np.intersect1d(new_solution, reference)\n        remaining = np.setdiff1d(reference, common)\n        np.random.shuffle(remaining)\n\n        # Insert remaining nodes at positions where they improve the most objectives\n        for node in remaining:\n            best_pos = -1\n            best_improvement = -1\n\n            for i in range(n):\n                if node in new_solution:\n                    continue\n\n                # Temporarily insert and evaluate\n                temp_solution = np.insert(new_solution, i, node)\n                temp_cost1 = sum(distance_matrix_1[temp_solution[j-1], temp_solution[j]] for j in range(len(temp_solution)))\n                temp_cost2 = sum(distance_matrix_2[temp_solution[j-1], temp_solution[j]] for j in range(len(temp_solution)))\n                temp_cost3 = sum(distance_matrix_3[temp_solution[j-1], temp_solution[j]] for j in range(len(temp_solution)))\n\n                # Calculate improvement (simplified for multi-objective)\n                improvement = (temp_cost1 + temp_cost2 + temp_cost3) - (sum(archive[selected_idx][1]) + sum(archive[ref_idx][1]))\n\n                if improvement < best_improvement:\n                    best_improvement = improvement\n                    best_pos = i\n\n            if best_pos != -1:\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or (counts != 1).any():\n        # Fallback to simple 2-opt if feasibility is violated\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8016912849053144,
            2.2465991616249084
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.linspace(0.1, 0.9, len(archive)).sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Adaptive segment inversion with multi-objective path relinking\n    n = len(new_solution)\n    segment_size = np.random.randint(2, min(10, n//2))\n\n    # Select a random segment to invert\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Path relinking: blend with another reference solution\n    if len(archive) > 1:\n        ref_idx = np.random.choice([i for i in range(len(archive)) if i != selected_idx])\n        reference = archive[ref_idx][0]\n\n        # Find common structure and fill gaps\n        common = np.intersect1d(new_solution, reference)\n        remaining = np.setdiff1d(reference, common)\n        np.random.shuffle(remaining)\n\n        # Insert remaining nodes at positions where they improve the most objectives\n        for node in remaining:\n            best_pos = -1\n            best_improvement = -1\n\n            for i in range(n):\n                if node in new_solution:\n                    continue\n\n                # Temporarily insert and evaluate\n                temp_solution = np.insert(new_solution, i, node)\n                temp_cost1 = sum(distance_matrix_1[temp_solution[j-1], temp_solution[j]] for j in range(len(temp_solution)))\n                temp_cost2 = sum(distance_matrix_2[temp_solution[j-1], temp_solution[j]] for j in range(len(temp_solution)))\n                temp_cost3 = sum(distance_matrix_3[temp_solution[j-1], temp_solution[j]] for j in range(len(temp_solution)))\n\n                # Calculate improvement (simplified for multi-objective)\n                improvement = (temp_cost1 + temp_cost2 + temp_cost3) - (sum(archive[selected_idx][1]) + sum(archive[ref_idx][1]))\n\n                if improvement < best_improvement:\n                    best_improvement = improvement\n                    best_pos = i\n\n            if best_pos != -1:\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or (counts != 1).any():\n        # Fallback to simple 2-opt if feasibility is violated\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 206,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations\n        i, j = np.random.choice(n, size=2, replace=False)\n        k, l = np.random.choice(n, size=2, replace=False)\n\n        # Try 2-opt move\n        if i < j:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:] = new_solution[i:][::-1]\n            new_solution[:j+1] = new_solution[:j+1][::-1]\n\n        # Check feasibility and objective improvement\n        if len(set(new_solution)) != n:\n            new_solution = base_solution.copy()\n            continue\n\n        # Objective-aware swap\n        a, b = np.random.choice(n, size=2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Check feasibility again\n        if len(set(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6582688569001832,
            2.7849724173545836
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations\n        i, j = np.random.choice(n, size=2, replace=False)\n        k, l = np.random.choice(n, size=2, replace=False)\n\n        # Try 2-opt move\n        if i < j:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:] = new_solution[i:][::-1]\n            new_solution[:j+1] = new_solution[:j+1][::-1]\n\n        # Check feasibility and objective improvement\n        if len(set(new_solution)) != n:\n            new_solution = base_solution.copy()\n            continue\n\n        # Objective-aware swap\n        a, b = np.random.choice(n, size=2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Check feasibility again\n        if len(set(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 207,
        "algorithm": "{This algorithm selects a promising solution from the archive by prioritizing those with the highest diversity in objective values, then applies a hybrid local search combining 2-opt and 3-opt moves tailored to the tri-objective structure, ensuring feasible neighbors through careful edge-swapping while maintaining non-dominated properties.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives (promising for improvement)\n    selected_idx = np.argmax([(max(obj) - min(obj)) for (_, obj) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to balance exploration/exploitation\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate objective-aware cost improvement\n        def cost_diff(sol, a, b, c, d):\n            old_edges = [(sol[a], sol[(a+1)%n]), (sol[b], sol[(b+1)%n])]\n            new_edges = [(sol[a], sol[c]), (sol[b], sol[d])]\n            delta = 0\n            for (x, y) in old_edges:\n                delta += distance_matrix_1[x, y] + distance_matrix_2[x, y] + distance_matrix_3[x, y]\n            for (x, y) in new_edges:\n                delta -= distance_matrix_1[x, y] + distance_matrix_2[x, y] + distance_matrix_3[x, y]\n            return delta\n\n        # Try 2-opt move\n        if cost_diff(new_solution, i, j, j, i) < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Try 3-opt move (if 2-opt didn't help)\n        if i + 2 < j:\n            k = random.randint(i+1, j-1)\n            # Try all 3-opt permutations\n            for perm in [(i, j, k), (i, k, j)]:\n                a, b, c = perm\n                if cost_diff(new_solution, a, b, c, a) < 0:\n                    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n                    new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5986943521739824,
            2.118124520778656
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives (promising for improvement)\n    selected_idx = np.argmax([(max(obj) - min(obj)) for (_, obj) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to balance exploration/exploitation\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate objective-aware cost improvement\n        def cost_diff(sol, a, b, c, d):\n            old_edges = [(sol[a], sol[(a+1)%n]), (sol[b], sol[(b+1)%n])]\n            new_edges = [(sol[a], sol[c]), (sol[b], sol[d])]\n            delta = 0\n            for (x, y) in old_edges:\n                delta += distance_matrix_1[x, y] + distance_matrix_2[x, y] + distance_matrix_3[x, y]\n            for (x, y) in new_edges:\n                delta -= distance_matrix_1[x, y] + distance_matrix_2[x, y] + distance_matrix_3[x, y]\n            return delta\n\n        # Try 2-opt move\n        if cost_diff(new_solution, i, j, j, i) < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Try 3-opt move (if 2-opt didn't help)\n        if i + 2 < j:\n            k = random.randint(i+1, j-1)\n            # Try all 3-opt permutations\n            for perm in [(i, j, k), (i, k, j)]:\n                a, b, c = perm\n                if cost_diff(new_solution, a, b, c, a) < 0:\n                    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n                    new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 208,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose a segment to perturb based on the objective with the highest variance\n    obj1 = np.array([archive[i][1][0] for i in range(len(archive))])\n    obj2 = np.array([archive[i][1][1] for i in range(len(archive))])\n    obj3 = np.array([archive[i][1][2] for i in range(len(archive))])\n\n    var1, var2, var3 = np.var(obj1), np.var(obj2), np.var(obj3)\n    max_var_idx = np.argmax([var1, var2, var3])\n\n    # Select edges with high distance in the most variable objective\n    if max_var_idx == 0:\n        dist_mat = distance_matrix_1\n    elif max_var_idx == 1:\n        dist_mat = distance_matrix_2\n    else:\n        dist_mat = distance_matrix_3\n\n    # Perform 2-opt with the selected edges\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        return base_solution  # Fallback to original if invalid\n\n",
        "score": [
            -0.7747282234018125,
            1.9120625138282776
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose a segment to perturb based on the objective with the highest variance\n    obj1 = np.array([archive[i][1][0] for i in range(len(archive))])\n    obj2 = np.array([archive[i][1][1] for i in range(len(archive))])\n    obj3 = np.array([archive[i][1][2] for i in range(len(archive))])\n\n    var1, var2, var3 = np.var(obj1), np.var(obj2), np.var(obj3)\n    max_var_idx = np.argmax([var1, var2, var3])\n\n    # Select edges with high distance in the most variable objective\n    if max_var_idx == 0:\n        dist_mat = distance_matrix_1\n    elif max_var_idx == 1:\n        dist_mat = distance_matrix_2\n    else:\n        dist_mat = distance_matrix_3\n\n    # Perform 2-opt with the selected edges\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        return base_solution  # Fallback to original if invalid\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 209,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: combine 2-opt with a multi-objective aware swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct positions for the 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform a multi-objective aware swap: identify the worst edge in any objective and swap it\n    def calculate_edge_costs(solution):\n        cost1 = sum(distance_matrix_1[solution[k], solution[(k+1)%n]] for k in range(n))\n        cost2 = sum(distance_matrix_2[solution[k], solution[(k+1)%n]] for k in range(n))\n        cost3 = sum(distance_matrix_3[solution[k], solution[(k+1)%n]] for k in range(n))\n        return cost1, cost2, cost3\n\n    current_costs = calculate_edge_costs(new_solution)\n    worst_obj = np.argmax(current_costs)\n\n    # Find the worst edge in the selected objective\n    if worst_obj == 0:\n        worst_edge = np.argmax([distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)])\n    elif worst_obj == 1:\n        worst_edge = np.argmax([distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)])\n    else:\n        worst_edge = np.argmax([distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n)])\n\n    # Swap nodes to potentially improve the worst objective\n    k = worst_edge\n    l = (k + 1) % n\n    if np.random.rand() < 0.5:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7058399350885585,
            2.179478406906128
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: combine 2-opt with a multi-objective aware swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct positions for the 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform a multi-objective aware swap: identify the worst edge in any objective and swap it\n    def calculate_edge_costs(solution):\n        cost1 = sum(distance_matrix_1[solution[k], solution[(k+1)%n]] for k in range(n))\n        cost2 = sum(distance_matrix_2[solution[k], solution[(k+1)%n]] for k in range(n))\n        cost3 = sum(distance_matrix_3[solution[k], solution[(k+1)%n]] for k in range(n))\n        return cost1, cost2, cost3\n\n    current_costs = calculate_edge_costs(new_solution)\n    worst_obj = np.argmax(current_costs)\n\n    # Find the worst edge in the selected objective\n    if worst_obj == 0:\n        worst_edge = np.argmax([distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)])\n    elif worst_obj == 1:\n        worst_edge = np.argmax([distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)])\n    else:\n        worst_edge = np.argmax([distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n)])\n\n    # Swap nodes to potentially improve the worst objective\n    k = worst_edge\n    l = (k + 1) % n\n    if np.random.rand() < 0.5:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 210,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # We use a combination of 2-opt and 3-opt moves to explore the solution space\n    new_solution = base_solution.copy()\n\n    # Perform 2-opt move\n    i, j = np.random.choice(len(new_solution), 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform 3-opt move if the solution is not improved enough\n    if np.random.rand() < 0.3:  # 30% chance to apply 3-opt\n        a, b, c = np.random.choice(len(new_solution), 3, replace=False)\n        a, b, c = sorted([a, b, c])\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution[a:c] = np.concatenate([segment1[::-1], segment2[::-1]])\n\n    # Ensure the solution remains feasible\n    assert len(np.unique(new_solution)) == len(base_solution), \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            -0.7521955549332624,
            1.5993801474571228
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # We use a combination of 2-opt and 3-opt moves to explore the solution space\n    new_solution = base_solution.copy()\n\n    # Perform 2-opt move\n    i, j = np.random.choice(len(new_solution), 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform 3-opt move if the solution is not improved enough\n    if np.random.rand() < 0.3:  # 30% chance to apply 3-opt\n        a, b, c = np.random.choice(len(new_solution), 3, replace=False)\n        a, b, c = sorted([a, b, c])\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution[a:c] = np.concatenate([segment1[::-1], segment2[::-1]])\n\n    # Ensure the solution remains feasible\n    assert len(np.unique(new_solution)) == len(base_solution), \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 211,
        "algorithm": "{This algorithm selects a promising solution from the archive using a hybrid local search strategy that combines 2-opt swaps with objective-specific path improvements, ensuring feasibility and multi-objective optimization by intelligently balancing improvements across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort archive by the sum of objectives (could be replaced with a more sophisticated selection criterion)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the top 30% of the archive\n        selected_idx = random.randint(0, max(0, int(0.3 * len(sorted_archive)) - 1))\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(new_solution)\n    if n > 3:\n        # Perform a 2-opt swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Perform an objective-specific improvement\n        obj_idx = random.randint(0, 2)\n        if obj_idx == 0:\n            mat = distance_matrix_1\n        elif obj_idx == 1:\n            mat = distance_matrix_2\n        else:\n            mat = distance_matrix_3\n\n        # Find the best 2-opt move in the selected objective space\n        best_delta = 0\n        best_i, best_j = 0, 0\n        for i in range(1, n):\n            for j in range(i + 1, n):\n                a, b, c, d = new_solution[i-1], new_solution[i], new_solution[j], new_solution[(j+1)%n]\n                delta = mat[a, c] + mat[b, d] - mat[a, b] - mat[c, d]\n                if delta < best_delta:\n                    best_delta = delta\n                    best_i, best_j = i, j\n\n        if best_delta < 0:\n            new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7096541623697367,
            3.5641801834106444
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort archive by the sum of objectives (could be replaced with a more sophisticated selection criterion)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the top 30% of the archive\n        selected_idx = random.randint(0, max(0, int(0.3 * len(sorted_archive)) - 1))\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(new_solution)\n    if n > 3:\n        # Perform a 2-opt swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Perform an objective-specific improvement\n        obj_idx = random.randint(0, 2)\n        if obj_idx == 0:\n            mat = distance_matrix_1\n        elif obj_idx == 1:\n            mat = distance_matrix_2\n        else:\n            mat = distance_matrix_3\n\n        # Find the best 2-opt move in the selected objective space\n        best_delta = 0\n        best_i, best_j = 0, 0\n        for i in range(1, n):\n            for j in range(i + 1, n):\n                a, b, c, d = new_solution[i-1], new_solution[i], new_solution[j], new_solution[(j+1)%n]\n                delta = mat[a, c] + mat[b, d] - mat[a, b] - mat[c, d]\n                if delta < best_delta:\n                    best_delta = delta\n                    best_i, best_j = i, j\n\n        if best_delta < 0:\n            new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 212,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent random selection: prefer solutions with lower objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = objectives / np.max(objectives, axis=0)  # Normalize each objective\n    selection_probs = 1 / (1 + np.sum(norm_objectives, axis=1))  # Higher probability for better solutions\n    selection_probs /= np.sum(selection_probs)  # Normalize probabilities\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt swap with multi-objective edge selection criterion\n    i, j = sorted(random.sample(range(n), 2))\n    if i == 0 and j == n-1:  # Avoid full reversal which would just flip the tour\n        i, j = i+1, j\n\n    # Calculate edge improvements across all objectives\n    def edge_improvement(a, b, c, d):\n        # Calculate improvement in each objective space\n        imp1 = distance_matrix_1[a, b] + distance_matrix_1[c, d] - distance_matrix_1[a, c] - distance_matrix_1[b, d]\n        imp2 = distance_matrix_2[a, b] + distance_matrix_2[c, d] - distance_matrix_2[a, c] - distance_matrix_2[b, d]\n        imp3 = distance_matrix_3[a, b] + distance_matrix_3[c, d] - distance_matrix_3[a, c] - distance_matrix_3[b, d]\n        return (imp1, imp2, imp3)\n\n    # Get current edges\n    a, b = new_solution[i-1], new_solution[i]\n    c, d = new_solution[j], new_solution[(j+1)%n]\n\n    # Calculate improvement if we swap edges\n    imp = edge_improvement(a, b, c, d)\n\n    # Apply swap if it improves at least one objective\n    if any(x < 0 for x in imp):\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional multi-objective 2-opt: try to improve other objectives\n    for _ in range(3):  # Try a few random 2-opt moves\n        i, j = sorted(random.sample(range(n), 2))\n        if i == 0 and j == n-1:\n            continue\n\n        a, b = new_solution[i-1], new_solution[i]\n        c, d = new_solution[j], new_solution[(j+1)%n]\n        imp = edge_improvement(a, b, c, d)\n\n        # Apply if it improves at least one objective\n        if any(x < 0 for x in imp):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains valid (visits all nodes exactly once)\n    assert len(new_solution) == len(base_solution) and len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.637590214397357,
            1.1338238358497619
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent random selection: prefer solutions with lower objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = objectives / np.max(objectives, axis=0)  # Normalize each objective\n    selection_probs = 1 / (1 + np.sum(norm_objectives, axis=1))  # Higher probability for better solutions\n    selection_probs /= np.sum(selection_probs)  # Normalize probabilities\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt swap with multi-objective edge selection criterion\n    i, j = sorted(random.sample(range(n), 2))\n    if i == 0 and j == n-1:  # Avoid full reversal which would just flip the tour\n        i, j = i+1, j\n\n    # Calculate edge improvements across all objectives\n    def edge_improvement(a, b, c, d):\n        # Calculate improvement in each objective space\n        imp1 = distance_matrix_1[a, b] + distance_matrix_1[c, d] - distance_matrix_1[a, c] - distance_matrix_1[b, d]\n        imp2 = distance_matrix_2[a, b] + distance_matrix_2[c, d] - distance_matrix_2[a, c] - distance_matrix_2[b, d]\n        imp3 = distance_matrix_3[a, b] + distance_matrix_3[c, d] - distance_matrix_3[a, c] - distance_matrix_3[b, d]\n        return (imp1, imp2, imp3)\n\n    # Get current edges\n    a, b = new_solution[i-1], new_solution[i]\n    c, d = new_solution[j], new_solution[(j+1)%n]\n\n    # Calculate improvement if we swap edges\n    imp = edge_improvement(a, b, c, d)\n\n    # Apply swap if it improves at least one objective\n    if any(x < 0 for x in imp):\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional multi-objective 2-opt: try to improve other objectives\n    for _ in range(3):  # Try a few random 2-opt moves\n        i, j = sorted(random.sample(range(n), 2))\n        if i == 0 and j == n-1:\n            continue\n\n        a, b = new_solution[i-1], new_solution[i]\n        c, d = new_solution[j], new_solution[(j+1)%n]\n        imp = edge_improvement(a, b, c, d)\n\n        # Apply if it improves at least one objective\n        if any(x < 0 for x in imp):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains valid (visits all nodes exactly once)\n    assert len(new_solution) == len(base_solution) and len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 213,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best overall objective value (sum of three objectives)\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(best_solution)\n    new_solution = best_solution.copy()\n\n    # Randomly select two edges to break and reconnect\n    i, j = sorted(random.sample(range(n), 2))\n    k = (i + 1) % n\n    l = (j + 1) % n\n\n    # Calculate the change in total distance across all three objectives\n    def calculate_delta(a, b, c, d):\n        delta = 0\n        delta += distance_matrix_1[a, b] + distance_matrix_1[c, d] - distance_matrix_1[a, c] - distance_matrix_1[b, d]\n        delta += distance_matrix_2[a, b] + distance_matrix_2[c, d] - distance_matrix_2[a, c] - distance_matrix_2[b, d]\n        delta += distance_matrix_3[a, b] + distance_matrix_3[c, d] - distance_matrix_3[a, c] - distance_matrix_3[b, d]\n        return delta\n\n    # Try to find a better 2-opt move by considering the combined effect on all objectives\n    best_delta = float('inf')\n    best_i, best_j = i, j\n\n    for _ in range(10):  # Limit the number of trials for efficiency\n        a, b = sorted(random.sample(range(n), 2))\n        c = (a + 1) % n\n        d = (b + 1) % n\n        delta = calculate_delta(a, b, c, d)\n        if delta < best_delta:\n            best_delta = delta\n            best_i, best_j = a, b\n\n    # Apply the best found move\n    i, j = best_i, best_j\n    k = (i + 1) % n\n    l = (j + 1) % n\n\n    # Reverse the segment between i and j\n    new_solution[i+1:j+1] = new_solution[j:i:-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5280436795135358,
            2.0004253029823302
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best overall objective value (sum of three objectives)\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(best_solution)\n    new_solution = best_solution.copy()\n\n    # Randomly select two edges to break and reconnect\n    i, j = sorted(random.sample(range(n), 2))\n    k = (i + 1) % n\n    l = (j + 1) % n\n\n    # Calculate the change in total distance across all three objectives\n    def calculate_delta(a, b, c, d):\n        delta = 0\n        delta += distance_matrix_1[a, b] + distance_matrix_1[c, d] - distance_matrix_1[a, c] - distance_matrix_1[b, d]\n        delta += distance_matrix_2[a, b] + distance_matrix_2[c, d] - distance_matrix_2[a, c] - distance_matrix_2[b, d]\n        delta += distance_matrix_3[a, b] + distance_matrix_3[c, d] - distance_matrix_3[a, c] - distance_matrix_3[b, d]\n        return delta\n\n    # Try to find a better 2-opt move by considering the combined effect on all objectives\n    best_delta = float('inf')\n    best_i, best_j = i, j\n\n    for _ in range(10):  # Limit the number of trials for efficiency\n        a, b = sorted(random.sample(range(n), 2))\n        c = (a + 1) % n\n        d = (b + 1) % n\n        delta = calculate_delta(a, b, c, d)\n        if delta < best_delta:\n            best_delta = delta\n            best_i, best_j = a, b\n\n    # Apply the best found move\n    i, j = best_i, best_j\n    k = (i + 1) % n\n    l = (j + 1) % n\n\n    # Reverse the segment between i and j\n    new_solution[i+1:j+1] = new_solution[j:i:-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 214,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # Perform a combination of 2-opt and node insertion to explore the search space\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment for 2-opt\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select a node to reinsert (node insertion)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7414641847889256,
            1.575222420692444
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # Perform a combination of 2-opt and node insertion to explore the search space\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment for 2-opt\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select a node to reinsert (node insertion)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 215,
        "algorithm": "{This algorithm selects a promising solution from the archive by evaluating the diversity and improvement potential of each solution, then applies a hybrid local search operator that combines 2-opt moves with a novel segment inversion strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger instances, perform a combination of 2-opt and segment inversion\n        # 2-opt move\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Segment inversion with objective-based selection\n        k = np.random.randint(1, n//2)\n        segment = new_solution[k:k*2]\n        # Invert the segment if it improves any objective\n        inverted_segment = segment[::-1]\n        original_costs = [sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]],\n                          sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]],\n                          sum(distance_matrix_3[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]]\n\n        temp_solution = new_solution.copy()\n        temp_solution[k:k*2] = inverted_segment\n        inverted_costs = [sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]],\n                          sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]],\n                          sum(distance_matrix_3[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_3[temp_solution[-1], temp_solution[0]]]\n\n        # Apply inversion if it improves at least one objective\n        if any(inverted_costs[i] < original_costs[i] for i in range(3)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7819596328113843,
            1.4031395316123962
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger instances, perform a combination of 2-opt and segment inversion\n        # 2-opt move\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Segment inversion with objective-based selection\n        k = np.random.randint(1, n//2)\n        segment = new_solution[k:k*2]\n        # Invert the segment if it improves any objective\n        inverted_segment = segment[::-1]\n        original_costs = [sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]],\n                          sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]],\n                          sum(distance_matrix_3[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]]\n\n        temp_solution = new_solution.copy()\n        temp_solution[k:k*2] = inverted_segment\n        inverted_costs = [sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]],\n                          sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]],\n                          sum(distance_matrix_3[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_3[temp_solution[-1], temp_solution[0]]]\n\n        # Apply inversion if it improves at least one objective\n        if any(inverted_costs[i] < original_costs[i] for i in range(3)):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 216,
        "algorithm": "{The algorithm intelligently selects a solution from the archive by prioritizing those with the highest potential for improvement across all three objectives, then applies a hybrid local search operator that combines 2-opt swaps with a novel multi-objective edge insertion heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # 2-opt swap\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective edge insertion\n    for _ in range(3):  # Perform 3 edge insertions\n        # Select a random edge to break\n        a, b = sorted(random.sample(range(n), 2))\n        node_a, node_b = new_solution[a], new_solution[b]\n\n        # Find insertion point that minimizes the sum of all three objectives\n        min_cost = float('inf')\n        best_insert_pos = -1\n\n        for k in range(n):\n            if k == a or k == b or k == (a+1)%n or k == (b+1)%n:\n                continue\n\n            # Calculate cost for inserting between k and k+1\n            prev_node = new_solution[k]\n            next_node = new_solution[(k+1)%n]\n\n            cost = (distance_matrix_1[prev_node, node_a] + distance_matrix_1[node_a, node_b] + distance_matrix_1[node_b, next_node] -\n                    distance_matrix_1[prev_node, next_node])\n\n            cost += (distance_matrix_2[prev_node, node_a] + distance_matrix_2[node_a, node_b] + distance_matrix_2[node_b, next_node] -\n                     distance_matrix_2[prev_node, next_node])\n\n            cost += (distance_matrix_3[prev_node, node_a] + distance_matrix_3[node_a, node_b] + distance_matrix_3[node_b, next_node] -\n                     distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_insert_pos = k\n\n        if best_insert_pos != -1:\n            # Perform the insertion\n            segment = new_solution[a:b+1]\n            new_solution = np.concatenate([\n                new_solution[:best_insert_pos+1],\n                segment,\n                new_solution[best_insert_pos+1:]\n            ])\n\n    return new_solution\n\n",
        "score": [
            -0.6948897447419391,
            0.8856941342353821
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # 2-opt swap\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective edge insertion\n    for _ in range(3):  # Perform 3 edge insertions\n        # Select a random edge to break\n        a, b = sorted(random.sample(range(n), 2))\n        node_a, node_b = new_solution[a], new_solution[b]\n\n        # Find insertion point that minimizes the sum of all three objectives\n        min_cost = float('inf')\n        best_insert_pos = -1\n\n        for k in range(n):\n            if k == a or k == b or k == (a+1)%n or k == (b+1)%n:\n                continue\n\n            # Calculate cost for inserting between k and k+1\n            prev_node = new_solution[k]\n            next_node = new_solution[(k+1)%n]\n\n            cost = (distance_matrix_1[prev_node, node_a] + distance_matrix_1[node_a, node_b] + distance_matrix_1[node_b, next_node] -\n                    distance_matrix_1[prev_node, next_node])\n\n            cost += (distance_matrix_2[prev_node, node_a] + distance_matrix_2[node_a, node_b] + distance_matrix_2[node_b, next_node] -\n                     distance_matrix_2[prev_node, next_node])\n\n            cost += (distance_matrix_3[prev_node, node_a] + distance_matrix_3[node_a, node_b] + distance_matrix_3[node_b, next_node] -\n                     distance_matrix_3[prev_node, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_insert_pos = k\n\n        if best_insert_pos != -1:\n            # Perform the insertion\n            segment = new_solution[a:b+1]\n            new_solution = np.concatenate([\n                new_solution[:best_insert_pos+1],\n                segment,\n                new_solution[best_insert_pos+1:]\n            ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 217,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1.0 / (obj[0] + obj[1] + obj[2]) for _, obj in archive]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: 2-opt with multi-objective segment reversal\n    n = len(base_solution)\n    for _ in range(10):  # Perform a small number of local search steps\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Decide whether to reverse the segment based on multi-objective improvement\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        reversed_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[segment[-1], new_solution[(j+1)%n]] +\n                         distance_matrix_2[segment[-1], new_solution[(j+1)%n]] +\n                         distance_matrix_3[segment[-1], new_solution[(j+1)%n]])\n\n        if reversed_cost < current_cost:\n            new_solution[i:j+1] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7910210102039359,
            3.187365472316742
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1.0 / (obj[0] + obj[1] + obj[2]) for _, obj in archive]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: 2-opt with multi-objective segment reversal\n    n = len(base_solution)\n    for _ in range(10):  # Perform a small number of local search steps\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Decide whether to reverse the segment based on multi-objective improvement\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        reversed_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[segment[-1], new_solution[(j+1)%n]] +\n                         distance_matrix_2[segment[-1], new_solution[(j+1)%n]] +\n                         distance_matrix_3[segment[-1], new_solution[(j+1)%n]])\n\n        if reversed_cost < current_cost:\n            new_solution[i:j+1] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 218,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, base_objectives = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and node relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose a segment to modify\n    start, end = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt within the selected segment\n    segment = new_solution[start:end]\n    segment = segment[::-1]  # Reverse the segment\n    new_solution[start:end] = segment\n\n    # Relocate a randomly selected node to a new position\n    node_to_relocate = np.random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node_to_relocate))\n    new_pos = np.random.randint(0, len(new_solution) + 1)\n    new_solution = np.insert(new_solution, new_pos, node_to_relocate)\n\n    return new_solution\n\n",
        "score": [
            -0.6455081001193173,
            1.7601975440979003
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, base_objectives = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator combining 2-opt and node relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose a segment to modify\n    start, end = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt within the selected segment\n    segment = new_solution[start:end]\n    segment = segment[::-1]  # Reverse the segment\n    new_solution[start:end] = segment\n\n    # Relocate a randomly selected node to a new position\n    node_to_relocate = np.random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node_to_relocate))\n    new_pos = np.random.randint(0, len(new_solution) + 1)\n    new_solution = np.insert(new_solution, new_pos, node_to_relocate)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 219,
        "algorithm": "{This heuristic function selects a promising solution from the archive by prioritizing those with the highest potential for improvement across multiple objectives, then applies a hybrid local search operator combining 2-opt and node insertion moves to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by the sum of objectives to prioritize those with potential for improvement\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select among top 3 or fewer\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt or node insertion\n    if random.random() < 0.5:\n        # 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Node insertion move\n        if n > 2:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            while j == i or j == (i+1)%n or j == (i-1)%n:\n                j = random.randint(0, n-1)\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    return new_solution\n\n",
        "score": [
            -0.6727122592891183,
            1.2718898177146911
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by the sum of objectives to prioritize those with potential for improvement\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select among top 3 or fewer\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt or node insertion\n    if random.random() < 0.5:\n        # 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Node insertion move\n        if n > 2:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            while j == i or j == (i+1)%n or j == (i-1)%n:\n                j = random.randint(0, n-1)\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 220,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.array([sum(obj) for _, obj in archive]) / sum(sum(obj) for _, obj in archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Perform 2-opt swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware refinement: swap nodes that improve at least one objective\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a == b:\n            continue\n\n        # Calculate original and new distances for all three objectives\n        orig_dist1 = distance_matrix_1[base_solution[a-1], base_solution[a]] + distance_matrix_1[base_solution[b-1], base_solution[b]]\n        new_dist1 = distance_matrix_1[base_solution[a-1], base_solution[b]] + distance_matrix_1[base_solution[b-1], base_solution[a]]\n\n        orig_dist2 = distance_matrix_2[base_solution[a-1], base_solution[a]] + distance_matrix_2[base_solution[b-1], base_solution[b]]\n        new_dist2 = distance_matrix_2[base_solution[a-1], base_solution[b]] + distance_matrix_2[base_solution[b-1], base_solution[a]]\n\n        orig_dist3 = distance_matrix_3[base_solution[a-1], base_solution[a]] + distance_matrix_3[base_solution[b-1], base_solution[b]]\n        new_dist3 = distance_matrix_3[base_solution[a-1], base_solution[b]] + distance_matrix_3[base_solution[b-1], base_solution[a]]\n\n        # Accept swap if it improves at least one objective\n        if (new_dist1 < orig_dist1 or new_dist2 < orig_dist2 or new_dist3 < orig_dist3):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7063165341376918,
            2.2339852094650268
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.array([sum(obj) for _, obj in archive]) / sum(sum(obj) for _, obj in archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Perform 2-opt swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware refinement: swap nodes that improve at least one objective\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a == b:\n            continue\n\n        # Calculate original and new distances for all three objectives\n        orig_dist1 = distance_matrix_1[base_solution[a-1], base_solution[a]] + distance_matrix_1[base_solution[b-1], base_solution[b]]\n        new_dist1 = distance_matrix_1[base_solution[a-1], base_solution[b]] + distance_matrix_1[base_solution[b-1], base_solution[a]]\n\n        orig_dist2 = distance_matrix_2[base_solution[a-1], base_solution[a]] + distance_matrix_2[base_solution[b-1], base_solution[b]]\n        new_dist2 = distance_matrix_2[base_solution[a-1], base_solution[b]] + distance_matrix_2[base_solution[b-1], base_solution[a]]\n\n        orig_dist3 = distance_matrix_3[base_solution[a-1], base_solution[a]] + distance_matrix_3[base_solution[b-1], base_solution[b]]\n        new_dist3 = distance_matrix_3[base_solution[a-1], base_solution[b]] + distance_matrix_3[base_solution[b-1], base_solution[a]]\n\n        # Accept swap if it improves at least one objective\n        if (new_dist1 < orig_dist1 or new_dist2 < orig_dist2 or new_dist3 < orig_dist3):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 221,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    combined_objectives = [sum(obj) for obj in objectives]\n    probabilities = [1.0 / (1.0 + combined) for combined in combined_objectives]\n    total_prob = sum(probabilities)\n    probabilities = [p / total_prob for p in probabilities]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    # Determine which objective to prioritize for the segment\n    obj_idx = random.randint(0, 2)\n    if obj_idx == 0:\n        dist_matrix = distance_matrix_1\n    elif obj_idx == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the best possible insertion point for the segment in the selected objective space\n    best_cost = float('inf')\n    best_k = -1\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n        cost = 0\n        if k < i:\n            # Insert segment [i:j] before k\n            cost += dist_matrix[new_solution[k], new_solution[i]]\n            cost += dist_matrix[new_solution[j], new_solution[(k + 1) % n]]\n        else:\n            # Insert segment [i:j] after k\n            cost += dist_matrix[new_solution[k], new_solution[i]]\n            cost += dist_matrix[new_solution[j], new_solution[(k + 1) % n]]\n\n        if cost < best_cost:\n            best_cost = cost\n            best_k = k\n\n    if best_k != -1:\n        # Perform the insertion\n        segment = new_solution[i:j+1]\n        if best_k < i:\n            new_solution = np.concatenate([new_solution[:best_k+1], segment, new_solution[best_k+1:i], new_solution[j+1:]])\n        else:\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:best_k+1], segment, new_solution[best_k+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7815498488265855,
            1.2227221488952638
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    combined_objectives = [sum(obj) for obj in objectives]\n    probabilities = [1.0 / (1.0 + combined) for combined in combined_objectives]\n    total_prob = sum(probabilities)\n    probabilities = [p / total_prob for p in probabilities]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    # Determine which objective to prioritize for the segment\n    obj_idx = random.randint(0, 2)\n    if obj_idx == 0:\n        dist_matrix = distance_matrix_1\n    elif obj_idx == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the best possible insertion point for the segment in the selected objective space\n    best_cost = float('inf')\n    best_k = -1\n\n    for k in range(n):\n        if k == i or k == j:\n            continue\n        cost = 0\n        if k < i:\n            # Insert segment [i:j] before k\n            cost += dist_matrix[new_solution[k], new_solution[i]]\n            cost += dist_matrix[new_solution[j], new_solution[(k + 1) % n]]\n        else:\n            # Insert segment [i:j] after k\n            cost += dist_matrix[new_solution[k], new_solution[i]]\n            cost += dist_matrix[new_solution[j], new_solution[(k + 1) % n]]\n\n        if cost < best_cost:\n            best_cost = cost\n            best_k = k\n\n    if best_k != -1:\n        # Perform the insertion\n        segment = new_solution[i:j+1]\n        if best_k < i:\n            new_solution = np.concatenate([new_solution[:best_k+1], segment, new_solution[best_k+1:i], new_solution[j+1:]])\n        else:\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:best_k+1], segment, new_solution[best_k+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 222,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Perform a 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware perturbation: swap nodes with high variance in objectives\n    if random.random() < 0.3:  # 30% chance to apply objective-aware swap\n        # Calculate objective variances for each node\n        variances = []\n        for node in new_solution:\n            costs = [\n                distance_matrix_1[node, new_solution[(i+1)%n]],\n                distance_matrix_2[node, new_solution[(i+1)%n]],\n                distance_matrix_3[node, new_solution[(i+1)%n]]\n            ]\n            variances.append(np.var(costs))\n\n        # Find nodes with highest variance (most \"problematic\" in objectives)\n        sorted_nodes = sorted(zip(new_solution, variances), key=lambda x: -x[1])\n        problematic_nodes = [node for node, var in sorted_nodes[:3]]  # top 3 problematic nodes\n\n        if len(problematic_nodes) >= 2:\n            # Swap two problematic nodes\n            a, b = random.sample(problematic_nodes, 2)\n            a_idx, b_idx = np.where(new_solution == a)[0][0], np.where(new_solution == b)[0][0]\n            new_solution[a_idx], new_solution[b_idx] = new_solution[b_idx], new_solution[a_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7460568331533433,
            2.084558534622192
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Perform a 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware perturbation: swap nodes with high variance in objectives\n    if random.random() < 0.3:  # 30% chance to apply objective-aware swap\n        # Calculate objective variances for each node\n        variances = []\n        for node in new_solution:\n            costs = [\n                distance_matrix_1[node, new_solution[(i+1)%n]],\n                distance_matrix_2[node, new_solution[(i+1)%n]],\n                distance_matrix_3[node, new_solution[(i+1)%n]]\n            ]\n            variances.append(np.var(costs))\n\n        # Find nodes with highest variance (most \"problematic\" in objectives)\n        sorted_nodes = sorted(zip(new_solution, variances), key=lambda x: -x[1])\n        problematic_nodes = [node for node, var in sorted_nodes[:3]]  # top 3 problematic nodes\n\n        if len(problematic_nodes) >= 2:\n            # Swap two problematic nodes\n            a, b = random.sample(problematic_nodes, 2)\n            a_idx, b_idx = np.where(new_solution == a)[0][0], np.where(new_solution == b)[0][0]\n            new_solution[a_idx], new_solution[b_idx] = new_solution[b_idx], new_solution[a_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 223,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    i, j = np.random.randint(0, n, size=2)\n    if i > j:\n        i, j = j, i\n\n    # Apply 2-opt for local improvement\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: identify the worst edge in any objective space\n    worst_edge_idx = -1\n    worst_edge_value = -1\n    for k in range(n):\n        node1 = base_solution[k]\n        node2 = base_solution[(k+1) % n]\n        edge_values = [\n            distance_matrix_1[node1, node2],\n            distance_matrix_2[node1, node2],\n            distance_matrix_3[node1, node2]\n        ]\n        max_edge_value = max(edge_values)\n        if max_edge_value > worst_edge_value:\n            worst_edge_value = max_edge_value\n            worst_edge_idx = k\n\n    # Perform a swap to replace the worst edge\n    if worst_edge_idx != -1:\n        l = np.random.randint(0, n)\n        if l != worst_edge_idx and l != (worst_edge_idx + 1) % n:\n            new_solution[worst_edge_idx], new_solution[l] = new_solution[l], new_solution[worst_edge_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7718879409872403,
            1.624856460094452
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    i, j = np.random.randint(0, n, size=2)\n    if i > j:\n        i, j = j, i\n\n    # Apply 2-opt for local improvement\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: identify the worst edge in any objective space\n    worst_edge_idx = -1\n    worst_edge_value = -1\n    for k in range(n):\n        node1 = base_solution[k]\n        node2 = base_solution[(k+1) % n]\n        edge_values = [\n            distance_matrix_1[node1, node2],\n            distance_matrix_2[node1, node2],\n            distance_matrix_3[node1, node2]\n        ]\n        max_edge_value = max(edge_values)\n        if max_edge_value > worst_edge_value:\n            worst_edge_value = max_edge_value\n            worst_edge_idx = k\n\n    # Perform a swap to replace the worst edge\n    if worst_edge_idx != -1:\n        l = np.random.randint(0, n)\n        if l != worst_edge_idx and l != (worst_edge_idx + 1) % n:\n            new_solution[worst_edge_idx], new_solution[l] = new_solution[l], new_solution[worst_edge_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 224,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n\n    # Apply a hybrid local search combining 2-opt and node relocation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    k = np.random.randint(1, n)\n\n    # Perform 2-opt swap\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node relocation\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.46199916315455897,
            1.7999709129333497
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n\n    # Apply a hybrid local search combining 2-opt and node relocation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    k = np.random.randint(1, n)\n\n    # Perform 2-opt swap\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node relocation\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 225,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid 3-objective local search operator\n    new_solution = selected_solution.copy()\n\n    # Step 1: Randomly select two segments to reverse (2-opt move)\n    i, j = sorted(random.sample(range(len(new_solution)), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Apply a 3-objective-aware swap: select two nodes and swap them if it improves at least one objective\n    a, b = random.sample(range(len(new_solution)), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n    # Calculate the change in each objective\n    def calculate_objective(sol):\n        cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(len(sol)-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(len(sol)-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(len(sol)-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    original_obj = calculate_objective(new_solution)\n    temp_obj = calculate_objective(temp_solution)\n\n    # Accept swap if it improves at least one objective\n    if any(temp_obj[i] < original_obj[i] for i in range(3)):\n        new_solution = temp_solution\n\n    # Step 3: Apply a 3-objective-aware 2-opt with a bias toward the objective with the highest relative improvement\n    i, j = sorted(random.sample(range(len(new_solution)), 2))\n    temp_solution = new_solution.copy()\n    temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n    temp_obj = calculate_objective(temp_solution)\n\n    # Calculate relative improvements\n    improvements = [(original_obj[k] - temp_obj[k]) / original_obj[k] if original_obj[k] > 0 else 0 for k in range(3)]\n    best_obj = np.argmax(improvements)\n\n    # Accept 2-opt if it improves the best objective\n    if improvements[best_obj] > 0:\n        new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7368265786487285,
            1.850621223449707
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid 3-objective local search operator\n    new_solution = selected_solution.copy()\n\n    # Step 1: Randomly select two segments to reverse (2-opt move)\n    i, j = sorted(random.sample(range(len(new_solution)), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Apply a 3-objective-aware swap: select two nodes and swap them if it improves at least one objective\n    a, b = random.sample(range(len(new_solution)), 2)\n    temp_solution = new_solution.copy()\n    temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n    # Calculate the change in each objective\n    def calculate_objective(sol):\n        cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(len(sol)-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(len(sol)-1)) + distance_matrix_2[sol[-1], sol[0]]\n        cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(len(sol)-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (cost1, cost2, cost3)\n\n    original_obj = calculate_objective(new_solution)\n    temp_obj = calculate_objective(temp_solution)\n\n    # Accept swap if it improves at least one objective\n    if any(temp_obj[i] < original_obj[i] for i in range(3)):\n        new_solution = temp_solution\n\n    # Step 3: Apply a 3-objective-aware 2-opt with a bias toward the objective with the highest relative improvement\n    i, j = sorted(random.sample(range(len(new_solution)), 2))\n    temp_solution = new_solution.copy()\n    temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n    temp_obj = calculate_objective(temp_solution)\n\n    # Calculate relative improvements\n    improvements = [(original_obj[k] - temp_obj[k]) / original_obj[k] if original_obj[k] > 0 else 0 for k in range(3)]\n    best_obj = np.argmax(improvements)\n\n    # Accept 2-opt if it improves the best objective\n    if improvements[best_obj] > 0:\n        new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 226,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0]\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware move selection\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse segment\n\n    # Further refine by selecting the best 2-opt move based on the worst objective\n    worst_obj = np.argmax([sum(x[1]) for x in archive])\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n        # Evaluate the candidate's worst objective\n        obj1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n        obj2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n        obj3 = sum(distance_matrix_3[candidate[k], candidate[(k+1)%n]] for k in range(n))\n        worst_candidate = max(obj1, obj2, obj3)\n        # Accept if the worst objective improves\n        if worst_candidate < max(archive[worst_obj][1]):\n            new_solution = candidate\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7295560871866723,
            1.89889954328537
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0]\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware move selection\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse segment\n\n    # Further refine by selecting the best 2-opt move based on the worst objective\n    worst_obj = np.argmax([sum(x[1]) for x in archive])\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n        # Evaluate the candidate's worst objective\n        obj1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n        obj2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n        obj3 = sum(distance_matrix_3[candidate[k], candidate[(k+1)%n]] for k in range(n))\n        worst_candidate = max(obj1, obj2, obj3)\n        # Accept if the worst objective improves\n        if worst_candidate < max(archive[worst_obj][1]):\n            new_solution = candidate\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 227,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([max(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: apply a combination of 2-opt and node insertion to improve all objectives\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to apply 2-opt\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select a node to reinsert (node insertion)\n    k = np.random.randint(n)\n    node_to_insert = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = np.random.randint(n-1)\n    new_solution = np.insert(new_solution, pos, node_to_insert)\n\n    # Ensure feasibility (no duplicates, all nodes included)\n    if len(np.unique(new_solution)) != n:\n        raise ValueError(\"Generated solution is invalid.\")\n\n    return new_solution\n\n",
        "score": [
            -0.4868760802042675,
            1.7492950439453125
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([max(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: apply a combination of 2-opt and node insertion to improve all objectives\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to apply 2-opt\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select a node to reinsert (node insertion)\n    k = np.random.randint(n)\n    node_to_insert = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = np.random.randint(n-1)\n    new_solution = np.insert(new_solution, pos, node_to_insert)\n\n    # Ensure feasibility (no duplicates, all nodes included)\n    if len(np.unique(new_solution)) != n:\n        raise ValueError(\"Generated solution is invalid.\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 228,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # Combine 2-opt with a novel objective-aware edge selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Objective-aware edge selection: prefer edges that are critical in any objective\n    # Calculate the contribution of the edges to the total distance\n    edge_contributions = []\n    for k in range(n - 1):\n        node1, node2 = new_solution[k], new_solution[k + 1]\n        contrib1 = distance_matrix_1[node1, node2] + distance_matrix_2[node1, node2] + distance_matrix_3[node1, node2]\n        contrib2 = distance_matrix_1[node2, new_solution[(k + 2) % n]] + distance_matrix_2[node2, new_solution[(k + 2) % n]] + distance_matrix_3[node2, new_solution[(k + 2) % n]]\n        edge_contributions.append(contrib1 + contrib2)\n\n    # Select edges with high contribution for potential improvement\n    if edge_contributions:\n        critical_edges = np.argsort(edge_contributions)[-max(2, len(edge_contributions) // 3):]\n        i, j = sorted(random.sample(list(critical_edges), 2))\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    # The swap operation already maintains feasibility\n\n    return new_solution\n\n",
        "score": [
            -0.675101560709146,
            3.620773708820343
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # Combine 2-opt with a novel objective-aware edge selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Objective-aware edge selection: prefer edges that are critical in any objective\n    # Calculate the contribution of the edges to the total distance\n    edge_contributions = []\n    for k in range(n - 1):\n        node1, node2 = new_solution[k], new_solution[k + 1]\n        contrib1 = distance_matrix_1[node1, node2] + distance_matrix_2[node1, node2] + distance_matrix_3[node1, node2]\n        contrib2 = distance_matrix_1[node2, new_solution[(k + 2) % n]] + distance_matrix_2[node2, new_solution[(k + 2) % n]] + distance_matrix_3[node2, new_solution[(k + 2) % n]]\n        edge_contributions.append(contrib1 + contrib2)\n\n    # Select edges with high contribution for potential improvement\n    if edge_contributions:\n        critical_edges = np.argsort(edge_contributions)[-max(2, len(edge_contributions) // 3):]\n        i, j = sorted(random.sample(list(critical_edges), 2))\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    # The swap operation already maintains feasibility\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 229,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best overall objective (sum of all objectives)\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Identify edges with worst contributions in each objective\n    worst_edges = []\n    for i in range(len(best_solution)-1):\n        node1, node2 = best_solution[i], best_solution[i+1]\n        cost1 = distance_matrix_1[node1, node2]\n        cost2 = distance_matrix_2[node1, node2]\n        cost3 = distance_matrix_3[node1, node2]\n        worst_edges.append((i, (cost1, cost2, cost3)))\n\n    # Sort edges by their worst objective contribution\n    worst_edges.sort(key=lambda x: min(x[1]), reverse=True)\n\n    # Perform hybrid local search: 2-opt with edge exchange for the worst edges\n    new_solution = best_solution.copy()\n    for edge_idx, _ in worst_edges[:3]:  # Focus on top 3 worst edges\n        # Try 2-opt move\n        if edge_idx < len(new_solution)-3:\n            # Perform 2-opt swap\n            i, j = edge_idx, edge_idx + 2\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n            # Check if the move improves any objective\n            improved = False\n            for k in range(len(new_solution)-1):\n                node1, node2 = new_solution[k], new_solution[k+1]\n                old_cost1 = distance_matrix_1[best_solution[k], best_solution[k+1]]\n                new_cost1 = distance_matrix_1[node1, node2]\n                if new_cost1 < old_cost1:\n                    improved = True\n                    break\n            if not improved:\n                # Revert if no improvement\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n        # Try edge exchange with a random neighbor\n        if edge_idx < len(new_solution)-2:\n            # Select a random node to exchange\n            rand_idx = np.random.randint(1, len(new_solution)-1)\n            if rand_idx != edge_idx and rand_idx != edge_idx+1:\n                # Perform edge exchange\n                new_solution[edge_idx+1], new_solution[rand_idx] = new_solution[rand_idx], new_solution[edge_idx+1]\n\n                # Check if the move improves any objective\n                improved = False\n                for k in range(len(new_solution)-1):\n                    node1, node2 = new_solution[k], new_solution[k+1]\n                    old_cost1 = distance_matrix_1[best_solution[k], best_solution[k+1]]\n                    new_cost1 = distance_matrix_1[node1, node2]\n                    if new_cost1 < old_cost1:\n                        improved = True\n                        break\n                if not improved:\n                    # Revert if no improvement\n                    new_solution[edge_idx+1], new_solution[rand_idx] = new_solution[rand_idx], new_solution[edge_idx+1]\n\n    return new_solution\n\n",
        "score": [
            -0.6687769140535271,
            1.3448994278907775
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best overall objective (sum of all objectives)\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Identify edges with worst contributions in each objective\n    worst_edges = []\n    for i in range(len(best_solution)-1):\n        node1, node2 = best_solution[i], best_solution[i+1]\n        cost1 = distance_matrix_1[node1, node2]\n        cost2 = distance_matrix_2[node1, node2]\n        cost3 = distance_matrix_3[node1, node2]\n        worst_edges.append((i, (cost1, cost2, cost3)))\n\n    # Sort edges by their worst objective contribution\n    worst_edges.sort(key=lambda x: min(x[1]), reverse=True)\n\n    # Perform hybrid local search: 2-opt with edge exchange for the worst edges\n    new_solution = best_solution.copy()\n    for edge_idx, _ in worst_edges[:3]:  # Focus on top 3 worst edges\n        # Try 2-opt move\n        if edge_idx < len(new_solution)-3:\n            # Perform 2-opt swap\n            i, j = edge_idx, edge_idx + 2\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n            # Check if the move improves any objective\n            improved = False\n            for k in range(len(new_solution)-1):\n                node1, node2 = new_solution[k], new_solution[k+1]\n                old_cost1 = distance_matrix_1[best_solution[k], best_solution[k+1]]\n                new_cost1 = distance_matrix_1[node1, node2]\n                if new_cost1 < old_cost1:\n                    improved = True\n                    break\n            if not improved:\n                # Revert if no improvement\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n        # Try edge exchange with a random neighbor\n        if edge_idx < len(new_solution)-2:\n            # Select a random node to exchange\n            rand_idx = np.random.randint(1, len(new_solution)-1)\n            if rand_idx != edge_idx and rand_idx != edge_idx+1:\n                # Perform edge exchange\n                new_solution[edge_idx+1], new_solution[rand_idx] = new_solution[rand_idx], new_solution[edge_idx+1]\n\n                # Check if the move improves any objective\n                improved = False\n                for k in range(len(new_solution)-1):\n                    node1, node2 = new_solution[k], new_solution[k+1]\n                    old_cost1 = distance_matrix_1[best_solution[k], best_solution[k+1]]\n                    new_cost1 = distance_matrix_1[node1, node2]\n                    if new_cost1 < old_cost1:\n                        improved = True\n                        break\n                if not improved:\n                    # Revert if no improvement\n                    new_solution[edge_idx+1], new_solution[rand_idx] = new_solution[rand_idx], new_solution[edge_idx+1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 230,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]) / 3)[0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # Randomly select a segment of the tour and reverse it (2-opt)\n    n = len(selected_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution = selected_solution.copy()\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 3: Ensure feasibility (already ensured by the 2-opt operation)\n    return new_solution\n\n",
        "score": [
            -0.6025904344334745,
            1.627057719230652
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]) / 3)[0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # Randomly select a segment of the tour and reverse it (2-opt)\n    n = len(selected_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution = selected_solution.copy()\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 3: Ensure feasibility (already ensured by the 2-opt operation)\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 231,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search: 2-opt with probabilistic edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    start = np.random.randint(0, n)\n    end = np.random.randint(start + 1, min(start + 10, n + 1))  # Limit segment size for efficiency\n    segment = new_solution[start:end]\n\n    # Reverse the segment (2-opt)\n    new_solution[start:end] = segment[::-1]\n\n    # Probabilistically swap edges to optimize across objectives\n    for i in range(n):\n        if np.random.rand() < 0.3:  # 30% chance to swap\n            j = np.random.randint(0, n)\n            if i != j:\n                # Evaluate swap impact across all three objectives\n                original_cost = (\n                    distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_3[new_solution[j-1], new_solution[j]]\n                )\n                swapped_cost = (\n                    distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                    distance_matrix_3[new_solution[j-1], new_solution[i]]\n                )\n                if swapped_cost < original_cost:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6536186244318164,
            1.6042163968086243
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search: 2-opt with probabilistic edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    start = np.random.randint(0, n)\n    end = np.random.randint(start + 1, min(start + 10, n + 1))  # Limit segment size for efficiency\n    segment = new_solution[start:end]\n\n    # Reverse the segment (2-opt)\n    new_solution[start:end] = segment[::-1]\n\n    # Probabilistically swap edges to optimize across objectives\n    for i in range(n):\n        if np.random.rand() < 0.3:  # 30% chance to swap\n            j = np.random.randint(0, n)\n            if i != j:\n                # Evaluate swap impact across all three objectives\n                original_cost = (\n                    distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_3[new_solution[j-1], new_solution[j]]\n                )\n                swapped_cost = (\n                    distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                    distance_matrix_3[new_solution[j-1], new_solution[i]]\n                )\n                if swapped_cost < original_cost:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 232,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high crowding distance or low objective values, then applies a hybrid local search combining 2-opt, 3-opt, and a novel multi-objective edge swap operator to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (high crowding distance or low objective values)\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n    selected_obj = archive[selected_idx][1]\n\n    # Generate neighbor using hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt or 3-opt with probability 0.7\n    if np.random.random() < 0.7:\n        # 2-opt\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # 3-opt\n        i, j, k = np.random.choice(n, 3, replace=False)\n        i, j, k = sorted([i, j, k])\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Apply multi-objective edge swap with probability 0.3\n    if np.random.random() < 0.3:\n        # Select two edges to swap\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n\n        # Calculate current and potential objectives\n        current_obj = selected_obj\n        new_obj = (\n            current_obj[0] - distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[j-1], new_solution[j]] +\n            distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]],\n            current_obj[1] - distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[j-1], new_solution[j]] +\n            distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]],\n            current_obj[2] - distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[j-1], new_solution[j]] +\n            distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]]\n        )\n\n        # Accept if at least one objective improves\n        if any(new_o < current_o for new_o, current_o in zip(new_obj, current_obj)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6724335266342434,
            1.6834563970565797
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (high crowding distance or low objective values)\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n    selected_obj = archive[selected_idx][1]\n\n    # Generate neighbor using hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt or 3-opt with probability 0.7\n    if np.random.random() < 0.7:\n        # 2-opt\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # 3-opt\n        i, j, k = np.random.choice(n, 3, replace=False)\n        i, j, k = sorted([i, j, k])\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Apply multi-objective edge swap with probability 0.3\n    if np.random.random() < 0.3:\n        # Select two edges to swap\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n\n        # Calculate current and potential objectives\n        current_obj = selected_obj\n        new_obj = (\n            current_obj[0] - distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[j-1], new_solution[j]] +\n            distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]],\n            current_obj[1] - distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[j-1], new_solution[j]] +\n            distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]],\n            current_obj[2] - distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[j-1], new_solution[j]] +\n            distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]]\n        )\n\n        # Accept if at least one objective improves\n        if any(new_o < current_o for new_o, current_o in zip(new_obj, current_obj)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 233,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0]\n    new_solution = best_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt + random swap\n    n = len(new_solution)\n    if n < 2:\n        return new_solution\n\n    # Randomly choose a segment to apply 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes to ensure diversity\n    a, b = random.sample(range(n), 2)\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7744293536183662,
            1.289122474193573
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0]\n    new_solution = best_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt + random swap\n    n = len(new_solution)\n    if n < 2:\n        return new_solution\n\n    # Randomly choose a segment to apply 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes to ensure diversity\n    a, b = random.sample(range(n), 2)\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 234,
        "algorithm": "{A novel hybrid local search strategy intelligently selects a promising solution from the archive based on objective diversity and applies a multi-objective 3-opt move, combined with a randomized edge swap, to generate a neighbor solution that balances improvement across all three objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    objectives = np.array([obj for _, obj in archive])\n    mean_obj = np.mean(objectives, axis=0)\n    diversity_scores = np.sum(np.abs(objectives - mean_obj), axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt move for one of the objectives\n    obj_idx = random.choice([0, 1, 2])\n    distance_matrices = [distance_matrix_1, distance_matrix_2, distance_matrix_3]\n    distance_matrix = distance_matrices[obj_idx]\n\n    # Randomly select three edges to reverse\n    if n >= 3:\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Reverse the segment between j and k\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Apply randomized edge swap to improve other objectives\n    if n >= 2:\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution is a valid tour\n    if not (np.all(np.sort(new_solution) == np.arange(n))):\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6135752355614519,
            1.0955234050750733
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    objectives = np.array([obj for _, obj in archive])\n    mean_obj = np.mean(objectives, axis=0)\n    diversity_scores = np.sum(np.abs(objectives - mean_obj), axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt move for one of the objectives\n    obj_idx = random.choice([0, 1, 2])\n    distance_matrices = [distance_matrix_1, distance_matrix_2, distance_matrix_3]\n    distance_matrix = distance_matrices[obj_idx]\n\n    # Randomly select three edges to reverse\n    if n >= 3:\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Reverse the segment between j and k\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Apply randomized edge swap to improve other objectives\n    if n >= 2:\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution is a valid tour\n    if not (np.all(np.sort(new_solution) == np.arange(n))):\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 235,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.std(objectives, axis=0)\n        selected_idx = np.argmax(diversity)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Determine which objective to prioritize for edge selection\n    obj_weights = np.array([obj for _, obj in archive][0])  # Use first solution's objectives as weights\n    obj_weights = obj_weights / np.sum(obj_weights)  # Normalize\n\n    # Select edges based on weighted combination of objectives\n    edge_scores = (obj_weights[0] * distance_matrix_1[new_solution[i], new_solution[j]] +\n                   obj_weights[1] * distance_matrix_2[new_solution[i], new_solution[j]] +\n                   obj_weights[2] * distance_matrix_3[new_solution[i], new_solution[j]])\n\n    # Perform 2-opt with the selected edges\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to standard 2-opt if feasibility is violated\n        new_solution = base_solution.copy()\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5783455264807895,
            1.927348506450653
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.std(objectives, axis=0)\n        selected_idx = np.argmax(diversity)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Determine which objective to prioritize for edge selection\n    obj_weights = np.array([obj for _, obj in archive][0])  # Use first solution's objectives as weights\n    obj_weights = obj_weights / np.sum(obj_weights)  # Normalize\n\n    # Select edges based on weighted combination of objectives\n    edge_scores = (obj_weights[0] * distance_matrix_1[new_solution[i], new_solution[j]] +\n                   obj_weights[1] * distance_matrix_2[new_solution[i], new_solution[j]] +\n                   obj_weights[2] * distance_matrix_3[new_solution[i], new_solution[j]])\n\n    # Perform 2-opt with the selected edges\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to standard 2-opt if feasibility is violated\n        new_solution = base_solution.copy()\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 236,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]), reverse=True)\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(1, n), 2))\n\n    # Check if reversing the segment improves at least one objective\n    def calculate_objective(sol):\n        obj1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        obj2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        obj3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (obj1, obj2, obj3)\n\n    current_obj = calculate_objective(new_solution)\n    reversed_segment = new_solution.copy()\n    reversed_segment[i:j] = reversed_segment[i:j][::-1]\n    new_obj = calculate_objective(reversed_segment)\n\n    if any(new_o < cur_o for new_o, cur_o in zip(new_obj, current_obj)):\n        new_solution = reversed_segment\n\n    # Apply a small perturbation to escape local optima\n    if random.random() < 0.3:\n        k, l = sorted(random.sample(range(1, n), 2))\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.6156838014737367,
            1.5608601331710816
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]), reverse=True)\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(1, n), 2))\n\n    # Check if reversing the segment improves at least one objective\n    def calculate_objective(sol):\n        obj1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        obj2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        obj3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (obj1, obj2, obj3)\n\n    current_obj = calculate_objective(new_solution)\n    reversed_segment = new_solution.copy()\n    reversed_segment[i:j] = reversed_segment[i:j][::-1]\n    new_obj = calculate_objective(reversed_segment)\n\n    if any(new_o < cur_o for new_o, cur_o in zip(new_obj, current_obj)):\n        new_solution = reversed_segment\n\n    # Apply a small perturbation to escape local optima\n    if random.random() < 0.3:\n        k, l = sorted(random.sample(range(1, n), 2))\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 237,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # Combine 2-opt with a novel objective-aware perturbation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on the worst objective\n    objectives = archive_sorted[0][1]\n    worst_obj_index = np.argmax(objectives)\n\n    # Select two random edges to swap\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i == 0 and j == n-1:\n        # Avoid swapping the first and last nodes\n        i, j = 1, 2\n\n    # Perform the swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Apply an objective-aware perturbation\n    # Identify critical nodes in the worst objective\n    critical_nodes = []\n    for k in range(n):\n        node = new_solution[k]\n        next_node = new_solution[(k+1) % n]\n        if worst_obj_index == 0:\n            critical_nodes.append((k, distance_matrix_1[node, next_node]))\n        elif worst_obj_index == 1:\n            critical_nodes.append((k, distance_matrix_2[node, next_node]))\n        else:\n            critical_nodes.append((k, distance_matrix_3[node, next_node]))\n\n    # Sort critical nodes by edge cost in descending order\n    critical_nodes.sort(key=lambda x: -x[1])\n\n    # Perturb the top 2 critical nodes\n    for idx, _ in critical_nodes[:2]:\n        k = idx\n        l = (k + 1) % n\n        # Swap nodes at positions k and l\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.5823868082952578,
            1.8248311281204224
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # Combine 2-opt with a novel objective-aware perturbation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on the worst objective\n    objectives = archive_sorted[0][1]\n    worst_obj_index = np.argmax(objectives)\n\n    # Select two random edges to swap\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i == 0 and j == n-1:\n        # Avoid swapping the first and last nodes\n        i, j = 1, 2\n\n    # Perform the swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Apply an objective-aware perturbation\n    # Identify critical nodes in the worst objective\n    critical_nodes = []\n    for k in range(n):\n        node = new_solution[k]\n        next_node = new_solution[(k+1) % n]\n        if worst_obj_index == 0:\n            critical_nodes.append((k, distance_matrix_1[node, next_node]))\n        elif worst_obj_index == 1:\n            critical_nodes.append((k, distance_matrix_2[node, next_node]))\n        else:\n            critical_nodes.append((k, distance_matrix_3[node, next_node]))\n\n    # Sort critical nodes by edge cost in descending order\n    critical_nodes.sort(key=lambda x: -x[1])\n\n    # Perturb the top 2 critical nodes\n    for idx, _ in critical_nodes[:2]:\n        k = idx\n        l = (k + 1) % n\n        # Swap nodes at positions k and l\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 238,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = base_solution[i:j+1][::-1]\n\n    # Objective-aware swap: identify nodes with high impact on multiple objectives\n    objective_values = archive[selected_idx][1]\n    worst_obj = np.argmax(objective_values)\n\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the most critical edge in the worst objective\n    max_diff = -1\n    best_k, best_l = -1, -1\n    for k in range(n):\n        l = (k + 1) % n\n        current_cost = dist_matrix[base_solution[k], base_solution[l]]\n        for m in range(n):\n            if m == k or m == l or (m + 1) % n == k or (m + 1) % n == l:\n                continue\n            # Try swapping edges (k,l) and (m, m+1)\n            new_cost = dist_matrix[base_solution[k], base_solution[m]] + dist_matrix[base_solution[l], base_solution[(m+1)%n]]\n            diff = new_cost - current_cost\n            if diff > max_diff:\n                max_diff = diff\n                best_k, best_l = k, m\n\n    if best_k != -1:\n        # Perform the swap\n        m = (best_l + 1) % n\n        new_solution[best_k], new_solution[m] = new_solution[m], new_solution[best_k]\n\n    return new_solution\n\n",
        "score": [
            -0.7468690273438869,
            2.9988197565078734
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = base_solution[i:j+1][::-1]\n\n    # Objective-aware swap: identify nodes with high impact on multiple objectives\n    objective_values = archive[selected_idx][1]\n    worst_obj = np.argmax(objective_values)\n\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the most critical edge in the worst objective\n    max_diff = -1\n    best_k, best_l = -1, -1\n    for k in range(n):\n        l = (k + 1) % n\n        current_cost = dist_matrix[base_solution[k], base_solution[l]]\n        for m in range(n):\n            if m == k or m == l or (m + 1) % n == k or (m + 1) % n == l:\n                continue\n            # Try swapping edges (k,l) and (m, m+1)\n            new_cost = dist_matrix[base_solution[k], base_solution[m]] + dist_matrix[base_solution[l], base_solution[(m+1)%n]]\n            diff = new_cost - current_cost\n            if diff > max_diff:\n                max_diff = diff\n                best_k, best_l = k, m\n\n    if best_k != -1:\n        # Perform the swap\n        m = (best_l + 1) % n\n        new_solution[best_k], new_solution[m] = new_solution[m], new_solution[best_k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 239,
        "algorithm": "{A novel multi-objective local search heuristic that intelligently selects a solution from the archive based on Pareto dominance and diversity, then applies a hybrid 2-opt and edge insertion operator tailored to three objectives, ensuring feasibility by validating the tour structure and objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance and diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution, _ = archive[selected_idx]\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt for two objectives, edge insertion for the third\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly choose a segment to modify\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    # Apply 2-opt for two objectives (distance_matrix_1 and distance_matrix_2)\n    if random.random() < 0.5:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Edge insertion for the third objective (distance_matrix_3)\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        insert_pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or not np.array_equal(np.sort(unique_nodes), np.sort(base_solution)):\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7938882504063938,
            1.6041092991828918
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance and diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution, _ = archive[selected_idx]\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt for two objectives, edge insertion for the third\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly choose a segment to modify\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    # Apply 2-opt for two objectives (distance_matrix_1 and distance_matrix_2)\n    if random.random() < 0.5:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Edge insertion for the third objective (distance_matrix_3)\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        insert_pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or not np.array_equal(np.sort(unique_nodes), np.sort(base_solution)):\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 240,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with the best trade-offs across objectives, then applies a hybrid local search combining edge swaps and segment reversals to generate a neighbor solution while ensuring feasibility through intelligent randomness and feasibility checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution = archive[selected_idx][0].copy()\n    objectives = archive[selected_idx][1]\n\n    # Hybrid local search: combine edge swaps and segment reversals\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly decide between edge swap or segment reversal\n    if random.random() < 0.5:\n        # Edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If not feasible, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7869559358964732,
            1.4585349917411805
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution = archive[selected_idx][0].copy()\n    objectives = archive[selected_idx][1]\n\n    # Hybrid local search: combine edge swaps and segment reversals\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly decide between edge swap or segment reversal\n    if random.random() < 0.5:\n        # Edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If not feasible, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 241,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the most diverse objectives\n    def objective_diversity(obj):\n        return max(obj) - min(obj)\n\n    archive_sorted = sorted(archive, key=lambda x: -objective_diversity(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid 3-opt with objective-aware edge selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to reconnect\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Reconnect the edges in a way that minimizes the sum of all three objectives\n    possible_reconnections = [\n        (i, j, k), (i, k, j), (j, i, k), (j, k, i), (k, i, j), (k, j, i)\n    ]\n\n    best_reconnection = None\n    best_score = float('inf')\n\n    for reconnection in possible_reconnections:\n        a, b, c = reconnection\n        # Create a temporary solution with this reconnection\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[b], temp_solution[c] = temp_solution[b], temp_solution[c], temp_solution[a]\n\n        # Calculate the total cost across all three objectives\n        total_cost = 0\n        for m in range(n):\n            u = temp_solution[m]\n            v = temp_solution[(m + 1) % n]\n            total_cost += distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v]\n\n        if total_cost < best_score:\n            best_score = total_cost\n            best_reconnection = reconnection\n\n    if best_reconnection:\n        a, b, c = best_reconnection\n        new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.5109524769200131,
            1.8945738792419433
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the most diverse objectives\n    def objective_diversity(obj):\n        return max(obj) - min(obj)\n\n    archive_sorted = sorted(archive, key=lambda x: -objective_diversity(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid 3-opt with objective-aware edge selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to reconnect\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Reconnect the edges in a way that minimizes the sum of all three objectives\n    possible_reconnections = [\n        (i, j, k), (i, k, j), (j, i, k), (j, k, i), (k, i, j), (k, j, i)\n    ]\n\n    best_reconnection = None\n    best_score = float('inf')\n\n    for reconnection in possible_reconnections:\n        a, b, c = reconnection\n        # Create a temporary solution with this reconnection\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[b], temp_solution[c] = temp_solution[b], temp_solution[c], temp_solution[a]\n\n        # Calculate the total cost across all three objectives\n        total_cost = 0\n        for m in range(n):\n            u = temp_solution[m]\n            v = temp_solution[(m + 1) % n]\n            total_cost += distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v]\n\n        if total_cost < best_score:\n            best_score = total_cost\n            best_reconnection = reconnection\n\n    if best_reconnection:\n        a, b, c = best_reconnection\n        new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 242,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the total objective value for each solution\n    objective_values = [sum(obj) for _, obj in archive]\n\n    # Select the solution with the minimum total objective value (or use other criteria)\n    selected_idx = np.argmin(objective_values)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Randomly select two distinct nodes to swap\n    n_nodes = len(new_solution)\n    i, j = np.random.choice(n_nodes, size=2, replace=False)\n\n    # Perform a 2-opt move: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.6344457949885217,
            4.124378943443299
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the total objective value for each solution\n    objective_values = [sum(obj) for _, obj in archive]\n\n    # Select the solution with the minimum total objective value (or use other criteria)\n    selected_idx = np.argmin(objective_values)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Randomly select two distinct nodes to swap\n    n_nodes = len(new_solution)\n    i, j = np.random.choice(n_nodes, size=2, replace=False)\n\n    # Perform a 2-opt move: reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 243,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by the worst objective (to encourage diversity)\n    archive_sorted = sorted(archive, key=lambda x: max(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to reverse (for intra-route improvement)\n    n = len(new_solution)\n    start, end = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select two nodes and swap them (for inter-route improvement)\n    i, j = np.random.choice(n, 2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Ensure feasibility (already ensured by the operations above)\n    return new_solution\n\n",
        "score": [
            -0.8576489585585033,
            1.5283458948135376
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by the worst objective (to encourage diversity)\n    archive_sorted = sorted(archive, key=lambda x: max(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to reverse (for intra-route improvement)\n    n = len(new_solution)\n    start, end = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select two nodes and swap them (for inter-route improvement)\n    i, j = np.random.choice(n, 2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Ensure feasibility (already ensured by the operations above)\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 244,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Find the worst edge in any of the three objectives\n    worst_edge = -1\n    max_cost = -1\n    for i in range(n):\n        a = new_solution[i]\n        b = new_solution[(i + 1) % n]\n        cost = distance_matrix_1[a, b] + distance_matrix_2[a, b] + distance_matrix_3[a, b]\n        if cost > max_cost:\n            max_cost = cost\n            worst_edge = i\n\n    # Apply 2-opt on the worst edge\n    if worst_edge != -1:\n        # Find the best possible 2-opt move\n        best_i = worst_edge\n        best_j = (worst_edge + 2) % n\n        best_gain = 0\n\n        for i in range(n):\n            for j in range(i + 2, n):\n                a = new_solution[i]\n                b = new_solution[(i + 1) % n]\n                c = new_solution[j]\n                d = new_solution[(j + 1) % n]\n\n                current_cost = distance_matrix_1[a, b] + distance_matrix_2[a, b] + distance_matrix_3[a, b] + \\\n                              distance_matrix_1[c, d] + distance_matrix_2[c, d] + distance_matrix_3[c, d]\n                new_cost = distance_matrix_1[a, c] + distance_matrix_2[a, c] + distance_matrix_3[a, c] + \\\n                          distance_matrix_1[b, d] + distance_matrix_2[b, d] + distance_matrix_3[b, d]\n\n                gain = current_cost - new_cost\n                if gain > best_gain:\n                    best_gain = gain\n                    best_i = i\n                    best_j = j\n\n        if best_gain > 0:\n            # Perform the 2-opt move\n            new_solution[best_i + 1:best_j + 1] = new_solution[best_i + 1:best_j + 1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7540637063940607,
            4.025304305553436
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Find the worst edge in any of the three objectives\n    worst_edge = -1\n    max_cost = -1\n    for i in range(n):\n        a = new_solution[i]\n        b = new_solution[(i + 1) % n]\n        cost = distance_matrix_1[a, b] + distance_matrix_2[a, b] + distance_matrix_3[a, b]\n        if cost > max_cost:\n            max_cost = cost\n            worst_edge = i\n\n    # Apply 2-opt on the worst edge\n    if worst_edge != -1:\n        # Find the best possible 2-opt move\n        best_i = worst_edge\n        best_j = (worst_edge + 2) % n\n        best_gain = 0\n\n        for i in range(n):\n            for j in range(i + 2, n):\n                a = new_solution[i]\n                b = new_solution[(i + 1) % n]\n                c = new_solution[j]\n                d = new_solution[(j + 1) % n]\n\n                current_cost = distance_matrix_1[a, b] + distance_matrix_2[a, b] + distance_matrix_3[a, b] + \\\n                              distance_matrix_1[c, d] + distance_matrix_2[c, d] + distance_matrix_3[c, d]\n                new_cost = distance_matrix_1[a, c] + distance_matrix_2[a, c] + distance_matrix_3[a, c] + \\\n                          distance_matrix_1[b, d] + distance_matrix_2[b, d] + distance_matrix_3[b, d]\n\n                gain = current_cost - new_cost\n                if gain > best_gain:\n                    best_gain = gain\n                    best_i = i\n                    best_j = j\n\n        if best_gain > 0:\n            # Perform the 2-opt move\n            new_solution[best_i + 1:best_j + 1] = new_solution[best_i + 1:best_j + 1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 245,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware node selection\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, 2)  # Randomly select one of the three objectives\n\n    # Evaluate the current segment and potential reversal\n    current_cost = 0\n    if k == 0:\n        current_cost = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n    elif k == 1:\n        current_cost = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n    else:\n        current_cost = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n\n    reversed_cost = 0\n    if k == 0:\n        reversed_cost = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n    elif k == 1:\n        reversed_cost = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n    else:\n        reversed_cost = distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n\n    # Apply 2-opt if it improves the selected objective\n    if reversed_cost < current_cost:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7255049263666502,
            1.429192876815796
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware node selection\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, 2)  # Randomly select one of the three objectives\n\n    # Evaluate the current segment and potential reversal\n    current_cost = 0\n    if k == 0:\n        current_cost = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n    elif k == 1:\n        current_cost = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n    else:\n        current_cost = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n\n    reversed_cost = 0\n    if k == 0:\n        reversed_cost = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n    elif k == 1:\n        reversed_cost = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n    else:\n        reversed_cost = distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n\n    # Apply 2-opt if it improves the selected objective\n    if reversed_cost < current_cost:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 246,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate edge contributions for each objective\n    def edge_contribution(sol, mat):\n        cost = 0\n        for i in range(n):\n            cost += mat[sol[i], sol[(i+1)%n]]\n        return cost\n\n    # Evaluate current solution\n    obj1 = edge_contribution(base_solution, distance_matrix_1)\n    obj2 = edge_contribution(base_solution, distance_matrix_2)\n    obj3 = edge_contribution(base_solution, distance_matrix_3)\n\n    # Try 2-opt with objective-aware edge selection\n    for i in range(n):\n        for j in range(i+1, n):\n            # Create candidate neighbor\n            candidate = new_solution.copy()\n            candidate[i:j+1] = candidate[i:j+1][::-1]\n\n            # Evaluate candidate\n            cand_obj1 = edge_contribution(candidate, distance_matrix_1)\n            cand_obj2 = edge_contribution(candidate, distance_matrix_2)\n            cand_obj3 = edge_contribution(candidate, distance_matrix_3)\n\n            # Accept if at least one objective improves\n            if (cand_obj1 < obj1) or (cand_obj2 < obj2) or (cand_obj3 < obj3):\n                new_solution = candidate\n                obj1, obj2, obj3 = cand_obj1, cand_obj2, cand_obj3\n                break  # Restart after improvement\n\n    return new_solution\n\n",
        "score": [
            -0.6758135615176887,
            4.485738909244537
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate edge contributions for each objective\n    def edge_contribution(sol, mat):\n        cost = 0\n        for i in range(n):\n            cost += mat[sol[i], sol[(i+1)%n]]\n        return cost\n\n    # Evaluate current solution\n    obj1 = edge_contribution(base_solution, distance_matrix_1)\n    obj2 = edge_contribution(base_solution, distance_matrix_2)\n    obj3 = edge_contribution(base_solution, distance_matrix_3)\n\n    # Try 2-opt with objective-aware edge selection\n    for i in range(n):\n        for j in range(i+1, n):\n            # Create candidate neighbor\n            candidate = new_solution.copy()\n            candidate[i:j+1] = candidate[i:j+1][::-1]\n\n            # Evaluate candidate\n            cand_obj1 = edge_contribution(candidate, distance_matrix_1)\n            cand_obj2 = edge_contribution(candidate, distance_matrix_2)\n            cand_obj3 = edge_contribution(candidate, distance_matrix_3)\n\n            # Accept if at least one objective improves\n            if (cand_obj1 < obj1) or (cand_obj2 < obj2) or (cand_obj3 < obj3):\n                new_solution = candidate\n                obj1, obj2, obj3 = cand_obj1, cand_obj2, cand_obj3\n                break  # Restart after improvement\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 247,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a random 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap\n    # Find the worst edge in terms of any objective\n    worst_edge = -1\n    max_cost = -1\n    for k in range(n):\n        a, b = new_solution[k], new_solution[(k+1)%n]\n        cost = max(distance_matrix_1[a][b], distance_matrix_2[a][b], distance_matrix_3[a][b])\n        if cost > max_cost:\n            max_cost = cost\n            worst_edge = k\n\n    # Swap nodes to break the worst edge\n    if worst_edge != -1:\n        k = worst_edge\n        a, b = new_solution[k], new_solution[(k+1)%n]\n        # Find the best swap candidate\n        best_candidate = -1\n        min_cost = float('inf')\n        for l in range(n):\n            if l == k or l == (k+1)%n:\n                continue\n            c = new_solution[l]\n            cost = max(distance_matrix_1[a][c] + distance_matrix_1[c][b],\n                      distance_matrix_2[a][c] + distance_matrix_2[c][b],\n                      distance_matrix_3[a][c] + distance_matrix_3[c][b])\n            if cost < min_cost:\n                min_cost = cost\n                best_candidate = l\n\n        if best_candidate != -1:\n            new_solution[k], new_solution[best_candidate] = new_solution[best_candidate], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.6397519650617298,
            1.4104707002639771
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a random 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware swap\n    # Find the worst edge in terms of any objective\n    worst_edge = -1\n    max_cost = -1\n    for k in range(n):\n        a, b = new_solution[k], new_solution[(k+1)%n]\n        cost = max(distance_matrix_1[a][b], distance_matrix_2[a][b], distance_matrix_3[a][b])\n        if cost > max_cost:\n            max_cost = cost\n            worst_edge = k\n\n    # Swap nodes to break the worst edge\n    if worst_edge != -1:\n        k = worst_edge\n        a, b = new_solution[k], new_solution[(k+1)%n]\n        # Find the best swap candidate\n        best_candidate = -1\n        min_cost = float('inf')\n        for l in range(n):\n            if l == k or l == (k+1)%n:\n                continue\n            c = new_solution[l]\n            cost = max(distance_matrix_1[a][c] + distance_matrix_1[c][b],\n                      distance_matrix_2[a][c] + distance_matrix_2[c][b],\n                      distance_matrix_3[a][c] + distance_matrix_3[c][b])\n            if cost < min_cost:\n                min_cost = cost\n                best_candidate = l\n\n        if best_candidate != -1:\n            new_solution[k], new_solution[best_candidate] = new_solution[best_candidate], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 248,
        "algorithm": "{A novel multi-objective local search heuristic that intelligently selects a solution from the archive based on Pareto dominance and objective diversity, then applies a hybrid 2-opt and 3-opt operator with adaptive step size to generate a neighbor solution while maintaining feasibility, ensuring balanced improvement across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive 2-opt and 3-opt\n    n = len(new_solution)\n    for _ in range(5):  # Number of attempts\n        # Randomly select a segment length (2 for 2-opt, 3 for 3-opt)\n        segment_length = np.random.choice([2, 3])\n\n        if segment_length == 2:\n            # 2-opt: reverse a random segment of length 2\n            i = np.random.randint(0, n-1)\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n        else:\n            # 3-opt: reverse a random segment of length 3\n            i = np.random.randint(0, n-2)\n            new_solution[i], new_solution[i+2] = new_solution[i+2], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7299519699537138,
            1.810086989402771
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive 2-opt and 3-opt\n    n = len(new_solution)\n    for _ in range(5):  # Number of attempts\n        # Randomly select a segment length (2 for 2-opt, 3 for 3-opt)\n        segment_length = np.random.choice([2, 3])\n\n        if segment_length == 2:\n            # 2-opt: reverse a random segment of length 2\n            i = np.random.randint(0, n-1)\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n        else:\n            # 3-opt: reverse a random segment of length 3\n            i = np.random.randint(0, n-2)\n            new_solution[i], new_solution[i+2] = new_solution[i+2], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 249,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    worst_obj_indices = np.argmax(np.array(objectives), axis=0)\n    worst_obj_values = np.array(objectives)[worst_obj_indices, range(3)]\n    worst_obj_solution_idx = np.argmax(worst_obj_values)\n    base_solution = archive[worst_obj_solution_idx][0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select edges with high potential for improvement based on all three objectives\n    for i in range(n):\n        for j in range(i + 2, n):\n            a, b = new_solution[i], new_solution[i+1]\n            c, d = new_solution[j], new_solution[(j+1)%n]\n            # Calculate the potential improvement in all three objectives\n            delta1 = distance_matrix_1[a, c] + distance_matrix_1[b, d] - distance_matrix_1[a, b] - distance_matrix_1[c, d]\n            delta2 = distance_matrix_2[a, c] + distance_matrix_2[b, d] - distance_matrix_2[a, b] - distance_matrix_2[c, d]\n            delta3 = distance_matrix_3[a, c] + distance_matrix_3[b, d] - distance_matrix_3[a, b] - distance_matrix_3[c, d]\n            # If improvement in at least one objective, perform the move\n            if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7240203954054045,
            2.6810026288032534
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    worst_obj_indices = np.argmax(np.array(objectives), axis=0)\n    worst_obj_values = np.array(objectives)[worst_obj_indices, range(3)]\n    worst_obj_solution_idx = np.argmax(worst_obj_values)\n    base_solution = archive[worst_obj_solution_idx][0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select edges with high potential for improvement based on all three objectives\n    for i in range(n):\n        for j in range(i + 2, n):\n            a, b = new_solution[i], new_solution[i+1]\n            c, d = new_solution[j], new_solution[(j+1)%n]\n            # Calculate the potential improvement in all three objectives\n            delta1 = distance_matrix_1[a, c] + distance_matrix_1[b, d] - distance_matrix_1[a, b] - distance_matrix_1[c, d]\n            delta2 = distance_matrix_2[a, c] + distance_matrix_2[b, d] - distance_matrix_2[a, b] - distance_matrix_2[c, d]\n            delta3 = distance_matrix_3[a, c] + distance_matrix_3[b, d] - distance_matrix_3[a, b] - distance_matrix_3[c, d]\n            # If improvement in at least one objective, perform the move\n            if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 250,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1] + x[1][2]) / 3)[0].copy()\n\n    # Hybrid local search: 2-opt with objective-aware edge selection\n    n = len(selected_solution)\n    for _ in range(10):  # Limit iterations to balance exploration and exploitation\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        k = np.random.randint(0, n)\n\n        # Calculate potential improvements across all three objectives\n        delta1 = (distance_matrix_1[selected_solution[i-1], selected_solution[j]] +\n                  distance_matrix_1[selected_solution[k], selected_solution[(i+1)%n]]) - \\\n                 (distance_matrix_1[selected_solution[i-1], selected_solution[i]] +\n                  distance_matrix_1[selected_solution[j], selected_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[selected_solution[i-1], selected_solution[j]] +\n                  distance_matrix_2[selected_solution[k], selected_solution[(i+1)%n]]) - \\\n                 (distance_matrix_2[selected_solution[i-1], selected_solution[i]] +\n                  distance_matrix_2[selected_solution[j], selected_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[selected_solution[i-1], selected_solution[j]] +\n                  distance_matrix_3[selected_solution[k], selected_solution[(i+1)%n]]) - \\\n                 (distance_matrix_3[selected_solution[i-1], selected_solution[i]] +\n                  distance_matrix_3[selected_solution[j], selected_solution[(j+1)%n]])\n\n        # Accept if any objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            # Apply 3-opt move (i,j,k)\n            new_solution = selected_solution.copy()\n            new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n            if i < k < j:\n                new_solution[i:k+1] = np.flip(new_solution[i:k+1])\n            selected_solution = new_solution\n\n    return selected_solution\n\n",
        "score": [
            -0.8001097122331473,
            2.7223456382751463
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1] + x[1][2]) / 3)[0].copy()\n\n    # Hybrid local search: 2-opt with objective-aware edge selection\n    n = len(selected_solution)\n    for _ in range(10):  # Limit iterations to balance exploration and exploitation\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        k = np.random.randint(0, n)\n\n        # Calculate potential improvements across all three objectives\n        delta1 = (distance_matrix_1[selected_solution[i-1], selected_solution[j]] +\n                  distance_matrix_1[selected_solution[k], selected_solution[(i+1)%n]]) - \\\n                 (distance_matrix_1[selected_solution[i-1], selected_solution[i]] +\n                  distance_matrix_1[selected_solution[j], selected_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[selected_solution[i-1], selected_solution[j]] +\n                  distance_matrix_2[selected_solution[k], selected_solution[(i+1)%n]]) - \\\n                 (distance_matrix_2[selected_solution[i-1], selected_solution[i]] +\n                  distance_matrix_2[selected_solution[j], selected_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[selected_solution[i-1], selected_solution[j]] +\n                  distance_matrix_3[selected_solution[k], selected_solution[(i+1)%n]]) - \\\n                 (distance_matrix_3[selected_solution[i-1], selected_solution[i]] +\n                  distance_matrix_3[selected_solution[j], selected_solution[(j+1)%n]])\n\n        # Accept if any objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            # Apply 3-opt move (i,j,k)\n            new_solution = selected_solution.copy()\n            new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n            if i < k < j:\n                new_solution[i:k+1] = np.flip(new_solution[i:k+1])\n            selected_solution = new_solution\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 251,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_idx = np.random.choice(len(archive) // 5, size=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt for single objective, then multi-objective edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on the objective with the largest improvement potential\n    obj_improvement = np.array([sum(distance_matrix_1[new_solution, np.roll(new_solution, -1)]),\n                               sum(distance_matrix_2[new_solution, np.roll(new_solution, -1)]),\n                               sum(distance_matrix_3[new_solution, np.roll(new_solution, -1)])])\n    worst_obj = np.argmax(obj_improvement)\n\n    # Select distance matrix based on worst objective\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Apply 2-opt to improve the worst objective\n    for i in range(n):\n        for j in range(i + 2, n):\n            if j >= n:\n                continue\n            # Calculate delta for 2-opt move\n            a, b, c, d = new_solution[i], new_solution[i+1], new_solution[j], new_solution[(j+1)%n]\n            delta = (dist_matrix[a, b] + dist_matrix[c, d]) - (dist_matrix[a, c] + dist_matrix[b, d])\n            if delta > 0:\n                # Reverse the segment if it improves the selected objective\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Multi-objective edge swap heuristic\n    for _ in range(5):  # Limited iterations for efficiency\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate potential improvement across all objectives\n        a, b, c, d = new_solution[i], new_solution[i+1], new_solution[j], new_solution[(j+1)%n]\n        delta1 = (distance_matrix_1[a, b] + distance_matrix_1[c, d]) - (distance_matrix_1[a, c] + distance_matrix_1[b, d])\n        delta2 = (distance_matrix_2[a, b] + distance_matrix_2[c, d]) - (distance_matrix_2[a, c] + distance_matrix_2[b, d])\n        delta3 = (distance_matrix_3[a, b] + distance_matrix_3[c, d]) - (distance_matrix_3[a, c] + distance_matrix_3[b, d])\n\n        # Accept if improvement in at least one objective\n        if delta1 > 0 or delta2 > 0 or delta3 > 0:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7734327584209597,
            3.5272446155548094
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_idx = np.random.choice(len(archive) // 5, size=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt for single objective, then multi-objective edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on the objective with the largest improvement potential\n    obj_improvement = np.array([sum(distance_matrix_1[new_solution, np.roll(new_solution, -1)]),\n                               sum(distance_matrix_2[new_solution, np.roll(new_solution, -1)]),\n                               sum(distance_matrix_3[new_solution, np.roll(new_solution, -1)])])\n    worst_obj = np.argmax(obj_improvement)\n\n    # Select distance matrix based on worst objective\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Apply 2-opt to improve the worst objective\n    for i in range(n):\n        for j in range(i + 2, n):\n            if j >= n:\n                continue\n            # Calculate delta for 2-opt move\n            a, b, c, d = new_solution[i], new_solution[i+1], new_solution[j], new_solution[(j+1)%n]\n            delta = (dist_matrix[a, b] + dist_matrix[c, d]) - (dist_matrix[a, c] + dist_matrix[b, d])\n            if delta > 0:\n                # Reverse the segment if it improves the selected objective\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Multi-objective edge swap heuristic\n    for _ in range(5):  # Limited iterations for efficiency\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate potential improvement across all objectives\n        a, b, c, d = new_solution[i], new_solution[i+1], new_solution[j], new_solution[(j+1)%n]\n        delta1 = (distance_matrix_1[a, b] + distance_matrix_1[c, d]) - (distance_matrix_1[a, c] + distance_matrix_1[b, d])\n        delta2 = (distance_matrix_2[a, b] + distance_matrix_2[c, d]) - (distance_matrix_2[a, c] + distance_matrix_2[b, d])\n        delta3 = (distance_matrix_3[a, b] + distance_matrix_3[c, d]) - (distance_matrix_3[a, c] + distance_matrix_3[b, d])\n\n        # Accept if improvement in at least one objective\n        if delta1 > 0 or delta2 > 0 or delta3 > 0:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 252,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.3, 0.3, 0.4]  # Adjust weights based on preference\n    ranked_solutions = sorted(archive, key=lambda x: sum(w * obj for w, obj in zip(weights, x[1])))\n    base_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # We use a combination of 2-opt and 3-opt moves, biased towards improving the worst-performing objective\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 3: Identify the worst-performing objective\n    worst_obj_index = np.argmin([obj for obj in archive[0][1]])  # Assuming first solution's objectives are representative\n\n    # Step 4: Apply targeted local search\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        if worst_obj_index == 0:\n            # Apply 2-opt for the worst objective\n            new_solution[i:j] = new_solution[i:j][::-1]\n        elif worst_obj_index == 1:\n            # Apply 3-opt for the second worst objective\n            k = random.randint(i, j)\n            new_solution[i:k] = new_solution[i:k][::-1]\n            new_solution[k:j] = new_solution[k:j][::-1]\n        else:\n            # Apply a mix of 2-opt and 3-opt for the best objective\n            if random.random() < 0.5:\n                new_solution[i:j] = new_solution[i:j][::-1]\n            else:\n                k = random.randint(i, j)\n                new_solution[i:k] = new_solution[i:k][::-1]\n                new_solution[k:j] = new_solution[k:j][::-1]\n\n        # Ensure solution remains valid (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.6210965909574767,
            2.586891222000122
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.3, 0.3, 0.4]  # Adjust weights based on preference\n    ranked_solutions = sorted(archive, key=lambda x: sum(w * obj for w, obj in zip(weights, x[1])))\n    base_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # We use a combination of 2-opt and 3-opt moves, biased towards improving the worst-performing objective\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 3: Identify the worst-performing objective\n    worst_obj_index = np.argmin([obj for obj in archive[0][1]])  # Assuming first solution's objectives are representative\n\n    # Step 4: Apply targeted local search\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        if worst_obj_index == 0:\n            # Apply 2-opt for the worst objective\n            new_solution[i:j] = new_solution[i:j][::-1]\n        elif worst_obj_index == 1:\n            # Apply 3-opt for the second worst objective\n            k = random.randint(i, j)\n            new_solution[i:k] = new_solution[i:k][::-1]\n            new_solution[k:j] = new_solution[k:j][::-1]\n        else:\n            # Apply a mix of 2-opt and 3-opt for the best objective\n            if random.random() < 0.5:\n                new_solution[i:j] = new_solution[i:j][::-1]\n            else:\n                k = random.randint(i, j)\n                new_solution[i:k] = new_solution[i:k][::-1]\n                new_solution[k:j] = new_solution[k:j][::-1]\n\n        # Ensure solution remains valid (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 253,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # We use a combination of 2-opt and edge swap, tailored for multi-objective optimization\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt between i and j\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select another segment and apply edge swap\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains feasible\n    if len(np.unique(new_solution)) != n:\n        # If not feasible, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.516903376392963,
            1.627958881855011
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # We use a combination of 2-opt and edge swap, tailored for multi-objective optimization\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt between i and j\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select another segment and apply edge swap\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains feasible\n    if len(np.unique(new_solution)) != n:\n        # If not feasible, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 254,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([obj[0] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two non-adjacent edges to break\n    i = np.random.randint(0, n - 2)\n    j = np.random.randint(i + 2, n)\n\n    # Calculate the improvement potential for each objective\n    obj1_improvement = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) - \\\n                       (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]])\n    obj2_improvement = (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) - \\\n                       (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n    obj3_improvement = (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]) - \\\n                       (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]])\n\n    # Apply 2-opt if it improves at least one objective\n    if obj1_improvement < 0 or obj2_improvement < 0 or obj3_improvement < 0:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply a small random swap to escape local optima\n    k, l = np.random.choice(n, 2, replace=False)\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7325077692533338,
            1.6152853846549988
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([obj[0] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two non-adjacent edges to break\n    i = np.random.randint(0, n - 2)\n    j = np.random.randint(i + 2, n)\n\n    # Calculate the improvement potential for each objective\n    obj1_improvement = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) - \\\n                       (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]])\n    obj2_improvement = (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) - \\\n                       (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n    obj3_improvement = (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]) - \\\n                       (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]])\n\n    # Apply 2-opt if it improves at least one objective\n    if obj1_improvement < 0 or obj2_improvement < 0 or obj3_improvement < 0:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply a small random swap to escape local optima\n    k, l = np.random.choice(n, 2, replace=False)\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 255,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]) / (1 + len(set(x[0]))))  # Balance between objective sum and diversity\n    base_solution = selected[0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # We use a combination of 2-opt and node insertion to explore the solution space\n    # while ensuring feasibility and diversity in the objectives\n    new_solution = base_solution.copy()\n\n    # Perform 2-opt on a random segment\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform node insertion to further optimize\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    l = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Ensure the solution remains feasible\n    assert len(new_solution) == len(base_solution) and len(set(new_solution)) == len(base_solution), \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.5429205305142258,
            2.4507877469062804
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]) / (1 + len(set(x[0]))))  # Balance between objective sum and diversity\n    base_solution = selected[0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # We use a combination of 2-opt and node insertion to explore the solution space\n    # while ensuring feasibility and diversity in the objectives\n    new_solution = base_solution.copy()\n\n    # Perform 2-opt on a random segment\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform node insertion to further optimize\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    l = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Ensure the solution remains feasible\n    assert len(new_solution) == len(base_solution) and len(set(new_solution)) == len(base_solution), \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 256,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives to identify those with high potential\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the middle of the sorted list to balance exploration and exploitation\n        base_solution = random.choice(archive_sorted[len(archive_sorted)//3:2*len(archive_sorted)//3])[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Calculate the improvement potential for each objective\n    obj1_improvement = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                        (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n    obj2_improvement = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                        (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n    obj3_improvement = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]) - \\\n                        (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n    # Accept the move if it improves at least one objective\n    if obj1_improvement < 0 or obj2_improvement < 0 or obj3_improvement < 0:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply a secondary operator: swap two nodes if it improves the overall solution quality\n    if n > 2:\n        k, l = random.sample(range(n), 2)\n        obj1_swap = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                      distance_matrix_1[new_solution[l], new_solution[(k+1)%n]]) - \\\n                     (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                      distance_matrix_1[new_solution[l], new_solution[(l+1)%n]])\n\n        obj2_swap = (distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                      distance_matrix_2[new_solution[l], new_solution[(k+1)%n]]) - \\\n                     (distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                      distance_matrix_2[new_solution[l], new_solution[(l+1)%n]])\n\n        obj3_swap = (distance_matrix_3[new_solution[k-1], new_solution[l]] +\n                      distance_matrix_3[new_solution[l], new_solution[(k+1)%n]]) - \\\n                     (distance_matrix_3[new_solution[k-1], new_solution[k]] +\n                      distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n        if obj1_swap < 0 or obj2_swap < 0 or obj3_swap < 0:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7385314914098118,
            1.685233461856842
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives to identify those with high potential\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the middle of the sorted list to balance exploration and exploitation\n        base_solution = random.choice(archive_sorted[len(archive_sorted)//3:2*len(archive_sorted)//3])[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Calculate the improvement potential for each objective\n    obj1_improvement = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                        (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n    obj2_improvement = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                        (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n    obj3_improvement = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]) - \\\n                        (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n    # Accept the move if it improves at least one objective\n    if obj1_improvement < 0 or obj2_improvement < 0 or obj3_improvement < 0:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply a secondary operator: swap two nodes if it improves the overall solution quality\n    if n > 2:\n        k, l = random.sample(range(n), 2)\n        obj1_swap = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                      distance_matrix_1[new_solution[l], new_solution[(k+1)%n]]) - \\\n                     (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                      distance_matrix_1[new_solution[l], new_solution[(l+1)%n]])\n\n        obj2_swap = (distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                      distance_matrix_2[new_solution[l], new_solution[(k+1)%n]]) - \\\n                     (distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                      distance_matrix_2[new_solution[l], new_solution[(l+1)%n]])\n\n        obj3_swap = (distance_matrix_3[new_solution[k-1], new_solution[l]] +\n                      distance_matrix_3[new_solution[l], new_solution[(k+1)%n]]) - \\\n                     (distance_matrix_3[new_solution[k-1], new_solution[k]] +\n                      distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n        if obj1_swap < 0 or obj2_swap < 0 or obj3_swap < 0:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 257,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = random.choice(archive)\n    base_solution = selected_solution.copy()\n\n    # Perform a hybrid local search: combine 2-opt and insertion moves\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and insertion move\n    if random.random() < 0.5:\n        # 2-opt move: select two edges and reverse the segment between them\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Insertion move: remove a node and insert it elsewhere\n        pos = random.randint(0, n-1)\n        node = new_solution[pos]\n        new_solution = np.delete(new_solution, pos)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8301907324433915,
            1.5756141543388367
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = random.choice(archive)\n    base_solution = selected_solution.copy()\n\n    # Perform a hybrid local search: combine 2-opt and insertion moves\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and insertion move\n    if random.random() < 0.5:\n        # 2-opt move: select two edges and reverse the segment between them\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Insertion move: remove a node and insert it elsewhere\n        pos = random.randint(0, n-1)\n        node = new_solution[pos]\n        new_solution = np.delete(new_solution, pos)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 258,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (sum(obj) + 1e-6) for sol, obj in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # Combine 2-opt with a novel objective-aware perturbation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt with a bias towards objectives\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware perturbation: swap nodes based on their contribution to objectives\n    if random.random() < 0.3:  # 30% chance to apply perturbation\n        # Calculate node contributions to each objective\n        contributions = np.zeros(n)\n        for k in range(n):\n            prev = new_solution[k-1]\n            curr = new_solution[k]\n            next_node = new_solution[(k+1) % n]\n            contrib = (\n                distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] +\n                distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node] +\n                distance_matrix_3[prev, curr] + distance_matrix_3[curr, next_node]\n            )\n            contributions[k] = contrib\n\n        # Select nodes with high contribution and swap them\n        high_contrib_nodes = np.argsort(contributions)[-2:]\n        if len(high_contrib_nodes) >= 2:\n            a, b = high_contrib_nodes[0], high_contrib_nodes[1]\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8168026864084752,
            1.5118032813072204
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (sum(obj) + 1e-6) for sol, obj in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # Combine 2-opt with a novel objective-aware perturbation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt with a bias towards objectives\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware perturbation: swap nodes based on their contribution to objectives\n    if random.random() < 0.3:  # 30% chance to apply perturbation\n        # Calculate node contributions to each objective\n        contributions = np.zeros(n)\n        for k in range(n):\n            prev = new_solution[k-1]\n            curr = new_solution[k]\n            next_node = new_solution[(k+1) % n]\n            contrib = (\n                distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] +\n                distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node] +\n                distance_matrix_3[prev, curr] + distance_matrix_3[curr, next_node]\n            )\n            contributions[k] = contrib\n\n        # Select nodes with high contribution and swap them\n        high_contrib_nodes = np.argsort(contributions)[-2:]\n        if len(high_contrib_nodes) >= 2:\n            a, b = high_contrib_nodes[0], high_contrib_nodes[1]\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 259,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = random.choice(archive)\n    base_solution = selected[0].copy()\n    objectives = selected[1]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: apply 2-opt with objective-specific edge swaps\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Perform 2-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-specific edge swaps: for each objective, check if swapping edges improves it\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        # Find the worst edge in the current solution for this objective\n        worst_edge = None\n        worst_edge_value = -1\n        for k in range(n):\n            u = new_solution[k]\n            v = new_solution[(k + 1) % n]\n            edge_value = distance_matrix[u, v]\n            if edge_value > worst_edge_value:\n                worst_edge_value = edge_value\n                worst_edge = (k, (k + 1) % n)\n\n        if worst_edge:\n            k1, k2 = worst_edge\n            u = new_solution[k1]\n            v = new_solution[k2]\n\n            # Try to replace this edge with a better one\n            for candidate in range(n):\n                if candidate == u or candidate == v:\n                    continue\n                # Check if swapping u-v with u-candidate-v improves the objective\n                new_edge1 = distance_matrix[u, candidate]\n                new_edge2 = distance_matrix[candidate, v]\n                if new_edge1 + new_edge2 < 2 * worst_edge_value:\n                    # Perform the swap\n                    temp_solution = new_solution.copy()\n                    temp_solution[k1] = u\n                    temp_solution[k2] = candidate\n                    temp_solution[(k2 + 1) % n] = v\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.6635632800955921,
            0.1311853528022766
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = random.choice(archive)\n    base_solution = selected[0].copy()\n    objectives = selected[1]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: apply 2-opt with objective-specific edge swaps\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Perform 2-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-specific edge swaps: for each objective, check if swapping edges improves it\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        # Find the worst edge in the current solution for this objective\n        worst_edge = None\n        worst_edge_value = -1\n        for k in range(n):\n            u = new_solution[k]\n            v = new_solution[(k + 1) % n]\n            edge_value = distance_matrix[u, v]\n            if edge_value > worst_edge_value:\n                worst_edge_value = edge_value\n                worst_edge = (k, (k + 1) % n)\n\n        if worst_edge:\n            k1, k2 = worst_edge\n            u = new_solution[k1]\n            v = new_solution[k2]\n\n            # Try to replace this edge with a better one\n            for candidate in range(n):\n                if candidate == u or candidate == v:\n                    continue\n                # Check if swapping u-v with u-candidate-v improves the objective\n                new_edge1 = distance_matrix[u, candidate]\n                new_edge2 = distance_matrix[candidate, v]\n                if new_edge1 + new_edge2 < 2 * worst_edge_value:\n                    # Perform the swap\n                    temp_solution = new_solution.copy()\n                    temp_solution[k1] = u\n                    temp_solution[k2] = candidate\n                    temp_solution[(k2 + 1) % n] = v\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 259,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = random.choice(archive)\n    base_solution = selected[0].copy()\n    objectives = selected[1]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: apply 2-opt with objective-specific edge swaps\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Perform 2-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-specific edge swaps: for each objective, check if swapping edges improves it\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        # Find the worst edge in the current solution for this objective\n        worst_edge = None\n        worst_edge_value = -1\n        for k in range(n):\n            u = new_solution[k]\n            v = new_solution[(k + 1) % n]\n            edge_value = distance_matrix[u, v]\n            if edge_value > worst_edge_value:\n                worst_edge_value = edge_value\n                worst_edge = (k, (k + 1) % n)\n\n        if worst_edge:\n            k1, k2 = worst_edge\n            u = new_solution[k1]\n            v = new_solution[k2]\n\n            # Try to replace this edge with a better one\n            for candidate in range(n):\n                if candidate == u or candidate == v:\n                    continue\n                # Check if swapping u-v with u-candidate-v improves the objective\n                new_edge1 = distance_matrix[u, candidate]\n                new_edge2 = distance_matrix[candidate, v]\n                if new_edge1 + new_edge2 < 2 * worst_edge_value:\n                    # Perform the swap\n                    temp_solution = new_solution.copy()\n                    temp_solution[k1] = u\n                    temp_solution[k2] = candidate\n                    temp_solution[(k2 + 1) % n] = v\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.6635632800955921,
            0.1311853528022766
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = random.choice(archive)\n    base_solution = selected[0].copy()\n    objectives = selected[1]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: apply 2-opt with objective-specific edge swaps\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Perform 2-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-specific edge swaps: for each objective, check if swapping edges improves it\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        # Find the worst edge in the current solution for this objective\n        worst_edge = None\n        worst_edge_value = -1\n        for k in range(n):\n            u = new_solution[k]\n            v = new_solution[(k + 1) % n]\n            edge_value = distance_matrix[u, v]\n            if edge_value > worst_edge_value:\n                worst_edge_value = edge_value\n                worst_edge = (k, (k + 1) % n)\n\n        if worst_edge:\n            k1, k2 = worst_edge\n            u = new_solution[k1]\n            v = new_solution[k2]\n\n            # Try to replace this edge with a better one\n            for candidate in range(n):\n                if candidate == u or candidate == v:\n                    continue\n                # Check if swapping u-v with u-candidate-v improves the objective\n                new_edge1 = distance_matrix[u, candidate]\n                new_edge2 = distance_matrix[candidate, v]\n                if new_edge1 + new_edge2 < 2 * worst_edge_value:\n                    # Perform the swap\n                    temp_solution = new_solution.copy()\n                    temp_solution[k1] = u\n                    temp_solution[k2] = candidate\n                    temp_solution[(k2 + 1) % n] = v\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 260,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: combination of 2-opt and node swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and node swap\n    if np.random.rand() < 0.5:\n        # 2-opt: randomly select two edges and reverse the segment between them\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Node swap: randomly select two nodes and swap their positions\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6242494849894177,
            1.4824465990066529
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: combination of 2-opt and node swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and node swap\n    if np.random.rand() < 0.5:\n        # 2-opt: randomly select two edges and reverse the segment between them\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Node swap: randomly select two nodes and swap their positions\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 261,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 0:\n        top_k = max(1, int(len(archive) * 0.3))\n        selected_solution = archive[np.random.randint(0, top_k)][0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: 2-opt with multi-objective aware segment swap\n    # Step 1: Randomly select two non-adjacent edges to perform 2-opt\n    i, j = sorted(np.random.choice(range(1, n-2), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Randomly select a segment and swap it with another segment to improve multi-objective trade-offs\n    seg_start = np.random.randint(1, n-3)\n    seg_length = np.random.randint(2, min(5, n-seg_start-1))\n    seg1 = new_solution[seg_start:seg_start+seg_length]\n\n    # Find the best segment to swap with based on the combined improvement in all three objectives\n    best_improvement = 0\n    best_seg = None\n\n    for k in range(1, n - seg_length):\n        if k >= seg_start and k <= seg_start + seg_length:\n            continue  # Skip overlapping segments\n\n        seg2 = new_solution[k:k+seg_length]\n\n        # Calculate the change in total distance for all three objectives\n        delta1 = (distance_matrix_1[new_solution[seg_start-1], seg1[0]] +\n                  distance_matrix_1[seg1[-1], new_solution[seg_start+seg_length]] +\n                  distance_matrix_1[new_solution[k-1], seg2[0]] +\n                  distance_matrix_1[seg2[-1], new_solution[k+seg_length]]) - \\\n                 (distance_matrix_1[new_solution[seg_start-1], seg2[0]] +\n                  distance_matrix_1[seg2[-1], new_solution[seg_start+seg_length]] +\n                  distance_matrix_1[new_solution[k-1], seg1[0]] +\n                  distance_matrix_1[seg1[-1], new_solution[k+seg_length]])\n\n        delta2 = (distance_matrix_2[new_solution[seg_start-1], seg1[0]] +\n                  distance_matrix_2[seg1[-1], new_solution[seg_start+seg_length]] +\n                  distance_matrix_2[new_solution[k-1], seg2[0]] +\n                  distance_matrix_2[seg2[-1], new_solution[k+seg_length]]) - \\\n                 (distance_matrix_2[new_solution[seg_start-1], seg2[0]] +\n                  distance_matrix_2[seg2[-1], new_solution[seg_start+seg_length]] +\n                  distance_matrix_2[new_solution[k-1], seg1[0]] +\n                  distance_matrix_2[seg1[-1], new_solution[k+seg_length]])\n\n        delta3 = (distance_matrix_3[new_solution[seg_start-1], seg1[0]] +\n                  distance_matrix_3[seg1[-1], new_solution[seg_start+seg_length]] +\n                  distance_matrix_3[new_solution[k-1], seg2[0]] +\n                  distance_matrix_3[seg2[-1], new_solution[k+seg_length]]) - \\\n                 (distance_matrix_3[new_solution[seg_start-1], seg2[0]] +\n                  distance_matrix_3[seg2[-1], new_solution[seg_start+seg_length]] +\n                  distance_matrix_3[new_solution[k-1], seg1[0]] +\n                  distance_matrix_3[seg1[-1], new_solution[k+seg_length]])\n\n        # Combined improvement (simple sum, but could be weighted or more sophisticated)\n        total_improvement = delta1 + delta2 + delta3\n\n        if total_improvement < best_improvement:\n            best_improvement = total_improvement\n            best_seg = k\n\n    if best_seg is not None:\n        seg2 = new_solution[best_seg:best_seg+seg_length]\n        new_solution[seg_start:seg_start+seg_length] = seg2\n        new_solution[best_seg:best_seg+seg_length] = seg1\n\n    return new_solution\n\n",
        "score": [
            -0.7273089021491266,
            0.9048210382461548
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 0:\n        top_k = max(1, int(len(archive) * 0.3))\n        selected_solution = archive[np.random.randint(0, top_k)][0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: 2-opt with multi-objective aware segment swap\n    # Step 1: Randomly select two non-adjacent edges to perform 2-opt\n    i, j = sorted(np.random.choice(range(1, n-2), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Randomly select a segment and swap it with another segment to improve multi-objective trade-offs\n    seg_start = np.random.randint(1, n-3)\n    seg_length = np.random.randint(2, min(5, n-seg_start-1))\n    seg1 = new_solution[seg_start:seg_start+seg_length]\n\n    # Find the best segment to swap with based on the combined improvement in all three objectives\n    best_improvement = 0\n    best_seg = None\n\n    for k in range(1, n - seg_length):\n        if k >= seg_start and k <= seg_start + seg_length:\n            continue  # Skip overlapping segments\n\n        seg2 = new_solution[k:k+seg_length]\n\n        # Calculate the change in total distance for all three objectives\n        delta1 = (distance_matrix_1[new_solution[seg_start-1], seg1[0]] +\n                  distance_matrix_1[seg1[-1], new_solution[seg_start+seg_length]] +\n                  distance_matrix_1[new_solution[k-1], seg2[0]] +\n                  distance_matrix_1[seg2[-1], new_solution[k+seg_length]]) - \\\n                 (distance_matrix_1[new_solution[seg_start-1], seg2[0]] +\n                  distance_matrix_1[seg2[-1], new_solution[seg_start+seg_length]] +\n                  distance_matrix_1[new_solution[k-1], seg1[0]] +\n                  distance_matrix_1[seg1[-1], new_solution[k+seg_length]])\n\n        delta2 = (distance_matrix_2[new_solution[seg_start-1], seg1[0]] +\n                  distance_matrix_2[seg1[-1], new_solution[seg_start+seg_length]] +\n                  distance_matrix_2[new_solution[k-1], seg2[0]] +\n                  distance_matrix_2[seg2[-1], new_solution[k+seg_length]]) - \\\n                 (distance_matrix_2[new_solution[seg_start-1], seg2[0]] +\n                  distance_matrix_2[seg2[-1], new_solution[seg_start+seg_length]] +\n                  distance_matrix_2[new_solution[k-1], seg1[0]] +\n                  distance_matrix_2[seg1[-1], new_solution[k+seg_length]])\n\n        delta3 = (distance_matrix_3[new_solution[seg_start-1], seg1[0]] +\n                  distance_matrix_3[seg1[-1], new_solution[seg_start+seg_length]] +\n                  distance_matrix_3[new_solution[k-1], seg2[0]] +\n                  distance_matrix_3[seg2[-1], new_solution[k+seg_length]]) - \\\n                 (distance_matrix_3[new_solution[seg_start-1], seg2[0]] +\n                  distance_matrix_3[seg2[-1], new_solution[seg_start+seg_length]] +\n                  distance_matrix_3[new_solution[k-1], seg1[0]] +\n                  distance_matrix_3[seg1[-1], new_solution[k+seg_length]])\n\n        # Combined improvement (simple sum, but could be weighted or more sophisticated)\n        total_improvement = delta1 + delta2 + delta3\n\n        if total_improvement < best_improvement:\n            best_improvement = total_improvement\n            best_seg = k\n\n    if best_seg is not None:\n        seg2 = new_solution[best_seg:best_seg+seg_length]\n        new_solution[seg_start:seg_start+seg_length] = seg2\n        new_solution[best_seg:best_seg+seg_length] = seg1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 262,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware edge selection: prioritize edges with high variance in objectives\n    edge_costs = []\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i+1)%n]\n        cost1 = distance_matrix_1[u, v]\n        cost2 = distance_matrix_2[u, v]\n        cost3 = distance_matrix_3[u, v]\n        # Variance of the edge costs across objectives\n        variance = np.var([cost1, cost2, cost3])\n        edge_costs.append((i, variance))\n\n    # Sort edges by variance (descending) to prioritize diverse edges\n    edge_costs.sort(key=lambda x: -x[1])\n    selected_edges = [i for i, _ in edge_costs[:max(1, n//10)]]  # Select top 10% of edges\n\n    # Perform 2-opt on selected edges\n    for i in selected_edges:\n        for j in range(i+2, n):\n            if j == (i+1)%n or j == (i-1)%n:\n                continue\n            # Swap edges (i, i+1) and (j, j+1)\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n            break  # Only perform one swap per selected edge\n\n    return new_solution\n\n",
        "score": [
            -0.6557975625849827,
            3.3570995688438416
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware edge selection: prioritize edges with high variance in objectives\n    edge_costs = []\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i+1)%n]\n        cost1 = distance_matrix_1[u, v]\n        cost2 = distance_matrix_2[u, v]\n        cost3 = distance_matrix_3[u, v]\n        # Variance of the edge costs across objectives\n        variance = np.var([cost1, cost2, cost3])\n        edge_costs.append((i, variance))\n\n    # Sort edges by variance (descending) to prioritize diverse edges\n    edge_costs.sort(key=lambda x: -x[1])\n    selected_edges = [i for i, _ in edge_costs[:max(1, n//10)]]  # Select top 10% of edges\n\n    # Perform 2-opt on selected edges\n    for i in selected_edges:\n        for j in range(i+2, n):\n            if j == (i+1)%n or j == (i-1)%n:\n                continue\n            # Swap edges (i, i+1) and (j, j+1)\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n            break  # Only perform one swap per selected edge\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 263,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Randomly choose between 2-opt, 3-opt, or multi-objective edge swap\n    operator_choice = random.choice(['2-opt', '3-opt', 'multi-objective'])\n\n    if operator_choice == '2-opt':\n        # Perform 2-opt local search\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator_choice == '3-opt':\n        # Perform 3-opt local search\n        i, j, k = sorted(random.sample(range(len(new_solution)), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment1, segment2[::-1]])\n\n    else:\n        # Multi-objective edge swap: identify edges that are critical in one objective but not in others\n        for _ in range(3):  # Try a few swaps\n            i, j = random.sample(range(len(new_solution)), 2)\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n\n            # Calculate the change in all three objectives\n            delta_obj1 = (distance_matrix_1[node_i, new_solution[(i-1)%len(new_solution)]] +\n                          distance_matrix_1[node_i, new_solution[(i+1)%len(new_solution)]] -\n                          distance_matrix_1[new_solution[(i-1)%len(new_solution)], new_solution[(i+1)%len(new_solution)]]) + \\\n                         (distance_matrix_1[node_j, new_solution[(j-1)%len(new_solution)]] +\n                          distance_matrix_1[node_j, new_solution[(j+1)%len(new_solution)]] -\n                          distance_matrix_1[new_solution[(j-1)%len(new_solution)], new_solution[(j+1)%len(new_solution)]])\n\n            delta_obj2 = (distance_matrix_2[node_i, new_solution[(i-1)%len(new_solution)]] +\n                          distance_matrix_2[node_i, new_solution[(i+1)%len(new_solution)]] -\n                          distance_matrix_2[new_solution[(i-1)%len(new_solution)], new_solution[(i+1)%len(new_solution)]]) + \\\n                         (distance_matrix_2[node_j, new_solution[(j-1)%len(new_solution)]] +\n                          distance_matrix_2[node_j, new_solution[(j+1)%len(new_solution)]] -\n                          distance_matrix_2[new_solution[(j-1)%len(new_solution)], new_solution[(j+1)%len(new_solution)]])\n\n            delta_obj3 = (distance_matrix_3[node_i, new_solution[(i-1)%len(new_solution)]] +\n                          distance_matrix_3[node_i, new_solution[(i+1)%len(new_solution)]] -\n                          distance_matrix_3[new_solution[(i-1)%len(new_solution)], new_solution[(i+1)%len(new_solution)]]) + \\\n                         (distance_matrix_3[node_j, new_solution[(j-1)%len(new_solution)]] +\n                          distance_matrix_3[node_j, new_solution[(j+1)%len(new_solution)]] -\n                          distance_matrix_3[new_solution[(j-1)%len(new_solution)], new_solution[(j+1)%len(new_solution)]])\n\n            # Only perform swap if it improves at least one objective\n            if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7298974764640551,
            1.8714899659156798
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Randomly choose between 2-opt, 3-opt, or multi-objective edge swap\n    operator_choice = random.choice(['2-opt', '3-opt', 'multi-objective'])\n\n    if operator_choice == '2-opt':\n        # Perform 2-opt local search\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator_choice == '3-opt':\n        # Perform 3-opt local search\n        i, j, k = sorted(random.sample(range(len(new_solution)), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment1, segment2[::-1]])\n\n    else:\n        # Multi-objective edge swap: identify edges that are critical in one objective but not in others\n        for _ in range(3):  # Try a few swaps\n            i, j = random.sample(range(len(new_solution)), 2)\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n\n            # Calculate the change in all three objectives\n            delta_obj1 = (distance_matrix_1[node_i, new_solution[(i-1)%len(new_solution)]] +\n                          distance_matrix_1[node_i, new_solution[(i+1)%len(new_solution)]] -\n                          distance_matrix_1[new_solution[(i-1)%len(new_solution)], new_solution[(i+1)%len(new_solution)]]) + \\\n                         (distance_matrix_1[node_j, new_solution[(j-1)%len(new_solution)]] +\n                          distance_matrix_1[node_j, new_solution[(j+1)%len(new_solution)]] -\n                          distance_matrix_1[new_solution[(j-1)%len(new_solution)], new_solution[(j+1)%len(new_solution)]])\n\n            delta_obj2 = (distance_matrix_2[node_i, new_solution[(i-1)%len(new_solution)]] +\n                          distance_matrix_2[node_i, new_solution[(i+1)%len(new_solution)]] -\n                          distance_matrix_2[new_solution[(i-1)%len(new_solution)], new_solution[(i+1)%len(new_solution)]]) + \\\n                         (distance_matrix_2[node_j, new_solution[(j-1)%len(new_solution)]] +\n                          distance_matrix_2[node_j, new_solution[(j+1)%len(new_solution)]] -\n                          distance_matrix_2[new_solution[(j-1)%len(new_solution)], new_solution[(j+1)%len(new_solution)]])\n\n            delta_obj3 = (distance_matrix_3[node_i, new_solution[(i-1)%len(new_solution)]] +\n                          distance_matrix_3[node_i, new_solution[(i+1)%len(new_solution)]] -\n                          distance_matrix_3[new_solution[(i-1)%len(new_solution)], new_solution[(i+1)%len(new_solution)]]) + \\\n                         (distance_matrix_3[node_j, new_solution[(j-1)%len(new_solution)]] +\n                          distance_matrix_3[node_j, new_solution[(j+1)%len(new_solution)]] -\n                          distance_matrix_3[new_solution[(j-1)%len(new_solution)], new_solution[(j+1)%len(new_solution)]])\n\n            # Only perform swap if it improves at least one objective\n            if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 264,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_sol = None\n    for sol, obj in archive:\n        if selected_sol is None or (obj[0] <= selected_sol[1][0] and obj[1] <= selected_sol[1][1] and obj[2] <= selected_sol[1][2]) and (obj[0] < selected_sol[1][0] or obj[1] < selected_sol[1][1] or obj[2] < selected_sol[1][2]):\n            selected_sol = (sol, obj)\n\n    if selected_sol is None:\n        selected_sol = archive[0]\n\n    base_solution = selected_sol[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt + edge exchange across objectives\n    n = len(base_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform 2-opt on the first objective\n    new_solution[i:j+1] = base_solution[i:j+1][::-1]\n\n    # Perform edge exchange based on the second and third objectives\n    if k != l and j != i:\n        temp = new_solution[k]\n        new_solution[k] = new_solution[l]\n        new_solution[l] = temp\n\n    # Ensure the solution remains feasible\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6679220498017269,
            1.4485372066497804
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_sol = None\n    for sol, obj in archive:\n        if selected_sol is None or (obj[0] <= selected_sol[1][0] and obj[1] <= selected_sol[1][1] and obj[2] <= selected_sol[1][2]) and (obj[0] < selected_sol[1][0] or obj[1] < selected_sol[1][1] or obj[2] < selected_sol[1][2]):\n            selected_sol = (sol, obj)\n\n    if selected_sol is None:\n        selected_sol = archive[0]\n\n    base_solution = selected_sol[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt + edge exchange across objectives\n    n = len(base_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform 2-opt on the first objective\n    new_solution[i:j+1] = base_solution[i:j+1][::-1]\n\n    # Perform edge exchange based on the second and third objectives\n    if k != l and j != i:\n        temp = new_solution[k]\n        new_solution[k] = new_solution[l]\n        new_solution[l] = temp\n\n    # Ensure the solution remains feasible\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 265,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for (_, obj) in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search to explore improved regions\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three distinct edges to reverse\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Perform 3-opt move: reverse the middle segment\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) != n:\n        return base_solution  # Fallback to original if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.6889296346019639,
            1.6073302149772644
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for (_, obj) in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 3-opt local search to explore improved regions\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three distinct edges to reverse\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Perform 3-opt move: reverse the middle segment\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) != n:\n        return base_solution  # Fallback to original if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 266,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    worst_obj_indices = np.argmax(np.array(objectives), axis=0)  # Find worst-performing objectives\n    selected_indices = np.unique(worst_obj_indices)  # Select solutions that perform poorly in any objective\n    selected_solution = archive[selected_indices[np.random.choice(len(selected_indices))]][0].copy()\n\n    # Apply a hybrid local search: combine 2-opt and edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to apply 2-opt\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse the segment\n\n    # Randomly select a node to reinsert (edge insertion)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7017279003449934,
            1.9312685012817383
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    worst_obj_indices = np.argmax(np.array(objectives), axis=0)  # Find worst-performing objectives\n    selected_indices = np.unique(worst_obj_indices)  # Select solutions that perform poorly in any objective\n    selected_solution = archive[selected_indices[np.random.choice(len(selected_indices))]][0].copy()\n\n    # Apply a hybrid local search: combine 2-opt and edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to apply 2-opt\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse the segment\n\n    # Randomly select a node to reinsert (edge insertion)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 267,
        "algorithm": "{A novel multi-objective local search heuristic that intelligently selects solutions from the archive based on their diversity and potential for improvement across all three objectives, then applies a hybrid of 2-opt and edge-swap operators tailored to the tri-objective space to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest sum of normalized objective improvements\n    selected_idx = 0\n    max_improvement = -np.inf\n    for i, (sol, obj) in enumerate(archive):\n        # Calculate normalized improvement potential (simplified)\n        improvement = sum(obj)  # Placeholder for actual improvement metric\n        if improvement > max_improvement:\n            max_improvement = improvement\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: 2-opt with edge-swap for tri-objective\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    k, l = np.random.choice(n, 2, replace=False)\n\n    # Perform 2-opt swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform edge-swap based on the worst objective\n    obj1 = sum(distance_matrix_1[new_solution[:-1], new_solution[1:]])\n    obj2 = sum(distance_matrix_2[new_solution[:-1], new_solution[1:]])\n    obj3 = sum(distance_matrix_3[new_solution[:-1], new_solution[1:]])\n\n    worst_obj = np.argmax([obj1, obj2, obj3])\n    if worst_obj == 0:\n        # Optimize for first objective\n        temp = new_solution[k]\n        new_solution[k] = new_solution[l]\n        new_solution[l] = temp\n    elif worst_obj == 1:\n        # Optimize for second objective\n        temp = new_solution[k]\n        new_solution[k] = new_solution[l]\n        new_solution[l] = temp\n    else:\n        # Optimize for third objective\n        temp = new_solution[k]\n        new_solution[k] = new_solution[l]\n        new_solution[l] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.5561197046378098,
            1.6971155524253845
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest sum of normalized objective improvements\n    selected_idx = 0\n    max_improvement = -np.inf\n    for i, (sol, obj) in enumerate(archive):\n        # Calculate normalized improvement potential (simplified)\n        improvement = sum(obj)  # Placeholder for actual improvement metric\n        if improvement > max_improvement:\n            max_improvement = improvement\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: 2-opt with edge-swap for tri-objective\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    k, l = np.random.choice(n, 2, replace=False)\n\n    # Perform 2-opt swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform edge-swap based on the worst objective\n    obj1 = sum(distance_matrix_1[new_solution[:-1], new_solution[1:]])\n    obj2 = sum(distance_matrix_2[new_solution[:-1], new_solution[1:]])\n    obj3 = sum(distance_matrix_3[new_solution[:-1], new_solution[1:]])\n\n    worst_obj = np.argmax([obj1, obj2, obj3])\n    if worst_obj == 0:\n        # Optimize for first objective\n        temp = new_solution[k]\n        new_solution[k] = new_solution[l]\n        new_solution[l] = temp\n    elif worst_obj == 1:\n        # Optimize for second objective\n        temp = new_solution[k]\n        new_solution[k] = new_solution[l]\n        new_solution[l] = temp\n    else:\n        # Optimize for third objective\n        temp = new_solution[k]\n        new_solution[k] = new_solution[l]\n        new_solution[l] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 268,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with above-average objective values)\n    objectives = np.array([obj for _, obj in archive])\n    avg_objectives = np.mean(objectives, axis=0)\n    selected_idx = np.argmax(np.sum((objectives - avg_objectives) > 0, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two non-adjacent edges to swap (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    if abs(i - j) == 1 or (i == 0 and j == n - 1):\n        # Ensure non-adjacent edges (including wrap-around)\n        i, j = (i + 1) % n, (j + 1) % n\n\n    # Perform the swap and reverse the segment between i and j\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware refinement: check if the swap improves at least one objective\n    for _ in range(3):  # Try up to 3 random swaps\n        i, j = sorted(random.sample(range(n), 2))\n        if abs(i - j) == 1 or (i == 0 and j == n - 1):\n            i, j = (i + 1) % n, (j + 1) % n\n\n        # Calculate objective changes\n        old_edges = [\n            (base_solution[i-1], base_solution[i]),\n            (base_solution[j], base_solution[(j+1)%n])\n        ]\n        new_edges = [\n            (base_solution[i-1], base_solution[j]),\n            (base_solution[i], base_solution[(j+1)%n])\n        ]\n\n        # Calculate change in each objective\n        delta_obj1 = (distance_matrix_1[new_edges[0]] + distance_matrix_1[new_edges[1]] -\n                      distance_matrix_1[old_edges[0]] - distance_matrix_1[old_edges[1]])\n        delta_obj2 = (distance_matrix_2[new_edges[0]] + distance_matrix_2[new_edges[1]] -\n                      distance_matrix_2[old_edges[0]] - distance_matrix_2[old_edges[1]])\n        delta_obj3 = (distance_matrix_3[new_edges[0]] + distance_matrix_3[new_edges[1]] -\n                      distance_matrix_3[old_edges[0]] - distance_matrix_3[old_edges[1]])\n\n        if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n            new_solution[i:j] = new_solution[i:j][::-1]\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.6191050865987483,
            1.467887008190155
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with above-average objective values)\n    objectives = np.array([obj for _, obj in archive])\n    avg_objectives = np.mean(objectives, axis=0)\n    selected_idx = np.argmax(np.sum((objectives - avg_objectives) > 0, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two non-adjacent edges to swap (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    if abs(i - j) == 1 or (i == 0 and j == n - 1):\n        # Ensure non-adjacent edges (including wrap-around)\n        i, j = (i + 1) % n, (j + 1) % n\n\n    # Perform the swap and reverse the segment between i and j\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware refinement: check if the swap improves at least one objective\n    for _ in range(3):  # Try up to 3 random swaps\n        i, j = sorted(random.sample(range(n), 2))\n        if abs(i - j) == 1 or (i == 0 and j == n - 1):\n            i, j = (i + 1) % n, (j + 1) % n\n\n        # Calculate objective changes\n        old_edges = [\n            (base_solution[i-1], base_solution[i]),\n            (base_solution[j], base_solution[(j+1)%n])\n        ]\n        new_edges = [\n            (base_solution[i-1], base_solution[j]),\n            (base_solution[i], base_solution[(j+1)%n])\n        ]\n\n        # Calculate change in each objective\n        delta_obj1 = (distance_matrix_1[new_edges[0]] + distance_matrix_1[new_edges[1]] -\n                      distance_matrix_1[old_edges[0]] - distance_matrix_1[old_edges[1]])\n        delta_obj2 = (distance_matrix_2[new_edges[0]] + distance_matrix_2[new_edges[1]] -\n                      distance_matrix_2[old_edges[0]] - distance_matrix_2[old_edges[1]])\n        delta_obj3 = (distance_matrix_3[new_edges[0]] + distance_matrix_3[new_edges[1]] -\n                      distance_matrix_3[old_edges[0]] - distance_matrix_3[old_edges[1]])\n\n        if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n            new_solution[i:j] = new_solution[i:j][::-1]\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 269,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate the range of each objective across the archive\n        obj1 = [obj[0] for _, obj in archive]\n        obj2 = [obj[1] for _, obj in archive]\n        obj3 = [obj[2] for _, obj in archive]\n\n        # Select the solution with the highest range in any objective (indicating potential for improvement)\n        ranges = [max(obj1) - min(obj1), max(obj2) - min(obj2), max(obj3) - min(obj3)]\n        selected_idx = ranges.index(max(ranges))\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply a hybrid local search operator combining 2-opt and edge insertion\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No improvement possible for small tours\n\n    # Randomly select a segment to modify (2-opt or edge insertion)\n    i = np.random.randint(0, n - 2)\n    j = np.random.randint(i + 1, n - 1)\n\n    # With 50% probability, apply 2-opt, else apply edge insertion\n    if np.random.rand() < 0.5:\n        # 2-opt: Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Edge insertion: Move a random node to a new position\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_pos = np.random.randint(0, n - 1)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.642295005091133,
            1.677004885673523
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate the range of each objective across the archive\n        obj1 = [obj[0] for _, obj in archive]\n        obj2 = [obj[1] for _, obj in archive]\n        obj3 = [obj[2] for _, obj in archive]\n\n        # Select the solution with the highest range in any objective (indicating potential for improvement)\n        ranges = [max(obj1) - min(obj1), max(obj2) - min(obj2), max(obj3) - min(obj3)]\n        selected_idx = ranges.index(max(ranges))\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply a hybrid local search operator combining 2-opt and edge insertion\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No improvement possible for small tours\n\n    # Randomly select a segment to modify (2-opt or edge insertion)\n    i = np.random.randint(0, n - 2)\n    j = np.random.randint(i + 1, n - 1)\n\n    # With 50% probability, apply 2-opt, else apply edge insertion\n    if np.random.rand() < 0.5:\n        # 2-opt: Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Edge insertion: Move a random node to a new position\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_pos = np.random.randint(0, n - 1)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 270,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: apply a combination of 2-opt and 3-opt moves\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 3-opt move (additional improvement)\n    if n >= 4:\n        k = random.randint(0, n-1)\n        if k < i:\n            new_solution[k:i] = new_solution[k:i][::-1]\n        elif k > j:\n            new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7746674847839855,
            1.483095908164978
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: apply a combination of 2-opt and 3-opt moves\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 3-opt move (additional improvement)\n    if n >= 4:\n        k = random.randint(0, n-1)\n        if k < i:\n            new_solution[k:i] = new_solution[k:i][::-1]\n        elif k > j:\n            new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 271,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # Hybrid of 2-opt and edge insertion, tailored for multi-objective optimization\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct edges to modify\n    i, j = sorted(random.sample(range(n), 2))\n    if i == j:\n        j = (j + 1) % n\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Edge insertion: insert a randomly selected edge at a new position\n    k, l = sorted(random.sample(range(n), 2))\n    if k == l:\n        l = (l + 1) % n\n\n    # Ensure the insertion is valid (no duplicate nodes)\n    if new_solution[k] != new_solution[l]:\n        # Remove the edge at position l\n        node_to_insert = new_solution[l]\n        new_solution = np.delete(new_solution, l)\n\n        # Insert the node at position k\n        new_solution = np.insert(new_solution, k, node_to_insert)\n\n    return new_solution\n\n",
        "score": [
            -0.7773015680790516,
            1.5277531743049622
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # Hybrid of 2-opt and edge insertion, tailored for multi-objective optimization\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct edges to modify\n    i, j = sorted(random.sample(range(n), 2))\n    if i == j:\n        j = (j + 1) % n\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Edge insertion: insert a randomly selected edge at a new position\n    k, l = sorted(random.sample(range(n), 2))\n    if k == l:\n        l = (l + 1) % n\n\n    # Ensure the insertion is valid (no duplicate nodes)\n    if new_solution[k] != new_solution[l]:\n        # Remove the edge at position l\n        node_to_insert = new_solution[l]\n        new_solution = np.delete(new_solution, l)\n\n        # Insert the node at position k\n        new_solution = np.insert(new_solution, k, node_to_insert)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 272,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: np.mean(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 3-opt with objective-aware swaps\n    n = len(selected_solution)\n    for _ in range(10):  # Perform multiple iterations\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        # Try different segment reversals and objective-aware swaps\n        for op in range(3):\n            new_solution = selected_solution.copy()\n            if op == 0:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse segment\n            elif op == 1:\n                new_solution[i:k+1] = np.concatenate([new_solution[j:k+1], new_solution[i:j]])  # Rotate segment\n            else:\n                # Objective-aware swap: swap nodes that are most different in objectives\n                obj1 = distance_matrix_1[selected_solution[i], selected_solution[j]] + distance_matrix_1[selected_solution[j], selected_solution[i]]\n                obj2 = distance_matrix_2[selected_solution[i], selected_solution[j]] + distance_matrix_2[selected_solution[j], selected_solution[i]]\n                obj3 = distance_matrix_3[selected_solution[i], selected_solution[j]] + distance_matrix_3[selected_solution[j], selected_solution[i]]\n                if obj1 + obj2 + obj3 > 0:  # If swap improves at least one objective\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n            # Check if the new solution is valid and improves the objectives\n            if np.array_equal(np.sort(new_solution), np.sort(selected_solution)):\n                selected_solution = new_solution\n\n    return selected_solution\n\n",
        "score": [
            -0.7294798988721858,
            3.709816777706146
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: np.mean(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 3-opt with objective-aware swaps\n    n = len(selected_solution)\n    for _ in range(10):  # Perform multiple iterations\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        # Try different segment reversals and objective-aware swaps\n        for op in range(3):\n            new_solution = selected_solution.copy()\n            if op == 0:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse segment\n            elif op == 1:\n                new_solution[i:k+1] = np.concatenate([new_solution[j:k+1], new_solution[i:j]])  # Rotate segment\n            else:\n                # Objective-aware swap: swap nodes that are most different in objectives\n                obj1 = distance_matrix_1[selected_solution[i], selected_solution[j]] + distance_matrix_1[selected_solution[j], selected_solution[i]]\n                obj2 = distance_matrix_2[selected_solution[i], selected_solution[j]] + distance_matrix_2[selected_solution[j], selected_solution[i]]\n                obj3 = distance_matrix_3[selected_solution[i], selected_solution[j]] + distance_matrix_3[selected_solution[j], selected_solution[i]]\n                if obj1 + obj2 + obj3 > 0:  # If swap improves at least one objective\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n            # Check if the new solution is valid and improves the objectives\n            if np.array_equal(np.sort(new_solution), np.sort(selected_solution)):\n                selected_solution = new_solution\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 273,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate diversity scores for each solution\n        diversity_scores = []\n        for sol, obj in archive:\n            diversity = (obj[0] + obj[1] + obj[2]) / 3  # Simple average diversity metric\n            diversity_scores.append(diversity)\n\n        # Select a solution with high diversity (promising for further improvement)\n        selected_idx = np.argmax(diversity_scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    # 1. Apply 2-opt for one objective\n    # 2. Apply edge insertion for another objective\n    # 3. Apply node swap for the third objective\n\n    # Randomly select which objectives to optimize\n    obj_to_optimize = random.choice([1, 2, 3])\n\n    if obj_to_optimize == 1:\n        # 2-opt for first objective\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    elif obj_to_optimize == 2:\n        # Edge insertion for second objective\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n    else:\n        # Node swap for third objective\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.71394138231752,
            1.2676599860191344
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate diversity scores for each solution\n        diversity_scores = []\n        for sol, obj in archive:\n            diversity = (obj[0] + obj[1] + obj[2]) / 3  # Simple average diversity metric\n            diversity_scores.append(diversity)\n\n        # Select a solution with high diversity (promising for further improvement)\n        selected_idx = np.argmax(diversity_scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    # 1. Apply 2-opt for one objective\n    # 2. Apply edge insertion for another objective\n    # 3. Apply node swap for the third objective\n\n    # Randomly select which objectives to optimize\n    obj_to_optimize = random.choice([1, 2, 3])\n\n    if obj_to_optimize == 1:\n        # 2-opt for first objective\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    elif obj_to_optimize == 2:\n        # Edge insertion for second objective\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n    else:\n        # Node swap for third objective\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 274,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with multi-objective consideration\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct edges to swap\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    new_solution[k:l+1] = np.flip(new_solution[k:l+1])\n\n    # Ensure the solution remains valid (no duplicate nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7234993820822562,
            1.4343510866165161
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with multi-objective consideration\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct edges to swap\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    new_solution[k:l+1] = np.flip(new_solution[k:l+1])\n\n    # Ensure the solution remains valid (no duplicate nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 275,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Generate a neighbor using a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to break\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Perform a 2-opt move with the selected edges\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = [node for node in range(n) if node not in unique]\n        for idx, node in enumerate(new_solution):\n            if counts[np.where(unique == node)[0][0]] > 1:\n                new_solution[idx] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.7485267727854706,
            1.4956298351287842
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Generate a neighbor using a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to break\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Perform a 2-opt move with the selected edges\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = [node for node in range(n) if node not in unique]\n        for idx, node in enumerate(new_solution):\n            if counts[np.where(unique == node)[0][0]] > 1:\n                new_solution[idx] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 276,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on diversity and objective values\n    selected_idx = np.random.choice(len(archive), p=[1.0 / len(archive) for _ in range(len(archive))])\n    base_solution, _ = archive[selected_idx]\n\n    # Hybrid 3-objective local search: combine 2-opt with objective-aware perturbations\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i = np.random.randint(0, n)\n    j = np.random.randint(i + 1, n + 1)\n\n    # Objective-aware segment reversal\n    segment = new_solution[i:j]\n    reversed_segment = segment[::-1]\n\n    # Evaluate the impact on all three objectives\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]],\n        sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]],\n        sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n    ]\n\n    # Apply the reversal\n    new_solution[i:j] = reversed_segment\n\n    # Evaluate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]],\n        sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]],\n        sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n    ]\n\n    # If any objective worsens, revert the change\n    if any(new_cost > original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[i:j] = segment\n\n    # Additional perturbation: swap two nodes in different objectives\n    if np.random.rand() < 0.3:\n        swap_i, swap_j = np.random.choice(n, 2, replace=False)\n        new_solution[swap_i], new_solution[swap_j] = new_solution[swap_j], new_solution[swap_i]\n\n    return new_solution\n\n",
        "score": [
            -0.7947528897241597,
            2.1282281398773195
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on diversity and objective values\n    selected_idx = np.random.choice(len(archive), p=[1.0 / len(archive) for _ in range(len(archive))])\n    base_solution, _ = archive[selected_idx]\n\n    # Hybrid 3-objective local search: combine 2-opt with objective-aware perturbations\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i = np.random.randint(0, n)\n    j = np.random.randint(i + 1, n + 1)\n\n    # Objective-aware segment reversal\n    segment = new_solution[i:j]\n    reversed_segment = segment[::-1]\n\n    # Evaluate the impact on all three objectives\n    original_costs = [\n        sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]],\n        sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]],\n        sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n    ]\n\n    # Apply the reversal\n    new_solution[i:j] = reversed_segment\n\n    # Evaluate new costs\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]],\n        sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]],\n        sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n    ]\n\n    # If any objective worsens, revert the change\n    if any(new_cost > original_cost for new_cost, original_cost in zip(new_costs, original_costs)):\n        new_solution[i:j] = segment\n\n    # Additional perturbation: swap two nodes in different objectives\n    if np.random.rand() < 0.3:\n        swap_i, swap_j = np.random.choice(n, 2, replace=False)\n        new_solution[swap_i], new_solution[swap_j] = new_solution[swap_j], new_solution[swap_i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 277,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    n = len(base_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional refinement: swap nodes with the least total distance improvement\n    total_distance = 0\n    for k in range(n):\n        total_distance += (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                           distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                           distance_matrix_3[new_solution[k-1], new_solution[k]])\n\n    # Try swapping nodes to reduce total distance\n    for _ in range(10):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        old_dist = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                    distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                    distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                    distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                    distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                    distance_matrix_3[new_solution[b-1], new_solution[b]])\n\n        new_dist = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                    distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                    distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                    distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                    distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                    distance_matrix_3[new_solution[b-1], new_solution[a]])\n\n        if new_dist < old_dist:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.782265899976356,
            2.4890787839889525
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    n = len(base_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional refinement: swap nodes with the least total distance improvement\n    total_distance = 0\n    for k in range(n):\n        total_distance += (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                           distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                           distance_matrix_3[new_solution[k-1], new_solution[k]])\n\n    # Try swapping nodes to reduce total distance\n    for _ in range(10):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        old_dist = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                    distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                    distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                    distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                    distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                    distance_matrix_3[new_solution[b-1], new_solution[b]])\n\n        new_dist = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                    distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                    distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                    distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                    distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                    distance_matrix_3[new_solution[b-1], new_solution[a]])\n\n        if new_dist < old_dist:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 278,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = random.choices(\n        [sol for sol, _ in archive],\n        weights=[1.0 / (1.0 + obj[0] + obj[1] + obj[2]) for _, obj in archive],\n        k=1\n    )[0].copy()\n\n    # Apply a hybrid local search operator: combine 2-opt with a novel 3-objective-aware swap\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform a novel 3-objective-aware swap\n    # Select two nodes that are close in at least one objective space\n    k, l = sorted(random.sample(range(n), 2))\n    node_k = new_solution[k]\n    node_l = new_solution[l]\n\n    # Calculate distances in all three spaces\n    dist1 = distance_matrix_1[node_k, node_l]\n    dist2 = distance_matrix_2[node_k, node_l]\n    dist3 = distance_matrix_3[node_k, node_l]\n\n    # If the nodes are close in at least one space, swap them with probability based on closeness\n    if min(dist1, dist2, dist3) < (np.mean(distance_matrix_1) + np.mean(distance_matrix_2) + np.mean(distance_matrix_3)) / 3:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.6848961694090477,
            1.741549015045166
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = random.choices(\n        [sol for sol, _ in archive],\n        weights=[1.0 / (1.0 + obj[0] + obj[1] + obj[2]) for _, obj in archive],\n        k=1\n    )[0].copy()\n\n    # Apply a hybrid local search operator: combine 2-opt with a novel 3-objective-aware swap\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform a novel 3-objective-aware swap\n    # Select two nodes that are close in at least one objective space\n    k, l = sorted(random.sample(range(n), 2))\n    node_k = new_solution[k]\n    node_l = new_solution[l]\n\n    # Calculate distances in all three spaces\n    dist1 = distance_matrix_1[node_k, node_l]\n    dist2 = distance_matrix_2[node_k, node_l]\n    dist3 = distance_matrix_3[node_k, node_l]\n\n    # If the nodes are close in at least one space, swap them with probability based on closeness\n    if min(dist1, dist2, dist3) < (np.mean(distance_matrix_1) + np.mean(distance_matrix_2) + np.mean(distance_matrix_3)) / 3:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 279,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to swap\n    i, j = sorted(random.sample(range(1, n - 1), 2))\n\n    # Evaluate the current and swapped segments in all three objectives\n    current_cost = (\n        distance_matrix_1[new_solution[i-1], new_solution[i]] +\n        distance_matrix_1[new_solution[j], new_solution[j+1]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n        distance_matrix_2[new_solution[j], new_solution[j+1]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] +\n        distance_matrix_3[new_solution[j], new_solution[j+1]]\n    )\n\n    swapped_cost = (\n        distance_matrix_1[new_solution[i-1], new_solution[j]] +\n        distance_matrix_1[new_solution[i], new_solution[j+1]],\n        distance_matrix_2[new_solution[i-1], new_solution[j]] +\n        distance_matrix_2[new_solution[i], new_solution[j+1]],\n        distance_matrix_3[new_solution[i-1], new_solution[j]] +\n        distance_matrix_3[new_solution[i], new_solution[j+1]]\n    )\n\n    # Accept the swap if it improves at least one objective\n    if any(s < c for s, c in zip(swapped_cost, current_cost)):\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additionally, perform a random 2-opt to escape local optima\n    i, j = sorted(random.sample(range(1, n - 1), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6669008486942041,
            1.6186750411987305
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to swap\n    i, j = sorted(random.sample(range(1, n - 1), 2))\n\n    # Evaluate the current and swapped segments in all three objectives\n    current_cost = (\n        distance_matrix_1[new_solution[i-1], new_solution[i]] +\n        distance_matrix_1[new_solution[j], new_solution[j+1]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n        distance_matrix_2[new_solution[j], new_solution[j+1]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] +\n        distance_matrix_3[new_solution[j], new_solution[j+1]]\n    )\n\n    swapped_cost = (\n        distance_matrix_1[new_solution[i-1], new_solution[j]] +\n        distance_matrix_1[new_solution[i], new_solution[j+1]],\n        distance_matrix_2[new_solution[i-1], new_solution[j]] +\n        distance_matrix_2[new_solution[i], new_solution[j+1]],\n        distance_matrix_3[new_solution[i-1], new_solution[j]] +\n        distance_matrix_3[new_solution[i], new_solution[j+1]]\n    )\n\n    # Accept the swap if it improves at least one objective\n    if any(s < c for s, c in zip(swapped_cost, current_cost)):\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additionally, perform a random 2-opt to escape local optima\n    i, j = sorted(random.sample(range(1, n - 1), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 280,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    improved = False\n\n    # Randomly sample segments for 2-opt\n    for _ in range(10):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j:\n            continue\n\n        # Create candidate solution\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n\n        # Evaluate candidate's potential improvement\n        original_cost = (\n            sum(distance_matrix_1[base_solution[k-1], base_solution[k]] for k in range(n)),\n            sum(distance_matrix_2[base_solution[k-1], base_solution[k]] for k in range(n)),\n            sum(distance_matrix_3[base_solution[k-1], base_solution[k]] for k in range(n))\n        )\n        new_cost = (\n            sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(n)),\n            sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(n)),\n            sum(distance_matrix_3[candidate[k-1], candidate[k]] for k in range(n))\n        )\n\n        # Accept if at least one objective improves\n        if any(new_cost[obj] < original_cost[obj] for obj in range(3)):\n            new_solution = candidate\n            improved = True\n            break\n\n    # If no improvement found, perform random swap\n    if not improved:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6882090716456266,
            2.9613301157951355
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    improved = False\n\n    # Randomly sample segments for 2-opt\n    for _ in range(10):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j:\n            continue\n\n        # Create candidate solution\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n\n        # Evaluate candidate's potential improvement\n        original_cost = (\n            sum(distance_matrix_1[base_solution[k-1], base_solution[k]] for k in range(n)),\n            sum(distance_matrix_2[base_solution[k-1], base_solution[k]] for k in range(n)),\n            sum(distance_matrix_3[base_solution[k-1], base_solution[k]] for k in range(n))\n        )\n        new_cost = (\n            sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(n)),\n            sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(n)),\n            sum(distance_matrix_3[candidate[k-1], candidate[k]] for k in range(n))\n        )\n\n        # Accept if at least one objective improves\n        if any(new_cost[obj] < original_cost[obj] for obj in range(3)):\n            new_solution = candidate\n            improved = True\n            break\n\n    # If no improvement found, perform random swap\n    if not improved:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 281,
        "algorithm": "{A novel hybrid local search strategy combines 2-opt moves with objective-specific edge swaps, prioritizing edges with high marginal improvement in at least two objectives, while ensuring feasibility through intelligent random selection of promising solutions from the archive.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive (here, random selection for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Make a copy to modify\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(random.sample(range(1, n), 2))\n        if i == j:\n            continue\n\n        # Original edges: (i-1, i) and (j, j+1)\n        orig_edges = [\n            (new_solution[i-1], new_solution[i]),\n            (new_solution[j], new_solution[(j+1)%n])\n        ]\n\n        # New edges: (i-1, j) and (i, j+1)\n        new_edges = [\n            (new_solution[i-1], new_solution[j]),\n            (new_solution[i], new_solution[(j+1)%n])\n        ]\n\n        # Compute marginal improvement for each objective\n        delta1 = (distance_matrix_1[new_edges[0][0], new_edges[0][1]] +\n                  distance_matrix_1[new_edges[1][0], new_edges[1][1]]) - \\\n                 (distance_matrix_1[orig_edges[0][0], orig_edges[0][1]] +\n                  distance_matrix_1[orig_edges[1][0], orig_edges[1][1]])\n\n        delta2 = (distance_matrix_2[new_edges[0][0], new_edges[0][1]] +\n                  distance_matrix_2[new_edges[1][0], new_edges[1][1]]) - \\\n                 (distance_matrix_2[orig_edges[0][0], orig_edges[0][1]] +\n                  distance_matrix_2[orig_edges[1][0], orig_edges[1][1]])\n\n        delta3 = (distance_matrix_3[new_edges[0][0], new_edges[0][1]] +\n                  distance_matrix_3[new_edges[1][0], new_edges[1][1]]) - \\\n                 (distance_matrix_3[orig_edges[0][0], orig_edges[0][1]] +\n                  distance_matrix_3[orig_edges[1][0], orig_edges[1][1]])\n\n        # Accept if at least two objectives improve\n        if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and delta3 < 0) or (delta2 < 0 and delta3 < 0):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7515373742073439,
            2.856399655342102
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive (here, random selection for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Make a copy to modify\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(random.sample(range(1, n), 2))\n        if i == j:\n            continue\n\n        # Original edges: (i-1, i) and (j, j+1)\n        orig_edges = [\n            (new_solution[i-1], new_solution[i]),\n            (new_solution[j], new_solution[(j+1)%n])\n        ]\n\n        # New edges: (i-1, j) and (i, j+1)\n        new_edges = [\n            (new_solution[i-1], new_solution[j]),\n            (new_solution[i], new_solution[(j+1)%n])\n        ]\n\n        # Compute marginal improvement for each objective\n        delta1 = (distance_matrix_1[new_edges[0][0], new_edges[0][1]] +\n                  distance_matrix_1[new_edges[1][0], new_edges[1][1]]) - \\\n                 (distance_matrix_1[orig_edges[0][0], orig_edges[0][1]] +\n                  distance_matrix_1[orig_edges[1][0], orig_edges[1][1]])\n\n        delta2 = (distance_matrix_2[new_edges[0][0], new_edges[0][1]] +\n                  distance_matrix_2[new_edges[1][0], new_edges[1][1]]) - \\\n                 (distance_matrix_2[orig_edges[0][0], orig_edges[0][1]] +\n                  distance_matrix_2[orig_edges[1][0], orig_edges[1][1]])\n\n        delta3 = (distance_matrix_3[new_edges[0][0], new_edges[0][1]] +\n                  distance_matrix_3[new_edges[1][0], new_edges[1][1]]) - \\\n                 (distance_matrix_3[orig_edges[0][0], orig_edges[0][1]] +\n                  distance_matrix_3[orig_edges[1][0], orig_edges[1][1]])\n\n        # Accept if at least two objectives improve\n        if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and delta3 < 0) or (delta2 < 0 and delta3 < 0):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 282,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    normalized_objectives = np.array(objectives) / np.max(objectives, axis=0)\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search: a combination of 2-opt and edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to perform 2-opt\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select a node to reinsert elsewhere to diversify\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6643509449125959,
            2.035667824745178
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    normalized_objectives = np.array(objectives) / np.max(objectives, axis=0)\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search: a combination of 2-opt and edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to perform 2-opt\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select a node to reinsert elsewhere to diversify\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 283,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest crowding distance in the objective space (promising for further improvement)\n    def crowding_distance(solutions, objectives):\n        n = len(solutions)\n        if n <= 2:\n            return [1.0] * n\n\n        distances = [0.0] * n\n        for m in range(3):  # For each objective\n            sorted_idx = np.argsort([obj[m] for obj in objectives])\n            distances[sorted_idx[0]] = float('inf')\n            distances[sorted_idx[-1]] = float('inf')\n            for i in range(1, n-1):\n                distances[sorted_idx[i]] += (objectives[sorted_idx[i+1]][m] - objectives[sorted_idx[i-1]][m]) / (objectives[sorted_idx[-1]][m] - objectives[sorted_idx[0]][m] + 1e-10)\n        return distances\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    distances = crowding_distance(solutions, objectives)\n    selected_idx = np.argmax(distances)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search: 2-opt with multi-objective edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Evaluate edges in the segment across all objectives\n    edge_scores = []\n    for k in range(len(segment)-1):\n        a, b = segment[k], segment[k+1]\n        score = (distance_matrix_1[a, b] + distance_matrix_2[a, b] + distance_matrix_3[a, b]) / 3\n        edge_scores.append((score, k))\n\n    # Sort edges by score (highest score first)\n    edge_scores.sort(reverse=True, key=lambda x: x[0])\n\n    # Select top 30% of edges to potentially reverse\n    num_to_reverse = max(1, len(edge_scores) // 3)\n    reverse_indices = [idx for _, idx in edge_scores[:num_to_reverse]]\n\n    # Reverse the selected edges\n    for idx in reverse_indices:\n        segment[idx], segment[idx+1] = segment[idx+1], segment[idx]\n\n    # Apply the segment back to the solution\n    new_solution[i:j+1] = segment\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5667552935395973,
            2.977378988265991
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest crowding distance in the objective space (promising for further improvement)\n    def crowding_distance(solutions, objectives):\n        n = len(solutions)\n        if n <= 2:\n            return [1.0] * n\n\n        distances = [0.0] * n\n        for m in range(3):  # For each objective\n            sorted_idx = np.argsort([obj[m] for obj in objectives])\n            distances[sorted_idx[0]] = float('inf')\n            distances[sorted_idx[-1]] = float('inf')\n            for i in range(1, n-1):\n                distances[sorted_idx[i]] += (objectives[sorted_idx[i+1]][m] - objectives[sorted_idx[i-1]][m]) / (objectives[sorted_idx[-1]][m] - objectives[sorted_idx[0]][m] + 1e-10)\n        return distances\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    distances = crowding_distance(solutions, objectives)\n    selected_idx = np.argmax(distances)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search: 2-opt with multi-objective edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Evaluate edges in the segment across all objectives\n    edge_scores = []\n    for k in range(len(segment)-1):\n        a, b = segment[k], segment[k+1]\n        score = (distance_matrix_1[a, b] + distance_matrix_2[a, b] + distance_matrix_3[a, b]) / 3\n        edge_scores.append((score, k))\n\n    # Sort edges by score (highest score first)\n    edge_scores.sort(reverse=True, key=lambda x: x[0])\n\n    # Select top 30% of edges to potentially reverse\n    num_to_reverse = max(1, len(edge_scores) // 3)\n    reverse_indices = [idx for _, idx in edge_scores[:num_to_reverse]]\n\n    # Reverse the selected edges\n    for idx in reverse_indices:\n        segment[idx], segment[idx+1] = segment[idx+1], segment[idx]\n\n    # Apply the segment back to the solution\n    new_solution[i:j+1] = segment\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 284,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt combined with node insertion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Perform 2-opt on the solution\n    for _ in range(10):  # Number of 2-opt iterations\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform node insertion to improve multi-objective quality\n    for _ in range(5):  # Number of insertion iterations\n        # Select a node to move\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Remove the node\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Find the best position to insert the node based on combined objective improvement\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(n-1):\n            # Evaluate insertion at position pos\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos]\n\n            # Calculate the change in all three objectives\n            delta_1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            delta_2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n            delta_3 = distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node] - distance_matrix_3[prev_node, next_node]\n\n            # Combined score (simple sum of normalized deltas)\n            score = delta_1 + delta_2 + delta_3\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7612445367754682,
            2.6521995306015014
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt combined with node insertion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Perform 2-opt on the solution\n    for _ in range(10):  # Number of 2-opt iterations\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform node insertion to improve multi-objective quality\n    for _ in range(5):  # Number of insertion iterations\n        # Select a node to move\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Remove the node\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Find the best position to insert the node based on combined objective improvement\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(n-1):\n            # Evaluate insertion at position pos\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos]\n\n            # Calculate the change in all three objectives\n            delta_1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            delta_2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n            delta_3 = distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node] - distance_matrix_3[prev_node, next_node]\n\n            # Combined score (simple sum of normalized deltas)\n            score = delta_1 + delta_2 + delta_3\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 285,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with objective-aware edge selection\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Determine which objective to prioritize based on the current solution's performance\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n\n    # Probabilistically select the objective to optimize\n    if np.random.rand() < obj1 / total_obj:\n        # Prioritize first objective: select edges with high distance in first space\n        edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        edge2 = distance_matrix_1[new_solution[j], new_solution[k]]\n        edge3 = distance_matrix_1[new_solution[k], new_solution[i]]\n        if edge1 > edge2 and edge1 > edge3:\n            # Reverse the segment between i and j\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif edge2 > edge1 and edge2 > edge3:\n            # Reverse the segment between j and k\n            new_solution[j:k+1] = new_solution[j:k+1][::-1]\n        else:\n            # Reverse the segment between k and i (back to start)\n            new_solution[k:] = new_solution[k:][::-1]\n            new_solution[:i+1] = new_solution[:i+1][::-1]\n    elif np.random.rand() < (obj1 + obj2) / total_obj:\n        # Prioritize second objective: select edges with high distance in second space\n        edge1 = distance_matrix_2[new_solution[i], new_solution[j]]\n        edge2 = distance_matrix_2[new_solution[j], new_solution[k]]\n        edge3 = distance_matrix_2[new_solution[k], new_solution[i]]\n        if edge1 > edge2 and edge1 > edge3:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif edge2 > edge1 and edge2 > edge3:\n            new_solution[j:k+1] = new_solution[j:k+1][::-1]\n        else:\n            new_solution[k:] = new_solution[k:][::-1]\n            new_solution[:i+1] = new_solution[:i+1][::-1]\n    else:\n        # Prioritize third objective: select edges with high distance in third space\n        edge1 = distance_matrix_3[new_solution[i], new_solution[j]]\n        edge2 = distance_matrix_3[new_solution[j], new_solution[k]]\n        edge3 = distance_matrix_3[new_solution[k], new_solution[i]]\n        if edge1 > edge2 and edge1 > edge3:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif edge2 > edge1 and edge2 > edge3:\n            new_solution[j:k+1] = new_solution[j:k+1][::-1]\n        else:\n            new_solution[k:] = new_solution[k:][::-1]\n            new_solution[:i+1] = new_solution[:i+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7159672966731245,
            1.6253032565116883
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with objective-aware edge selection\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Determine which objective to prioritize based on the current solution's performance\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    total_obj = obj1 + obj2 + obj3\n\n    # Probabilistically select the objective to optimize\n    if np.random.rand() < obj1 / total_obj:\n        # Prioritize first objective: select edges with high distance in first space\n        edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        edge2 = distance_matrix_1[new_solution[j], new_solution[k]]\n        edge3 = distance_matrix_1[new_solution[k], new_solution[i]]\n        if edge1 > edge2 and edge1 > edge3:\n            # Reverse the segment between i and j\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif edge2 > edge1 and edge2 > edge3:\n            # Reverse the segment between j and k\n            new_solution[j:k+1] = new_solution[j:k+1][::-1]\n        else:\n            # Reverse the segment between k and i (back to start)\n            new_solution[k:] = new_solution[k:][::-1]\n            new_solution[:i+1] = new_solution[:i+1][::-1]\n    elif np.random.rand() < (obj1 + obj2) / total_obj:\n        # Prioritize second objective: select edges with high distance in second space\n        edge1 = distance_matrix_2[new_solution[i], new_solution[j]]\n        edge2 = distance_matrix_2[new_solution[j], new_solution[k]]\n        edge3 = distance_matrix_2[new_solution[k], new_solution[i]]\n        if edge1 > edge2 and edge1 > edge3:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif edge2 > edge1 and edge2 > edge3:\n            new_solution[j:k+1] = new_solution[j:k+1][::-1]\n        else:\n            new_solution[k:] = new_solution[k:][::-1]\n            new_solution[:i+1] = new_solution[:i+1][::-1]\n    else:\n        # Prioritize third objective: select edges with high distance in third space\n        edge1 = distance_matrix_3[new_solution[i], new_solution[j]]\n        edge2 = distance_matrix_3[new_solution[j], new_solution[k]]\n        edge3 = distance_matrix_3[new_solution[k], new_solution[i]]\n        if edge1 > edge2 and edge1 > edge3:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif edge2 > edge1 and edge2 > edge3:\n            new_solution[j:k+1] = new_solution[j:k+1][::-1]\n        else:\n            new_solution[k:] = new_solution[k:][::-1]\n            new_solution[:i+1] = new_solution[:i+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 286,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def normalize_objectives(archive):\n        objectives = np.array([obj for _, obj in archive])\n        min_vals = np.min(objectives, axis=0)\n        max_vals = np.max(objectives, axis=0)\n        normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n        return normalized.sum(axis=1)\n\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    scores = normalize_objectives(archive)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with objective-aware edge selection\n    def calculate_edge_cost(i, j, k, solution, distance_matrices):\n        # Current edges: (i, j) and (k, l)\n        n = len(solution)\n        l = (k + 1) % n\n        # New edges: (i, k) and (j, l)\n        cost = 0\n        for dm in distance_matrices:\n            cost += dm[solution[i], solution[k]] + dm[solution[j], solution[l]] - dm[solution[i], solution[j]] - dm[solution[k], solution[l]]\n        return cost\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    distance_matrices = [distance_matrix_1, distance_matrix_2, distance_matrix_3]\n\n    # Randomly sample edges to consider for 2-opt\n    for _ in range(10):  # Number of attempts\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k = np.random.randint(0, n)\n        if k == i or k == j or (k + 1) % n == i or (k + 1) % n == j:\n            continue\n\n        # Calculate cost of reversing segment [j, k]\n        cost = calculate_edge_cost(i, j, k, new_solution, distance_matrices)\n\n        if cost < 0:  # Only accept if improvement\n            # Reverse the segment between j and k\n            new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5614672279080569,
            2.754914951324463
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def normalize_objectives(archive):\n        objectives = np.array([obj for _, obj in archive])\n        min_vals = np.min(objectives, axis=0)\n        max_vals = np.max(objectives, axis=0)\n        normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n        return normalized.sum(axis=1)\n\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    scores = normalize_objectives(archive)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with objective-aware edge selection\n    def calculate_edge_cost(i, j, k, solution, distance_matrices):\n        # Current edges: (i, j) and (k, l)\n        n = len(solution)\n        l = (k + 1) % n\n        # New edges: (i, k) and (j, l)\n        cost = 0\n        for dm in distance_matrices:\n            cost += dm[solution[i], solution[k]] + dm[solution[j], solution[l]] - dm[solution[i], solution[j]] - dm[solution[k], solution[l]]\n        return cost\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    distance_matrices = [distance_matrix_1, distance_matrix_2, distance_matrix_3]\n\n    # Randomly sample edges to consider for 2-opt\n    for _ in range(10):  # Number of attempts\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k = np.random.randint(0, n)\n        if k == i or k == j or (k + 1) % n == i or (k + 1) % n == j:\n            continue\n\n        # Calculate cost of reversing segment [j, k]\n        cost = calculate_edge_cost(i, j, k, new_solution, distance_matrices)\n\n        if cost < 0:  # Only accept if improvement\n            # Reverse the segment between j and k\n            new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 287,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: a combination of 2-opt and node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Apply 2-opt on the segment\n    if len(segment) >= 4:\n        k, l = sorted(np.random.choice(len(segment), 2, replace=False))\n        segment[k:l+1] = segment[k:l+1][::-1]\n\n    # Insert a random node from the segment elsewhere in the tour\n    if len(segment) >= 2:\n        node_to_move = np.random.choice(segment)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move))\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.7691034966146656,
            1.2097249746322631
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: a combination of 2-opt and node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Apply 2-opt on the segment\n    if len(segment) >= 4:\n        k, l = sorted(np.random.choice(len(segment), 2, replace=False))\n        segment[k:l+1] = segment[k:l+1][::-1]\n\n    # Insert a random node from the segment elsewhere in the tour\n    if len(segment) >= 2:\n        node_to_move = np.random.choice(segment)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move))\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 288,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0)\n    scores = np.sum(normalized_obj, axis=1)  # Higher score = more potential for improvement\n    selected_idx = np.random.choice(len(archive), p=scores/scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First: 2-opt for the objective with worst current performance\n    worst_obj = np.argmax(archive[selected_idx][1])\n    if worst_obj == 0:\n        dist_mat = distance_matrix_1\n    elif worst_obj == 1:\n        dist_mat = distance_matrix_2\n    else:\n        dist_mat = distance_matrix_3\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Second: Node insertion for the other objectives\n    other_objs = [o for o in range(3) if o != worst_obj]\n    for obj in other_objs:\n        if obj == 0:\n            dist_mat = distance_matrix_1\n        elif obj == 1:\n            dist_mat = distance_matrix_2\n        else:\n            dist_mat = distance_matrix_3\n\n        # Find worst segment in current solution\n        max_gain = -np.inf\n        best_i, best_j = -1, -1\n        for i in range(n):\n            for j in range(i+1, min(i+5, n)):  # Limit search space\n                if dist_mat[new_solution[i], new_solution[j]] > dist_mat[new_solution[i], new_solution[(i+1)%n]] + dist_mat[new_solution[j], new_solution[(j+1)%n]]:\n                    gain = dist_mat[new_solution[i], new_solution[j]] - (dist_mat[new_solution[i], new_solution[(i+1)%n]] + dist_mat[new_solution[j], new_solution[(j+1)%n]])\n                    if gain > max_gain:\n                        max_gain = gain\n                        best_i, best_j = i, j\n\n        if best_i != -1:\n            new_solution[best_i+1:best_j+1] = new_solution[best_i+1:best_j+1][::-1]\n\n    # Third: Random swap for diversification\n    if random.random() < 0.3:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6758836090276528,
            2.3204427361488342
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0)\n    scores = np.sum(normalized_obj, axis=1)  # Higher score = more potential for improvement\n    selected_idx = np.random.choice(len(archive), p=scores/scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First: 2-opt for the objective with worst current performance\n    worst_obj = np.argmax(archive[selected_idx][1])\n    if worst_obj == 0:\n        dist_mat = distance_matrix_1\n    elif worst_obj == 1:\n        dist_mat = distance_matrix_2\n    else:\n        dist_mat = distance_matrix_3\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Second: Node insertion for the other objectives\n    other_objs = [o for o in range(3) if o != worst_obj]\n    for obj in other_objs:\n        if obj == 0:\n            dist_mat = distance_matrix_1\n        elif obj == 1:\n            dist_mat = distance_matrix_2\n        else:\n            dist_mat = distance_matrix_3\n\n        # Find worst segment in current solution\n        max_gain = -np.inf\n        best_i, best_j = -1, -1\n        for i in range(n):\n            for j in range(i+1, min(i+5, n)):  # Limit search space\n                if dist_mat[new_solution[i], new_solution[j]] > dist_mat[new_solution[i], new_solution[(i+1)%n]] + dist_mat[new_solution[j], new_solution[(j+1)%n]]:\n                    gain = dist_mat[new_solution[i], new_solution[j]] - (dist_mat[new_solution[i], new_solution[(i+1)%n]] + dist_mat[new_solution[j], new_solution[(j+1)%n]])\n                    if gain > max_gain:\n                        max_gain = gain\n                        best_i, best_j = i, j\n\n        if best_i != -1:\n            new_solution[best_i+1:best_j+1] = new_solution[best_i+1:best_j+1][::-1]\n\n    # Third: Random swap for diversification\n    if random.random() < 0.3:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 289,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search: 2-opt for one objective, followed by a randomized swap for the other two\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on the first objective space\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select two distinct positions and swap them\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility by checking for duplicates (though 2-opt and swap should preserve it)\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback: perform a single swap if infeasible\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.5388201667411223,
            1.0468338131904602
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search: 2-opt for one objective, followed by a randomized swap for the other two\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on the first objective space\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select two distinct positions and swap them\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility by checking for duplicates (though 2-opt and swap should preserve it)\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback: perform a single swap if infeasible\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 290,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware node swapping\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # First, apply 2-opt to the first objective\n    for _ in range(10):  # Limit iterations for efficiency\n        i, j = sorted(random.sample(range(n), 2))\n        if i == 0 and j == n-1:\n            continue  # Avoid reversing the entire tour\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform objective-aware node swaps\n    for _ in range(5):\n        i, j = random.sample(range(n), 2)\n        if i == j:\n            continue\n        # Calculate improvement potential across all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                 (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                 (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) - \\\n                 (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid\n    assert len(new_solution) == len(selected_solution)\n    assert len(set(new_solution)) == len(selected_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.6726354468925371,
            0.9873759984970093
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware node swapping\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # First, apply 2-opt to the first objective\n    for _ in range(10):  # Limit iterations for efficiency\n        i, j = sorted(random.sample(range(n), 2))\n        if i == 0 and j == n-1:\n            continue  # Avoid reversing the entire tour\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform objective-aware node swaps\n    for _ in range(5):\n        i, j = random.sample(range(n), 2)\n        if i == j:\n            continue\n        # Calculate improvement potential across all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                 (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                 (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) - \\\n                 (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid\n    assert len(new_solution) == len(selected_solution)\n    assert len(set(new_solution)) == len(selected_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 291,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: (x[1][0] + x[1][1] + x[1][2]) / 3)  # Select the solution with the highest average objective value\n\n    # Perform a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Find the worst edge in terms of any of the three objectives\n    worst_edge_idx = -1\n    max_edge_cost = -1\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i + 1) % n]\n        edge_cost = (distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v]) / 3\n        if edge_cost > max_edge_cost:\n            max_edge_cost = edge_cost\n            worst_edge_idx = i\n\n    if worst_edge_idx != -1:\n        # Perform 2-opt on the worst edge\n        i = worst_edge_idx\n        j = (worst_edge_idx + 1) % n\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6570560282500546,
            1.2816376447677613
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: (x[1][0] + x[1][1] + x[1][2]) / 3)  # Select the solution with the highest average objective value\n\n    # Perform a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Find the worst edge in terms of any of the three objectives\n    worst_edge_idx = -1\n    max_edge_cost = -1\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i + 1) % n]\n        edge_cost = (distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v]) / 3\n        if edge_cost > max_edge_cost:\n            max_edge_cost = edge_cost\n            worst_edge_idx = i\n\n    if worst_edge_idx != -1:\n        # Perform 2-opt on the worst edge\n        i = worst_edge_idx\n        j = (worst_edge_idx + 1) % n\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 292,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[np.argmax([np.sum(obj) for _, obj in archive])][0].copy()\n\n    # Apply a hybrid local search: 2-opt with multi-objective awareness\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to swap (2-opt)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Further refine by considering the worst objective\n    worst_obj = np.argmax([obj[0] + obj[1] + obj[2] for _, obj in archive])\n    worst_solution = archive[worst_obj][0].copy()\n\n    # Apply a small perturbation to the worst solution\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n    worst_solution[k], worst_solution[l] = worst_solution[l], worst_solution[k]\n\n    # Combine the two solutions (e.g., take alternating segments)\n    combined = np.empty_like(new_solution)\n    combined[::2] = new_solution[::2]\n    combined[1::2] = worst_solution[1::2]\n\n    # Ensure feasibility (no duplicates)\n    _, unique_indices = np.unique(combined, return_index=True)\n    combined = combined[np.sort(unique_indices)]\n\n    # If missing nodes, append them in order\n    missing = np.setdiff1d(np.arange(n), combined)\n    if len(missing) > 0:\n        combined = np.concatenate([combined, missing])\n\n    return combined\n\n",
        "score": [
            -0.5910381683125989,
            2.939675974845886
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[np.argmax([np.sum(obj) for _, obj in archive])][0].copy()\n\n    # Apply a hybrid local search: 2-opt with multi-objective awareness\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to swap (2-opt)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Further refine by considering the worst objective\n    worst_obj = np.argmax([obj[0] + obj[1] + obj[2] for _, obj in archive])\n    worst_solution = archive[worst_obj][0].copy()\n\n    # Apply a small perturbation to the worst solution\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n    worst_solution[k], worst_solution[l] = worst_solution[l], worst_solution[k]\n\n    # Combine the two solutions (e.g., take alternating segments)\n    combined = np.empty_like(new_solution)\n    combined[::2] = new_solution[::2]\n    combined[1::2] = worst_solution[1::2]\n\n    # Ensure feasibility (no duplicates)\n    _, unique_indices = np.unique(combined, return_index=True)\n    combined = combined[np.sort(unique_indices)]\n\n    # If missing nodes, append them in order\n    missing = np.setdiff1d(np.arange(n), combined)\n    if len(missing) > 0:\n        combined = np.concatenate([combined, missing])\n\n    return combined\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 293,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a novel hybrid local search strategy that combines 2-opt moves with objective-specific edge swaps, prioritizing edges that show potential for multi-objective improvement, and ensures feasibility by validating the tour structure before returning the neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value (sum of all three objectives)\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: perform a series of 2-opt moves with objective-aware edge selection\n    n = len(base_solution)\n    for _ in range(10):  # Perform 10 iterations of local search\n        # Select two random edges to swap\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n        # Compute the change in all three objectives\n        delta_1 = (distance_matrix_1[base_solution[i], base_solution[j]] + distance_matrix_1[base_solution[k], base_solution[l]] -\n                   distance_matrix_1[base_solution[i], base_solution[k]] - distance_matrix_1[base_solution[j], base_solution[l]])\n        delta_2 = (distance_matrix_2[base_solution[i], base_solution[j]] + distance_matrix_2[base_solution[k], base_solution[l]] -\n                   distance_matrix_2[base_solution[i], base_solution[k]] - distance_matrix_2[base_solution[j], base_solution[l]])\n        delta_3 = (distance_matrix_3[base_solution[i], base_solution[j]] + distance_matrix_3[base_solution[k], base_solution[l]] -\n                   distance_matrix_3[base_solution[i], base_solution[k]] - distance_matrix_3[base_solution[j], base_solution[l]])\n\n        # Accept the move if it improves at least one objective\n        if delta_1 < 0 or delta_2 < 0 or delta_3 < 0:\n            new_solution[i:j+1] = base_solution[i:j+1][::-1]\n            new_solution[k:l+1] = base_solution[k:l+1][::-1]\n            base_solution = new_solution.copy()\n\n    # Ensure the solution is valid (visits each node exactly once)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a simple 2-opt to fix\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6301746527590859,
            2.054836106300354
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value (sum of all three objectives)\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: perform a series of 2-opt moves with objective-aware edge selection\n    n = len(base_solution)\n    for _ in range(10):  # Perform 10 iterations of local search\n        # Select two random edges to swap\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n        # Compute the change in all three objectives\n        delta_1 = (distance_matrix_1[base_solution[i], base_solution[j]] + distance_matrix_1[base_solution[k], base_solution[l]] -\n                   distance_matrix_1[base_solution[i], base_solution[k]] - distance_matrix_1[base_solution[j], base_solution[l]])\n        delta_2 = (distance_matrix_2[base_solution[i], base_solution[j]] + distance_matrix_2[base_solution[k], base_solution[l]] -\n                   distance_matrix_2[base_solution[i], base_solution[k]] - distance_matrix_2[base_solution[j], base_solution[l]])\n        delta_3 = (distance_matrix_3[base_solution[i], base_solution[j]] + distance_matrix_3[base_solution[k], base_solution[l]] -\n                   distance_matrix_3[base_solution[i], base_solution[k]] - distance_matrix_3[base_solution[j], base_solution[l]])\n\n        # Accept the move if it improves at least one objective\n        if delta_1 < 0 or delta_2 < 0 or delta_3 < 0:\n            new_solution[i:j+1] = base_solution[i:j+1][::-1]\n            new_solution[k:l+1] = base_solution[k:l+1][::-1]\n            base_solution = new_solution.copy()\n\n    # Ensure the solution is valid (visits each node exactly once)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a simple 2-opt to fix\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 294,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement by choosing the one with the highest sum of objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: apply a combination of 2-opt and node insertion\n    n = len(base_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = base_solution[i:j+1][::-1]\n\n    # Perform node insertion\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.5389372572505771,
            1.5717575550079346
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement by choosing the one with the highest sum of objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: apply a combination of 2-opt and node insertion\n    n = len(base_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = base_solution[i:j+1][::-1]\n\n    # Perform node insertion\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 295,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1] + x[1][2]) / 3)  # Example selection criterion\n    base_solution = selected[0].copy()\n\n    # Perform a hybrid local search: combine 2-opt with a multi-objective-aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Further refine by evaluating edge swaps across all three objectives\n    for _ in range(5):  # Limit iterations for efficiency\n        a, b = sorted(random.sample(range(n), 2))\n        if a == b or a+1 == b:\n            continue\n\n        # Calculate current and new objective values\n        current_obj = (\n            distance_matrix_1[new_solution[a], new_solution[a+1]] +\n            distance_matrix_2[new_solution[a], new_solution[a+1]] +\n            distance_matrix_3[new_solution[a], new_solution[a+1]] +\n            distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] +\n            distance_matrix_2[new_solution[b], new_solution[(b+1)%n]] +\n            distance_matrix_3[new_solution[b], new_solution[(b+1)%n]]\n        )\n        new_obj = (\n            distance_matrix_1[new_solution[a], new_solution[b]] +\n            distance_matrix_2[new_solution[a], new_solution[b]] +\n            distance_matrix_3[new_solution[a], new_solution[b]] +\n            distance_matrix_1[new_solution[a+1], new_solution[(b+1)%n]] +\n            distance_matrix_2[new_solution[a+1], new_solution[(b+1)%n]] +\n            distance_matrix_3[new_solution[a+1], new_solution[(b+1)%n]]\n        )\n\n        # Accept if overall improvement is found\n        if new_obj < current_obj:\n            new_solution[a+1:b+1] = new_solution[a+1:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6323808424312419,
            1.6902675867080688
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1] + x[1][2]) / 3)  # Example selection criterion\n    base_solution = selected[0].copy()\n\n    # Perform a hybrid local search: combine 2-opt with a multi-objective-aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Further refine by evaluating edge swaps across all three objectives\n    for _ in range(5):  # Limit iterations for efficiency\n        a, b = sorted(random.sample(range(n), 2))\n        if a == b or a+1 == b:\n            continue\n\n        # Calculate current and new objective values\n        current_obj = (\n            distance_matrix_1[new_solution[a], new_solution[a+1]] +\n            distance_matrix_2[new_solution[a], new_solution[a+1]] +\n            distance_matrix_3[new_solution[a], new_solution[a+1]] +\n            distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] +\n            distance_matrix_2[new_solution[b], new_solution[(b+1)%n]] +\n            distance_matrix_3[new_solution[b], new_solution[(b+1)%n]]\n        )\n        new_obj = (\n            distance_matrix_1[new_solution[a], new_solution[b]] +\n            distance_matrix_2[new_solution[a], new_solution[b]] +\n            distance_matrix_3[new_solution[a], new_solution[b]] +\n            distance_matrix_1[new_solution[a+1], new_solution[(b+1)%n]] +\n            distance_matrix_2[new_solution[a+1], new_solution[(b+1)%n]] +\n            distance_matrix_3[new_solution[a+1], new_solution[(b+1)%n]]\n        )\n\n        # Accept if overall improvement is found\n        if new_obj < current_obj:\n            new_solution[a+1:b+1] = new_solution[a+1:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 296,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with multi-objective edge swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Perform the swap to create a neighbor\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6664289079201142,
            1.5112158060073853
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with multi-objective edge swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Perform the swap to create a neighbor\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 297,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # We use a combination of 2-opt and path relinking to generate a neighbor\n    new_solution = base_solution.copy()\n\n    # 2-opt local search\n    for _ in range(10):  # Limit the number of iterations\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Path relinking with another solution in the archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.randint(len(archive))][0]\n        for i in range(len(new_solution)):\n            if np.random.rand() < 0.3:  # 30% chance to replace with node from other solution\n                new_solution[i] = other_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != len(new_solution):\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(len(new_solution)), unique_nodes)\n        for i in range(len(new_solution)):\n            if new_solution[i] in new_solution[:i]:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.6609694308306707,
            2.9162696957588197
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # We use a combination of 2-opt and path relinking to generate a neighbor\n    new_solution = base_solution.copy()\n\n    # 2-opt local search\n    for _ in range(10):  # Limit the number of iterations\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Path relinking with another solution in the archive\n    if len(archive) > 1:\n        other_solution = archive[np.random.randint(len(archive))][0]\n        for i in range(len(new_solution)):\n            if np.random.rand() < 0.3:  # 30% chance to replace with node from other solution\n                new_solution[i] = other_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != len(new_solution):\n        # If duplicates exist, repair by replacing duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(len(new_solution)), unique_nodes)\n        for i in range(len(new_solution)):\n            if new_solution[i] in new_solution[:i]:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 298,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware edge swap: identify edges with high contribution to any objective\n    for _ in range(5):  # Limit iterations to balance exploration and exploitation\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate current and potential edge costs across all objectives\n        current_costs = [\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n            distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n            distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n            distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        ]\n\n        # Perform swap and calculate new costs\n        temp = new_solution[i+1:j+1]\n        new_solution[i+1:j+1] = temp[::-1]\n\n        new_costs = [\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n            distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n            distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n            distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        ]\n\n        # Accept swap if it improves at least one objective\n        if any(new_cost < current_cost for new_cost, current_cost in zip(new_costs, current_costs)):\n            continue\n        else:\n            # Revert if no improvement\n            new_solution[i+1:j+1] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.5538741829216988,
            2.2359699606895447
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware edge swap: identify edges with high contribution to any objective\n    for _ in range(5):  # Limit iterations to balance exploration and exploitation\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate current and potential edge costs across all objectives\n        current_costs = [\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n            distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n            distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n            distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        ]\n\n        # Perform swap and calculate new costs\n        temp = new_solution[i+1:j+1]\n        new_solution[i+1:j+1] = temp[::-1]\n\n        new_costs = [\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n            distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n            distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n            distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        ]\n\n        # Accept swap if it improves at least one objective\n        if any(new_cost < current_cost for new_cost, current_cost in zip(new_costs, current_costs)):\n            continue\n        else:\n            # Revert if no improvement\n            new_solution[i+1:j+1] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 299,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, objectives = max(archive, key=lambda x: sum(x[1]))\n\n    # Hybrid local search: combine 2-opt with objective-aware edge swaps\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt for the primary objective (distance_matrix_1)\n    for i in range(n - 1):\n        for j in range(i + 2, n - 1):\n            if distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]] > \\\n               distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]:\n                new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Objective-aware edge swaps for secondary objectives\n    for _ in range(5):  # Limited iterations for efficiency\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j: i, j = j, i\n\n        # Calculate objective improvements\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                 distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) * 0.5\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                 distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) * 0.3\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] -\n                 distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]) * 0.2\n\n        if delta1 + delta2 + delta3 < 0:  # Accept if total improvement is positive\n            new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    return new_solution\n\n",
        "score": [
            -0.7913246759511596,
            3.251181972026825
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, objectives = max(archive, key=lambda x: sum(x[1]))\n\n    # Hybrid local search: combine 2-opt with objective-aware edge swaps\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt for the primary objective (distance_matrix_1)\n    for i in range(n - 1):\n        for j in range(i + 2, n - 1):\n            if distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]] > \\\n               distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]:\n                new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Objective-aware edge swaps for secondary objectives\n    for _ in range(5):  # Limited iterations for efficiency\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j: i, j = j, i\n\n        # Calculate objective improvements\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                 distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) * 0.5\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                 distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) * 0.3\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] -\n                 distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]) * 0.2\n\n        if delta1 + delta2 + delta3 < 0:  # Accept if total improvement is positive\n            new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 300,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(selected_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Check if the swap improves any objective\n    def get_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[k], solution[(k+1)%n]] for k in range(n))\n        cost2 = sum(distance_matrix_2[solution[k], solution[(k+1)%n]] for k in range(n))\n        cost3 = sum(distance_matrix_3[solution[k], solution[(k+1)%n]] for k in range(n))\n        return (cost1, cost2, cost3)\n\n    current_cost = get_cost(selected_solution)\n    new_solution = selected_solution.copy()\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]  # 2-opt move\n    new_cost = get_cost(new_solution)\n\n    # Accept if at least one objective improves\n    if any(new_cost[k] < current_cost[k] for k in range(3)):\n        return new_solution\n\n    # If no improvement, try a different local search: node insertion\n    for k in range(n):\n        if k in (i, j):\n            continue\n        temp_solution = selected_solution.copy()\n        node = temp_solution[k]\n        temp_solution = np.delete(temp_solution, k)\n        temp_solution = np.insert(temp_solution, i, node)\n        temp_cost = get_cost(temp_solution)\n        if any(temp_cost[k] < current_cost[k] for k in range(3)):\n            return temp_solution\n\n    # If no improvement, return the original solution\n    return selected_solution\n\n",
        "score": [
            -0.6493992497319424,
            1.9653175354003907
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(selected_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Check if the swap improves any objective\n    def get_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[k], solution[(k+1)%n]] for k in range(n))\n        cost2 = sum(distance_matrix_2[solution[k], solution[(k+1)%n]] for k in range(n))\n        cost3 = sum(distance_matrix_3[solution[k], solution[(k+1)%n]] for k in range(n))\n        return (cost1, cost2, cost3)\n\n    current_cost = get_cost(selected_solution)\n    new_solution = selected_solution.copy()\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]  # 2-opt move\n    new_cost = get_cost(new_solution)\n\n    # Accept if at least one objective improves\n    if any(new_cost[k] < current_cost[k] for k in range(3)):\n        return new_solution\n\n    # If no improvement, try a different local search: node insertion\n    for k in range(n):\n        if k in (i, j):\n            continue\n        temp_solution = selected_solution.copy()\n        node = temp_solution[k]\n        temp_solution = np.delete(temp_solution, k)\n        temp_solution = np.insert(temp_solution, i, node)\n        temp_cost = get_cost(temp_solution)\n        if any(temp_cost[k] < current_cost[k] for k in range(3)):\n            return temp_solution\n\n    # If no improvement, return the original solution\n    return selected_solution\n\n"
    }
]